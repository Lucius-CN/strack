(function(d) {
    function a(g) {
        var h = d.extend(true, {}, d.fn.combobox.defaults, d(g).combobox("options"));
        var f = h.customAttr.slave;
        if (f.id == null) {
            return;
        }
        if (/^#/.test(f.id)) {
            f.id = f.id;
        } else {
            f.id = "#" + f.id;
        }
        if (!h.multiple && !h.editable) {
            d(g).combobox("addEventListener", [ {
                name:"onSelect",
                handler:function(j) {
                    b(g, f, j, h.valueField);
                }
            }, {
                name:"onChange",
                handler:function(k, j) {
                    if (k == null || k == "") {
                        d(f.id).combobox("clear").combobox("loadData", []);
                        d(g).combobox("textbox").trigger("blur");
                    }
                }
            } ]);
        }
    }
    function b(j, k, f, h) {
        if (k.remote) {
            var g = k.url || d(k.id).combobox("options").url;
            if (g.indexOf("?") > -1) {
                g += "&swd=" + f[h];
            } else {
                g += "?swd=" + f[h];
            }
            d(k.id).combobox("clear").combobox("reload", g);
        } else {
            d(k.id).combobox("clear").combobox("loadData", f.data);
        }
    }
    function e(g) {
        var h = d(g).combobox("options");
        var f = d.extend(true, {}, d.fn.combobox.defaults, h);
        if (!f.customAttr.headervalue) {
            return;
        }
        d(g).combobox("addEventListener", {
            name:"onLoadSuccess",
            handler:function() {
                d(g).combobox("textbox").trigger("blur");
            }
        });
    }
    function c(k, f, j, h) {
        var g = d(k).combobox("options");
        var l = g[f];
        switch (f) {
            case "onBeforeLoad":
                if (h) {
                    g[f] = j;
                } else {
                    g[f] = function(m) {
                        l.apply(this, arguments);
                        j.apply(this, arguments);
                    };
                }
                break;

            case "onLoadSuccess":
                if (h) {
                    g[f] = j;
                } else {
                    g[f] = function() {
                        l.apply(this, arguments);
                        j.apply(this, arguments);
                    };
                }
                break;

            case "onLoadError":
                if (h) {
                    g[f] = j;
                } else {
                    g[f] = function() {
                        l.apply(this, arguments);
                        j.apply(this, arguments);
                    };
                }
                break;

            case "onSelect":
                if (h) {
                    g[f] = j;
                } else {
                    g[f] = function(m) {
                        l.apply(this, arguments);
                        j.apply(this, arguments);
                    };
                }
                break;

            case "onUnselect":
                if (h) {
                    g[f] = j;
                } else {
                    g[f] = function(m) {
                        l.apply(this, arguments);
                        j.apply(this, arguments);
                    };
                }
                break;

            default:
                d(k).combo("addEventListener", {
                    name:f,
                    override:h,
                    handler:j
                });
                break;
        }
    }
    d.fn.combobox.defaults.customAttr = {
        slave:{
            id:null,
            remote:true,
            url:null
        }
    };
    d.extend(d.fn.combobox.methods, {
        followCustomHandle:function(f) {
            return f.each(function() {
                e(this);
                a(this);
                d(this).combo("followCustomHandle");
            });
        },
        addEventListener:function(g, f) {
            return g.each(function() {
                var h = d.isArray(f) ? f :[ f ];
                var j = this;
                d.each(h, function(k, l) {
                    c(j, l.name, l.handler || function() {}, l.override);
                });
            });
        },
        getSelected:function(m) {
            var f = m.combobox("options");
            var h = f.valueField;
            var l = m.combobox("getValue");
            var k = m.combobox("getData");
            for (var g = 0; g < k.length; g++) {
                var j = k[g];
                if (j[h] == l) {
                    return j;
                }
            }
            return null;
        }
    });
})(jQuery);

(function(f) {
    function c(j) {
        var k = f.data(j, "combo").options;
        var h = f.extend(true, {}, f.fn.combo.defaults, k);
        if (!h.customAttr.headervalue) {
            return;
        }
        if (k.required) {
            var g = [ 'unequal["' + h.customAttr.headervalue + '"]' ];
            if (k.validType) {
                if (typeof k.validType == "string") {
                    g.push(k.validType);
                    k.validType = g;
                }
                if (f.isArray(k.validType)) {
                    f.merge(k.validType, g);
                }
            } else {
                f.extend(k, {
                    validType:g
                });
            }
        }
        f(j).combo("addEventListener", {
            name:"onChange",
            handler:function(m, l) {
                if (m == null || m == "") {
                    f(j).combo("setText", h.customAttr.headervalue);
                }
            }
        }).combo("textbox").val(h.customAttr.headervalue).attr("prompt", h.customAttr.headervalue).focus(function() {
            if (f(this).val() == h.customAttr.headervalue) {
                f(this).val("");
            }
        }).blur(function() {
            if (f.trim(f(this).val()) == "") {
                f(this).val(h.customAttr.headervalue);
            }
            f(j).combo("validate");
        });
    }
    function a(j) {
        var h = f(j).combo("getValue");
        if (!h) {
            return;
        }
        var g = f.data(j, "combo").options;
        f(j).combo("setText", "");
        if (g.multiple) {
            f(j).combo("setValues", []);
        } else {
            f(j).combo("setValue", "");
        }
    }
    function b(h) {
        var g = f(h).combo("getValues");
        return g.length > 0 ? g[0] != "" ? g[0] :null :null;
    }
    function e(h) {
        var j = f.extend(true, {}, f.fn.combo.defaults, f.data(h, "combo").options);
        var g = j.customAttr.autocomplete;
        if (!g.enabled) {
            return;
        }
        f(h).combo("textbox").keyup(function(k) {
            if (f(this).val().length != 0 && f(this).val().length % g.minLength == 0 && g.url) {
                f.ajax({
                    type:"POST",
                    url:g.url,
                    data:{
                        wd:f(this).val()
                    },
                    dataType:"json",
                    success:function(n) {
                        var l = f(h).combo("panel").empty();
                        for (var m = 0; m < n.length; m++) {
                            f("<div>").addClass("combobox-item").attr("value", n[m].id).text(n[m].text).click(function(q) {
                                var o = f(this).attr("value");
                                var p = f(this).text();
                                f(h).combo("setValue", o).combo("setText", p).combo("hidePanel");
                            }).hover(function() {
                                f(this).addClass("combobox-item-hover");
                            }, function() {
                                f(this).removeClass("combobox-item-hover");
                            }).appendTo(l);
                        }
                    },
                    error:function(l, n, m) {
                        f.messager.alert("Error", m, "error");
                    }
                });
            }
        });
    }
    function d(l, g, k, j) {
        var h = f(l).combo("options");
        var m = h[g];
        switch (g) {
            case "onShowPanel":
                if (j) {
                    h[g] = k;
                } else {
                    h[g] = function() {
                        m.apply(this, arguments);
                        k.apply(this, arguments);
                    };
                }
                break;

            case "onHidePanel":
                if (j) {
                    h[g] = k;
                } else {
                    h[g] = function() {
                        m.apply(this, arguments);
                        k.apply(this, arguments);
                    };
                }
                break;

            case "onChange":
                if (j) {
                    h[g] = k;
                } else {
                    h[g] = function(o, n) {
                        m.apply(this, arguments);
                        k.apply(this, arguments);
                    };
                }
                break;

            default:
                break;
        }
    }
    f.fn.combo.defaults.customAttr = {
        headervalue:null,
        autocomplete:{
            enabled:false,
            minLength:3,
            url:undefined
        }
    };
    f.extend(f.fn.combo.methods, {
        followCustomHandle:function(g) {
            return g.each(function() {
                c(this);
                e(this);
            });
        },
        clear:function(g) {
            return g.each(function() {
                a(this);
            });
        },
        getValue:function(g) {
            return b(g[0]);
        },
        addEventListener:function(h, g) {
            return h.each(function() {
                var j = f.isArray(g) ? g :[ g ];
                var k = this;
                f.each(j, function(l, m) {
                    d(k, m.name, m.handler || function() {}, m.override);
                });
            });
        }
    });
})(jQuery);

(function(a) {
    a.extend(a.fn.combogrid.methods, {
        getSelected:function(b) {
            return b.combogrid("grid").datagrid("getSelected");
        }
    });
})(jQuery);

(function(a) {
    a.extend(a.fn.combotree.methods, {
        followCustomHandle:function(b) {
            return b.each(function() {
                a(this).combotree("tree").tree("followCustomHandle");
                a(this).combo("followCustomHandle");
            });
        }
    });
})(jQuery);

(function(c) {
    function v(A, B, x) {
        var z = h(A, x);
        var y = c("#" + z);
        if (y.length == 0) {
            y = c("<div>", {
                id:z
            }).menu().menu("appendItems", B);
        }
        return y;
    }
    function h(y, x) {
        return c(y).attr("id") + "_" + x;
    }
    function t(y) {
        var x = {};
        c.each(y, function() {
            var A = this;
            if (A.onclick) {
                var z = A.id || A.text;
                x[z] = A.onclick;
                delete A.onclick;
            }
            if (A.submenu && c.isArray(A.submenu) && A.submenu.length > 0) {
                c.extend(x, t(A.submenu));
            }
        });
        return x;
    }
    function n(E) {
        var D = h(E, "headerContextMenu");
        var y = [ {
            text:StrackLang["Show_Hide_Column"],
            iconCls:"icon-columns",
            submenu:[ {
                id:D + "_showAll",
                text:StrackLang["ShowAll"],
                iconCls:"icon-columns",
                onclick:function(G, H, F) {
                    c.fn.datagrid.headerContextMenu.defaultEvents.doShowAll(F);
                }
            }, {
                id:D + "_restore",
                text:StrackLang["Restore"],
                iconCls:"icon-columns",
                onclick:function(G, H, F) {
                    c.fn.datagrid.headerContextMenu.defaultEvents.doRestore(F);
                }
            }, "-" ]
        } ];
        var A = function(F) {
            return F.substr(F.lastIndexOf("-") + 1, F.length);
        };
        var B = [];
        var z = c(E).datagrid("getColumnFields", true);
        var C = c(E).datagrid("getColumnFields");
        x(C, false);
        function x(G, F) {
            c.each(G, function(I, J) {
                if (!J || J == "ck") {
                    return true;
                }
                var H = c(E).datagrid("getColumnOption", J);
                H._hidden = H.hidden;
                B.push({
                    id:D + "-" + J,
                    text:H.title,
                    disabled:F,
                    iconCls:H.hidden ? "icon-unchecked" :"icon-checked",
                    onclick:function(L, K, O) {
                        var N = A(L.id);
                        var M = c(O).datagrid("getColumnOption", N).hidden;
                        if (!M) {
                            c.fn.datagrid.headerContextMenu.defaultEvents.doHideColumn(O, N, L);
                        } else {
                            c.fn.datagrid.headerContextMenu.defaultEvents.doShowColumn(O, N, L);
                        }
                    }
                });
            });
        }
        c.merge(y[0].submenu, B);
        return y;
    }
    function m(A) {
        var y = c.extend(true, {}, c.fn.datagrid.defaults, c(A).datagrid("options"));
        var C = y.customAttr.headerContextMenu;
        if (!C.isShow) {
            return;
        }
        if (y.columns[0][0].checkbox) {
            y.columns[0][0].field = "ck";
        }
        var B = n(A);
        if (C.isMerge) {
            c.merge(B, C.items);
        }
        if (!C.isMerge && c.isArray(C.items) && C.items.length > 0) {
            B = C.items;
        }
        var z = t(B);
        var x = v(A, B, "headerContextMenu");
        c(A).datagrid("addEventListener", {
            name:"onHeaderContextMenu",
            handler:function(E, D) {
                E.preventDefault();
                x.menu("addEventListener", [ {
                    name:"onClick",
                    override:true,
                    handler:function(G) {
                        var F = G.id || G.text;
                        if (z[F]) {
                            z[F].call(this, G, D, A);
                        }
                    }
                }, {
                    name:"onShow",
                    override:true,
                    handler:function() {
                        C.onShow && C.onShow.call(this, D, A);
                    }
                }, {
                    name:"onHide",
                    override:true,
                    handler:function() {
                        C.onHide && C.onHide.call(this);
                    }
                } ]).menu("show", {
                    left:E.pageX,
                    top:E.pageY
                });
            }
        });
    }
    function j(z) {
        var y = h(z, "rowContextMenu");
        var x = [ {
            id:y + "_delete",
            text:"删除",
            iconCls:"icon-remove",
            onclick:function(B, D, C, A) {
                c.fn.datagrid.rowContextMenu.defaultEvents.doDelete(B, D, C, A);
            }
        }, "-", {
            id:y + "_reload",
            text:"刷新",
            iconCls:"icon-reload",
            onclick:function(B, D, C, A) {
                c.fn.datagrid.rowContextMenu.defaultEvents.doReload(B, D, C, A);
            }
        }, {
            id:y + "_reload_this_page",
            text:"刷新当前页",
            onclick:function(B, D, C, A) {
                c.fn.datagrid.rowContextMenu.defaultEvents.doReloadThisPage(B, D, C, A);
            }
        } ];
        return x;
    }
    function e(B) {
        var y = c.extend(true, {}, c.fn.datagrid.defaults, c(B).datagrid("options"));
        var z = y.customAttr.rowContextMenu;
        if (!z.isShow) {
            return;
        }
        var C = j(B);
        if (z.isMerge) {
            c.merge(C, z.items);
        }
        if (!z.isMerge && c.isArray(z.items) && z.items.length > 0) {
            C = z.items;
        }
        var A = t(C);
        var x = v(B, C, "rowContextMenu");
        c(B).datagrid("addEventListener", {
            name:"onRowContextMenu",
            handler:function(E, F, D) {
                E.preventDefault();
                c(B).datagrid("selectRow", F);
                x.menu("addEventListener", {
                    name:"onClick",
                    override:true,
                    handler:function(H) {
                        var G = H.id || H.text;
                        if (A[G]) {
                            A[G].call(this, H, F, D, B);
                        }
                    }
                }).menu("show", {
                    left:E.pageX,
                    top:E.pageY
                });
            }
        });
    }
    function f(D) {
        var F = c.extend(true, {}, c.fn.datagrid.defaults, c(D).datagrid("options"));
        if (!c.isArray(F.customAttr.slaveList)) {
            return;
        }
        if (F.customAttr.slaveList.length == 0) {
            return;
        }
        var E = {
            slaveList:F.customAttr.slaveList,
            activeSlave:F.customAttr.activeSlave
        };
        var z = c(D);
        var y = [];
        for (var C in E.slaveList) {
            var A = {
                id:E.slaveList[C].id,
                params:{}
            };
            var B = {}, x;
            if (!E.slaveList[C].relatedfield) {
                x = z.datagrid("options").idField;
                B[x] = "undefined";
            } else {
                x = E.slaveList[C].relatedfield;
                B[E.slaveList[C].relatedfield] = "undefined";
            }
            c.extend(A.params, B, E.slaveList[C].queryParams);
            y.push(A);
        }
        if (E.activeSlave == c.fn.datagrid.defaults.customAttr.activeSlave) {
            z.datagrid("addEventListener", {
                name:"onDblClickRow",
                handler:function(I, H) {
                    for (var G in y) {
                        y[G].params[x] = H[x];
                        c("#" + y[G].id).datagrid("load", y[G].params);
                    }
                }
            });
        }
    }
    function q(C) {
        var y = c.extend(true, {}, c.fn.datagrid.defaults, c(C).datagrid("options"));
        if (!y.customAttr.rowediting) {
            return;
        }
        var D = function(E) {
            return c(E).attr("id") + "_editor_buttons_panel";
        };
        var x = 120;
        var A = function(J) {
            var H = D(J);
            if (c("#" + H).length > 0) {
                return;
            }
            var F = c(J).datagrid("getPanel");
            var I = c.data(J, "datagrid");
            var G = I.dc.body2;
            G.css("position", "relative");
            var E = c("<div>", {
                id:H
            }).addClass("dialog-button").appendTo(G).css({
                position:"absolute",
                display:"block",
                "border-bottom":"1px solid #ddd",
                "border-left":"1px solid #ddd",
                "border-right":"1px solid #ddd",
                left:parseInt(F.width() / 2) - x,
                "z-index":2013,
                display:"none",
                padding:"4px 5px"
            });
            c('<a href="javascript:void(0)">确定</a>').css("margin-left", "0px").linkbutton({
                iconCls:"icon-ok"
            }).click(function() {
                var K = c(J).datagrid("getRowIndex", c(J).datagrid("getEditingRow"));
                if (!y.customAttr.onConfirmEdit.call(J, K)) {
                    return;
                }
                c(J).datagrid("endEdit", K);
            }).appendTo(E);
            c('<a href="javascript:void(0)">取消</a>').css("margin-left", "6px").linkbutton({
                iconCls:"icon-cancel"
            }).click(function() {
                var K = c(J).datagrid("getRowIndex", c(J).datagrid("getEditingRow"));
                c(J).datagrid("cancelEdit", K);
            }).appendTo(E);
        };
        var B = function(L, K) {
            var E = c.data(L, "datagrid").options;
            var M = E.finder.getTr(L, K, "body", 2);
            var H = M.position();
            var G = "#" + D(L);
            var F = c.data(L, "datagrid");
            var I = F.dc.body2;
            var J = function() {
                var N = M.height(), O = M.width();
                var Q = H.top + I.scrollTop(), P = H.left;
                var R = 11;
                if (O > I.width()) {
                    P = I.width() / 2 - x;
                } else {
                    P = O / 2 - x;
                }
                if (H.top + (N * 2 + R) > I.height()) {
                    Q = Q - (N + R);
                } else {
                    Q = Q + N;
                }
                return {
                    top:Q,
                    left:P
                };
            };
            c(G).css(J()).show();
        };
        var z = function(F) {
            var E = "#" + D(F);
            c(E).hide();
        };
        c(C).datagrid("addEventListener", [ {
            name:"onLoadSuccess",
            handler:function(E) {
                A(this);
            }
        }, {
            name:"onBeforeEdit",
            handler:function(E, F) {
                A(C);
                B(C, E);
            }
        }, {
            name:"onAfterEdit",
            handler:function(E, G, F) {
                z(C);
            }
        }, {
            name:"onCancelEdit",
            handler:function(E, F) {
                z(C);
            }
        } ]);
    }
    function u(z) {
        var y = c.extend(true, {}, c.fn.datagrid.defaults, c(z).datagrid("options"));
        if (!y.customAttr.tooltip.enable) {
            return;
        }
        var C = function(F, E) {
            var D = {
                position:y.customAttr.tooltip.position,
                trackMouse:true,
                onHide:function() {
                    c(F).tooltip("destroy");
                },
                onShow:function() {
                    if (c.isPlainObject(E) && E.css) {
                        c(this).tooltip("tip").css(E.css);
                    }
                }
            };
            c.extend(D, c.isPlainObject(E) ? E :{
                content:E
            });
            c(F).tooltip(D).tooltip("show");
        };
        var B = function(H, E) {
            var I = parseInt(H.attr("datagrid-row-index"));
            var G = c(z).datagrid("getRows")[I];
            var D = function(L) {
                var K = [];
                var J = c.grep(c.merge(c(z).datagrid("getColumnFields", true), c(z).datagrid("getColumnFields")), function(N, M) {
                    return c.trim(N).length > 0;
                });
                c.each(J, function() {
                    var M = this;
                    var N = c(z).datagrid("getColumnOption", M).title;
                    K.push(N + ": " + L[M]);
                });
                return K.join("<br>");
            };
            var F = E ? E(G, I) :D(G);
            H.mouseover(function() {
                C(this, F);
            });
        };
        var x = function(D, E) {
            D.mouseover(function() {
                var J = c(this).parent().attr("datagrid-row-index");
                var H = c(z).datagrid("getRows")[J];
                var I = c(this).attr("field");
                var G = H[I];
                var F = E ? E(G, I) :G;
                C(this, F);
            });
        };
        var A = function() {
            if (y.customAttr.tooltip.target == "row") {
                y.finder.getTr(z, "", "allbody").each(function() {
                    var G = c(this);
                    if (G.hasClass("datagrid-row")) {
                        B(G, y.customAttr.tooltip.formatter);
                    }
                });
            } else {
                if (y.customAttr.tooltip.fields && c.isArray(y.customAttr.tooltip.fields)) {
                    var D = c(z).datagrid("getPanel");
                    var F = c.data(z, "datagrid");
                    var E = F.dc.body2;
                    c.each(y.customAttr.tooltip.fields, function() {
                        var G = this;
                        x(c("td[field=" + G + "]", E), y.customAttr.tooltip.formatter);
                    });
                }
            }
        };
        c(z).datagrid("addEventListener", {
            name:"onLoadSuccess",
            handler:function(D) {
                A();
            }
        });
    }
    function b(y) {

    }
    function r(z) {

    }
    function p(A, z) {
        var x = c(A).datagrid("options"),
            B = c(A).datagrid("getColumnFields", true),
            op = x.columns[0],
            nop = [],
            fop = [],
            y = op[0];

        if (B.length == 0 && y.checkbox) {
            w(A, y.field, 2, 1);
        }
        s(A, z, true);
        w(A, z, 2, 1);

        /*删除*/
        for(var ci =0;ci<op.length;ci++){
            if(op[ci]["field"] == z || op[ci]["checkbox"]){
                fop.push(op[ci]);
            }else {
                nop.push(op[ci]);
            }
        }
        //改变datagrid 设置
        if(nop.length<1){
            x.columns = [];
        }else{
            x.columns[0] = nop;
        }
        if(x.frozenColumns[0]){
            fop.forEach(function (cv) {
                x.frozenColumns[0].push(cv);
            });
        }else{
            x.frozenColumns.push(fop);
        }
    }
    function o(C, B) {
        var x = c(C).datagrid("options");
        if (!x.frozenColumns[0]) {
            x.frozenColumns = [ [] ];
        }
        var A = c(C).datagrid("getColumnOption", B);
        x.frozenColumns[0].push(A);
        z(A);
        c(C).datagrid(x);
        var y = c(C).datagrid("getHeaderContextMenu").menu("findItem", A.title);
        c(C).datagrid("getHeaderContextMenu").menu("disableItem", y.target);
        function z(F) {
            for (var E = 0; E < x.columns.length; E++) {
                for (var D = 0; D < x.columns[E].length; D++) {
                    if (x.columns[E][D].field == F.field) {
                        x.columns[E].splice(D, 1);
                        return;
                    }
                }
            }
        }
    }
    function w(B, C, D, E) {
        var G = c(B).datagrid("options");
        var F = c.data(B, "datagrid").dc;
        var x = null;
        var x = (D == 1 ? F.header1 :F.header2).find(">table>tbody>tr.datagrid-header-row>td[field=" + C + "]");

        if (D > E) {
            (E == 1 ? F.header1 :F.header2).find(">table>tbody>tr.datagrid-header-row").append(x);
        } else {
            (E == 1 ? F.header1 :F.header2).find(">table>tbody>tr.datagrid-header-row").children("td[field]").each(function() {
                if (A(C, c(this).attr("field"))) {
                    c(this).before(x);
                    return false;
                }
            });
        }
        var y = (D == 1 ? F.body1 :F.body2).find(">table>tbody>tr>td[field=" + C + "]");
        if (D > E) {
            c.each(y, function(H, I) {
                G.finder.getTr(B, H, "body", E).append(I);
            });
        } else {
            c.each(y, function(H, I) {
                G.finder.getTr(B, H, "body", E).children("td[field]").each(function() {
                    if (A(C, c(this).attr("field"))) {
                        c(this).before(I);
                        return false;
                    }
                });
            });
        }
        c(B).datagrid("fixColumnSize");
        function A(H, I) {
            return z(H) < z(I);
        }
        function z(H) {
            return c.inArray(H, c(B).datagrid("getColumnFields"));
        }
    }
    function s(D, C, z) {
        var y = E(C);
        var B = c(D).datagrid("getColumnOption", C);
        c.extend(B, {
            index:y
        });
        var x = c(D).datagrid("getHeaderContextMenu");
        var A = x.menu("findItem", B.title);
        if (!A) {
            return;
        }
        if (z) {
            x.menu("disableItem", A.target);
        } else {
            x.menu("enableItem", A.target);
        }
        function E(F) {
            return c.inArray(F, c(D).datagrid("getColumnFields"));
        }
    }
    function g(D, C) {
        var z = c(C).datagrid("getHeaderContextMenu");
        var B = c(C).datagrid("getColumnOption", D);
        var y = z.menu("findItem", B.title);
        if (y) {
            if (!y.disabled) {
                x(StrackLang["Freeze_Column"]);
                A(StrackLang["Cancel_Freeze"]);
            } else {
                x(StrackLang["Cancel_Freeze"]);
                A(StrackLang["Freeze_Column"]);
            }
        } else {
            A(StrackLang["Freeze_Column"]);
            A(StrackLang["Cancel_Freeze"]);
        }
        function A(F) {
            var E = z.menu("findItem", F);
            if (E) {
                z.menu("disableItem", E.target);
            }
        }
        function x(F) {
            var E = z.menu("findItem", F);
            if (E) {
                z.menu("enableItem", E.target);
            }
        }
    }
    //冻结
    function d(z, y, x) {
        var xz = c(z).datagrid("options"),
            $unfrozen =$('.unfrozen_gtitle'),
            $frozen = $('.frozen_gtitle');
        if(xz.frozenColumns.length<2){
            $unfrozen.hide();
            $frozen.show().html($unfrozen.html());
        }
        if (x) {
            p(z, y);
        } else {
            o(z, y);
        }
    }
    //解除
    function a(y, x) {
        var xz = c(y).datagrid("options"),
            nyz = xz.frozenColumns[0],
            yz = xz.columns[0],
            fop = [],
            nop = [],
            ck ='';
        if(nyz.length==2){
            $('.frozen_gtitle').hide();
            $('.unfrozen_gtitle').show();
        }
        for(var ci =0;ci<nyz.length;ci++) {
            if (nyz[ci]["field"] == x) {
                nop.push(nyz[ci]);
            }else if(nyz[ci]["checkbox"]&&nyz.length==2){
                fop.push(nyz[ci]);
            }
        }
        s(y, x, false);
        w(y, x, 1, 2);
        if(fop.length<1){
            xz.frozenColumns = [];
        }else{
            xz.frozenColumns[0]=fop;
        }
        if(xz.columns[0]){
            nop.forEach(function (cv) {
                xz.columns[0].unshift(cv);
            });
        }else{
            xz.columns.push(nop);
        }
    }
    function k(B, x, A, z) {
        var y = c(B).datagrid("options");
        var C = y[x];
        switch (x) {
            case "onLoadSuccess":
                if (z) {
                    y[x] = A;
                } else {
                    y[x] = function(D) {
                        C.apply(this, arguments);
                        A.apply(this, arguments);
                    };
                }
                break;

            case "onLoadError":
                if (z) {
                    y[x] = A;
                } else {
                    y[x] = function() {
                        C.apply(this, arguments);
                        A.apply(this, arguments);
                    };
                }
                break;

            case "onBeforeLoad":
                if (z) {
                    y[x] = A;
                } else {
                    y[x] = function(D) {
                        C.apply(this, arguments);
                        A.apply(this, arguments);
                    };
                }
                break;

            case "onClickRow":
                if (z) {
                    y[x] = A;
                } else {
                    y[x] = function(E, D) {
                        C.apply(this, arguments);
                        A.apply(this, arguments);
                    };
                }
                break;

            case "onDblClickRow":
                if (z) {
                    y[x] = A;
                } else {
                    y[x] = function(E, D) {
                        C.apply(this, arguments);
                        A.apply(this, arguments);
                    };
                }
                break;

            case "onClickCell":
                if (z) {
                    y[x] = A;
                } else {
                    y[x] = function(F, E, D) {
                        C.apply(this, arguments);
                        A.apply(this, arguments);
                    };
                }
                break;

            case "onDblClickCell":
                if (z) {
                    y[x] = A;
                } else {
                    y[x] = function(F, E, D) {
                        C.apply(this, arguments);
                        A.apply(this, arguments);
                    };
                }
                break;

            case "onSortColumn":
                if (z) {
                    y[x] = A;
                } else {
                    y[x] = function(E, D) {
                        C.apply(this, arguments);
                        A.apply(this, arguments);
                    };
                }
                break;

            case "onResizeColumn":
                if (z) {
                    y[x] = A;
                } else {
                    y[x] = function(E, D) {
                        C.apply(this, arguments);
                        A.apply(this, arguments);
                    };
                }
                break;

            case "onSelect":
                if (z) {
                    y[x] = A;
                } else {
                    y[x] = function(E, D) {
                        C.apply(this, arguments);
                        A.apply(this, arguments);
                    };
                }
                break;

            case "onUnselect":
                if (z) {
                    y[x] = A;
                } else {
                    y[x] = function(E, D) {
                        C.apply(this, arguments);
                        A.apply(this, arguments);
                    };
                }
                break;

            case "onSelectAll":
                if (z) {
                    y[x] = A;
                } else {
                    y[x] = function(D) {
                        C.apply(this, arguments);
                        A.apply(this, arguments);
                    };
                }
                break;

            case "onUnselectAll":
                if (z) {
                    y[x] = A;
                } else {
                    y[x] = function(D) {
                        C.apply(this, arguments);
                        handlerapply(this, arguments);
                    };
                }
                break;

            case "onCheck":
                if (z) {
                    y[x] = A;
                } else {
                    y[x] = function(E, D) {
                        C.apply(this, arguments);
                        A.apply(this, arguments);
                    };
                }
                break;

            case "onUncheck":
                if (z) {
                    y[x] = A;
                } else {
                    y[x] = function(E, D) {
                        C.apply(this, arguments);
                        A.apply(this, arguments);
                    };
                }
                break;

            case "onCheckAll":
                if (z) {
                    y[x] = A;
                } else {
                    y[x] = function(D) {
                        C.apply(this, arguments);
                        A.apply(this, arguments);
                    };
                }
                break;

            case "onUncheckAll":
                if (z) {
                    y[x] = A;
                } else {
                    y[x] = function(D) {
                        C.apply(this, arguments);
                        A.apply(this, arguments);
                    };
                }
                break;

            case "onBeforeEdit":
                if (z) {
                    y[x] = A;
                } else {
                    y[x] = function(E, D) {
                        C.apply(this, arguments);
                        A.apply(this, arguments);
                    };
                }
                break;

            case "onAfterEdit":
                if (z) {
                    y[x] = A;
                } else {
                    y[x] = function(F, E, D) {
                        C.apply(this, arguments);
                        A.apply(this, arguments);
                    };
                }
                break;

            case "onCancelEdit":
                if (z) {
                    y[x] = A;
                } else {
                    y[x] = function(E, D) {
                        C.apply(this, arguments);
                        A.apply(this, arguments);
                    };
                }
                break;

            case "onHeaderContextMenu":
                if (z) {
                    y[x] = A;
                } else {
                    y[x] = function(E, D) {
                        C.apply(this, arguments);
                        A.apply(this, arguments);
                    };
                }
                break;

            case "onRowContextMenu":
                if (z) {
                    y[x] = A;
                } else {
                    y[x] = function(E, F, D) {
                        C.apply(this, arguments);
                        A.apply(this, arguments);
                    };
                }
                break;

            case "onExpandRow":
                if (z) {
                    y[x] = A;
                } else {
                    y[x] = function(D, E) {
                        C && C.apply(this, arguments);
                        A.apply(this, arguments);
                    };
                }
                break;

            case "onCollapseRow":
                if (z) {
                    y[x] = A;
                } else {
                    y[x] = function(D, E) {
                        C && C.apply(this, arguments);
                        A.apply(this, arguments);
                    };
                }
                break;

            default:
                break;
        }
    }
    function l(z) {
        var y = c(z).datagrid("options");
        var x = [];
        y.finder.getTr(z, "", "allbody", 1).each(function() {
            if (c("span.datagrid-row-collapse", this).length > 0) {
                x.push(c(this).attr("datagrid-row-index"));
            }
        });
        return x;
    }
    c.fn.datagrid.headerContextMenu = {};
    c.fn.datagrid.headerContextMenu.defaultEvents = {
        doHideColumn:function(z, y, x) {
            c(z).datagrid("hideColumn", y);
            var A = c(z).datagrid("getHeaderContextMenu");
            A.menu("setIcon", {
                target:x.target,
                iconCls:"icon-unchecked"
            });
        },
        doShowColumn:function(z, y, x) {
            c(z).datagrid("showColumn", y);
            var A = c(z).datagrid("getHeaderContextMenu");
            A.menu("setIcon", {
                target:x.target,
                iconCls:"icon-checked"
            });
        },
        doShowAll:function(A) {
            var x = c(A).datagrid("getColumnFields");
            var B = c(A).datagrid("getHeaderContextMenu");
            for (i in x) {
                c(A).datagrid("showColumn", x[i]);
                var y = c(A).datagrid("getColumnOption", x[i]);
                var z = B.menu("findItem", y.title);
                if (z) {
                    B.menu("setIcon", {
                        target:z.target,
                        iconCls:"icon-checked"
                    });
                }
            }
        },
        doRestore:function(A) {
            var x = c(A).datagrid("getColumnFields");
            var B = c(A).datagrid("getHeaderContextMenu");
            for (i in x) {
                var y = c(A).datagrid("getColumnOption", x[i]);
                var z = B.menu("findItem", y.title);
                if (!y._hidden) {
                    c(A).datagrid("showColumn", x[i]);
                    z && B.menu("setIcon", {
                        target:z.target,
                        iconCls:"icon-checked"
                    });
                } else {
                    c(A).datagrid("hideColumn", x[i]);
                    z && B.menu("setIcon", {
                        target:z.target,
                        iconCls:"icon-unchecked"
                    });
                }
            }
        }
    };
    c.fn.datagrid.rowContextMenu = {};
    c.fn.datagrid.rowContextMenu.defaultEvents = {
        doAdd:function(x, A, y, z) {},
        doEdit:function(x, A, y, z) {},
        doDelete:function(x, A, y, z) {
            c.messager.confirm("疑问", "您确定要删除已选中的行？", function(B) {
                if (B) {
                    c(z).datagrid("deleteRows", c(z).datagrid("getSelections"));
                }
            });
        },
        doReload:function(x, A, y, z) {
            c(z).datagrid("load");
        },
        doReloadThisPage:function(x, A, y, z) {
            c(z).datagrid("reload");
        },
        doExportThisPage:function(x, A, y, z) {},
        doExprotAll:function(x, A, y, z) {}
    };
    c.extend(c.fn.datagrid.defaults.editors, {
        my97:{
            init:function(x, z) {
                var y = c('<input type="text" class="Wdate">').appendTo(x);
                z = z || {};
                z = c.extend({}, z, {
                    readOnly:true
                });
                return y.focus(function() {
                    WdatePicker();
                });
            },
            getValue:function(x) {
                return c(x).val();
            },
            setValue:function(y, x) {
                c(y).val(x);
            },
            resize:function(z, y) {
                var x = c(z);
                if (c.boxModel == true) {
                    x.width(y - (x.outerWidth() - x.width()));
                } else {
                    x.width(y);
                }
            }
        },
        // datetimebox:{
        //     init:function(x, z) {
        //         var y = c('<input type="text" class="easyui-datetimebox datagrid-editable-input">').appendTo(x);
        //         var cell_h = $(x).closest(".datagrid-row").height();
        //         console.log(cell_h);
        //         z = z || {};
        //         z = c.extend({}, z, {
        //             formatter:function(A) {
        //                 return c.dateFormat(new Date(A), "yyyy-MM-dd hh:mm");
        //             }
        //         });
        //         return y.datetimebox(z);
        //     },
        //     getValue:function(x) {
        //         return c(x).datetimebox("getValue");
        //     },
        //     setValue:function(y, x) {
        //         c(y).datetimebox("setValue", x);
        //     },
        //     resize:function(y, x) {
        //         c(y).datetimebox("resize", x);
        //     }
        // },
        numberspinner:{
            init:function(x, z) {
                var y = c('<input type="text">').appendTo(x);
                z = z || {};
                z = c.extend({}, z, {
                    min:0,
                    editable:false
                });
                return y.numberspinner(z);
            },
            getValue:function(x) {
                return c(x).numberspinner("getValue");
            },
            setValue:function(y, x) {
                c(y).numberspinner("setValue", x);
            },
            resize:function(y, x) {
                c(y).numberspinner("resize", x);
            }
        },
        timespinner:{
            init:function(x, z) {
                var y = c('<input type="text">').appendTo(x);
                z = z || {};
                return y.timespinner(z);
            },
            getValue:function(x) {
                return c(x).timespinner("getValue");
            },
            setValue:function(y, x) {
                c(y).timespinner("setValue", x);
            },
            resize:function(y, x) {
                c(y).timespinner("resize", x);
            }
        },
        combogrid:{
            init:function(x, z) {
                var y = c('<input type="text">').appendTo(x);
                z = z || {};
                z = c.extend({}, z, {
                    panelWidth:400,
                    editable:false
                });
                return y.combogrid(z);
            },
            getValue:function(x) {
                return c(x).combogrid("getValue");
            },
            setValue:function(y, x) {
                c(y).combogrid("setValue", x);
            },
            resize:function(y, x) {
                c(y).combogrid("resize", x);
            }
        }
    });
    c.fn.datagrid.defaults.customAttr = {
        headerContextMenu:{
            isShow:false,
            isMerge:true,
            items:[],
            onShow:function(y, x) {},
            onHide:function() {}
        },
        rowContextMenu:{
            isShow:false,
            isMerge:true,
            items:[]
        },
        pagination:{
            showPageList:false,
            showRefresh:true,
            beforePageText:undefined,
            afterPageText:undefined,
            displayMsg:undefined
        },
        slaveList:undefined,
        activeSlave:"dblclickrow",
        rowediting:false,
        tooltip:{
            enable:false,
            target:"row",
            position:"bottom",
            fields:undefined,
            formatter:undefined
        },
        onConfirmEdit:function(x) {
            return true;
        }
    };
    c.extend(c.fn.datagrid.methods, {
        followCustomHandle:function(x) {
            return x.each(function() {
                //r(this);
                m(this);
                e(this);
                b(this);
                f(this);
                q(this);
                u(this);
            });
        },
        getHeaderContextMenu:function(x) {
            return c("#" + h(x[0], "headerContextMenu"));
        },
        getRowContextMenu:function(x) {
            return c("#" + h(x[0], "rowContextMenu"));
        },
        getEditingRow:function(y) {
            var x = y.datagrid("getEditingRows");
            return x.length ? x[0] :null;
        },
        getEditingRows:function(B) {
            var x = c.data(B[0], "datagrid");
            var z = x.options;
            var A = x.data;
            var y = [];
            z.finder.getTr(B[0], "", "allbody").each(function() {
                if (c(this).hasClass("datagrid-row-editing")) {
                    var C = parseInt(c(this).attr("datagrid-row-index"));
                    y.push(A.rows[C]);
                }
            });
            return y;
        },
        setPagination:function(y, x) {
            return y.each(function() {
                c(this).datagrid("getPager").pagination(x);
            });
        },
        deleteRows:function(y, x) {
            return y.each(function() {
                var A = undefined;
                if (!c.isArray(x)) {
                    A = [ x ];
                } else {
                    A = x;
                }
                var z = this;
                c.each(A, function(C, D) {
                    if (c.isPlainObject(D)) {
                        var B = c(z).datagrid("getRowIndex", D);
                        c(z).datagrid("deleteRow", B);
                    } else {
                        c(z).datagrid("deleteRow", D);
                    }
                });
            });
        },
        Freeze_Column:function(y, x) {
            return y.each(function() {
                d(this, x, true);
            });
        },
        unfreezColumn:function(y, x) {
            return y.each(function() {
                a(this, x);
            });
        },
        addEventListener:function(y, x) {
            return y.each(function() {
                var z = c.isArray(x) ? x :[ x ];
                var A = this;
                c.each(z, function(B, C) {
                    k(A, C.name, C.handler || function() {}, C.override);
                });
            });
        },
        fixDetailRowWidth:function(y, x) {
            return y.each(function() {
                var A = c.data(this, "datagrid");
                var z = A.dc.header2.children();
                x.handler && x.handler.call(this, x.index, z.width());
            });
        },
        getAllExpandRowIndex:function(x) {
            return l(x[0]);
        },
        getExpandRowIndex:function(y) {
            var x = y.datagrid("getAllExpandRowIndex");
            return x.length > 0 ? x[0] :-1;
        }
    });
})(jQuery);

//portal
(function($){
    /**
     * initialize the portal
     */
    function init(target){
        $(target).addClass('portal');
        var table = $('<table border="0" cellspacing="0" cellpadding="0"><tr></tr></table>').appendTo(target);
        var tr = table.find('tr');

        var columnWidths = [];
        var totalWidth = 0;
        $(target).children('div:first').addClass('portal-column-left');
        $(target).children('div:last').addClass('portal-column-right');
        $(target).find('>div').each(function(){	// each column panel
            var column = $(this);
            totalWidth += column.outerWidth();
            columnWidths.push(column.outerWidth());

            var td = $('<td class="portal-column-td"></td>').appendTo(tr)
            column.addClass('portal-column').appendTo(td);
            column.find('>div').each(function(){	// each portal panel
                var p = $(this).addClass('portal-p').panel({
                    doSize:false,
                    cls:'portal-panel'
                });
                makeDraggable(target, p);
            });
        });
        for(var i=0; i<columnWidths.length; i++){
            columnWidths[i] /= totalWidth;
        }

        $(target).bind('_resize', function(){
            var opts = $.data(target, 'portal').options;
            if (opts.fit == true){
                setSize(target);
            }
            return false;
        });

        return columnWidths;
    }

    function initCss(){
        if (!$('#easyui-portal-style').length){
            $('head').append(
                '<style id="easyui-portal-style">' +
                '.portal{padding:0;margin:0;overflow:auto;}' +
                '.portal-noborder{border:0;}' +
                '.portal .portal-panel{margin-bottom:10px;}' +
                '.portal-column-td{vertical-align:top;}' +
                '.portal-column{padding:10px 0 10px 10px;overflow:hidden;}' +
                '.portal-column-left{padding-left:10px;}' +
                '.portal-column-right{padding-right:10px;}' +
                '.portal-proxy{opacity:0.6;filter:alpha(opacity=60);}' +
                '.portal-spacer{border:3px dashed #eee;margin-bottom:10px;}' +
                '</style>'
            );
        }
    }

    function setSize(target){
        var t = $(target);
        var opts = $.data(target, 'portal').options;
        if (opts.fit){
            var p = t.parent();
            opts.width = p.width();
            opts.height = p.height();
        }
        if (!isNaN(opts.width)){
            t._outerWidth(opts.width);
        } else {
            t.width('auto');
        }
        if (!isNaN(opts.height)){
            t._outerHeight(opts.height);
        } else {
            t.height('auto');
        }

        var hasScroll = t.find('>table').outerHeight() > t.height();
        var width = t.width();
        var columnWidths = $.data(target, 'portal').columnWidths;
        var leftWidth = 0;

        // calculate and set every column size
        for(var i=0; i<columnWidths.length; i++){
            var p = t.find('div.portal-column:eq('+i+')');
            var w = Math.floor(width * columnWidths[i]);
            if (i == columnWidths.length - 1){
//				w = width - leftWidth - (hasScroll == true ? 28 : 10);
                w = width - leftWidth - (hasScroll == true ? 18 : 0);
            }
            p._outerWidth(w);
            leftWidth += p.outerWidth();

            // resize every panel of the column
            p.find('div.portal-p').panel('resize', {width:p.width()});
        }
        opts.onResize.call(target, opts.width, opts.height);
    }

    /**
     * set draggable feature for the specified panel
     */
    function makeDraggable(target, panel){
        var spacer;
        panel.panel('panel').draggable({
            handle:'>div.panel-header>div.panel-title',
            proxy:function(source){
                var p = $('<div class="portal-proxy">proxy</div>').insertAfter(source);
                p.width($(source).width());
                p.height($(source).height());
                p.html($(source).html());
                p.find('div.portal-p').removeClass('portal-p');
                return p;
            },
            onBeforeDrag:function(e){
                e.data.startTop = $(this).position().top + $(target).scrollTop();
            },
            onStartDrag:function(e){
                $(this).hide();
                spacer = $('<div class="portal-spacer"></div>').insertAfter(this);
                setSpacerSize($(this).outerWidth(), $(this).outerHeight());
            },
            onDrag:function(e){
                var p = findPanel(e, this);
                if (p){
                    if (p.pos == 'up'){
                        spacer.insertBefore(p.target);
                    } else {
                        spacer.insertAfter(p.target);
                    }
                    setSpacerSize($(p.target).outerWidth());
                } else {
                    var c = findColumn(e);
                    if (c){
                        if (c.find('div.portal-spacer').length == 0){
                            spacer.appendTo(c);
                            setSize(target);
                            setSpacerSize(c.width());
                        }
                    }
                }
            },
            onStopDrag:function(e){
                $(this).css('position', 'static');
                $(this).show();
                spacer.hide();
                $(this).insertAfter(spacer);
                spacer.remove();
                setSize(target);
                panel.panel('move');

                var opts = $.data(target, 'portal').options;
                opts.onStateChange.call(target, panel);
            }
        });

        /**
         * find which panel the cursor is over
         */
        function findPanel(e, source){
            var result = null;
            $(target).find('div.portal-p').each(function(){
                var pal = $(this).panel('panel');
                if (pal[0] != source){
                    var pos = pal.offset();
                    if (e.pageX > pos.left && e.pageX < pos.left + pal.outerWidth()
                        && e.pageY > pos.top && e.pageY < pos.top + pal.outerHeight()){
                        if (e.pageY > pos.top + pal.outerHeight() / 2){
                            result = {
                                target:pal,
                                pos:'down'
                            };
                        } else {
                            result = {
                                target:pal,
                                pos:'up'
                            }
                        }
                    }
                }
            });
            return result;
        }

        /**
         * find which portal column the cursor is over
         */
        function findColumn(e){
            var result = null;
            $(target).find('div.portal-column').each(function(){
                var pal = $(this);
                var pos = pal.offset();
                if (e.pageX > pos.left && e.pageX < pos.left + pal.outerWidth()){
                    result = pal;
                }
            });
            return result;
        }

        /**
         * set the spacer size
         */
        function setSpacerSize(width, height){
            spacer._outerWidth(width);
            if (height){
                spacer._outerHeight(height);
            }
        }
    }


    $.fn.portal = function(options, param){
        if (typeof options == 'string'){
            return $.fn.portal.methods[options](this, param);
        }

        options = options || {};
        return this.each(function(){
            var state = $.data(this, 'portal');
            if (state){
                $.extend(state.options, options);
            } else {
                state = $.data(this, 'portal', {
                    options: $.extend({}, $.fn.portal.defaults, $.fn.portal.parseOptions(this), options),
                    columnWidths: init(this)
                });
            }
            if (state.options.border){
                $(this).removeClass('portal-noborder');
            } else {
                $(this).addClass('portal-noborder');
            }
            initCss();
            setSize(this);
        });
    };

    $.fn.portal.methods = {
        options: function(jq){
            return $.data(jq[0], 'portal').options;
        },
        resize: function(jq, param){
            return jq.each(function(){
                if (param){
                    var opts = $.data(this, 'portal').options;
                    if (param.width) opts.width = param.width;
                    if (param.height) opts.height = param.height;
                }
                setSize(this);
            });
        },
        getPanels: function(jq, columnIndex){
            var c = jq;	// the panel container
            if (columnIndex >= 0){
                c = jq.find('div.portal-column:eq(' + columnIndex + ')');
            }
            var panels = [];
            c.find('div.portal-p').each(function(){
                panels.push($(this));
            });
            return panels;
        },
        add: function(jq, param){	// param: {panel,columnIndex}
            return jq.each(function(){
                var c = $(this).find('div.portal-column:eq(' + param.columnIndex + ')');
                var p = param.panel.addClass('portal-p');
                p.panel('panel').addClass('portal-panel').appendTo(c);
                makeDraggable(this, p);
                p.panel('resize', {width:c.width()});
            });
        },
        remove: function(jq, panel){
            return jq.each(function(){
                var panels = $(this).portal('getPanels');
                for(var i=0; i<panels.length; i++){
                    var p = panels[i];
                    if (p[0] == $(panel)[0]){
                        p.panel('destroy');
                    }
                }
            });
        },
        disableDragging: function(jq, panel){
            panel.panel('panel').draggable('disable');
            return jq;
        },
        enableDragging: function(jq, panel){
            panel.panel('panel').draggable('enable');
            return jq;
        }
    };

    $.fn.portal.parseOptions = function(target){
        var t = $(target);
        return {
            width: (parseInt(target.style.width) || undefined),
            height: (parseInt(target.style.height) || undefined),
            border: (t.attr('border') ? t.attr('border') == 'true' : undefined),
            fit: (t.attr('fit') ? t.attr('fit') == 'true' : undefined)
        };
    };

    $.fn.portal.defaults = {
        width:'auto',
        height:'auto',
        border:true,
        fit:false,
        onResize:function(width,height){},
        onStateChange:function(panel){}
    };
})(jQuery);

(function(a) {
    a.extend({
        dateFormat:function(c, k) {
            if (c == null) {
                return null;
            }
            if (k == null) {
                var p = "yyyy-MM-dd";
            } else {
                var p = k;
            }
            var l = c.getFullYear().toString();
            var j = (c.getMonth() + 1).toString();
            var m = c.getDate().toString();
            var n = c.getHours().toString();
            var e = c.getMinutes().toString();
            var o = c.getSeconds().toString();
            var d = p.replace(/[^y]/g, "");
            var q = p.replace(/[^M]/g, "");
            var b = p.replace(/[^d]/g, "");
            var g = p.replace(/[^h]/g, "");
            var f = p.replace(/[^m]/g, "");
            var h = p.replace(/[^s]/g, "");
            if (d.length == 2) {
                l = l.substring(2, 4);
            }
            if (q.length > 1 && j.length == 1) {
                j = "0" + j;
            }
            if (b.length > 1 && m.length == 1) {
                m = "0" + m;
            }
            if (g.length > 1 && n.length == 1) {
                n = "0" + n;
            }
            if (f.length > 1 && e.length == 1) {
                e = "0" + e;
            }
            if (h.length > 1 && o.length == 1) {
                o = "0" + o;
            }
            if (d.length > 0) {
                p = p.replace(d, l);
            }
            if (q.length > 0) {
                p = p.replace(q, j);
            }
            if (b.length > 0) {
                p = p.replace(b, m);
            }
            if (g.length > 0) {
                p = p.replace(g, n);
            }
            if (f.length > 0) {
                p = p.replace(f, e);
            }
            if (h.length > 0) {
                p = p.replace(h, o);
            }
            return p;
        },
        parseDate:function(u, p) {
            var t = new Date();
            if (u == null) {
                return t;
            }
            if (p == null) {
                var m = "yyyy-MM-dd";
            } else {
                var m = p;
            }
            var w = m.replace(/[^y]/g, "");
            var l = m.replace(/[^M]/g, "");
            var h = m.replace(/[^d]/g, "");
            var x = m.replace(/[^h]/g, "");
            var d = m.replace(/[^m]/g, "");
            var f = m.replace(/[^s]/g, "");
            var j = m.indexOf(w);
            var q = w.length;
            var e = parseInt(u.substring(j, j + q));
            if (isNaN(e)) {
                e = t.getYear();
            } else {
                if (q == 2) {
                    if (e < 50) {
                        e += 2e3;
                    } else {
                        e += 1900;
                    }
                }
            }
            var y = m.indexOf(l);
            var v = parseInt(u.substring(y, y + l.length));
            if (isNaN(v)) {
                v = t.getMonth();
            } else {
                v -= 1;
            }
            var b = m.indexOf(h);
            var n = parseInt(u.substring(b, b + h.length));
            if (isNaN(n)) {
                n = t.getDate();
            }
            var s = m.indexOf(x);
            var o = parseInt(u.substring(s, s + x.length));
            if (isNaN(o)) {
                o = 0;
            }
            var c = m.indexOf(d);
            var k = parseInt(u.substring(c, c + d.length));
            if (isNaN(k)) {
                k = 0;
            }
            var r = m.indexOf(f);
            var g = parseInt(u.substring(r, r + f.length));
            if (isNaN(g)) {
                g = 0;
            }
            return new Date(e, v, n, o, k, g);
        }
    });
})(jQuery);

(function(b) {
    function a(d, c) {
        if (b("#" + d).length > 0) {
            return;
        }
        return b("<style>" + c + "</style>").attr("id", d).attr("type", "text/css").appendTo("head");
    }
    b.extend({
        mask:function(f) {
            f = f || {};
            var d = b.extend({}, {
                target:"body",
                loadMsg:b.fn.datagrid.defaults.loadMsg
            }, f);
            this.unmask(d);
            if (d.target != "body" && b(d.target).css("position") == "static") {
                b(d.target).addClass("mask-relative");
            }
            var c = b('<div class="datagrid-mask" style="display:block;"></div>').appendTo(d.target);
            var g = b('<div class="datagrid-mask-msg" style="display:block; left: 50%;"></div>').html(d.loadMsg).appendTo(d.target);
            setTimeout(function() {
                g.css("marginLeft", -g.outerWidth() / 2);
            }, 5);
            var e = ".mask-relative {position: relative !important;}";
            a("mask_css", e);
        },
        unmask:function(c) {
            var d = c.target || "body";
            b(">div.datagrid-mask-msg", d).remove();
            b(">div.datagrid-mask", d).remove();
            b(c.target).removeClass("mask-relative");
        }
    });
})(jQuery);

(function(c) {
    function a(f, e, d) {
        if (e && c.isArray(e)) {
            c.each(e, function() {
                var j = this;
                var h = {};
                if (d) {
                    c.extend(h, {
                        parent:d
                    });
                }
                if (c.isPlainObject(j)) {
                    c(f).menu("appendItem", c.extend(j, h));
                    if (j.submenu) {
                        var k = c(f).menu("findItem", j.text);
                        a(f, j.submenu, k.target);
                    }
                } else {
                    if (j == "-") {
                        var g = c(f).menu("appendItem", c.extend({
                            text:j
                        }, h)).menu("findItem", j).target;
                        c(g).removeClass("menu-item").addClass("menu-sep").removeAttr("style").empty();
                    }
                }
            });
        }
    }
    function b(h, d, g, f) {
        var e = c(h).menu("options");
        var j = e[d];
        switch (d) {
            case "onShow":
                if (f) {
                    e[d] = g;
                } else {
                    e[d] = function() {
                        j.apply(this, arguments);
                        g.apply(this, arguments);
                    };
                }
                break;

            case "onHide":
                if (f) {
                    e[d] = g;
                } else {
                    e[d] = function() {
                        j.apply(this, arguments);
                        g.apply(this, arguments);
                    };
                }
                break;

            case "onClick":
                if (f) {
                    e[d] = g;
                } else {
                    e[d] = function(k) {
                        j.apply(this, arguments);
                        g.apply(this, arguments);
                    };
                }
                break;

            default:
                break;
        }
    }
    c.extend(c.fn.menu.methods, {
        followCustomHandle:function(d) {},
        appendItems:function(e, d) {
            return e.each(function() {
                a(this, d);
            });
        },
        addEventListener:function(e, d) {
            return e.each(function() {
                var f = c.isArray(d) ? d :[ d ];
                var g = this;
                c.each(f, function(h, j) {
                    b(g, j.name, j.handler || function() {}, j.override);
                });
            });
        }
    });
})(jQuery);

(function(b) {
    function c(h) {
        var f = b.extend(true, {}, b.fn.panel.defaults, b(h).panel("options"));
        var g = f.customAttr.toolbar;
        if (!g) {
            return;
        }
        var d = b(h).panel("body");
        if (typeof g == "string") {
            b(g).addClass("dialog-toolbar panel-body").insertBefore(d);
            b(g).show();
        } else {
            var e = b("<div></div>").insertBefore(d);
            e.toolbar(g);
        }
    }
    function a(h, d, g, f) {
        var e = b(h).panel("options");
        var j = e[d];
        switch (d) {
            case "onResize":
                if (f) {
                    e[d] = g;
                } else {
                    e[d] = function(l, k) {
                        j.apply(this, arguments);
                        g.apply(this, arguments);
                    };
                }
                break;

            case "onMove":
                if (f) {
                    e[d] = g;
                } else {
                    e[d] = function(l, k) {
                        j.apply(this, arguments);
                        g.apply(this, arguments);
                    };
                }
                break;

            default:
                if (f) {
                    e[d] = g;
                } else {
                    e[d] = function() {
                        j.apply(this, arguments);
                        g.apply(this, arguments);
                    };
                }
        }
    }
    b.fn.panel.defaults.customAttr = {
        toolbar:{
            buttonPosition:"left",
            data:undefined
        }
    };
    b.extend(b.fn.panel.methods, {
        followCustomHandle:function(d) {
            return d.each(function() {
                c(this);
            });
        },
        addEventListener:function(e, d) {
            return e.each(function() {
                var f = b.isArray(d) ? d :[ d ];
                var g = this;
                b.each(f, function(h, j) {
                    a(g, j.name, j.handler || function() {}, j.override);
                });
            });
        }
    });
})(jQuery);

(function(a) {
    var b = function(d, h) {
        var e = d;
        var n = h;
        if (e < 1) {
            e = 1;
        }
        if (n < 1) {
            n = 1;
        }
        var c = parseInt(a(this).parent().css("width")) + 14;
        var k = parseInt(a(this).parent().css("height")) + 14;
        var j = e + c;
        var g = n + k;
        var m = a(window).width();
        var f = a(window).height();
        if (j > m) {
            e = m - c;
        }
        if (g > f) {
            n = f - k;
        }
        a(this).parent().css({
            left:e,
            top:n
        });
    };
    a.fn.dialog.defaults.onMove = b;
    a.fn.window.defaults.onMove = b;
    a.fn.panel.defaults.onMove = b;
    a.fn.panel.defaults = jQuery.extend({}, a.fn.panel.defaults, {
        onBeforeDestroy:function() {
            var c = a("iframe", this);
            if (c.length > 0) {
                c[0].contentWindow.document.write("");
                c[0].contentWindow.close();
                c.remove();
                if (navigator.userAgent.indexOf("MSIE") > 0) {
                    CollectGarbage();
                }
            }
        }
    });
})(jQuery);

(function(f) {
    function g(o) {
        return f(o).attr("id") + "_contextmenu";
    }
    function h(q, r) {
        var p = g(q);
        var o = f("#" + p);
        if (o.length == 0) {
            o = f("<div>", {
                id:p
            }).menu();
            o.menu("appendItems", r);
        }
        return o;
    }
    function m(p) {
        var o = {};
        f.each(p, function() {
            var r = this;
            if (r.onclick) {
                var q = r.id || r.text;
                o[q] = r.onclick;
                delete r.onclick;
            }
            if (r.submenu && f.isArray(r.submenu) && r.submenu.length > 0) {
                f.extend(o, m(r.submenu));
            }
        });
        return o;
    }
    function n(s) {
        var p = f.extend(true, {}, f.fn.tabs.defaults, f.data(s, "tabs").options);
        var o = p.customAttr.contextMenu;
        if (!o.isShow) {
            return;
        }
        var t = l(s);
        if (o.isMerge && f.isArray(o.items) && o.items.length > 0) {
            t = f.merge(t, o.items);
        }
        if (!o.isMerge && f.isArray(o.items) && o.items.length > 0) {
            t = o.items;
        }
        var r = m(t);
        var q = h(s, t);
        f(s).tabs("addEventListener", {
            name:"onContextMenu",
            handler:function(v, w, u) {
                v.preventDefault();
                j(s, q, u);
                q.menu("addEventListener", {
                    name:"onClick",
                    override:true,
                    handler:function(y) {
                        var x = y.id || y.text;
                        if (r[x]) {
                            r[x].call(this, y, w, u, s);
                        }
                    }
                }).menu("show", {
                    left:v.pageX,
                    top:v.pageY
                });
            }
        });
    }
    function j(s, q, o) {
        var r = g(s);
        var p = f("#" + r + "_fixed");
        if (f.inArray(o, f.fn.tabs.defaults.customAttr.fixedtabs) == -1 && !f(s).tabs("getTab", o).panel("options").closable) {
            q.menu("setText", {
                target:p,
                text:f.fn.tabs.defaults.contextMenu.itemname.unfixtab
            });
        } else {
            q.menu("setText", {
                target:p,
                text:f.fn.tabs.defaults.contextMenu.itemname.fixtab
            });
            if (f.inArray(o, f.fn.tabs.defaults.customAttr.fixedtabs) > -1) {
                q.menu("disableItem", p);
            } else {
                q.menu("enableItem", p);
            }
        }
        p = f("#" + r + "_close");
        if (!f(s).tabs("getTab", o).panel("options").closable) {
            q.menu("disableItem", p);
        } else {
            q.menu("enableItem", p);
        }
    }
    function l(p) {
        var o = g(p);
        return [ {
            id:o + "_reload",
            text:f.fn.tabs.defaults.contextMenu.itemname.reload,
            onclick:f.fn.tabs.defaults.contextMenu.defaultEventsHandler.reload
        }, {
            id:o + "_fixed",
            text:f.fn.tabs.defaults.contextMenu.itemname.fixtab,
            onclick:function(s, t, q, r) {
                if (s.text == f.fn.tabs.defaults.contextMenu.itemname.fixtab) {
                    f.fn.tabs.defaults.contextMenu.defaultEventsHandler.fixtab(s, t, q, r);
                } else {
                    f.fn.tabs.defaults.contextMenu.defaultEventsHandler.unfixtab(s, t, q, r);
                }
            }
        }, "-", {
            id:o + "_close",
            text:f.fn.tabs.defaults.contextMenu.itemname.close,
            onclick:f.fn.tabs.defaults.contextMenu.defaultEventsHandler.closetab
        }, {
            id:o + "_close_others",
            text:f.fn.tabs.defaults.contextMenu.itemname.closeothers,
            onclick:f.fn.tabs.defaults.contextMenu.defaultEventsHandler.closeOthersTab
        }, {
            id:o + "_close_rightside",
            text:f.fn.tabs.defaults.contextMenu.itemname.closerightside,
            onclick:f.fn.tabs.defaults.contextMenu.defaultEventsHandler.closeRightSideTabs
        }, {
            id:o + "_close_all",
            text:f.fn.tabs.defaults.contextMenu.itemname.closeall,
            onclick:f.fn.tabs.defaults.contextMenu.defaultEventsHandler.closeAll
        } ];
    }
    function a(p, o) {
        var q = [];
        o++;
        f(p).children("div.tabs-header").find("ul li:nth-child(" + o + ")").each(function() {
            q.push(this);
        });
        return q.length > 0 ? q[0] :null;
    }
    function b(u, r, o, v) {
        if (typeof o == "number" && typeof r == "number") {
            var w = f.data(u, "tabs").tabs;
            if (o < 0 || o > w.length) {
                return;
            }
            if (r < 0 || r > w.length) {
                return;
            }
            if (v) {
                var y = w[o];
                for (var q = o; q > r; q--) {
                    w.splice(q, 1, w[q - 1]);
                }
                w[r] = y;
                var x = a(u, r);
                if (x) {
                    var t = a(u, o);
                    f(x).before(t);
                }
            } else {
                var y = w[r];
                for (var p = r; p <= o; p++) {
                    w.splice(p, 1, w[p + 1]);
                }
                w[o] = y;
                var x = a(u, o);
                if (x) {
                    var s = a(u, r);
                    f(x).after(s);
                }
            }
        }
    }
    function e(r) {
        var p = f(r).tabs("tabs");
        var s = [];
        for (var o = 0; o < p.length; o++) {
            var q = p[o];
            if (q.panel("options").closable == undefined || !q.panel("options").closable) {
                s.push(q);
            }
        }
        return s;
    }
    function d(v, r, o, w, t) {
        var s = f("<iframe>").attr("height", "100%").attr("width", "100%").attr("marginheight", "0").attr("marginwidth", "0").attr("frameborder", "0");
        setTimeout(function() {
            s.attr("src", o);
        }, 1);
        var q = f(v).tabs("getTab", r);
        q.panel("body").css({
            overflow:"hidden"
        }).empty().append(s);
        if (w) {
            var t = t || f.fn.datagrid.defaults.loadMsg;
            var u = q.panel("body");
            u.css("position", "relative");
            var x = f('<div class="datagrid-mask" style="display:block;"></div>').appendTo(u);
            var p = f('<div class="datagrid-mask-msg" style="display:block; left: 50%;"></div>').html(t).appendTo(u);
            setTimeout(function() {
                p.css("marginLeft", -p.outerWidth() / 2);
            }, 5);
        }
        s.bind("load", function() {
            if (s[0].contentWindow) {
                q.panel("body").children("div.datagrid-mask-msg").remove();
                q.panel("body").children("div.datagrid-mask").remove();
            }
        });
    }
    f.fn.tabs.defaults.contextMenu = {};
    f.fn.tabs.defaults.contextMenu.itemname = {};
    f.fn.tabs.defaults.contextMenu.itemname.reload = "重新加载";
    f.fn.tabs.defaults.contextMenu.itemname.fixtab = "固定标签页";
    f.fn.tabs.defaults.contextMenu.itemname.unfixtab = "取消固定标签";
    f.fn.tabs.defaults.contextMenu.itemname.close = "关闭标签页";
    f.fn.tabs.defaults.contextMenu.itemname.closeothers = "关闭其他标签页";
    f.fn.tabs.defaults.contextMenu.itemname.closerightside = "关闭右侧标签页";
    f.fn.tabs.defaults.contextMenu.itemname.closeall = "关闭所有标签页";
    f.fn.tabs.defaults.contextMenu.defaultEventsHandler = {
        reload:function(r, t, q, s) {
            var o = f(s).tabs("getTab", q);
            var p = o.panel("options").useiframe;
            if (p) {
                f("iframe", o.panel("body")).each(function() {
                    this.contentWindow.location.reload();
                });
            } else {
                o.panel("refresh");
            }
        },
        fixtab:function(r, t, p, s) {
            var q = f(s).tabs("getTab", p);
            f(s).tabs("update", {
                tab:q,
                options:{
                    closable:false
                }
            });
            var o = f.fn.tabs.defaults.customAttr.fixedtabs.length;
            b(s, o, p, true);
        },
        unfixtab:function(r, t, o, s) {
            var p = e(s).length - 1;
            var q = f(s).tabs("getTab", o);
            f(s).tabs("update", {
                tab:q,
                options:{
                    closable:true
                }
            });
            b(s, o, p);
        },
        closetab:function(q, s, p, r) {
            var o = f(r).tabs("getTab", p).panel("options");
            if (o.closable) {
                f(r).tabs("close", p);
            }
        },
        closeOthersTab:function(s, r, p, t) {
            var q = f(t).tabs("tabs");
            var o = f.grep(q, function(v, u) {
                return v.panel("options").closable && u != p;
            });
            f.each(o, function() {
                f(t).tabs("close", this.panel("options").title);
            });
        },
        closeRightSideTabs:function(r, t, p, s) {
            var q = f(s).tabs("tabs");
            var o = f.grep(q, function(v, u) {
                return u > p && v.panel("options").closable;
            });
            f.each(o, function() {
                f(s).tabs("close", this.panel("options").title);
            });
        },
        closeAll:function(r, t, p, s) {
            var q = f(s).tabs("tabs");
            var o = f.grep(q, function(v, u) {
                return v.panel("options").closable;
            });
            f.each(o, function() {
                f(s).tabs("close", this.panel("options").title);
            });
        }
    };
    function c(s, o, r, q) {
        var p = f(s).tabs("options");
        var t = p[o];
        switch (o) {
            case "onLoad":
                if (q) {
                    p[o] = r;
                } else {
                    p[o] = function(u) {
                        t.apply(this, arguments);
                        r.apply(this, arguments);
                    };
                }
                break;

            case "onContextMenu":
                if (q) {
                    p[o] = r;
                } else {
                    p[o] = function(v, w, u) {
                        t.apply(this, arguments);
                        r.apply(this, arguments);
                    };
                }
                break;

            default:
                if (q) {
                    p[o] = r;
                } else {
                    p[o] = function(v, u) {
                        t.apply(this, arguments);
                        r.apply(this, arguments);
                    };
                }
                break;
        }
    }
    f.fn.tabs.defaults.customAttr = {
        fixedtabs:[ 0 ],
        contextMenu:{
            isShow:false,
            isMerge:true,
            items:[]
        }
    };
    var k = f.extend({}, f.fn.tabs.methods);
    f.extend(f.fn.tabs.methods, {
        followCustomHandle:function(o) {
            return o.each(function() {
                n(this);
            });
        },
        add:function(p, o) {
            return p.each(function() {
                var q = null;
                if (o.href || /^url:/.test(o.content)) {
                    q = o.href || o.content.substr(4, o.content.length);
                    delete o.content;
                    delete o.href;
                }
                if (q) {
                    if (o.useiframe) {
                        k.add(p, o);
                        d(this, o.title, q, o.showMask, o.loadMsg);
                    } else {
                        k.add(p, f.extend(o, {
                            href:q
                        }));
                    }
                } else {
                    k.add(p, o);
                }
                if (o.css) {
                    f(this).tabs("getTab", o.title).css(o.css);
                }
            });
        },
        addEventListener:function(p, o) {
            return p.each(function() {
                var q = f.isArray(o) ? o :[ o ];
                var r = this;
                f.each(q, function(s, t) {
                    c(r, t.name, t.handler || function() {}, t.override);
                });
            });
        }
    });
})(jQuery);

(function($) {
    function init(target) {
        var options = $(target).toolbar("options");
        var tb = $(target).addClass("datagrid-toolbar").css({
            "border-top-width":1
        });
        tb.append('<table cellspacing="0" cellpadding="0"><tr></tr></table>');
        if (options.buttonPosition == "right") {
            tb.find("table").css("float", "right");
        }
        if (options.data) {
            addItems(target, options.data);
        } else {
            options.loader.call(target, function(data) {
                options.data = data;
                addItems(target, options.data);
            }, function() {
                options.onLoadError.apply(target, arguments);
            });
        }
    }
    function add(target, item) {
        var tr = $(target).find("tr");
        if (typeof item == "string" && $.trim(item) == "-") {
            $('<td><div class="dialog-tool-separator"></div></td>').appendTo(tr);
        } else {
            if ($.trim(item.text) == "-") {
                $('<td><div class="dialog-tool-separator"></div></td>').appendTo(tr);
            } else {
                var td = $("<td></td>").appendTo(tr);
                var button = $('<a href="javascript:void(0)"></a>').appendTo(td);
                button[0].onclick = eval(item.handler || function() {});
                button.linkbutton($.extend({}, item, {
                    plain:true
                }));
            }
        }
    }
    function addItems(target, items) {
        if (!$.isArray(items)) {
            return;
        }
        for (var i = 0; i < items.length; i++) {
            add(target, items[i]);
        }
    }
    $.fn.toolbar = function(options, param) {
        if (typeof options == "string") {
            return $.fn.toolbar.methods[options](this, param);
        }
        options = options || {};
        return this.each(function() {
            var state = $.data(this, "toolbar");
            if (state) {
                $.extend(state.options, options);
            } else {
                $.data(this, "toolbar", {
                    options:$.extend({}, $.fn.toolbar.defaults, $.parser.parseOptions(this), options)
                });
                init(this);
            }
        });
    };
    $.fn.toolbar.methods = {
        options:function(jq) {
            return $.data(jq[0], "toolbar").options;
        },
        add:function(jq, items) {
            return jq.each(function() {
                addItems(this, items);
            });
        }
    };
    $.fn.toolbar.defaults = {
        data:null,
        url:undefined,
        buttonPosition:"left",
        loader:function(success, error) {
            var options = $(this).toolbar("options");
            $.ajax({
                type:"POST",
                url:"toolbar_data.json",
                dataType:"json",
                success:function(data) {
                    success(data);
                },
                error:function() {
                    error.apply(this, arguments);
                }
            });
        },
        onLoadError:function() {}
    };
})(jQuery);

(function(f) {
    function k(u) {
        return f(u).attr("id") + "_contextmenu";
    }
    function r(w, x) {
        var v = k(w);
        var u = f("#" + v);
        if (u.length == 0) {
            u = f("<div>", {
                id:v
            }).menu();
            u.menu("appendItems", x);
        }
        return u;
    }
    function q(v) {
        var u = {};
        f.each(v, function() {
            var x = this;
            if (x.onclick) {
                var w = x.id || x.text;
                u[w] = x.onclick;
                delete x.onclick;
            }
            if (x.submenu && f.isArray(x.submenu) && x.submenu.length > 0) {
                f.extend(u, q(x.submenu));
            }
        });
        return u;
    }
    function d(v) {
        var u = k(v);
        return [ {
            id:u + "_moveup",
            text:"位置上移",
            iconCls:"icon-moveup",
            onclick:f.fn.tree.contextmenu.defaultEvents.moveup
        }, {
            id:u + "_movedown",
            text:"位置下移",
            iconCls:"icon-movedown",
            onclick:f.fn.tree.contextmenu.defaultEvents.movedown
        } ];
    }
    function s(y) {
        var v = f.extend(true, {}, f.fn.tree.defaults, f(y).tree("options"));
        var u = v.customAttr.contextMenu;
        if (!u.isShow) {
            return;
        }
        var z = d(y);
        if (u.isMerge && f.isArray(u.items) && u.items.length > 0) {
            z = f.merge(z, u.items);
        }
        if (!u.isMerge && f.isArray(u.items) && u.items.length > 0) {
            z = u.items;
        }
        var x = q(z);
        var w = r(y, z);
        f(y).tree("addEventListener", {
            name:"onContextMenu",
            handler:function(B, A) {
                B.preventDefault();
                f(y).tree("select", A.target);
                w.menu("addEventListener", {
                    name:"onClick",
                    override:true,
                    handler:function(D) {
                        var C = D.id || D.text;
                        if (x[C]) {
                            x[C].call(this, D, A, y);
                        }
                    }
                }).menu("show", {
                    left:B.pageX,
                    top:B.pageY
                });
            }
        });
    }
    function l(A, v) {
        var z = v.id || v.text;
        var B = f(A).tree("getParent", v.target);
        var u = e(A, B.target, false);
        var C = -1;
        for (var w = 0, y = u.length; w < y; w++) {
            var x = u[w].id || u[w].text;
            if (z == x) {
                C = w - 1;
                break;
            }
        }
        if (C > -1) {
            return u[C];
        }
        return null;
    }
    function a(A, v) {
        var z = v.id || v.text;
        var C = f(A).tree("getParent", v.target);
        var u = e(A, C.target, false);
        var B = -1;
        for (var w = 0, y = u.length; w < y; w++) {
            var x = u[w].id || u[w].text;
            if (z == x) {
                B = w + 1;
                break;
            }
        }
        if (B > -1 && B < u.length) {
            return u[B];
        }
        return null;
    }
    function e(x, w, u) {
        if (u) {
            return f(x).tree("getChildren", w);
        } else {
            var v = [];
            f(w).next().find(">li>div.tree-node").each(function() {
                v.push(f(x).tree("getNode", this));
            });
            return v;
        }
    }
    function b(v) {
        var u = f.extend(true, {}, f.fn.tree.defaults, f(v).tree("options"));
        if (!u.customAttr.expandOnNodeClick && !u.customAttr.expandOnDblClick) {
            return;
        }
        if (u.customAttr.expandOnNodeClick) {
            f(v).tree("addEventListener", {
                name:"onClick",
                handler:function(w) {
                    f(v).tree("toggle", w.target);
                }
            });
            return;
        }
        if (u.customAttr.expandOnDblClick) {
            f(v).tree("addEventListener", {
                name:"onDblClick",
                handler:function(w) {
                    f(v).tree("toggle", w.target);
                }
            });
        }
    }
    function h(w, v) {
        var x = 1;
        var u = f(w).tree("getParent", v.target);
        if (!u) {
            return 1;
        }
        return x + h(w, u);
    }
    function o(z, A, y) {
        var u = y ? [ y ] :f(z).tree("getRoots");
        for (var x = 0; x < u.length; x++) {
            var w = e(z, u[x].target, false);
            for (var v = 0; v < w.length; v++) {
                f(z).tree("expandTo", w[v].target);
            }
            A--;
            if (A > 0) {
                for (var v = 0; v < w.length; v++) {
                    o(z, A, w[v]);
                }
            }
        }
    }
    function p(v) {
        var u = f.extend(true, {}, f.fn.tree.defaults, f(v).tree("options"));
        if (!u.customAttr.onlyNodeExpand) {
            return;
        }
        f(v).tree("addEventListener", {
            name:"onBeforeExpand",
            handler:function(z) {
                var y = f(v).tree("getParent", z.target);
                if (y) {
                    var x = e(v, y.target, false);
                    for (var w = 0; w < x.length; w++) {
                        if (x[w].state == "open") {
                            f(v).tree("collapseAll", x[w].target);
                        }
                    }
                } else {
                    f(v).tree("collapseAll");
                }
            }
        });
    }
    function m(y, u, x, w) {
        var v = f(y).tree("options");
        var z = v[u];
        switch (u) {
            case "onBeforeLoad":
                if (w) {
                    v[u] = x;
                } else {
                    v[u] = function(A, B) {
                        z.apply(this, arguments);
                        x.apply(this, arguments);
                    };
                }
                break;

            case "onLoadSuccess":
                if (w) {
                    v[u] = x;
                } else {
                    v[u] = function(A, B) {
                        z.apply(this, arguments);
                        x.apply(this, arguments);
                    };
                }
                break;

            case "onLoadError":
                if (w) {
                    v[u] = x;
                } else {
                    v[u] = function(A) {
                        z.apply(this, A);
                        x.apply(this, A);
                    };
                }
                break;

            case "onBeforeCheck":
                if (w) {
                    v[u] = x;
                } else {
                    v[u] = function(B, A) {
                        z.apply(this, arguments);
                        x.apply(this, arguments);
                    };
                }
                break;

            case "onCheck":
                if (w) {
                    v[u] = x;
                } else {
                    v[u] = function(B, A) {
                        z.apply(this, arguments);
                        x.apply(this, arguments);
                    };
                }
                break;

            case "onContextMenu":
                if (w) {
                    v[u] = x;
                } else {
                    v[u] = function(B, A) {
                        z.apply(this, arguments);
                        x.apply(this, arguments);
                    };
                }
                break;

            case "onDragEnter":
                if (w) {
                    v[u] = x;
                } else {
                    v[u] = function(B, A) {
                        z.apply(this, arguments);
                        x.apply(this, arguments);
                    };
                }
                break;

            case "onDragOver":
                if (w) {
                    v[u] = x;
                } else {
                    v[u] = function(B, A) {
                        z.apply(this, arguments);
                        x.apply(this, arguments);
                    };
                }
                break;

            case "onDragLeave":
                if (w) {
                    v[u] = x;
                } else {
                    v[u] = function(B, A) {
                        z.apply(this, arguments);
                        x.apply(this, arguments);
                    };
                }
                break;

            case "onBeforeDrop":
                if (w) {
                    v[u] = x;
                } else {
                    v[u] = function(C, B, A) {
                        z.apply(this, arguments);
                        x.apply(this, arguments);
                    };
                }
                break;

            case "onDrop":
                if (w) {
                    v[u] = x;
                } else {
                    v[u] = function(C, B, A) {
                        z.apply(this, arguments);
                        x.apply(this, arguments);
                    };
                }
                break;

            default:
                if (w) {
                    v[u] = x;
                } else {
                    v[u] = function(A) {
                        z.apply(this, arguments);
                        x.apply(this, arguments);
                    };
                }
                break;
        }
    }
    function n(w, u) {
        if (!w.attributes) {
            w.attributes = {};
        }
        for (var v = 0; v < u.length; v++) {
            w.attributes[u[v]] = w[u[v]];
        }
    }
    function t(v) {
        var u = v.idField || v.textField || v.iconField || v.childrenField || v.attributesField || v.attributes || false;
        return u ? true :false;
    }
    function g(E, z) {
        if (!t(E)) {
            return z;
        }
        var u = E.idField || "id", w = E.textField || "text", v = E.iconField || "iconCls", B = E.parentField || "pid", x = E.attributes || [];
        var C = [], D = [];
        for (var y = 0, A = z.length; y < A; y++) {
            D[z[y][u]] = z[y];
        }
        for (var y = 0, A = z.length; y < A; y++) {
            if (D[z[y][B]] && z[y][u] != z[y][B]) {
                if (!D[z[y][B]]["children"]) {
                    D[z[y][B]]["children"] = [];
                }
                z[y]["text"] = z[y][w];
                z[y][v] && (z[y]["iconCls"] = z[y][v]);
                n(z[y], x);
                D[z[y][B]]["children"].push(z[y]);
            } else {
                z[y]["text"] = z[y][w];
                z[y][v] && (z[y]["iconCls"] = z[y][v]);
                n(z[y], x);
                C.push(z[y]);
            }
        }
        return C;
    }
    function c(D, A) {
        if (!t(D)) {
            return A;
        }
        var u = D.idField || "id", x = D.textField || "text", w = D.iconField || "iconCls", C = D.childrenField || "children", B = D.attributesField || "attributes", y = D.attributes || [];
        var v = function(F) {
            if (!F.id && F[u]) {
                F.id = F[u];
            }
            if (!F.text && F[x]) {
                F.text = F[x];
            }
            if (!F.iconCls && F[w]) {
                F.iconCls = F[w];
            }
            if (!F.children && F[C]) {
                F.children = F[C];
            }
            if (!F.attributes && F[B]) {
                F.attributes = F[B];
            }
            if (y && f.isArray(y)) {
                n(F, y);
            }
            if (F.children) {
                for (var E = 0; E < F.children.length; E++) {
                    v(F.children[E]);
                }
            }
        };
        for (var z = 0; z < A.length; z++) {
            v(A[z]);
        }
        return A;
    }
    f.fn.tree.contextmenu = {};
    f.fn.tree.contextmenu.defaultEvents = {
        moveup:function(y, x, z) {
            var v = f.extend(true, {}, f.fn.tree.defaults, f(z).tree("options"));
            var w = l(z, x);
            if (w) {
                var u = f(z).tree("pop", x.target);
                f(z).tree("insert", {
                    before:w.target,
                    data:u
                });
                v.customAttr.onAfterMove.call(this, w, x);
            }
        },
        movedown:function(y, x, z) {
            var w = f.extend(true, {}, f.fn.tree.defaults, f(z).tree("options"));
            var v = a(z, x);
            if (v) {
                var u = f(z).tree("pop", x.target);
                f(z).tree("insert", {
                    after:v.target,
                    data:u
                });
                w.customAttr.onAfterMove.call(this, v, x);
            }
        }
    };
    f.fn.tree.defaults.customAttr = {
        idField:null,
        textField:null,
        parentField:null,
        iconField:null,
        childrenField:null,
        attributesField:null,
        attributes:null,
        dataModel:null,
        expandOnNodeClick:false,
        expandOnDblClick:false,
        onlyNodeExpand:false,
        contextMenu:{
            isShow:false,
            isMerge:true,
            items:[]
        },
        onAfterMove:function(v, u) {}
    };
    f.fn.tree.defaults.loadFilter = function(w, v) {
        var u = f(this).tree("options").customAttr;
        if (u) {
            if (u.dataModel == "simpleData") {
                return g(u, w);
            } else {
                return c(u, w);
            }
        }
        return w;
    };
    f.fn.combotree.defaults.loadFilter = f.fn.tree.defaults.loadFilter;
    var j = f.extend({}, f.fn.tree.methods);
    f.extend(f.fn.tree.methods, {
        followCustomHandle:function(u) {
            return u.each(function() {
                s(this);
                b(this);
                p(this);
            });
        },
        getLevel:function(v, u) {
            return h(v[0], u);
        },
        expandTo:function(v, u) {
            return v.each(function() {
                if (f.type(u) == "number") {
                    var w = u;
                    o(this, w);
                } else {
                    j.expandTo(v, u);
                }
            });
        },
        addEventListener:function(v, u) {
            return v.each(function() {
                var w = f.isArray(u) ? u :[ u ];
                var x = this;
                f.each(w, function(y, z) {
                    m(x, z.name, z.handler || function() {}, z.override);
                });
            });
        }
    });
})(jQuery);

(function(d) {
    function e(o, n) {
        return d(o).attr("id") + "_" + n;
    }
    function g(q, r, n) {
        var p = e(q, n);
        var o = d("#" + p);
        if (o.length == 0) {
            o = d("<div>", {
                id:p
            }).menu();
            o.menu("appendItems", r);
        }
        return o;
    }
    function l(o) {
        var n = {};
        d.each(o, function() {
            var q = this;
            if (q.onclick) {
                var p = q.id || q.text;
                n[p] = q.onclick;
                delete q.onclick;
            }
            if (q.submenu && d.isArray(q.submenu) && q.submenu.length > 0) {
                d.extend(n, l(q.submenu));
            }
        });
        return n;
    }
    function j(o) {
        var n = e(o, "rowContextMenu");
        return [ {
            id:n + "_delete",
            text:"删除",
            iconCls:"icon-remove",
            onclick:d.fn.treegrid.headerContextMenu.defaultEvents.doRemove
        }, "-", {
            id:n + "_reload",
            text:"刷新",
            iconCls:"icon-reload",
            onclick:d.fn.treegrid.headerContextMenu.defaultEvents.doReload
        } ];
    }
    function m(r) {
        var n = d.extend(true, {}, d.fn.treegrid.defaults, d(r).treegrid("options"));
        var o = n.customAttr.contextMenu;
        if (!o.isShow) {
            return;
        }
        var s = j(r);
        if (o.isMerge && d.isArray(o.items) && o.items.length > 0) {
            d.merge(s, o.items);
        }
        if (!o.isMerge && d.isArray(o.items) && o.items.length > 0) {
            s = o.items;
        }
        var q = l(s);
        var p = g(r, s, "rowContextMenu");
        d(r).treegrid("addEventListener", {
            name:"onContextMenu",
            handler:function(u, v) {
                u.preventDefault();
                d(r).treegrid("select", v[n.idField]);
                var t = p.menu("options");
                t.onClickCallback = t.onClickCallback || t.onClick;
                p.menu("addEventListener", {
                    name:"onClick",
                    override:true,
                    handler:function(x) {
                        var w = x.id || x.text;
                        if (q[w]) {
                            q[w].call(this, x, v, r);
                        }
                    }
                }).menu("show", {
                    left:u.pageX,
                    top:u.pageY
                });
            }
        });
    }
    function f(t) {
        var s = e(t, "headerContextMenu");
        var n = [ {
            text:StrackLang["Show_Hide_Column"],
            iconCls:"icon-columns",
            submenu:[ {
                id:s + "_showAll",
                text:StrackLang["ShowAll"],
                iconCls:"icon-columns",
                onclick:function(v, w, u) {
                    d.fn.datagrid.headerContextMenu.defaultEvents.doShowAll(u);
                }
            }, {
                id:s + "_restore",
                text:StrackLang["Restore"],
                iconCls:"icon-columns",
                onclick:function(v, w, u) {
                    d.fn.datagrid.headerContextMenu.defaultEvents.doRestore(u);
                }
            }, "-" ]
        } ];
        var o = function(u) {
            return u.substr(u.lastIndexOf("-") + 1, u.length);
        };
        var q = [];
        var r = d(t).treegrid("getColumnFields");
        var p = d(t).treegrid("options").treeField;
        d.each(r, function(v, x) {
            if (!x) {
                return true;
            }
            var w = x == p ? true :false;
            var u = d(t).treegrid("getColumnOption", x);
            u._hidden = u.hidden;
            q.push({
                id:s + "-" + x,
                text:u.title,
                iconCls:u.hidden ? "icon-unchecked" :"icon-checked",
                disabled:w,
                onclick:function(z, y, C) {
                    var B = o(z.id);
                    var A = d(C).treegrid("getColumnOption", B).hidden;
                    if (!A) {
                        d.fn.datagrid.headerContextMenu.defaultEvents.doHideColumn(C, B, z);
                    } else {
                        d.fn.datagrid.headerContextMenu.defaultEvents.doShowColumn(C, B, z);
                    }
                }
            });
        });
        d.merge(n[0].submenu, q);
        return n;
    }
    function k(q) {
        var o = d.extend(true, {}, d.fn.treegrid.defaults, d(q).treegrid("options"));
        var s = o.customAttr.headerContextMenu;
        if (!s.isShow) {
            return;
        }
        var r = f(q);
        if (s.isMerge) {
            d.merge(r, s.items);
        }
        if (!s.isMerge && d.isArray(s.items) && s.items.length > 0) {
            r = s.items;
        }
        var p = l(r);
        var n = g(q, r, "headerContextMenu");
        d(q).treegrid("addEventListener", {
            name:"onHeaderContextMenu",
            handler:function(u, t) {
                u.preventDefault();
                n.menu("addEventListener", {
                    name:"onClick",
                    override:true,
                    handler:function(w) {
                        var v = w.id || w.text;
                        if (p[v]) {
                            p[v].call(this, w, t, q);
                        }
                    }
                }).menu("show", {
                    left:u.pageX,
                    top:u.pageY
                });
            }
        });
    }
    function a(q) {
        var p = d.extend(true, {}, d.fn.treegrid.defaults, d(q).treegrid("options"));
        if (!p.customAttr.expandOnNodeClick && !p.customAttr.expandOnDblClick) {
            return;
        }
        var n = p.treeField;
        var o = p.idField;
        if (p.customAttr.expandOnNodeClick) {
            d(q).treegrid("addEventListener", {
                name:"onClickCell",
                handler:function(r, s) {
                    if (n == r) {
                        d(q).treegrid("toggle", s[o]);
                    }
                }
            });
            return;
        }
        if (p.customAttr.expandOnDblClick) {
            d(q).treegrid("addEventListener", {
                name:"onDblClickCell",
                handler:function(r, s) {
                    if (n == r) {
                        d(q).treegrid("toggle", s[o]);
                    }
                }
            });
        }
    }
    function b(s) {
        var o = d.extend(true, {}, d.fn.treegrid.defaults, d(s).treegrid("options"));
        if (!o.customAttr.rowediting) {
            return;
        }
        var t = function(u) {
            return d(u).attr("id") + "_editor_buttons_panel";
        };
        var n = 120;
        var q = function(y) {
            var x = t(y);
            if (d("#" + x).length > 0) {
                return;
            }
            var v = d(y).treegrid("getPanel");
            var w = d(">div.datagrid-view>div.datagrid-view2>div.datagrid-body", v);
            w.css("position", "relative");
            var u = d("<div>", {
                id:x
            }).addClass("dialog-button").appendTo(w).css({
                position:"absolute",
                display:"block",
                "border-bottom":"1px solid #ddd",
                "border-left":"1px solid #ddd",
                "border-right":"1px solid #ddd",
                left:parseInt(v.width() / 2) - n,
                "z-index":2013,
                display:"none",
                padding:"4px 5px"
            });
            d('<a href="javascript:void(0)">确定</a>').css("margin-left", "0px").linkbutton({
                iconCls:"icon-ok"
            }).click(function() {
                var z = o.idField;
                var A = d(y).treegrid("getEditingRow");
                if (!o.customAttr.onConfirmEdit.call(y, A)) {
                    return;
                }
                d(y).treegrid("endEdit", A[z]);
            }).appendTo(u);
            d('<a href="javascript:void(0)">取消</a>').css("margin-left", "6px").linkbutton({
                iconCls:"icon-cancel"
            }).click(function() {
                var z = o.idField;
                var A = d(y).treegrid("getEditingRow");
                d(y).treegrid("cancelEdit", A[z]);
            }).appendTo(u);
        };
        var r = function(A, C) {
            var v = o.idField;
            var B = o.finder.getTr(A, C[v], "body", 2);
            var x = B.position();
            var w = "#" + t(A);
            var u = d(A).treegrid("getPanel");
            var y = d(">div.datagrid-view>div.datagrid-view2>div.datagrid-body", u);
            var z = function() {
                var D = B.height(), E = B.width();
                var G = x.top + y.scrollTop(), F = x.left;
                var H = 11;
                if (E > y.width()) {
                    F = y.width() / 2 - n;
                } else {
                    F = E / 2 - n;
                }
                if (x.top + (D * 2 + H) > y.height()) {
                    G = G - (D + H);
                } else {
                    G = G + D;
                }
                return {
                    top:G,
                    left:F
                };
            };
            d(w).css(z()).show();
        };
        var p = function(v) {
            var u = "#" + t(v);
            d(u).hide();
        };
        d(s).treegrid("addEventListener", [ {
            name:"onLoadSuccess",
            handler:function(v, u) {
                q(this);
            }
        }, {
            name:"onBeforeEdit",
            handler:function(u) {
                r(s, u);
            }
        }, {
            name:"onAfterEdit",
            handler:function(v, u) {
                p(s);
            }
        }, {
            name:"onCancelEdit",
            handler:function(u) {
                p(s);
            }
        } ]);
    }
    function h(p) {
        var o = d.extend(true, {}, d.fn.treegrid.defaults, d(p).treegrid("options"));
        if (!o.customAttr.tooltip.enable) {
            return;
        }
        var s = function(v, u) {
            var t = {
                position:o.customAttr.tooltip.position,
                trackMouse:true,
                onHide:function() {
                    d(v).tooltip("destroy");
                },
                onShow:function() {
                    if (d.isPlainObject(u) && u.css) {
                        d(this).tooltip("tip").css(u.css);
                    }
                }
            };
            d.extend(t, d.isPlainObject(u) ? u :{
                content:u
            });
            d(v).tooltip(t).tooltip("show");
        };
        var r = function(y, u) {
            var x = d(y).attr("node-id");
            var w = d(p).treegrid("find", x);
            var t = function(B) {
                var A = [];
                var z = d.grep(d.merge(d(p).treegrid("getColumnFields", true), d(p).treegrid("getColumnFields")), function(D, C) {
                    return d.trim(D).length > 0;
                });
                d.each(z, function() {
                    var C = this;
                    var D = d(p).treegrid("getColumnOption", C).title;
                    A.push(D + ": " + B[C]);
                });
                return A.join("<br>");
            };
            var v = u ? u(x, w) :t(w);
            d(y).mouseover(function() {
                s(this, v);
            });
        };
        var n = function(t, u) {
            t.mouseover(function() {
                var y = d(this).parent().attr("node-id");
                var w = d(p).treegrid("find", y);
                var z = d(this).attr("field");
                var x = w[z];
                var v = u ? u(x, z, y, w) :x;
                s(this, v);
            });
        };
        var q = function() {
            if (o.customAttr.tooltip.target == "row") {
                o.finder.getTr(p, "", "allbody").each(function() {
                    if (d(this).hasClass("datagrid-row")) {
                        r(this, o.customAttr.tooltip.formatter);
                    }
                });
            } else {
                if (o.customAttr.tooltip.fields && d.isArray(o.customAttr.tooltip.fields)) {
                    var t = d(p).treegrid("getPanel");
                    var u = d(">div.datagrid-view>div.datagrid-view2>div.datagrid-body", t);
                    d.each(o.customAttr.tooltip.fields, function() {
                        var v = this;
                        n(d("td[field=" + v + "]", u), o.customAttr.tooltip.formatter);
                    });
                }
            }
        };
        d(p).treegrid("addEventListener", {
            name:"onLoadSuccess",
            handler:function(u, t) {
                q();
            }
        });
    }
    function c(r, n, q, p) {
        var o = d(r).treegrid("options");
        var s = o[n];
        switch (n) {
            case "onClickRow":
                if (p) {
                    o[n] = q;
                } else {
                    o[n] = function(t) {
                        s.apply(this, arguments);
                        q.apply(this, arguments);
                    };
                }
                break;

            case "onDblClickRow":
                if (p) {
                    o[n] = q;
                } else {
                    o[n] = function(t) {
                        s.apply(this, arguments);
                        q.apply(this, arguments);
                    };
                }
                break;

            case "onClickCell":
                if (p) {
                    o[n] = q;
                } else {
                    o[n] = function(t, u) {
                        s.apply(this, arguments);
                        q.apply(this, arguments);
                    };
                }
                break;

            case "onDblClickCell":
                if (p) {
                    o[n] = q;
                } else {
                    o[n] = function(t, u) {
                        s.apply(this, arguments);
                        q.apply(this, arguments);
                    };
                }
                break;

            case "onBeforeLoad":
                if (p) {
                    o[n] = q;
                } else {
                    o[n] = function(u, t) {
                        s.apply(this, arguments);
                        q.apply(this, arguments);
                    };
                }
                break;

            case "onLoadSuccess":
                if (p) {
                    o[n] = q;
                } else {
                    o[n] = function(u, t) {
                        s.apply(this, arguments);
                        q.apply(this, arguments);
                    };
                }
                break;

            case "onLoadError":
                if (p) {
                    o[n] = q;
                } else {
                    o[n] = function(t) {
                        s.apply(this, t);
                        q.apply(this, t);
                    };
                }
                break;

            case "onBeforeExpand":
                if (p) {
                    o[n] = q;
                } else {
                    o[n] = function(t) {
                        s.apply(this, arguments);
                        q.apply(this, arguments);
                    };
                }
                break;

            case "onExpand":
                if (p) {
                    o[n] = q;
                } else {
                    o[n] = function(t) {
                        s.apply(this, arguments);
                        q.apply(this, arguments);
                    };
                }
                break;

            case "onBeforeCollapse":
                if (p) {
                    o[n] = q;
                } else {
                    o[n] = function(t) {
                        s.apply(this, arguments);
                        q.apply(this, arguments);
                    };
                }
                break;

            case "onCollapse":
                if (p) {
                    o[n] = q;
                } else {
                    o[n] = function(t) {
                        s.apply(this, arguments);
                        q.apply(this, arguments);
                    };
                }
                break;

            case "onContextMenu":
                if (p) {
                    o[n] = q;
                } else {
                    o[n] = function(t, u) {
                        s.apply(this, arguments);
                        q.apply(this, arguments);
                    };
                }
                break;

            case "onBeforeEdit":
                if (p) {
                    o[n] = q;
                } else {
                    o[n] = function(t) {
                        s.apply(this, arguments);
                        q.apply(this, arguments);
                    };
                }
                break;

            case "onAfterEdit":
                if (p) {
                    o[n] = q;
                } else {
                    o[n] = function(u, t) {
                        s.apply(this, arguments);
                        q.apply(this, arguments);
                    };
                }
                break;

            case "onCancelEdit":
                if (p) {
                    o[n] = q;
                } else {
                    o[n] = function(t) {
                        s.apply(this, arguments);
                        q.apply(this, arguments);
                    };
                }
                break;

            default:
                d(r).datagrid("addEventListener", {
                    name:n,
                    override:p,
                    handler:q
                });
                break;
        }
    }
    d.fn.treegrid.headerContextMenu = {};
    d.fn.treegrid.headerContextMenu.defaultEvents = {
        doRemove:function(n, p, o) {
            d.messager.confirm("疑问", "您确定要删除已选中的行？", function(s) {
                if (s) {
                    var q = d(o).treegrid("options").idField;
                    var t = p[q];
                    d(o).treegrid("remove", t);
                }
            });
        },
        doReload:function(n, p, o) {
            d(o).treegrid("reload");
        }
    };
    d.fn.treegrid.defaults.customAttr = {
        iconField:null,
        parentField:null,
        expandOnNodeClick:false,
        expandOnDblClick:false,
        headerContextMenu:{
            isShow:false,
            isMerge:true,
            items:[]
        },
        contextMenu:{
            isShow:false,
            isMerge:true,
            items:[]
        },
        rowediting:false,
        tooltip:{
            enable:false,
            target:"row",
            position:"bottom",
            fields:undefined,
            formatter:undefined
        },
        onConfirmEdit:function(n) {
            return true;
        }
    };
    d.fn.treegrid.defaults.loadFilter = function(p, r) {
        var v = d(this).treegrid("options");
        var u = v.customAttr;
        if (u && u.parentField) {
            var n = v.idField, t = u.parentField, o = u.iconField || "icon";
            for (var q = 0, s = p.rows.length; q < s; q++) {
                if (p.rows[q][t] && p.rows[q][t] != "0" && p.rows[q][n] != p.rows[q][t]) {
                    p.rows[q]["_parentId"] = p.rows[q][t];
                } else {
                    delete p.rows[q][t];
                }
                p.rows[q]["iconCls"] = p.rows[q][o];
            }
        }
        return p;
    };
    d.extend(d.fn.treegrid.methods, {
        followCustomHandle:function(n) {
            return n.each(function() {
                k(this);
                m(this);
                a(this);
                b(this);
                h(this);
            });
        },
        getEditingRow:function(o) {
            var n = o.treegrid("getEditingRows");
            return n.length ? n[0] :null;
        },
        getEditingRows:function(p) {
            var n = p.treegrid("options");
            var o = [];
            n.finder.getTr(p[0], "", "allbody").each(function() {
                if (d(this).hasClass("datagrid-row-editing")) {
                    var q = d(this).attr("node-id");
                    o.push(p.treegrid("find", q));
                }
            });
            return o;
        },
        addEventListener:function(o, n) {
            return o.each(function() {
                var p = d.isArray(n) ? n :[ n ];
                var q = this;
                d.each(p, function(r, s) {
                    c(q, s.name, s.handler || function() {}, s.override);
                });
            });
        }
    });
})(jQuery);

(function(d) {
    function e(h) {
        var f = d(h);
        var g = d.data(h, "validatebox");
        f.unbind(".validatebox");
        if (g.options.novalidate) {
            return;
        }
        f.bind("focus.validatebox", function() {
            g.validating = true;
            g.value = undefined;
            (function() {
                if (g.validating) {
                    if (g.value != f.val()) {
                        g.value = f.val();
                        if (g.timer) {
                            clearTimeout(g.timer);
                        }
                        g.timer = setTimeout(function() {
                            d(h).validatebox("validate");
                        }, g.options.delay);
                    } else {
                        a(h);
                    }
                    setTimeout(arguments.callee, 200);
                }
            })();
        }).bind("blur.validatebox", function() {
            if (g.timer) {
                clearTimeout(g.timer);
                g.timer = undefined;
            }
            g.validating = false;
            c(h);
        }).bind("mouseenter.validatebox", function() {
            if (f.hasClass("validatebox-invalid")) {
                b(h);
            }
        }).bind("mouseleave.validatebox", function() {
            if (!g.validating) {
                c(h);
            }
        });
    }
    function b(h) {
        var g = d.data(h, "validatebox");
        var f = g.options;
        d(h).tooltip(d.extend({}, f.tipOptions, {
            content:g.message,
            position:f.tipPosition,
            deltaX:f.deltaX
        })).tooltip("show");
        g.tip = true;
    }
    function a(g) {
        var f = d.data(g, "validatebox");
        if (f && f.tip) {
            d(g).tooltip("reposition");
        }
    }
    function c(g) {
        var f = d.data(g, "validatebox");
        f.tip = false;
        d(g).tooltip("hide");
    }
    d.extend(d.fn.validatebox.defaults.rules, {
        unequal:{
            validator:function(f, g) {
                return f != g;
            },
            message:d.fn.validatebox.defaults.missingMessage
        },
        minLength:{
            validator:function(f, g) {
                return f.length >= g[0];
            }
        },
        equals:{
            validator:function(f, g) {
                if (/^#/.test(g)) {
                    return f == d(g).val();
                } else {
                    return f == g;
                }
            }
        }
    });
    if (d.fn.validatebox) {
        d.fn.validatebox.defaults.rules.minLength.message = "请至少输入{0}个字符。";
        d.fn.validatebox.defaults.rules.equals.message = "字段不匹配";
    }
})(jQuery);

(function($) {
    function getTop(w, options) {
        var _doc;
        try {
            _doc = w.top.document;
            _doc.getElementsByTagName;
        } catch (e) {
            return w;
        }
        if (options.locate == "document" || _doc.getElementsByTagName("frameset").length > 0) {
            return w;
        }
        return w.top;
    }
    function setWindowSize(w, options) {
        var _top = getTop(w, options);
        var wHeight = $(_top).height(), wWidth = $(_top).width();
        if (options.locate == "top" || options.locate == "document") {
            if (options.height == "auto") {
                options.height = wHeight * .6;
            }
            if (options.width == "auto") {
                options.width = wWidth * .6;
            }
        } else {
            var locate = /^#/.test(options.locate) ? options.locate :"#" + options.locate;
            if (options.height == "auto") {
                options.height = $(locate).height() * .6;
            }
            if (options.width == "auto") {
                options.width = $(locate).width() * .6;
            }
        }
    }
    $.extend({
        showWindow:function(options) {
            options = options || {};
            var target;
            var winOpts = $.extend({}, {
                iconCls:"icon-form",
                useiframe:false,
                locate:"top",
                data:undefined,
                width:"auto",
                height:"auto",
                cache:false,
                minimizable:true,
                maximizable:true,
                collapsible:true,
                resizable:true,
                loadMsg:$.fn.datagrid.defaults.loadMsg,
                showMask:false,
                onClose:function() {
                    target.dialog("destroy");
                }
            }, options);
            var iframe = null;
            if (/^url:/.test(winOpts.content)) {
                var url = winOpts.content.substr(4, winOpts.content.length);
                if (winOpts.useiframe) {
                    iframe = $("<iframe>").attr("height", "100%").attr("width", "100%").attr("marginheight", 0).attr("marginwidth", 0).attr("frameborder", 0);
                    setTimeout(function() {
                        iframe.attr("src", url);
                    }, 10);
                } else {
                    winOpts.href = url;
                }
                delete winOpts.content;
            }
            var selfRefrence = {
                getData:function(name) {
                    return winOpts.data ? winOpts.data[name] :null;
                },
                close:function() {
                    target.panel("close");
                }
            };
            var _top = getTop(window, winOpts);
            var warpHandler = function(handler) {
                if (typeof handler == "function") {
                    return function() {
                        handler(selfRefrence);
                    };
                }
                if (typeof handler == "string" && winOpts.useiframe) {
                    return function() {
                        iframe[0].contentWindow[handler](selfRefrence);
                    };
                }
                if (typeof handler == "string") {
                    return function() {
                        eval(_top[handler])(selfRefrence);
                    };
                }
            };
            setWindowSize(window, winOpts);
            if (winOpts.toolbar && $.isArray(winOpts.toolbar)) {
                $.each(winOpts.toolbar, function(i, button) {
                    button.handler = warpHandler(button.handler);
                });
            }
            if (winOpts.buttons && $.isArray(winOpts.buttons)) {
                $.each(winOpts.buttons, function(i, button) {
                    button.handler = warpHandler(button.handler);
                });
            }
            var onLoadCallback = winOpts.onLoad;
            winOpts.onLoad = function() {
                onLoadCallback && onLoadCallback.call(this, selfRefrence, _top);
            };
            if (winOpts.locate == "top" || winOpts.locate == "document") {
                if (winOpts.useiframe && iframe) {
                    if (winOpts.showMask) {
                        winOpts.onBeforeOpen = function() {
                            var panel = $(this).panel("panel");
                            var header = $(this).panel("header");
                            var body = $(this).panel("body");
                            body.css("position", "relative");
                            var mask = $('<div class="datagrid-mask" style="display:block;"></div>').appendTo(body);
                            var msg = $('<div class="datagrid-mask-msg" style="display:block; left: 50%;"></div>').html(winOpts.loadMsg).appendTo(body);
                            setTimeout(function() {
                                msg.css("marginLeft", -msg.outerWidth() / 2);
                            }, 5);
                        };
                    }
                    iframe.bind("load", function() {
                        if (iframe[0].contentWindow) {
                            onLoadCallback && onLoadCallback.call(this, selfRefrence, iframe[0].contentWindow);
                            target.panel("body").children("div.datagrid-mask-msg").remove();
                            target.panel("body").children("div.datagrid-mask").remove();
                        }
                    });
                    target = _top.$("<div>").css({
                        overflow:"hidden"
                    }).append(iframe).dialog(winOpts);
                } else {
                    target = _top.$("<div>").dialog(winOpts);
                }
            } else {
                var locate = /^#/.test(winOpts.locate) ? winOpts.locate :"#" + winOpts.locate;
                target = $("<div>").appendTo(locate).dialog($.extend({}, winOpts, {
                    inline:true
                }));
            }
            return target;
        },
        showModalDialog:function(options) {
            options = options || {};
            var opts = $.extend({}, options, {
                modal:true,
                minimizable:false,
                maximizable:false,
                resizable:false,
                collapsible:false
            });
            return $.showWindow(opts);
        }
    });
})(jQuery);

//eadyui datagrid行拖拽扩展
;(function($){
    $.extend($.fn.datagrid.defaults, {
        dragSelection: false,
        onBeforeDrag: function(row){},	// return false to deny drag
        onStartDrag: function(row){},
        onStopDrag: function(row){},
        onDragEnter: function(targetRow, sourceRow){},	// return false to deny drop
        onDragOver: function(targetRow, sourceRow){},	// return false to deny drop
        onDragLeave: function(targetRow, sourceRow){},
        onBeforeDrop: function(targetRow, sourceRow, point){},
        onDrop: function(targetRow, sourceRow, point){},	// point:'append','top','bottom'
    });

    $.extend($.fn.datagrid.methods, {
        _appendRow: function(jq, row){
            return jq.each(function(){
                var dg = $(this);
                var rows = $.isArray(row) ? row : [row];
                $.map(rows, function(row){
                    dg.datagrid('appendRow', row).datagrid('enableDnd', dg.datagrid('getRows').length-1);
                    if (row._selected){
                        dg.datagrid('selectRow', dg.datagrid('getRows').length-1);
                    }
                });
            });
        },
        _insertRow: function(jq, param){
            return jq.each(function(){
                var dg = $(this);
                var index = param.index;
                var row = param.row;
                var rows = $.isArray(row) ? row : [row];
                $.map(rows, function(row, i){
                    dg.datagrid('insertRow', {
                        index: (index+i),
                        row: row
                    }).datagrid('enableDnd', index+i);
                    if (row._selected){
                        dg.datagrid('selectRow', index+i);
                    }
                });
            });
        },
        _deleteRow: function(jq, row){
            return jq.each(function(){
                var dg = $(this);
                var rows = $.isArray(row) ? row : [row];
                $.map(rows, function(row){
                    var index = dg.datagrid('getRowIndex', row);
                    dg.datagrid('deleteRow', index);
                });
            });
        }
    });

    var disabledDroppingRows = [];

    $.extend($.fn.datagrid.methods, {
        enableDnd: function(jq, index){
            return jq.each(function(){
                var target = this;
                var state = $.data(this, 'datagrid');
                var dg = $(this);
                var opts = state.options;

                var draggableOptions = {
                    disabled: false,
                    revert: true,
                    cursor: 'pointer',
                    proxy: function(source) {
                        var p = $('<div style="z-index:9999999999999;background-color: #ffffff"></div>').appendTo('body');
                        var draggingRow = getDraggingRow(source);
                        var rows = $.isArray(draggingRow) ? draggingRow : [draggingRow];
                        $.map(rows, function(row,i){
                            var index = dg.datagrid('getRowIndex', row);
                            var tr1 = opts.finder.getTr(target, index, 'body', 1);
                            var tr2 = opts.finder.getTr(target, index, 'body', 2);
                            tr2.clone().removeAttr('id').removeClass('droppable').appendTo(p);
                            tr1.clone().removeAttr('id').removeClass('droppable').find('td').insertBefore(p.find('tr:eq('+i+') td:first'));
                            $('<td><span class="tree-dnd-icon tree-dnd-no" style="position:static;width: 20px;">&nbsp;</span></td>').insertBefore(p.find('tr:eq('+i+') td:first'));
                        });
                        p.find('td').css('vertical-align','middle');
                        p.hide();
                        return p;
                    },
                    deltaX: 15,
                    deltaY: 15,
                    onBeforeDrag:function(e){
                        if(e.target.tagName == 'INPUT' || e.target.tagName == 'TEXTAREA'){
                            return false;
                        };
                        var draggingRow = getDraggingRow(this);
                        if (opts.onBeforeDrag.call(target, draggingRow) == false){return false;}
                        if ($(e.target).parent().hasClass('datagrid-cell-check')){return false;}
                        if (e.which != 1){return false;}
                        $.map($.isArray(draggingRow)?draggingRow:[draggingRow], function(row){
                            var index = $(target).datagrid('getRowIndex', row);
                            opts.finder.getTr(target, index).droppable({accept:'no-accept'});
                        });
                    },
                    onStartDrag: function() {
                        $(this).draggable('proxy').css({
                            left: -10000,
                            top: -10000
                        });
                        var draggingRow = getDraggingRow(this);
                        opts.onStartDrag.call(target, draggingRow);
                        state.draggingRow = draggingRow;
                    },
                    onDrag: function(e) {
                        var x1=e.pageX,y1=e.pageY,x2=e.data.startX,y2=e.data.startY;
                        var d = Math.sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2));
                        if (d>3){	// when drag a little distance, show the proxy object
                            $(this).draggable('proxy').show();
                            var tr = opts.finder.getTr(target, parseInt($(this).attr('datagrid-row-index')), 'body');
                            $.extend(e.data, {
                                startX: tr.offset().left,
                                startY: tr.offset().top,
                                offsetWidth: 0,
                                offsetHeight: 0
                            });
                        }
                        this.pageY = e.pageY;
                    },
                    onStopDrag:function(){
                        $.map(disabledDroppingRows, function(row){
                            var r = $(row);
                            if (r.hasClass('datagrid-row')){
                                r.droppable('enable');
                            } else if (r.find('tr.datagrid-row:first').length == 0){
                                r.droppable('enable');
                            }
                        });
                        disabledDroppingRows = [];

                        $.map($.isArray(state.draggingRow) ? state.draggingRow : [state.draggingRow], function(row){
                            var index = dg.datagrid('getRowIndex', row);
                            dg.datagrid('enableDnd', index);
                        });
                        opts.onStopDrag.call(target, state.draggingRow);
                    }
                };
                var droppableOptions = {
                    accept: 'tr.datagrid-row',
                    onDragEnter: function(e, source){
                        if ($(this).droppable('options').disabled){return;}
                        if (opts.onDragEnter.call(target, getRow(this), getDraggingRow(source)) == false){
                            setProxyFlag(source, false);
                            var tr = opts.finder.getTr(target, $(this).attr('datagrid-row-index'));
                            tr.find('td').css('border', '');
                            tr.droppable('disable');
                            $(this).droppable('disable');
                            disabledDroppingRows.push(this);
                        }
                    },
                    onDragOver: function(e, source) {
                        if ($(this).droppable('options').disabled){
                            return;
                        }
                        if ($.inArray(this, disabledDroppingRows) >= 0){
                            return;
                        }
                        var pageY = source.pageY;
                        var top = $(this).offset().top;
                        var bottom = top + $(this).outerHeight();

                        setProxyFlag(source, true);
                        var tr = opts.finder.getTr(target, $(this).attr('datagrid-row-index'));
                        tr.children('td').css('border','');
                        if (pageY > top + (bottom - top) / 2) {
                            tr.children('td').css('border-bottom','1px solid red');
                        } else {
                            tr.children('td').css('border-top','1px solid red');
                        }

                        if (opts.onDragOver.call(target, getRow(this), getDraggingRow(source)) == false){
                            setProxyFlag(source, false);
                            tr.find('td').css('border', '');
                            tr.droppable('disable');
                            $(this).droppable('disable');
                            disabledDroppingRows.push(this);
                        }
                    },
                    onDragLeave: function(e, source) {
                        if ($(this).droppable('options').disabled){
                            return;
                        }
                        setProxyFlag(source, false);
                        var tr = opts.finder.getTr(target, $(this).attr('datagrid-row-index'));
                        tr.children('td').css('border','');
                        opts.onDragLeave.call(target, getRow(this), getDraggingRow(source));
                    },
                    onDrop: function(e, source) {
                        if ($(this).droppable('options').disabled){
                            return;
                        }

                        var tr = opts.finder.getTr(target, $(this).attr('datagrid-row-index'));
                        var td = tr.children('td');
                        var point =  parseInt(td.css('border-top-width')) ? 'top' : 'bottom';
                        td.css('border','');
                        var dRow = getRow(this);
                        var sRow = getDraggingRow(source);

                        if (opts.onBeforeDrop.call(target, dRow, sRow, point) == false){
                            return;
                        }
                        insert.call(this);
                        opts.onDrop.call(target, dRow, sRow, point);

                        function insert(){
                            var sourceIndex = parseInt($(source).attr('datagrid-row-index'));
                            var destIndex = parseInt($(this).attr('datagrid-row-index'));
                            var sourceTarget = $(source).closest('div.datagrid-view').children('table')[0];
                            var target = $(this).closest('div.datagrid-view').children('table')[0];

                            if ($(this).hasClass('datagrid-view')){
                                $(target).datagrid('_appendRow', sRow);
                                $(sourceTarget).datagrid('_deleteRow', sRow);
                                if ($(sourceTarget).datagrid('getRows').length == 0){
                                    $(sourceTarget).datagrid('enableDnd');
                                }
                            } else if (target != sourceTarget){
                                var index = point == 'top' ? destIndex : (destIndex+1);
                                if (index >= 0){
                                    $(sourceTarget).datagrid('_deleteRow', sRow);
                                    $(target).datagrid('_insertRow', {
                                        index: index,
                                        row: sRow
                                    });
                                }
                            } else {
                                var dg = $(target);
                                var index = point == 'top' ? destIndex : (destIndex+1);
                                if (index >= 0){
                                    dg.datagrid('_deleteRow', sRow);
                                    var destIndex = parseInt($(this).attr('datagrid-row-index'));
                                    var index = point == 'top' ? destIndex : (destIndex+1);
                                    if (index >= 0){
                                        dg.datagrid('_insertRow', {
                                            index: index,
                                            row: sRow
                                        });
                                    }
                                }
                            }
                        }
                    }
                }

                if (index != undefined){
                    var trs = opts.finder.getTr(this, index);
                } else {
                    var trs = opts.finder.getTr(this, 0, 'allbody');
                }
                trs.draggable(draggableOptions);
                trs.droppable(droppableOptions);
                setDroppable(target);

                function setProxyFlag(source, allowed){
                    var icon = $(source).draggable('proxy').find('span.tree-dnd-icon');
                    icon.removeClass('tree-dnd-yes tree-dnd-no').addClass(allowed ? 'tree-dnd-yes' : 'tree-dnd-no');
                }
                function getRow(tr){
                    if (!$(tr).hasClass('datagrid-row')){return null}
                    var target = $(tr).closest('div.datagrid-view').children('table')[0];
                    var opts = $(target).datagrid('options');
                    return opts.finder.getRow(target, $(tr));
                }
                function getDraggingRow(tr){
                    if (!$(tr).hasClass('datagrid-row')){return null}
                    var target = $(tr).closest('div.datagrid-view').children('table')[0];
                    var opts = $(target).datagrid('options');
                    if (opts.dragSelection){
                        var rows = $(target).datagrid('getSelections');
                        $.map(rows, function(row){
                            row._selected = true;
                        });
                        if (!rows.length){
                            var row = opts.finder.getRow(target, $(tr));
                            row._selected = false;
                            return row;
                        }
                        return rows;
                    } else {
                        var row = opts.finder.getRow(target, $(tr));
                        if ($(tr).hasClass('datagrid-row-selected')){
                            row._selected = true;
                        }
                        return row;
                    }
                }
                function setDroppable(target){
                    var c = $(target).datagrid('getPanel').find('div.datagrid-view');
                    c.droppable(droppableOptions);
                    if (c.find('tr.datagrid-row:first').length){
                        c.droppable('disable');
                    } else {
                        c.droppable('enable');
                    }
                }
            });
        }

    });
})(jQuery);

/*
 * # Semantic UI - 2.1.6
 * https://github.com/Semantic-Org/Semantic-UI
 * http://www.semantic-ui.com/
 *
 * Copyright 2014 Contributors
 * Released under the MIT license
 * http://opensource.org/licenses/MIT
 *
 */
/*!
 * # Semantic UI 2.1.6 - Site
 * http://github.com/semantic-org/semantic-ui/
 *
 *
 * Copyright 2015 Contributors
 * Released under the MIT license
 * http://opensource.org/licenses/MIT
 *
 */
;(function ( $, window, document, undefined ) {

    $.site = $.fn.site = function(parameters) {
        var
            time           = new Date().getTime(),
            performance    = [],

            query          = arguments[0],
            methodInvoked  = (typeof query == 'string'),
            queryArguments = [].slice.call(arguments, 1),

            settings        = ( $.isPlainObject(parameters) )
                ? $.extend(true, {}, $.site.settings, parameters)
                : $.extend({}, $.site.settings),

            namespace       = settings.namespace,
            error           = settings.error,

            eventNamespace  = '.' + namespace,
            moduleNamespace = 'module-' + namespace,

            $document       = $(document),
            $module         = $document,
            element         = this,
            instance        = $module.data(moduleNamespace),

            module,
            returnedValue
            ;
        module = {

            initialize: function() {
                module.instantiate();
            },

            instantiate: function() {
                module.verbose('Storing instance of site', module);
                instance = module;
                $module
                    .data(moduleNamespace, module)
                ;
            },

            normalize: function() {
                module.fix.console();
                module.fix.requestAnimationFrame();
            },

            fix: {
                console: function() {
                    module.debug('Normalizing window.console');
                    if (console === undefined || console.log === undefined) {
                        module.verbose('Console not available, normalizing events');
                        module.disable.console();
                    }
                    if (typeof console.group == 'undefined' || typeof console.groupEnd == 'undefined' || typeof console.groupCollapsed == 'undefined') {
                        module.verbose('Console group not available, normalizing events');
                        window.console.group = function() {};
                        window.console.groupEnd = function() {};
                        window.console.groupCollapsed = function() {};
                    }
                    if (typeof console.markTimeline == 'undefined') {
                        module.verbose('Mark timeline not available, normalizing events');
                        window.console.markTimeline = function() {};
                    }
                },
                consoleClear: function() {
                    module.debug('Disabling programmatic console clearing');
                    window.console.clear = function() {};
                },
                requestAnimationFrame: function() {
                    module.debug('Normalizing requestAnimationFrame');
                    if(window.requestAnimationFrame === undefined) {
                        module.debug('RequestAnimationFrame not available, normalizing event');
                        window.requestAnimationFrame = window.requestAnimationFrame
                            || window.mozRequestAnimationFrame
                            || window.webkitRequestAnimationFrame
                            || window.msRequestAnimationFrame
                            || function(callback) { setTimeout(callback, 0); }
                        ;
                    }
                }
            },

            moduleExists: function(name) {
                return ($.fn[name] !== undefined && $.fn[name].settings !== undefined);
            },

            enabled: {
                modules: function(modules) {
                    var enabledModules = []
                        ;
                    modules = modules || settings.modules;
                    $.each(modules, function(index, name) {
                        if(module.moduleExists(name)) {
                            enabledModules.push(name);
                        }
                    });
                    return enabledModules;
                }
            },

            disabled: {
                modules: function(modules) {
                    var
                        disabledModules = []
                        ;
                    modules = modules || settings.modules;
                    $.each(modules, function(index, name) {
                        if(!module.moduleExists(name)) {
                            disabledModules.push(name);
                        }
                    });
                    return disabledModules;
                }
            },

            change: {
                setting: function(setting, value, modules, modifyExisting) {
                    modules = (typeof modules === 'string')
                        ? (modules === 'all')
                        ? settings.modules
                        : [modules]
                        : modules || settings.modules
                    ;
                    modifyExisting = (modifyExisting !== undefined)
                        ? modifyExisting
                        : true
                    ;
                    $.each(modules, function(index, name) {
                        var
                            namespace = (module.moduleExists(name))
                                ? $.fn[name].settings.namespace || false
                                : true,
                            $existingModules
                            ;
                        if(module.moduleExists(name)) {
                            module.verbose('Changing default setting', setting, value, name);
                            $.fn[name].settings[setting] = value;
                            if(modifyExisting && namespace) {
                                $existingModules = $(':data(module-' + namespace + ')');
                                if($existingModules.length > 0) {
                                    module.verbose('Modifying existing settings', $existingModules);
                                    $existingModules[name]('setting', setting, value);
                                }
                            }
                        }
                    });
                },
                settings: function(newSettings, modules, modifyExisting) {
                    modules = (typeof modules === 'string')
                        ? [modules]
                        : modules || settings.modules
                    ;
                    modifyExisting = (modifyExisting !== undefined)
                        ? modifyExisting
                        : true
                    ;
                    $.each(modules, function(index, name) {
                        var
                            $existingModules
                            ;
                        if(module.moduleExists(name)) {
                            module.verbose('Changing default setting', newSettings, name);
                            $.extend(true, $.fn[name].settings, newSettings);
                            if(modifyExisting && namespace) {
                                $existingModules = $(':data(module-' + namespace + ')');
                                if($existingModules.length > 0) {
                                    module.verbose('Modifying existing settings', $existingModules);
                                    $existingModules[name]('setting', newSettings);
                                }
                            }
                        }
                    });
                }
            },

            enable: {
                console: function() {
                    module.console(true);
                },
                debug: function(modules, modifyExisting) {
                    modules = modules || settings.modules;
                    module.debug('Enabling debug for modules', modules);
                    module.change.setting('debug', true, modules, modifyExisting);
                },
                verbose: function(modules, modifyExisting) {
                    modules = modules || settings.modules;
                    module.debug('Enabling verbose debug for modules', modules);
                    module.change.setting('verbose', true, modules, modifyExisting);
                }
            },
            disable: {
                console: function() {
                    module.console(false);
                },
                debug: function(modules, modifyExisting) {
                    modules = modules || settings.modules;
                    module.debug('Disabling debug for modules', modules);
                    module.change.setting('debug', false, modules, modifyExisting);
                },
                verbose: function(modules, modifyExisting) {
                    modules = modules || settings.modules;
                    module.debug('Disabling verbose debug for modules', modules);
                    module.change.setting('verbose', false, modules, modifyExisting);
                }
            },

            console: function(enable) {
                if(enable) {
                    if(instance.cache.console === undefined) {
                        module.error(error.console);
                        return;
                    }
                    module.debug('Restoring console function');
                    window.console = instance.cache.console;
                }
                else {
                    module.debug('Disabling console function');
                    instance.cache.console = window.console;
                    window.console = {
                        clear          : function(){},
                        error          : function(){},
                        group          : function(){},
                        groupCollapsed : function(){},
                        groupEnd       : function(){},
                        info           : function(){},
                        log            : function(){},
                        markTimeline   : function(){},
                        warn           : function(){}
                    };
                }
            },

            destroy: function() {
                module.verbose('Destroying previous site for', $module);
                $module
                    .removeData(moduleNamespace)
                ;
            },

            cache: {},

            setting: function(name, value) {
                if( $.isPlainObject(name) ) {
                    $.extend(true, settings, name);
                }
                else if(value !== undefined) {
                    settings[name] = value;
                }
                else {
                    return settings[name];
                }
            },
            internal: function(name, value) {
                if( $.isPlainObject(name) ) {
                    $.extend(true, module, name);
                }
                else if(value !== undefined) {
                    module[name] = value;
                }
                else {
                    return module[name];
                }
            },
            debug: function() {
                if(settings.debug) {
                    if(settings.performance) {
                        module.performance.log(arguments);
                    }
                    else {
                        module.debug = Function.prototype.bind.call(console.info, console, settings.name + ':');
                        module.debug.apply(console, arguments);
                    }
                }
            },
            verbose: function() {
                if(settings.verbose && settings.debug) {
                    if(settings.performance) {
                        module.performance.log(arguments);
                    }
                    else {
                        module.verbose = Function.prototype.bind.call(console.info, console, settings.name + ':');
                        module.verbose.apply(console, arguments);
                    }
                }
            },
            error: function() {
                module.error = Function.prototype.bind.call(console.error, console, settings.name + ':');
                module.error.apply(console, arguments);
            },
            performance: {
                log: function(message) {
                    var
                        currentTime,
                        executionTime,
                        previousTime
                        ;
                    if(settings.performance) {
                        currentTime   = new Date().getTime();
                        previousTime  = time || currentTime;
                        executionTime = currentTime - previousTime;
                        time          = currentTime;
                        performance.push({
                            'Element'        : element,
                            'Name'           : message[0],
                            'Arguments'      : [].slice.call(message, 1) || '',
                            'Execution Time' : executionTime
                        });
                    }
                    clearTimeout(module.performance.timer);
                    module.performance.timer = setTimeout(module.performance.display, 500);
                },
                display: function() {
                    var
                        title = settings.name + ':',
                        totalTime = 0
                        ;
                    time = false;
                    clearTimeout(module.performance.timer);
                    $.each(performance, function(index, data) {
                        totalTime += data['Execution Time'];
                    });
                    title += ' ' + totalTime + 'ms';
                    if( (console.group !== undefined || console.table !== undefined) && performance.length > 0) {
                        console.groupCollapsed(title);
                        if(console.table) {
                            console.table(performance);
                        }
                        else {
                            $.each(performance, function(index, data) {
                                console.log(data['Name'] + ': ' + data['Execution Time']+'ms');
                            });
                        }
                        console.groupEnd();
                    }
                    performance = [];
                }
            },
            invoke: function(query, passedArguments, context) {
                var
                    object = instance,
                    maxDepth,
                    found,
                    response
                    ;
                passedArguments = passedArguments || queryArguments;
                context         = element         || context;
                if(typeof query == 'string' && object !== undefined) {
                    query    = query.split(/[\. ]/);
                    maxDepth = query.length - 1;
                    $.each(query, function(depth, value) {
                        var camelCaseValue = (depth != maxDepth)
                                ? value + query[depth + 1].charAt(0).toUpperCase() + query[depth + 1].slice(1)
                                : query
                            ;
                        if( $.isPlainObject( object[camelCaseValue] ) && (depth != maxDepth) ) {
                            object = object[camelCaseValue];
                        }
                        else if( object[camelCaseValue] !== undefined ) {
                            found = object[camelCaseValue];
                            return false;
                        }
                        else if( $.isPlainObject( object[value] ) && (depth != maxDepth) ) {
                            object = object[value];
                        }
                        else if( object[value] !== undefined ) {
                            found = object[value];
                            return false;
                        }
                        else {
                            module.error(error.method, query);
                            return false;
                        }
                    });
                }
                if ( $.isFunction( found ) ) {
                    response = found.apply(context, passedArguments);
                }
                else if(found !== undefined) {
                    response = found;
                }
                if($.isArray(returnedValue)) {
                    returnedValue.push(response);
                }
                else if(returnedValue !== undefined) {
                    returnedValue = [returnedValue, response];
                }
                else if(response !== undefined) {
                    returnedValue = response;
                }
                return found;
            }
        };

        if(methodInvoked) {
            if(instance === undefined) {
                module.initialize();
            }
            module.invoke(query);
        }
        else {
            if(instance !== undefined) {
                module.destroy();
            }
            module.initialize();
        }
        return (returnedValue !== undefined)
            ? returnedValue
            : this
            ;
    };

    $.site.settings = {

        name        : 'Site',
        namespace   : 'site',

        error : {
            console : 'Console cannot be restored, most likely it was overwritten outside of module',
            method : 'The method you called is not defined.'
        },

        debug       : false,
        verbose     : false,
        performance : true,

        modules: [
            'accordion',
            'api',
            'checkbox',
            'dimmer',
            'dropdown',
            'embed',
            'form',
            'modal',
            'nag',
            'popup',
            'rating',
            'shape',
            'sidebar',
            'state',
            'sticky',
            'tab',
            'transition',
            'visit',
            'visibility'
        ],

        siteNamespace   : 'site',
        namespaceStub   : {
            cache     : {},
            config    : {},
            sections  : {},
            section   : {},
            utilities : {}
        }

    };

// allows for selection of elements with data attributes
    $.extend($.expr[ ":" ], {
        data: ($.expr.createPseudo)
            ? $.expr.createPseudo(function(dataName) {
            return function(elem) {
                return !!$.data(elem, dataName);
            };
        })
            : function(elem, i, match) {
            // support: jQuery < 1.8
            return !!$.data(elem, match[ 3 ]);
        }
    });


})( jQuery, window, document );

/*!
 * # Semantic UI 2.1.6 - Form Validation
 * http://github.com/semantic-org/semantic-ui/
 *
 *
 * Copyright 2015 Contributors
 * Released under the MIT license
 * http://opensource.org/licenses/MIT
 *
 */

;(function ( $, window, document, undefined ) {

    "use strict";

    $.fn.form = function(parameters) {
        var
            $allModules      = $(this),
            moduleSelector   = $allModules.selector || '',

            time             = new Date().getTime(),
            performance      = [],

            query            = arguments[0],
            legacyParameters = arguments[1],
            methodInvoked    = (typeof query == 'string'),
            queryArguments   = [].slice.call(arguments, 1),
            returnedValue
            ;
        $allModules
            .each(function() {
                var
                    $module     = $(this),
                    element     = this,

                    formErrors  = [],
                    keyHeldDown = false,

                // set at run-time
                    $field,
                    $group,
                    $message,
                    $prompt,
                    $submit,
                    $clear,
                    $reset,

                    settings,
                    validation,

                    metadata,
                    selector,
                    className,
                    error,

                    namespace,
                    moduleNamespace,
                    eventNamespace,

                    instance,
                    module
                    ;

                module      = {

                    initialize: function() {

                        // settings grabbed at run time
                        module.get.settings();
                        if(methodInvoked) {
                            if(instance === undefined) {
                                module.instantiate();
                            }
                            module.invoke(query);
                        }
                        else {
                            module.verbose('Initializing form validation', $module, settings);
                            module.bindEvents();
                            module.set.defaults();
                            module.instantiate();
                        }
                    },

                    instantiate: function() {
                        module.verbose('Storing instance of module', module);
                        instance = module;
                        $module
                            .data(moduleNamespace, module)
                        ;
                    },

                    destroy: function() {
                        module.verbose('Destroying previous module', instance);
                        module.removeEvents();
                        $module
                            .removeData(moduleNamespace)
                        ;
                    },

                    refresh: function() {
                        module.verbose('Refreshing selector cache');
                        $field      = $module.find(selector.field);
                        $group      = $module.find(selector.group);
                        $message    = $module.find(selector.message);
                        $prompt     = $module.find(selector.prompt);

                        $submit     = $module.find(selector.submit);
                        $clear      = $module.find(selector.clear);
                        $reset      = $module.find(selector.reset);
                    },

                    submit: function() {
                        module.verbose('Submitting form', $module);
                        $module
                            .submit()
                        ;
                    },

                    attachEvents: function(selector, action) {
                        action = action || 'submit';
                        $(selector)
                            .on('click' + eventNamespace, function(event) {
                                module[action]();
                                event.preventDefault();
                            })
                        ;
                    },

                    bindEvents: function() {
                        module.verbose('Attaching form events');
                        $module
                            .on('submit' + eventNamespace, module.validate.form)
                            .on('blur'   + eventNamespace, selector.field, module.event.field.blur)
                            .on('click'  + eventNamespace, selector.submit, module.submit)
                            .on('click'  + eventNamespace, selector.reset, module.reset)
                            .on('click'  + eventNamespace, selector.clear, module.clear)
                        ;
                        if(settings.keyboardShortcuts) {
                            $module
                                .on('keydown' + eventNamespace, selector.field, module.event.field.keydown)
                            ;
                        }
                        $field
                            .each(function() {
                                var
                                    $input     = $(this),
                                    type       = $input.prop('type'),
                                    inputEvent = module.get.changeEvent(type, $input)
                                    ;
                                $(this)
                                    .on(inputEvent + eventNamespace, module.event.field.change)
                                ;
                            })
                        ;
                    },

                    clear: function() {
                        $field
                            .each(function () {
                                var
                                    $field       = $(this),
                                    $element     = $field.parent(),
                                    $fieldGroup  = $field.closest($group),
                                    $prompt      = $fieldGroup.find(selector.prompt),
                                    defaultValue = $field.data(metadata.defaultValue) || '',
                                    isCheckbox   = $element.is(selector.uiCheckbox),
                                    isDropdown   = $element.is(selector.uiDropdown),
                                    isErrored    = $fieldGroup.hasClass(className.error)
                                    ;
                                if(isErrored) {
                                    module.verbose('Resetting error on field', $fieldGroup);
                                    $fieldGroup.removeClass(className.error);
                                    $prompt.remove();
                                }
                                if(isDropdown) {
                                    module.verbose('Resetting dropdown value', $element, defaultValue);
                                    $element.dropdown('clear');
                                }
                                else if(isCheckbox) {
                                    $field.prop('checked', false);
                                }
                                else {
                                    module.verbose('Resetting field value', $field, defaultValue);
                                    $field.val('');
                                }
                            })
                        ;
                    },

                    reset: function() {
                        $field
                            .each(function () {
                                var
                                    $field       = $(this),
                                    $element     = $field.parent(),
                                    $fieldGroup  = $field.closest($group),
                                    $prompt      = $fieldGroup.find(selector.prompt),
                                    defaultValue = $field.data(metadata.defaultValue),
                                    isCheckbox   = $element.is(selector.uiCheckbox),
                                    isDropdown   = $element.is(selector.uiDropdown),
                                    isErrored    = $fieldGroup.hasClass(className.error)
                                    ;
                                if(defaultValue === undefined) {
                                    return;
                                }
                                if(isErrored) {
                                    module.verbose('Resetting error on field', $fieldGroup);
                                    $fieldGroup.removeClass(className.error);
                                    $prompt.remove();
                                }
                                if(isDropdown) {
                                    module.verbose('Resetting dropdown value', $element, defaultValue);
                                    $element.dropdown('restore defaults');
                                }
                                else if(isCheckbox) {
                                    module.verbose('Resetting checkbox value', $element, defaultValue);
                                    $field.prop('checked', defaultValue);
                                }
                                else {
                                    module.verbose('Resetting field value', $field, defaultValue);
                                    $field.val(defaultValue);
                                }
                            })
                        ;
                    },

                    is: {
                        bracketedRule: function(rule) {
                            return (rule.type && rule.type.match(settings.regExp.bracket));
                        },
                        valid: function() {
                            var
                                allValid = true
                                ;
                            module.verbose('Checking if form is valid');
                            $.each(validation, function(fieldName, field) {
                                if( !( module.validate.field(field, fieldName) ) ) {
                                    allValid = false;
                                }
                            });
                            return allValid;
                        }
                    },

                    removeEvents: function() {
                        $module
                            .off(eventNamespace)
                        ;
                        $field
                            .off(eventNamespace)
                        ;
                        $submit
                            .off(eventNamespace)
                        ;
                        $field
                            .off(eventNamespace)
                        ;
                    },

                    event: {
                        field: {
                            keydown: function(event) {
                                var
                                    $field  = $(this),
                                    key     = event.which,
                                    keyCode = {
                                        enter  : 13,
                                        escape : 27
                                    }
                                    ;
                                if( key == keyCode.escape) {
                                    module.verbose('Escape key pressed blurring field');
                                    $field
                                        .blur()
                                    ;
                                }
                                if(!event.ctrlKey && key == keyCode.enter && $field.is(selector.input) && $field.not(selector.checkbox).length > 0 ) {
                                    if(!keyHeldDown) {
                                        $field
                                            .one('keyup' + eventNamespace, module.event.field.keyup)
                                        ;
                                        module.submit();
                                        module.debug('Enter pressed on input submitting form');
                                    }
                                    keyHeldDown = true;
                                }
                            },
                            keyup: function() {
                                keyHeldDown = false;
                            },
                            blur: function(event) {
                                var
                                    $field          = $(this),
                                    $fieldGroup     = $field.closest($group),
                                    validationRules = module.get.validation($field)
                                    ;
                                if( $fieldGroup.hasClass(className.error) ) {
                                    module.debug('Revalidating field', $field, validationRules);
                                    module.validate.form.call(module, event, true);
                                }
                                else if(settings.on == 'blur' || settings.on == 'change') {
                                    if(validationRules) {
                                        module.validate.field( validationRules );
                                    }
                                }
                            },
                            change: function(event) {
                                var
                                    $field      = $(this),
                                    $fieldGroup = $field.closest($group)
                                    ;
                                if(settings.on == 'change' || ( $fieldGroup.hasClass(className.error) && settings.revalidate) ) {
                                    clearTimeout(module.timer);
                                    module.timer = setTimeout(function() {
                                        module.debug('Revalidating field', $field,  module.get.validation($field));
                                        module.validate.form.call(module, event, true);
                                    }, settings.delay);
                                }
                            }
                        }

                    },

                    get: {
                        ancillaryValue: function(rule) {
                            if(!rule.type || !module.is.bracketedRule(rule)) {
                                return false;
                            }
                            return rule.type.match(settings.regExp.bracket)[1] + '';
                        },
                        ruleName: function(rule) {
                            if( module.is.bracketedRule(rule) ) {
                                return rule.type.replace(rule.type.match(settings.regExp.bracket)[0], '');
                            }
                            return rule.type;
                        },
                        changeEvent: function(type, $input) {
                            if(type == 'checkbox' || type == 'radio' || type == 'hidden' || $input.is('select')) {
                                return 'change';
                            }
                            else {
                                return module.get.inputEvent();
                            }
                        },
                        inputEvent: function() {
                            return (document.createElement('input').oninput !== undefined)
                                ? 'input'
                                : (document.createElement('input').onpropertychange !== undefined)
                                ? 'propertychange'
                                : 'keyup'
                                ;
                        },
                        prompt: function(rule, field) {
                            var
                                ruleName      = module.get.ruleName(rule),
                                ancillary     = module.get.ancillaryValue(rule),
                                prompt        = rule.prompt || settings.prompt[ruleName] || settings.text.unspecifiedRule,
                                requiresValue = (prompt.search('{value}') !== -1),
                                requiresName  = (prompt.search('{name}') !== -1),
                                $label,
                                $field,
                                name
                                ;
                            if(requiresName || requiresValue) {
                                $field = module.get.field(field.identifier);
                            }
                            if(requiresValue) {
                                prompt = prompt.replace('{value}', $field.val());
                            }
                            if(requiresName) {
                                $label = $field.closest(selector.group).find('label').eq(0);
                                name = ($label.size() == 1)
                                    ? $label.text()
                                    : $field.prop('placeholder') || settings.text.unspecifiedField
                                ;
                                prompt = prompt.replace('{name}', name);
                            }
                            prompt = prompt.replace('{identifier}', field.identifier);
                            prompt = prompt.replace('{ruleValue}', ancillary);
                            if(!rule.prompt) {
                                module.verbose('Using default validation prompt for type', prompt, ruleName);
                            }
                            return prompt;
                        },
                        settings: function() {
                            if($.isPlainObject(parameters)) {
                                var
                                    keys     = Object.keys(parameters),
                                    isLegacySettings = (keys.length > 0)
                                        ? (parameters[keys[0]].identifier !== undefined && parameters[keys[0]].rules !== undefined)
                                        : false,
                                    ruleKeys
                                    ;
                                if(isLegacySettings) {
                                    // 1.x (ducktyped)
                                    settings   = $.extend(true, {}, $.fn.form.settings, legacyParameters);
                                    validation = $.extend({}, $.fn.form.settings.defaults, parameters);
                                    module.error(settings.error.oldSyntax, element);
                                    module.verbose('Extending settings from legacy parameters', validation, settings);
                                }
                                else {
                                    // 2.x
                                    if(parameters.fields) {
                                        ruleKeys = Object.keys(parameters.fields);
                                        if( typeof parameters.fields[ruleKeys[0]] == 'string' || $.isArray(parameters.fields[ruleKeys[0]]) ) {
                                            $.each(parameters.fields, function(name, rules) {
                                                if(typeof rules == 'string') {
                                                    rules = [rules];
                                                }
                                                parameters.fields[name] = {
                                                    rules: []
                                                };
                                                $.each(rules, function(index, rule) {
                                                    parameters.fields[name].rules.push({ type: rule });
                                                });
                                            });
                                        }
                                    }

                                    settings   = $.extend(true, {}, $.fn.form.settings, parameters);
                                    validation = $.extend({}, $.fn.form.settings.defaults, settings.fields);
                                    module.verbose('Extending settings', validation, settings);
                                }
                            }
                            else {
                                settings   = $.fn.form.settings;
                                validation = $.fn.form.settings.defaults;
                                module.verbose('Using default form validation', validation, settings);
                            }

                            // shorthand
                            namespace       = settings.namespace;
                            metadata        = settings.metadata;
                            selector        = settings.selector;
                            className       = settings.className;
                            error           = settings.error;
                            moduleNamespace = 'module-' + namespace;
                            eventNamespace  = '.' + namespace;

                            // grab instance
                            instance = $module.data(moduleNamespace);

                            // refresh selector cache
                            module.refresh();
                        },
                        field: function(identifier) {
                            module.verbose('Finding field with identifier', identifier);
                            if( $field.filter('#' + identifier).length > 0 ) {
                                return $field.filter('#' + identifier);
                            }
                            else if( $field.filter('[name="' + identifier +'"]').length > 0 ) {
                                return $field.filter('[name="' + identifier +'"]');
                            }
                            else if( $field.filter('[name="' + identifier +'[]"]').length > 0 ) {
                                return $field.filter('[name="' + identifier +'[]"]');
                            }
                            else if( $field.filter('[data-' + metadata.validate + '="'+ identifier +'"]').length > 0 ) {
                                return $field.filter('[data-' + metadata.validate + '="'+ identifier +'"]');
                            }
                            return $('<input/>');
                        },
                        fields: function(fields) {
                            var
                                $fields = $()
                                ;
                            $.each(fields, function(index, name) {
                                $fields = $fields.add( module.get.field(name) );
                            });
                            return $fields;
                        },
                        validation: function($field) {
                            var
                                fieldValidation,
                                identifier
                                ;
                            if(!validation) {
                                return false;
                            }
                            $.each(validation, function(fieldName, field) {
                                identifier = field.identifier || fieldName;
                                if( module.get.field(identifier)[0] == $field[0] ) {
                                    field.identifier = identifier;
                                    fieldValidation = field;
                                }
                            });
                            return fieldValidation || false;
                        },
                        value: function (field) {
                            var
                                fields = [],
                                results
                                ;
                            fields.push(field);
                            results = module.get.values.call(element, fields);
                            return results[field];
                        },
                        values: function (fields) {
                            var
                                $fields = $.isArray(fields)
                                    ? module.get.fields(fields)
                                    : $field,
                                values = {}
                                ;
                            $fields.each(function(index, field) {
                                var
                                    $field     = $(field),
                                    type       = $field.prop('type'),
                                    name       = $field.prop('name'),
                                    value      = $field.val(),
                                    isCheckbox = $field.is(selector.checkbox),
                                    isRadio    = $field.is(selector.radio),
                                    isMultiple = (name.indexOf('[]') !== -1),
                                    isChecked  = (isCheckbox)
                                        ? $field.is(':checked')
                                        : false
                                    ;
                                if(name) {
                                    if(isMultiple) {
                                        name = name.replace('[]', '');
                                        if(!values[name]) {
                                            values[name] = [];
                                        }
                                        if(isCheckbox) {
                                            if(isChecked) {
                                                values[name].push(value || true);
                                            }
                                            else {
                                                values[name].push(false);
                                            }
                                        }
                                        else {
                                            values[name].push(value);
                                        }
                                    }
                                    else {
                                        if(isRadio) {
                                            if(isChecked) {
                                                values[name] = value;
                                            }
                                        }
                                        else if(isCheckbox) {
                                            if(isChecked) {
                                                values[name] = value || true;
                                            }
                                            else {
                                                values[name] = false;
                                            }
                                        }
                                        else {
                                            values[name] = value;
                                        }
                                    }
                                }
                            });
                            return values;
                        }
                    },

                    has: {

                        field: function(identifier) {
                            module.verbose('Checking for existence of a field with identifier', identifier);
                            if(typeof identifier !== 'string') {
                                module.error(error.identifier, identifier);
                            }
                            if( $field.filter('#' + identifier).length > 0 ) {
                                return true;
                            }
                            else if( $field.filter('[name="' + identifier +'"]').length > 0 ) {
                                return true;
                            }
                            else if( $field.filter('[data-' + metadata.validate + '="'+ identifier +'"]').length > 0 ) {
                                return true;
                            }
                            return false;
                        }

                    },
                    add: {
                        prompt: function(identifier, errors) {
                            var
                                $field       = module.get.field(identifier),
                                $fieldGroup  = $field.closest($group),
                                $prompt      = $fieldGroup.children(selector.prompt),
                                promptExists = ($prompt.length !== 0)
                                ;
                            errors = (typeof errors == 'string')
                                ? [errors]
                                : errors
                            ;
                            module.verbose('Adding field error state', identifier);
                            $fieldGroup
                                .addClass(className.error)
                            ;
                            if(settings.inline) {
                                if(!promptExists) {
                                    $prompt = settings.templates.prompt(errors);
                                    $prompt
                                        .appendTo($fieldGroup)
                                    ;
                                }
                                $prompt
                                    .html(errors[0])
                                ;
                                if(!promptExists) {
                                    if(settings.transition && $.fn.transition !== undefined && $module.transition('is supported')) {
                                        module.verbose('Displaying error with css transition', settings.transition);
                                        $prompt.transition(settings.transition + ' in', settings.duration);
                                    }
                                    else {
                                        module.verbose('Displaying error with fallback javascript animation');
                                        $prompt
                                            .fadeIn(settings.duration)
                                        ;
                                    }
                                }
                                else {
                                    module.verbose('Inline errors are disabled, no inline error added', identifier);
                                }
                            }
                        },
                        errors: function(errors) {
                            module.debug('Adding form error messages', errors);
                            module.set.error();
                            $message
                                .html( settings.templates.error(errors) )
                            ;
                        }
                    },

                    remove: {
                        prompt: function(identifier) {
                            var
                                $field      = module.get.field(identifier),
                                $fieldGroup = $field.closest($group),
                                $prompt     = $fieldGroup.children(selector.prompt)
                                ;
                            $fieldGroup
                                .removeClass(className.error)
                            ;
                            if(settings.inline && $prompt.is(':visible')) {
                                module.verbose('Removing prompt for field', identifier);
                                if(settings.transition && $.fn.transition !== undefined && $module.transition('is supported')) {
                                    $prompt.transition(settings.transition + ' out', settings.duration, function() {
                                        $prompt.remove();
                                    });
                                }
                                else {
                                    $prompt
                                        .fadeOut(settings.duration, function(){
                                            $prompt.remove();
                                        })
                                    ;
                                }
                            }
                        }
                    },

                    set: {
                        success: function() {
                            $module
                                .removeClass(className.error)
                                .addClass(className.success)
                            ;
                        },
                        defaults: function () {
                            $field
                                .each(function () {
                                    var
                                        $field     = $(this),
                                        isCheckbox = ($field.filter(selector.checkbox).length > 0),
                                        value      = (isCheckbox)
                                            ? $field.is(':checked')
                                            : $field.val()
                                        ;
                                    $field.data(metadata.defaultValue, value);
                                })
                            ;
                        },
                        error: function() {
                            $module
                                .removeClass(className.success)
                                .addClass(className.error)
                            ;
                        },
                        value: function (field, value) {
                            var
                                fields = {}
                                ;
                            fields[field] = value;
                            return module.set.values.call(element, fields);
                        },
                        values: function (fields) {
                            if($.isEmptyObject(fields)) {
                                return;
                            }
                            $.each(fields, function(key, value) {
                                var
                                    $field      = module.get.field(key),
                                    $element    = $field.parent(),
                                    isMultiple  = $.isArray(value),
                                    isCheckbox  = $element.is(selector.uiCheckbox),
                                    isDropdown  = $element.is(selector.uiDropdown),
                                    isRadio     = ($field.is(selector.radio) && isCheckbox),
                                    fieldExists = ($field.length > 0),
                                    $multipleField
                                    ;
                                if(fieldExists) {
                                    if(isMultiple && isCheckbox) {
                                        module.verbose('Selecting multiple', value, $field);
                                        $element.checkbox('uncheck');
                                        $.each(value, function(index, value) {
                                            $multipleField = $field.filter('[value="' + value + '"]');
                                            $element       = $multipleField.parent();
                                            if($multipleField.length > 0) {
                                                $element.checkbox('check');
                                            }
                                        });
                                    }
                                    else if(isRadio) {
                                        module.verbose('Selecting radio value', value, $field);
                                        $field.filter('[value="' + value + '"]')
                                            .parent(selector.uiCheckbox)
                                            .checkbox('check')
                                        ;
                                    }
                                    else if(isCheckbox) {
                                        module.verbose('Setting checkbox value', value, $element);
                                        if(value === true) {
                                            $element.checkbox('check');
                                        }
                                        else {
                                            $element.checkbox('uncheck');
                                        }
                                    }
                                    else if(isDropdown) {
                                        module.verbose('Setting dropdown value', value, $element);
                                        $element.dropdown('set selected', value);
                                    }
                                    else {
                                        module.verbose('Setting field value', value, $field);
                                        $field.val(value);
                                    }
                                }
                            });
                        }
                    },

                    validate: {

                        form: function(event, ignoreCallbacks) {
                            var
                                values = module.get.values(),
                                apiRequest
                                ;

                            // input keydown event will fire submit repeatedly by browser default
                            if(keyHeldDown) {
                                return false;
                            }

                            // reset errors
                            formErrors = [];
                            if( module.is.valid() ) {
                                module.debug('Form has no validation errors, submitting');
                                module.set.success();
                                if(ignoreCallbacks !== true) {
                                    return settings.onSuccess.call(element, event, values);
                                }
                            }
                            else {
                                module.debug('Form has errors');
                                module.set.error();
                                if(!settings.inline) {
                                    module.add.errors(formErrors);
                                }
                                // prevent ajax submit
                                if($module.data('moduleApi') !== undefined) {
                                    event.stopImmediatePropagation();
                                }
                                if(ignoreCallbacks !== true) {
                                    return settings.onFailure.call(element, formErrors, values);
                                }
                            }
                        },

                        // takes a validation object and returns whether field passes validation
                        field: function(field, fieldName) {
                            var
                                identifier  = field.identifier || fieldName,
                                $field      = module.get.field(identifier),
                                fieldValid  = true,
                                fieldErrors = []
                                ;
                            if(!field.identifier) {
                                module.debug('Using field name as identifier', identifier);
                                field.identifier = identifier;
                            }
                            if($field.prop('disabled')) {
                                module.debug('Field is disabled. Skipping', identifier);
                                fieldValid = true;
                            }
                            else if(field.optional && $.trim($field.val()) === ''){
                                module.debug('Field is optional and empty. Skipping', identifier);
                                fieldValid = true;
                            }
                            else if(field.rules !== undefined) {
                                $.each(field.rules, function(index, rule) {
                                    if( module.has.field(identifier) && !( module.validate.rule(field, rule) ) ) {
                                        module.debug('Field is invalid', identifier, rule.type);
                                        fieldErrors.push(module.get.prompt(rule, field));
                                        fieldValid = false;
                                    }
                                });
                            }
                            if(fieldValid) {
                                module.remove.prompt(identifier, fieldErrors);
                                settings.onValid.call($field);
                            }
                            else {
                                formErrors = formErrors.concat(fieldErrors);
                                module.add.prompt(identifier, fieldErrors);
                                settings.onInvalid.call($field, fieldErrors);
                                return false;
                            }
                            return true;
                        },

                        // takes validation rule and returns whether field passes rule
                        rule: function(field, rule) {
                            var
                                $field       = module.get.field(field.identifier),
                                type         = rule.type,
                                value        = $field.val(),
                                isValid      = true,
                                ancillary    = module.get.ancillaryValue(rule),
                                ruleName     = module.get.ruleName(rule),
                                ruleFunction = settings.rules[ruleName]
                                ;
                            if( !$.isFunction(ruleFunction) ) {
                                module.error(error.noRule, ruleName);
                                return;
                            }
                            // cast to string avoiding encoding special values
                            value = (value === undefined || value === '' || value === null)
                                ? ''
                                : $.trim(value + '')
                            ;
                            return ruleFunction.call($field, value, ancillary);
                        }
                    },

                    setting: function(name, value) {
                        if( $.isPlainObject(name) ) {
                            $.extend(true, settings, name);
                        }
                        else if(value !== undefined) {
                            settings[name] = value;
                        }
                        else {
                            return settings[name];
                        }
                    },
                    internal: function(name, value) {
                        if( $.isPlainObject(name) ) {
                            $.extend(true, module, name);
                        }
                        else if(value !== undefined) {
                            module[name] = value;
                        }
                        else {
                            return module[name];
                        }
                    },
                    debug: function() {
                        if(settings.debug) {
                            if(settings.performance) {
                                module.performance.log(arguments);
                            }
                            else {
                                module.debug = Function.prototype.bind.call(console.info, console, settings.name + ':');
                                module.debug.apply(console, arguments);
                            }
                        }
                    },
                    verbose: function() {
                        if(settings.verbose && settings.debug) {
                            if(settings.performance) {
                                module.performance.log(arguments);
                            }
                            else {
                                module.verbose = Function.prototype.bind.call(console.info, console, settings.name + ':');
                                module.verbose.apply(console, arguments);
                            }
                        }
                    },
                    error: function() {
                        module.error = Function.prototype.bind.call(console.error, console, settings.name + ':');
                        module.error.apply(console, arguments);
                    },
                    performance: {
                        log: function(message) {
                            var
                                currentTime,
                                executionTime,
                                previousTime
                                ;
                            if(settings.performance) {
                                currentTime   = new Date().getTime();
                                previousTime  = time || currentTime;
                                executionTime = currentTime - previousTime;
                                time          = currentTime;
                                performance.push({
                                    'Name'           : message[0],
                                    'Arguments'      : [].slice.call(message, 1) || '',
                                    'Element'        : element,
                                    'Execution Time' : executionTime
                                });
                            }
                            clearTimeout(module.performance.timer);
                            module.performance.timer = setTimeout(module.performance.display, 500);
                        },
                        display: function() {
                            var
                                title = settings.name + ':',
                                totalTime = 0
                                ;
                            time = false;
                            clearTimeout(module.performance.timer);
                            $.each(performance, function(index, data) {
                                totalTime += data['Execution Time'];
                            });
                            title += ' ' + totalTime + 'ms';
                            if(moduleSelector) {
                                title += ' \'' + moduleSelector + '\'';
                            }
                            if($allModules.length > 1) {
                                title += ' ' + '(' + $allModules.length + ')';
                            }
                            if( (console.group !== undefined || console.table !== undefined) && performance.length > 0) {
                                console.groupCollapsed(title);
                                if(console.table) {
                                    console.table(performance);
                                }
                                else {
                                    $.each(performance, function(index, data) {
                                        console.log(data['Name'] + ': ' + data['Execution Time']+'ms');
                                    });
                                }
                                console.groupEnd();
                            }
                            performance = [];
                        }
                    },
                    invoke: function(query, passedArguments, context) {
                        var
                            object = instance,
                            maxDepth,
                            found,
                            response
                            ;
                        passedArguments = passedArguments || queryArguments;
                        context         = element         || context;
                        if(typeof query == 'string' && object !== undefined) {
                            query    = query.split(/[\. ]/);
                            maxDepth = query.length - 1;
                            $.each(query, function(depth, value) {
                                var camelCaseValue = (depth != maxDepth)
                                        ? value + query[depth + 1].charAt(0).toUpperCase() + query[depth + 1].slice(1)
                                        : query
                                    ;
                                if( $.isPlainObject( object[camelCaseValue] ) && (depth != maxDepth) ) {
                                    object = object[camelCaseValue];
                                }
                                else if( object[camelCaseValue] !== undefined ) {
                                    found = object[camelCaseValue];
                                    return false;
                                }
                                else if( $.isPlainObject( object[value] ) && (depth != maxDepth) ) {
                                    object = object[value];
                                }
                                else if( object[value] !== undefined ) {
                                    found = object[value];
                                    return false;
                                }
                                else {
                                    return false;
                                }
                            });
                        }
                        if( $.isFunction( found ) ) {
                            response = found.apply(context, passedArguments);
                        }
                        else if(found !== undefined) {
                            response = found;
                        }
                        if($.isArray(returnedValue)) {
                            returnedValue.push(response);
                        }
                        else if(returnedValue !== undefined) {
                            returnedValue = [returnedValue, response];
                        }
                        else if(response !== undefined) {
                            returnedValue = response;
                        }
                        return found;
                    }
                };
                module.initialize();
            })
        ;

        return (returnedValue !== undefined)
            ? returnedValue
            : this
            ;
    };

    $.fn.form.settings = {

        name              : 'Form',
        namespace         : 'form',

        debug             : false,
        verbose           : false,
        performance       : true,

        fields            : false,

        keyboardShortcuts : true,
        on                : 'submit',
        inline            : false,

        delay             : 200,
        revalidate        : true,

        transition        : 'scale',
        duration          : 200,

        onValid           : function() {},
        onInvalid         : function() {},
        onSuccess         : function() { return true; },
        onFailure         : function() { return false; },

        metadata : {
            defaultValue : 'default',
            validate     : 'validate'
        },

        regExp: {
            bracket : /\[(.*)\]/i,
            decimal : /^\d*(\.)\d+/,
            email   : "[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?",
            escape  : /[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g,
            flags   : /^\/(.*)\/(.*)?/,
            integer : /^\-?\d+$/,
            number  : /^\-?\d*(\.\d+)?$/,
            url     : /(https?:\/\/(?:www\.|(?!www))[^\s\.]+\.[^\s]{2,}|www\.[^\s]+\.[^\s]{2,})/i
        },

        text: {
            unspecifiedRule  : 'Please enter a valid value',
            unspecifiedField : 'This field'
        },

        prompt: {
            empty                : '{name} must have a value',
            checked              : '{name} must be checked',
            email                : '{name} must be a valid e-mail',
            url                  : '{name} must be a valid url',
            regExp               : '{name} is not formatted correctly',
            integer              : '{name} must be an integer',
            decimal              : '{name} must be a decimal number',
            number               : '{name} must be set to a number',
            is                   : '{name} must be "{ruleValue}"',
            isExactly            : '{name} must be exactly "{ruleValue}"',
            not                  : '{name} cannot be set to "{ruleValue}"',
            notExactly           : '{name} cannot be set to exactly "{ruleValue}"',
            contain              : '{name} cannot contain "{ruleValue}"',
            containExactly       : '{name} cannot contain exactly "{ruleValue}"',
            doesntContain        : '{name} must contain  "{ruleValue}"',
            doesntContainExactly : '{name} must contain exactly "{ruleValue}"',
            minLength            : '{name} must be at least {ruleValue} characters',
            length               : '{name} must be at least {ruleValue} characters',
            exactLength          : '{name} must be exactly {ruleValue} characters',
            maxLength            : '{name} cannot be longer than {ruleValue} characters',
            match                : '{name} must match {ruleValue} field',
            different            : '{name} must have a different value than {ruleValue} field',
            creditCard           : '{name} must be a valid credit card number',
            minCount             : '{name} must have at least {ruleValue} choices',
            exactCount           : '{name} must have exactly {ruleValue} choices',
            maxCount             : '{name} must have {ruleValue} or less choices'
        },

        selector : {
            checkbox   : 'input[type="checkbox"], input[type="radio"]',
            clear      : '.clear',
            field      : 'input, textarea, select',
            group      : '.field',
            input      : 'input',
            message    : '.error.message',
            prompt     : '.prompt.label',
            radio      : 'input[type="radio"]',
            reset      : '.reset:not([type="reset"])',
            submit     : '.submit:not([type="submit"])',
            uiCheckbox : '.ui.checkbox',
            uiDropdown : '.ui.dropdown'
        },

        className : {
            error   : 'error',
            label   : 'ui prompt label',
            pressed : 'down',
            success : 'success'
        },

        error: {
            identifier : 'You must specify a string identifier for each field',
            method     : 'The method you called is not defined.',
            noRule     : 'There is no rule matching the one you specified',
            oldSyntax  : 'Starting in 2.0 forms now only take a single settings object. Validation settings converted to new syntax automatically.'
        },

        templates: {

            // template that produces error message
            error: function(errors) {
                var
                    html = '<ul class="list">'
                    ;
                $.each(errors, function(index, value) {
                    html += '<li>' + value + '</li>';
                });
                html += '</ul>';
                return $(html);
            },

            // template that produces label
            prompt: function(errors) {
                return $('<div/>')
                    .addClass('ui basic red pointing prompt label')
                    .html(errors[0])
                    ;
            }
        },

        rules: {

            // is not empty or blank string
            empty: function(value) {
                return !(value === undefined || '' === value || $.isArray(value) && value.length === 0);
            },

            // checkbox checked
            checked: function() {
                return ($(this).filter(':checked').length > 0);
            },

            // is most likely an email
            email: function(value){
                var
                    emailRegExp = new RegExp($.fn.form.settings.regExp.email, 'i')
                    ;
                return emailRegExp.test(value);
            },

            // value is most likely url
            url: function(value) {
                return $.fn.form.settings.regExp.url.test(value);
            },

            // matches specified regExp
            regExp: function(value, regExp) {
                var
                    regExpParts = regExp.match($.fn.form.settings.regExp.flags),
                    flags
                    ;
                // regular expression specified as /baz/gi (flags)
                if(regExpParts) {
                    regExp = (regExpParts.length >= 2)
                        ? regExpParts[1]
                        : regExp
                    ;
                    flags = (regExpParts.length >= 3)
                        ? regExpParts[2]
                        : ''
                    ;
                }
                return value.match( new RegExp(regExp, flags) );
            },

            // is valid integer or matches range
            integer: function(value, range) {
                var
                    intRegExp = $.fn.form.settings.regExp.integer,
                    min,
                    max,
                    parts
                    ;
                if( !range || ['', '..'].indexOf(range) !== -1) {
                    // do nothing
                }
                else if(range.indexOf('..') == -1) {
                    if(intRegExp.test(range)) {
                        min = max = range - 0;
                    }
                }
                else {
                    parts = range.split('..', 2);
                    if(intRegExp.test(parts[0])) {
                        min = parts[0] - 0;
                    }
                    if(intRegExp.test(parts[1])) {
                        max = parts[1] - 0;
                    }
                }
                return (
                    intRegExp.test(value) &&
                    (min === undefined || value >= min) &&
                    (max === undefined || value <= max)
                );
            },

            // is valid number (with decimal)
            decimal: function(value) {
                return $.fn.form.settings.regExp.decimal.test(value);
            },

            // is valid number
            number: function(value) {
                return $.fn.form.settings.regExp.number.test(value);
            },

            // is value (case insensitive)
            is: function(value, text) {
                text = (typeof text == 'string')
                    ? text.toLowerCase()
                    : text
                ;
                value = (typeof value == 'string')
                    ? value.toLowerCase()
                    : value
                ;
                return (value == text);
            },

            // is value
            isExactly: function(value, text) {
                return (value == text);
            },

            // value is not another value (case insensitive)
            not: function(value, notValue) {
                value = (typeof value == 'string')
                    ? value.toLowerCase()
                    : value
                ;
                notValue = (typeof notValue == 'string')
                    ? notValue.toLowerCase()
                    : notValue
                ;
                return (value != notValue);
            },

            // value is not another value (case sensitive)
            notExactly: function(value, notValue) {
                return (value != notValue);
            },

            // value contains text (insensitive)
            contains: function(value, text) {
                // escape regex characters
                text = text.replace($.fn.form.settings.regExp.escape, "\\$&");
                return (value.search( new RegExp(text, 'i') ) !== -1);
            },

            // value contains text (case sensitive)
            containsExactly: function(value, text) {
                // escape regex characters
                text = text.replace($.fn.form.settings.regExp.escape, "\\$&");
                return (value.search( new RegExp(text) ) !== -1);
            },

            // value contains text (insensitive)
            doesntContain: function(value, text) {
                // escape regex characters
                text = text.replace($.fn.form.settings.regExp.escape, "\\$&");
                return (value.search( new RegExp(text, 'i') ) === -1);
            },

            // value contains text (case sensitive)
            doesntContainExactly: function(value, text) {
                // escape regex characters
                text = text.replace($.fn.form.settings.regExp.escape, "\\$&");
                return (value.search( new RegExp(text) ) === -1);
            },

            // is at least string length
            minLength: function(value, requiredLength) {
                return (value !== undefined)
                    ? (value.length >= requiredLength)
                    : false
                    ;
            },

            // see rls notes for 2.0.6 (this is a duplicate of minLength)
            length: function(value, requiredLength) {
                return (value !== undefined)
                    ? (value.length >= requiredLength)
                    : false
                    ;
            },

            // is exactly length
            exactLength: function(value, requiredLength) {
                return (value !== undefined)
                    ? (value.length == requiredLength)
                    : false
                    ;
            },

            // is less than length
            maxLength: function(value, maxLength) {
                return (value !== undefined)
                    ? (value.length <= maxLength)
                    : false
                    ;
            },

            // matches another field
            match: function(value, identifier) {
                var
                    $form = $(this),
                    matchingValue
                    ;
                if( $('[data-validate="'+ identifier +'"]').length > 0 ) {
                    matchingValue = $('[data-validate="'+ identifier +'"]').val();
                }
                else if($('#' + identifier).length > 0) {
                    matchingValue = $('#' + identifier).val();
                }
                else if($('[name="' + identifier +'"]').length > 0) {
                    matchingValue = $('[name="' + identifier + '"]').val();
                }
                else if( $('[name="' + identifier +'[]"]').length > 0 ) {
                    matchingValue = $('[name="' + identifier +'[]"]');
                }
                return (matchingValue !== undefined)
                    ? ( value.toString() == matchingValue.toString() )
                    : false
                    ;
            },

            // different than another field
            different: function(value, identifier) {
                // use either id or name of field
                var
                    $form = $(this),
                    matchingValue
                    ;
                if( $('[data-validate="'+ identifier +'"]').length > 0 ) {
                    matchingValue = $('[data-validate="'+ identifier +'"]').val();
                }
                else if($('#' + identifier).length > 0) {
                    matchingValue = $('#' + identifier).val();
                }
                else if($('[name="' + identifier +'"]').length > 0) {
                    matchingValue = $('[name="' + identifier + '"]').val();
                }
                else if( $('[name="' + identifier +'[]"]').length > 0 ) {
                    matchingValue = $('[name="' + identifier +'[]"]');
                }
                return (matchingValue !== undefined)
                    ? ( value.toString() !== matchingValue.toString() )
                    : false
                    ;
            },

            creditCard: function(cardNumber, cardTypes) {
                var
                    cards = {
                        visa: {
                            pattern : /^4/,
                            length  : [16]
                        },
                        amex: {
                            pattern : /^3[47]/,
                            length  : [15]
                        },
                        mastercard: {
                            pattern : /^5[1-5]/,
                            length  : [16]
                        },
                        discover: {
                            pattern : /^(6011|622(12[6-9]|1[3-9][0-9]|[2-8][0-9]{2}|9[0-1][0-9]|92[0-5]|64[4-9])|65)/,
                            length  : [16]
                        },
                        unionPay: {
                            pattern : /^(62|88)/,
                            length  : [16, 17, 18, 19]
                        },
                        jcb: {
                            pattern : /^35(2[89]|[3-8][0-9])/,
                            length  : [16]
                        },
                        maestro: {
                            pattern : /^(5018|5020|5038|6304|6759|676[1-3])/,
                            length  : [12, 13, 14, 15, 16, 17, 18, 19]
                        },
                        dinersClub: {
                            pattern : /^(30[0-5]|^36)/,
                            length  : [14]
                        },
                        laser: {
                            pattern : /^(6304|670[69]|6771)/,
                            length  : [16, 17, 18, 19]
                        },
                        visaElectron: {
                            pattern : /^(4026|417500|4508|4844|491(3|7))/,
                            length  : [16]
                        }
                    },
                    valid         = {},
                    validCard     = false,
                    requiredTypes = (typeof cardTypes == 'string')
                        ? cardTypes.split(',')
                        : false,
                    unionPay,
                    validation
                    ;

                if(typeof cardNumber !== 'string' || cardNumber.length === 0) {
                    return;
                }

                // verify card types
                if(requiredTypes) {
                    $.each(requiredTypes, function(index, type){
                        // verify each card type
                        validation = cards[type];
                        if(validation) {
                            valid = {
                                length  : ($.inArray(cardNumber.length, validation.length) !== -1),
                                pattern : (cardNumber.search(validation.pattern) !== -1)
                            };
                            if(valid.length && valid.pattern) {
                                validCard = true;
                            }
                        }
                    });

                    if(!validCard) {
                        return false;
                    }
                }

                // skip luhn for UnionPay
                unionPay = {
                    number  : ($.inArray(cardNumber.length, cards.unionPay.length) !== -1),
                    pattern : (cardNumber.search(cards.unionPay.pattern) !== -1)
                };
                if(unionPay.number && unionPay.pattern) {
                    return true;
                }

                // verify luhn, adapted from  <https://gist.github.com/2134376>
                var
                    length        = cardNumber.length,
                    multiple      = 0,
                    producedValue = [
                        [0, 1, 2, 3, 4, 5, 6, 7, 8, 9],
                        [0, 2, 4, 6, 8, 1, 3, 5, 7, 9]
                    ],
                    sum           = 0
                    ;
                while (length--) {
                    sum += producedValue[multiple][parseInt(cardNumber.charAt(length), 10)];
                    multiple ^= 1;
                }
                return (sum % 10 === 0 && sum > 0);
            },

            minCount: function(value, minCount) {
                if(minCount == 0) {
                    return true;
                }
                if(minCount == 1) {
                    return (value !== '');
                }
                return (value.split(',').length >= minCount);
            },

            exactCount: function(value, exactCount) {
                if(exactCount == 0) {
                    return (value === '');
                }
                if(exactCount == 1) {
                    return (value !== '' && value.search(',') === -1);
                }
                return (value.split(',').length == exactCount);
            },

            maxCount: function(value, maxCount) {
                if(maxCount == 0) {
                    return false;
                }
                if(maxCount == 1) {
                    return (value.search(',') === -1);
                }
                return (value.split(',').length <= maxCount);
            }
        }

    };

})( jQuery, window, document );

/*!
 * # Semantic UI 2.1.6 - Accordion
 * http://github.com/semantic-org/semantic-ui/
 *
 *
 * Copyright 2015 Contributors
 * Released under the MIT license
 * http://opensource.org/licenses/MIT
 *
 */

;(function ($, window, document, undefined) {

    "use strict";

    $.fn.accordion = function(parameters) {
        var
            $allModules     = $(this),

            time            = new Date().getTime(),
            performance     = [],

            query           = arguments[0],
            methodInvoked   = (typeof query == 'string'),
            queryArguments  = [].slice.call(arguments, 1),

            requestAnimationFrame = window.requestAnimationFrame
                || window.mozRequestAnimationFrame
                || window.webkitRequestAnimationFrame
                || window.msRequestAnimationFrame
                || function(callback) { setTimeout(callback, 0); },

            returnedValue
            ;
        $allModules
            .each(function() {
                var
                    settings        = ( $.isPlainObject(parameters) )
                        ? $.extend(true, {}, $.fn.accordion.settings, parameters)
                        : $.extend({}, $.fn.accordion.settings),

                    className       = settings.className,
                    namespace       = settings.namespace,
                    selector        = settings.selector,
                    error           = settings.error,

                    eventNamespace  = '.' + namespace,
                    moduleNamespace = 'module-' + namespace,
                    moduleSelector  = $allModules.selector || '',

                    $module  = $(this),
                    $title   = $module.find(selector.title),
                    $content = $module.find(selector.content),

                    element  = this,
                    instance = $module.data(moduleNamespace),
                    observer,
                    module
                    ;

                module = {

                    initialize: function() {
                        module.debug('Initializing', $module);
                        module.bind.events();
                        if(settings.observeChanges) {
                            module.observeChanges();
                        }
                        module.instantiate();
                    },

                    instantiate: function() {
                        instance = module;
                        $module
                            .data(moduleNamespace, module)
                        ;
                    },

                    destroy: function() {
                        module.debug('Destroying previous instance', $module);
                        $module
                            .off(eventNamespace)
                            .removeData(moduleNamespace)
                        ;
                    },

                    refresh: function() {
                        $title   = $module.find(selector.title);
                        $content = $module.find(selector.content);
                    },

                    observeChanges: function() {
                        if('MutationObserver' in window) {
                            observer = new MutationObserver(function(mutations) {
                                module.debug('DOM tree modified, updating selector cache');
                                module.refresh();
                            });
                            observer.observe(element, {
                                childList : true,
                                subtree   : true
                            });
                            module.debug('Setting up mutation observer', observer);
                        }
                    },

                    bind: {
                        events: function() {
                            module.debug('Binding delegated events');
                            $module
                                .on(settings.on + eventNamespace, selector.trigger, module.event.click)
                            ;
                        }
                    },

                    event: {
                        click: function() {
                            module.toggle.call(this);
                        }
                    },

                    toggle: function(query) {
                        var
                            $activeTitle = (query !== undefined)
                                ? (typeof query === 'number')
                                ? $title.eq(query)
                                : $(query).closest(selector.title)
                                : $(this).closest(selector.title),
                            $activeContent = $activeTitle.next($content),
                            isAnimating = $activeContent.hasClass(className.animating),
                            isActive    = $activeContent.hasClass(className.active),
                            isOpen      = (isActive && !isAnimating),
                            isOpening   = (!isActive && isAnimating)
                            ;
                        module.debug('Toggling visibility of content', $activeTitle);
                        if(isOpen || isOpening) {
                            if(settings.collapsible) {
                                module.close.call($activeTitle);
                            }
                            else {
                                module.debug('Cannot close accordion content collapsing is disabled');
                            }
                        }
                        else {
                            module.open.call($activeTitle);
                        }
                    },

                    open: function(query) {
                        var
                            $activeTitle = (query !== undefined)
                                ? (typeof query === 'number')
                                ? $title.eq(query)
                                : $(query).closest(selector.title)
                                : $(this).closest(selector.title),
                            $activeContent = $activeTitle.next($content),
                            isAnimating = $activeContent.hasClass(className.animating),
                            isActive    = $activeContent.hasClass(className.active),
                            isOpen      = (isActive || isAnimating)
                            ;
                        if(isOpen) {
                            module.debug('Accordion already open, skipping', $activeContent);
                            return;
                        }
                        module.debug('Opening accordion content', $activeTitle);
                        settings.onOpening.call($activeContent);
                        if(settings.exclusive) {
                            module.closeOthers.call($activeTitle);
                        }
                        $activeTitle
                            .addClass(className.active)
                        ;
                        $activeContent
                            .stop(true, true)
                            .addClass(className.animating)
                        ;
                        if(settings.animateChildren) {
                            if($.fn.transition !== undefined && $module.transition('is supported')) {
                                $activeContent
                                    .children()
                                    .transition({
                                        animation   : 'fade in',
                                        queue       : false,
                                        useFailSafe : true,
                                        debug       : settings.debug,
                                        verbose     : settings.verbose,
                                        duration    : settings.duration
                                    })
                                ;
                            }
                            else {
                                $activeContent
                                    .children()
                                    .stop(true, true)
                                    .animate({
                                        opacity: 1
                                    }, settings.duration, module.resetOpacity)
                                ;
                            }
                        }
                        $activeContent
                            .slideDown(settings.duration, settings.easing, function() {
                                $activeContent
                                    .removeClass(className.animating)
                                    .addClass(className.active)
                                ;
                                module.reset.display.call(this);
                                settings.onOpen.call(this);
                                settings.onChange.call(this);
                            })
                        ;
                    },

                    close: function(query) {
                        var
                            $activeTitle = (query !== undefined)
                                ? (typeof query === 'number')
                                ? $title.eq(query)
                                : $(query).closest(selector.title)
                                : $(this).closest(selector.title),
                            $activeContent = $activeTitle.next($content),
                            isAnimating    = $activeContent.hasClass(className.animating),
                            isActive       = $activeContent.hasClass(className.active),
                            isOpening      = (!isActive && isAnimating),
                            isClosing      = (isActive && isAnimating)
                            ;
                        if((isActive || isOpening) && !isClosing) {
                            module.debug('Closing accordion content', $activeContent);
                            settings.onClosing.call($activeContent);
                            $activeTitle
                                .removeClass(className.active)
                            ;
                            $activeContent
                                .stop(true, true)
                                .addClass(className.animating)
                            ;
                            if(settings.animateChildren) {
                                if($.fn.transition !== undefined && $module.transition('is supported')) {
                                    $activeContent
                                        .children()
                                        .transition({
                                            animation   : 'fade out',
                                            queue       : false,
                                            useFailSafe : true,
                                            debug       : settings.debug,
                                            verbose     : settings.verbose,
                                            duration    : settings.duration
                                        })
                                    ;
                                }
                                else {
                                    $activeContent
                                        .children()
                                        .stop(true, true)
                                        .animate({
                                            opacity: 0
                                        }, settings.duration, module.resetOpacity)
                                    ;
                                }
                            }
                            $activeContent
                                .slideUp(settings.duration, settings.easing, function() {
                                    $activeContent
                                        .removeClass(className.animating)
                                        .removeClass(className.active)
                                    ;
                                    module.reset.display.call(this);
                                    settings.onClose.call(this);
                                    settings.onChange.call(this);
                                })
                            ;
                        }
                    },

                    closeOthers: function(index) {
                        var
                            $activeTitle = (index !== undefined)
                                ? $title.eq(index)
                                : $(this).closest(selector.title),
                            $parentTitles    = $activeTitle.parents(selector.content).prev(selector.title),
                            $activeAccordion = $activeTitle.closest(selector.accordion),
                            activeSelector   = selector.title + '.' + className.active + ':visible',
                            activeContent    = selector.content + '.' + className.active + ':visible',
                            $openTitles,
                            $nestedTitles,
                            $openContents
                            ;
                        if(settings.closeNested) {
                            $openTitles   = $activeAccordion.find(activeSelector).not($parentTitles);
                            $openContents = $openTitles.next($content);
                        }
                        else {
                            $openTitles   = $activeAccordion.find(activeSelector).not($parentTitles);
                            $nestedTitles = $activeAccordion.find(activeContent).find(activeSelector).not($parentTitles);
                            $openTitles   = $openTitles.not($nestedTitles);
                            $openContents = $openTitles.next($content);
                        }
                        if( ($openTitles.length > 0) ) {
                            module.debug('Exclusive enabled, closing other content', $openTitles);
                            $openTitles
                                .removeClass(className.active)
                            ;
                            $openContents
                                .removeClass(className.animating)
                                .stop(true, true)
                            ;
                            if(settings.animateChildren) {
                                if($.fn.transition !== undefined && $module.transition('is supported')) {
                                    $openContents
                                        .children()
                                        .transition({
                                            animation   : 'fade out',
                                            useFailSafe : true,
                                            debug       : settings.debug,
                                            verbose     : settings.verbose,
                                            duration    : settings.duration
                                        })
                                    ;
                                }
                                else {
                                    $openContents
                                        .children()
                                        .stop(true, true)
                                        .animate({
                                            opacity: 0
                                        }, settings.duration, module.resetOpacity)
                                    ;
                                }
                            }
                            $openContents
                                .slideUp(settings.duration , settings.easing, function() {
                                    $(this).removeClass(className.active);
                                    module.reset.display.call(this);
                                })
                            ;
                        }
                    },

                    reset: {

                        display: function() {
                            module.verbose('Removing inline display from element', this);
                            $(this).css('display', '');
                            if( $(this).attr('style') === '') {
                                $(this)
                                    .attr('style', '')
                                    .removeAttr('style')
                                ;
                            }
                        },

                        opacity: function() {
                            module.verbose('Removing inline opacity from element', this);
                            $(this).css('opacity', '');
                            if( $(this).attr('style') === '') {
                                $(this)
                                    .attr('style', '')
                                    .removeAttr('style')
                                ;
                            }
                        },

                    },

                    setting: function(name, value) {
                        module.debug('Changing setting', name, value);
                        if( $.isPlainObject(name) ) {
                            $.extend(true, settings, name);
                        }
                        else if(value !== undefined) {
                            settings[name] = value;
                        }
                        else {
                            return settings[name];
                        }
                    },
                    internal: function(name, value) {
                        module.debug('Changing internal', name, value);
                        if(value !== undefined) {
                            if( $.isPlainObject(name) ) {
                                $.extend(true, module, name);
                            }
                            else {
                                module[name] = value;
                            }
                        }
                        else {
                            return module[name];
                        }
                    },
                    debug: function() {
                        if(settings.debug) {
                            if(settings.performance) {
                                module.performance.log(arguments);
                            }
                            else {
                                module.debug = Function.prototype.bind.call(console.info, console, settings.name + ':');
                                module.debug.apply(console, arguments);
                            }
                        }
                    },
                    verbose: function() {
                        if(settings.verbose && settings.debug) {
                            if(settings.performance) {
                                module.performance.log(arguments);
                            }
                            else {
                                module.verbose = Function.prototype.bind.call(console.info, console, settings.name + ':');
                                module.verbose.apply(console, arguments);
                            }
                        }
                    },
                    error: function() {
                        module.error = Function.prototype.bind.call(console.error, console, settings.name + ':');
                        module.error.apply(console, arguments);
                    },
                    performance: {
                        log: function(message) {
                            var
                                currentTime,
                                executionTime,
                                previousTime
                                ;
                            if(settings.performance) {
                                currentTime   = new Date().getTime();
                                previousTime  = time || currentTime;
                                executionTime = currentTime - previousTime;
                                time          = currentTime;
                                performance.push({
                                    'Name'           : message[0],
                                    'Arguments'      : [].slice.call(message, 1) || '',
                                    'Element'        : element,
                                    'Execution Time' : executionTime
                                });
                            }
                            clearTimeout(module.performance.timer);
                            module.performance.timer = setTimeout(module.performance.display, 500);
                        },
                        display: function() {
                            var
                                title = settings.name + ':',
                                totalTime = 0
                                ;
                            time = false;
                            clearTimeout(module.performance.timer);
                            $.each(performance, function(index, data) {
                                totalTime += data['Execution Time'];
                            });
                            title += ' ' + totalTime + 'ms';
                            if(moduleSelector) {
                                title += ' \'' + moduleSelector + '\'';
                            }
                            if( (console.group !== undefined || console.table !== undefined) && performance.length > 0) {
                                console.groupCollapsed(title);
                                if(console.table) {
                                    console.table(performance);
                                }
                                else {
                                    $.each(performance, function(index, data) {
                                        console.log(data['Name'] + ': ' + data['Execution Time']+'ms');
                                    });
                                }
                                console.groupEnd();
                            }
                            performance = [];
                        }
                    },
                    invoke: function(query, passedArguments, context) {
                        var
                            object = instance,
                            maxDepth,
                            found,
                            response
                            ;
                        passedArguments = passedArguments || queryArguments;
                        context         = element         || context;
                        if(typeof query == 'string' && object !== undefined) {
                            query    = query.split(/[\. ]/);
                            maxDepth = query.length - 1;
                            $.each(query, function(depth, value) {
                                var camelCaseValue = (depth != maxDepth)
                                        ? value + query[depth + 1].charAt(0).toUpperCase() + query[depth + 1].slice(1)
                                        : query
                                    ;
                                if( $.isPlainObject( object[camelCaseValue] ) && (depth != maxDepth) ) {
                                    object = object[camelCaseValue];
                                }
                                else if( object[camelCaseValue] !== undefined ) {
                                    found = object[camelCaseValue];
                                    return false;
                                }
                                else if( $.isPlainObject( object[value] ) && (depth != maxDepth) ) {
                                    object = object[value];
                                }
                                else if( object[value] !== undefined ) {
                                    found = object[value];
                                    return false;
                                }
                                else {
                                    module.error(error.method, query);
                                    return false;
                                }
                            });
                        }
                        if ( $.isFunction( found ) ) {
                            response = found.apply(context, passedArguments);
                        }
                        else if(found !== undefined) {
                            response = found;
                        }
                        if($.isArray(returnedValue)) {
                            returnedValue.push(response);
                        }
                        else if(returnedValue !== undefined) {
                            returnedValue = [returnedValue, response];
                        }
                        else if(response !== undefined) {
                            returnedValue = response;
                        }
                        return found;
                    }
                };
                if(methodInvoked) {
                    if(instance === undefined) {
                        module.initialize();
                    }
                    module.invoke(query);
                }
                else {
                    if(instance !== undefined) {
                        instance.invoke('destroy');
                    }
                    module.initialize();
                }
            })
        ;
        return (returnedValue !== undefined)
            ? returnedValue
            : this
            ;
    };

    $.fn.accordion.settings = {

        name            : 'Accordion',
        namespace       : 'accordion',

        debug           : false,
        verbose         : false,
        performance     : true,

        on              : 'click', // event on title that opens accordion

        observeChanges  : true,  // whether accordion should automatically refresh on DOM insertion

        exclusive       : true,  // whether a single accordion content panel should be open at once
        collapsible     : true,  // whether accordion content can be closed
        closeNested     : false, // whether nested content should be closed when a panel is closed
        animateChildren : true,  // whether children opacity should be animated

        duration        : 350, // duration of animation
        easing          : 'easeOutQuad', // easing equation for animation


        onOpening       : function(){}, // callback before open animation
        onOpen          : function(){}, // callback after open animation
        onClosing       : function(){}, // callback before closing animation
        onClose         : function(){}, // callback after closing animation
        onChange        : function(){}, // callback after closing or opening animation

        error: {
            method : 'The method you called is not defined'
        },

        className   : {
            active    : 'active',
            animating : 'animating'
        },

        selector    : {
            accordion : '.accordion',
            title     : '.title',
            trigger   : '.title',
            content   : '.content'
        }

    };

// Adds easing
    $.extend( $.easing, {
        easeOutQuad: function (x, t, b, c, d) {
            return -c *(t/=d)*(t-2) + b;
        }
    });

})( jQuery, window, document );


/*!
 * # Semantic UI 2.1.6 - Checkbox
 * http://github.com/semantic-org/semantic-ui/
 *
 *
 * Copyright 2015 Contributors
 * Released under the MIT license
 * http://opensource.org/licenses/MIT
 *
 */

;(function ( $, window, document, undefined ) {

    "use strict";

    $.fn.checkbox = function(parameters) {
        var
            $allModules    = $(this),
            moduleSelector = $allModules.selector || '',

            time           = new Date().getTime(),
            performance    = [],

            query          = arguments[0],
            methodInvoked  = (typeof query == 'string'),
            queryArguments = [].slice.call(arguments, 1),
            returnedValue
            ;

        $allModules
            .each(function() {
                var
                    settings        = $.extend(true, {}, $.fn.checkbox.settings, parameters),

                    className       = settings.className,
                    namespace       = settings.namespace,
                    selector        = settings.selector,
                    error           = settings.error,

                    eventNamespace  = '.' + namespace,
                    moduleNamespace = 'module-' + namespace,

                    $module         = $(this),
                    $label          = $(this).children(selector.label),
                    $input          = $(this).children(selector.input),
                    input           = $input[0],

                    initialLoad     = false,
                    shortcutPressed = false,
                    instance        = $module.data(moduleNamespace),

                    observer,
                    element         = this,
                    module
                    ;

                module      = {

                    initialize: function() {
                        module.verbose('Initializing checkbox', settings);

                        module.create.label();
                        module.bind.events();

                        module.set.tabbable();
                        module.hide.input();

                        module.observeChanges();
                        module.instantiate();
                        module.setup();
                    },

                    instantiate: function() {
                        module.verbose('Storing instance of module', module);
                        instance = module;
                        $module
                            .data(moduleNamespace, module)
                        ;
                    },

                    destroy: function() {
                        module.verbose('Destroying module');
                        module.unbind.events();
                        module.show.input();
                        $module.removeData(moduleNamespace);
                    },

                    fix: {
                        reference: function() {
                            if( $module.is(selector.input) ) {
                                module.debug('Behavior called on <input> adjusting invoked element');
                                $module = $module.closest(selector.checkbox);
                                module.refresh();
                            }
                        }
                    },

                    setup: function() {
                        module.set.initialLoad();
                        if( module.is.indeterminate() ) {
                            module.debug('Initial value is indeterminate');
                            module.indeterminate();
                        }
                        else if( module.is.checked() ) {
                            module.debug('Initial value is checked');
                            module.check();
                        }
                        else {
                            module.debug('Initial value is unchecked');
                            module.uncheck();
                        }
                        module.remove.initialLoad();
                    },

                    refresh: function() {
                        $label = $module.children(selector.label);
                        $input = $module.children(selector.input);
                        input  = $input[0];
                    },

                    hide: {
                        input: function() {
                            module.verbose('Modfying <input> z-index to be unselectable');
                            $input.addClass(className.hidden);
                        }
                    },
                    show: {
                        input: function() {
                            module.verbose('Modfying <input> z-index to be selectable');
                            $input.removeClass(className.hidden);
                        }
                    },

                    observeChanges: function() {
                        if('MutationObserver' in window) {
                            observer = new MutationObserver(function(mutations) {
                                module.debug('DOM tree modified, updating selector cache');
                                module.refresh();
                            });
                            observer.observe(element, {
                                childList : true,
                                subtree   : true
                            });
                            module.debug('Setting up mutation observer', observer);
                        }
                    },

                    attachEvents: function(selector, event) {
                        var
                            $element = $(selector)
                            ;
                        event = $.isFunction(module[event])
                            ? module[event]
                            : module.toggle
                        ;
                        if($element.length > 0) {
                            module.debug('Attaching checkbox events to element', selector, event);
                            $element
                                .on('click' + eventNamespace, event)
                            ;
                        }
                        else {
                            module.error(error.notFound);
                        }
                    },

                    event: {
                        click: function(event) {
                            var
                                $target = $(event.target)
                                ;
                            if( $target.is(selector.input) ) {
                                module.verbose('Using default check action on initialized checkbox');
                                return;
                            }
                            if( $target.is(selector.link) ) {
                                module.debug('Clicking link inside checkbox, skipping toggle');
                                return;
                            }
                            module.toggle();
                            $input.focus();
                            event.preventDefault();
                        },
                        keydown: function(event) {
                            var
                                key     = event.which,
                                keyCode = {
                                    enter  : 13,
                                    space  : 32,
                                    escape : 27
                                }
                                ;
                            if(key == keyCode.escape) {
                                module.verbose('Escape key pressed blurring field');
                                $input.blur();
                                shortcutPressed = true;
                            }
                            else if(!event.ctrlKey && ( key == keyCode.space || key == keyCode.enter) ) {
                                module.verbose('Enter/space key pressed, toggling checkbox');
                                module.toggle();
                                shortcutPressed = true;
                            }
                            else {
                                shortcutPressed = false;
                            }
                        },
                        keyup: function(event) {
                            if(shortcutPressed) {
                                event.preventDefault();
                            }
                        }
                    },

                    check: function() {
                        if( !module.should.allowCheck() ) {
                            return;
                        }
                        module.debug('Checking checkbox', $input);
                        module.set.checked();
                        if( !module.should.ignoreCallbacks() ) {
                            settings.onChecked.call(input);
                            settings.onChange.call(input);
                        }
                    },

                    uncheck: function() {
                        if( !module.should.allowUncheck() ) {
                            return;
                        }
                        module.debug('Unchecking checkbox');
                        module.set.unchecked();
                        if( !module.should.ignoreCallbacks() ) {
                            settings.onUnchecked.call(input);
                            settings.onChange.call(input);
                        }
                    },

                    indeterminate: function() {
                        if( module.should.allowIndeterminate() ) {
                            module.debug('Checkbox is already indeterminate');
                            return;
                        }
                        module.debug('Making checkbox indeterminate');
                        module.set.indeterminate();
                        if( !module.should.ignoreCallbacks() ) {
                            settings.onIndeterminate.call(input);
                            settings.onChange.call(input);
                        }
                    },

                    determinate: function() {
                        if( module.should.allowDeterminate() ) {
                            module.debug('Checkbox is already determinate');
                            return;
                        }
                        module.debug('Making checkbox determinate');
                        module.set.determinate();
                        if( !module.should.ignoreCallbacks() ) {
                            settings.onDeterminate.call(input);
                            settings.onChange.call(input);
                        }
                    },

                    enable: function() {
                        if( module.is.enabled() ) {
                            module.debug('Checkbox is already enabled');
                            return;
                        }
                        module.debug('Enabling checkbox');
                        module.set.enabled();
                        settings.onEnable.call(input);
                    },

                    disable: function() {
                        if( module.is.disabled() ) {
                            module.debug('Checkbox is already disabled');
                            return;
                        }
                        module.debug('Disabling checkbox');
                        module.set.disabled();
                        settings.onDisable.call(input);
                    },

                    get: {
                        radios: function() {
                            var
                                name = module.get.name()
                                ;
                            return $('input[name="' + name + '"]').closest(selector.checkbox);
                        },
                        otherRadios: function() {
                            return module.get.radios().not($module);
                        },
                        name: function() {
                            return $input.attr('name');
                        }
                    },

                    is: {
                        initialLoad: function() {
                            return initialLoad;
                        },
                        radio: function() {
                            return ($input.hasClass(className.radio) || $input.attr('type') == 'radio');
                        },
                        indeterminate: function() {
                            return $input.prop('indeterminate') !== undefined && $input.prop('indeterminate');
                        },
                        checked: function() {
                            return $input.prop('checked') !== undefined && $input.prop('checked');
                        },
                        disabled: function() {
                            return $input.prop('disabled') !== undefined && $input.prop('disabled');
                        },
                        enabled: function() {
                            return !module.is.disabled();
                        },
                        determinate: function() {
                            return !module.is.indeterminate();
                        },
                        unchecked: function() {
                            return !module.is.checked();
                        }
                    },

                    should: {
                        allowCheck: function() {
                            if(module.is.determinate() && module.is.checked() && !module.should.forceCallbacks() ) {
                                module.debug('Should not allow check, checkbox is already checked');
                                return false;
                            }
                            if(settings.beforeChecked.apply(input) === false) {
                                module.debug('Should not allow check, beforeChecked cancelled');
                                return false;
                            }
                            return true;
                        },
                        allowUncheck: function() {
                            if(module.is.determinate() && module.is.unchecked() && !module.should.forceCallbacks() ) {
                                module.debug('Should not allow uncheck, checkbox is already unchecked');
                                return false;
                            }
                            if(settings.beforeUnchecked.apply(input) === false) {
                                module.debug('Should not allow uncheck, beforeUnchecked cancelled');
                                return false;
                            }
                            return true;
                        },
                        allowIndeterminate: function() {
                            if(module.is.indeterminate() && !module.should.forceCallbacks() ) {
                                module.debug('Should not allow indeterminate, checkbox is already indeterminate');
                                return false;
                            }
                            if(settings.beforeIndeterminate.apply(input) === false) {
                                module.debug('Should not allow indeterminate, beforeIndeterminate cancelled');
                                return false;
                            }
                            return true;
                        },
                        allowDeterminate: function() {
                            if(module.is.determinate() && !module.should.forceCallbacks() ) {
                                module.debug('Should not allow determinate, checkbox is already determinate');
                                return false;
                            }
                            if(settings.beforeDeterminate.apply(input) === false) {
                                module.debug('Should not allow determinate, beforeDeterminate cancelled');
                                return false;
                            }
                            return true;
                        },
                        forceCallbacks: function() {
                            return (module.is.initialLoad() && settings.fireOnInit);
                        },
                        ignoreCallbacks: function() {
                            return (initialLoad && !settings.fireOnInit);
                        }
                    },

                    can: {
                        change: function() {
                            return !( $module.hasClass(className.disabled) || $module.hasClass(className.readOnly) || $input.prop('disabled') || $input.prop('readonly') );
                        },
                        uncheck: function() {
                            return (typeof settings.uncheckable === 'boolean')
                                ? settings.uncheckable
                                : !module.is.radio()
                                ;
                        }
                    },

                    set: {
                        initialLoad: function() {
                            initialLoad = true;
                        },
                        checked: function() {
                            module.verbose('Setting class to checked');
                            $module
                                .removeClass(className.indeterminate)
                                .addClass(className.checked)
                            ;
                            if( module.is.radio() ) {
                                module.uncheckOthers();
                            }
                            if(!module.is.indeterminate() && module.is.checked()) {
                                module.debug('Input is already checked, skipping input property change');
                                return;
                            }
                            module.verbose('Setting state to checked', input);
                            $input
                                .prop('indeterminate', false)
                                .prop('checked', true)
                            ;
                            module.trigger.change();
                        },
                        unchecked: function() {
                            module.verbose('Removing checked class');
                            $module
                                .removeClass(className.indeterminate)
                                .removeClass(className.checked)
                            ;
                            if(!module.is.indeterminate() &&  module.is.unchecked() ) {
                                module.debug('Input is already unchecked');
                                return;
                            }
                            module.debug('Setting state to unchecked');
                            $input
                                .prop('indeterminate', false)
                                .prop('checked', false)
                            ;
                            module.trigger.change();
                        },
                        indeterminate: function() {
                            module.verbose('Setting class to indeterminate');
                            $module
                                .addClass(className.indeterminate)
                            ;
                            if( module.is.indeterminate() ) {
                                module.debug('Input is already indeterminate, skipping input property change');
                                return;
                            }
                            module.debug('Setting state to indeterminate');
                            $input
                                .prop('indeterminate', true)
                            ;
                            module.trigger.change();
                        },
                        determinate: function() {
                            module.verbose('Removing indeterminate class');
                            $module
                                .removeClass(className.indeterminate)
                            ;
                            if( module.is.determinate() ) {
                                module.debug('Input is already determinate, skipping input property change');
                                return;
                            }
                            module.debug('Setting state to determinate');
                            $input
                                .prop('indeterminate', false)
                            ;
                        },
                        disabled: function() {
                            module.verbose('Setting class to disabled');
                            $module
                                .addClass(className.disabled)
                            ;
                            if( module.is.disabled() ) {
                                module.debug('Input is already disabled, skipping input property change');
                                return;
                            }
                            module.debug('Setting state to disabled');
                            $input
                                .prop('disabled', 'disabled')
                            ;
                            module.trigger.change();
                        },
                        enabled: function() {
                            module.verbose('Removing disabled class');
                            $module.removeClass(className.disabled);
                            if( module.is.enabled() ) {
                                module.debug('Input is already enabled, skipping input property change');
                                return;
                            }
                            module.debug('Setting state to enabled');
                            $input
                                .prop('disabled', false)
                            ;
                            module.trigger.change();
                        },
                        tabbable: function() {
                            module.verbose('Adding tabindex to checkbox');
                            if( $input.attr('tabindex') === undefined) {
                                $input.attr('tabindex', 0);
                            }
                        }
                    },

                    remove: {
                        initialLoad: function() {
                            initialLoad = false;
                        }
                    },

                    trigger: {
                        change: function() {
                            var
                                events       = document.createEvent('HTMLEvents'),
                                inputElement = $input[0]
                                ;
                            if(inputElement) {
                                module.verbose('Triggering native change event');
                                events.initEvent('change', true, false);
                                inputElement.dispatchEvent(events);
                            }
                        }
                    },


                    create: {
                        label: function() {
                            if($input.prevAll(selector.label).length > 0) {
                                $input.prev(selector.label).detach().insertAfter($input);
                                module.debug('Moving existing label', $label);
                            }
                            else if( !module.has.label() ) {
                                $label = $('<label>').insertAfter($input);
                                module.debug('Creating label', $label);
                            }
                        }
                    },

                    has: {
                        label: function() {
                            return ($label.length > 0);
                        }
                    },

                    bind: {
                        events: function() {
                            module.verbose('Attaching checkbox events');
                            $module
                                .on('click'   + eventNamespace, module.event.click)
                                .on('keydown' + eventNamespace, selector.input, module.event.keydown)
                                .on('keyup'   + eventNamespace, selector.input, module.event.keyup)
                            ;
                        }
                    },

                    unbind: {
                        events: function() {
                            module.debug('Removing events');
                            $module
                                .off(eventNamespace)
                            ;
                        }
                    },

                    uncheckOthers: function() {
                        var
                            $radios = module.get.otherRadios()
                            ;
                        module.debug('Unchecking other radios', $radios);
                        $radios.removeClass(className.checked);
                    },

                    toggle: function() {
                        if( !module.can.change() ) {
                            if(!module.is.radio()) {
                                module.debug('Checkbox is read-only or disabled, ignoring toggle');
                            }
                            return;
                        }
                        if( module.is.indeterminate() || module.is.unchecked() ) {
                            module.debug('Currently unchecked');
                            module.check();
                        }
                        else if( module.is.checked() && module.can.uncheck() ) {
                            module.debug('Currently checked');
                            module.uncheck();
                        }
                    },
                    setting: function(name, value) {
                        module.debug('Changing setting', name, value);
                        if( $.isPlainObject(name) ) {
                            $.extend(true, settings, name);
                        }
                        else if(value !== undefined) {
                            settings[name] = value;
                        }
                        else {
                            return settings[name];
                        }
                    },
                    internal: function(name, value) {
                        if( $.isPlainObject(name) ) {
                            $.extend(true, module, name);
                        }
                        else if(value !== undefined) {
                            module[name] = value;
                        }
                        else {
                            return module[name];
                        }
                    },
                    debug: function() {
                        if(settings.debug) {
                            if(settings.performance) {
                                module.performance.log(arguments);
                            }
                            else {
                                module.debug = Function.prototype.bind.call(console.info, console, settings.name + ':');
                                module.debug.apply(console, arguments);
                            }
                        }
                    },
                    verbose: function() {
                        if(settings.verbose && settings.debug) {
                            if(settings.performance) {
                                module.performance.log(arguments);
                            }
                            else {
                                module.verbose = Function.prototype.bind.call(console.info, console, settings.name + ':');
                                module.verbose.apply(console, arguments);
                            }
                        }
                    },
                    error: function() {
                        module.error = Function.prototype.bind.call(console.error, console, settings.name + ':');
                        module.error.apply(console, arguments);
                    },
                    performance: {
                        log: function(message) {
                            var
                                currentTime,
                                executionTime,
                                previousTime
                                ;
                            if(settings.performance) {
                                currentTime   = new Date().getTime();
                                previousTime  = time || currentTime;
                                executionTime = currentTime - previousTime;
                                time          = currentTime;
                                performance.push({
                                    'Name'           : message[0],
                                    'Arguments'      : [].slice.call(message, 1) || '',
                                    'Element'        : element,
                                    'Execution Time' : executionTime
                                });
                            }
                            clearTimeout(module.performance.timer);
                            module.performance.timer = setTimeout(module.performance.display, 500);
                        },
                        display: function() {
                            var
                                title = settings.name + ':',
                                totalTime = 0
                                ;
                            time = false;
                            clearTimeout(module.performance.timer);
                            $.each(performance, function(index, data) {
                                totalTime += data['Execution Time'];
                            });
                            title += ' ' + totalTime + 'ms';
                            if(moduleSelector) {
                                title += ' \'' + moduleSelector + '\'';
                            }
                            if( (console.group !== undefined || console.table !== undefined) && performance.length > 0) {
                                console.groupCollapsed(title);
                                if(console.table) {
                                    console.table(performance);
                                }
                                else {
                                    $.each(performance, function(index, data) {
                                        console.log(data['Name'] + ': ' + data['Execution Time']+'ms');
                                    });
                                }
                                console.groupEnd();
                            }
                            performance = [];
                        }
                    },
                    invoke: function(query, passedArguments, context) {
                        var
                            object = instance,
                            maxDepth,
                            found,
                            response
                            ;
                        passedArguments = passedArguments || queryArguments;
                        context         = element         || context;
                        if(typeof query == 'string' && object !== undefined) {
                            query    = query.split(/[\. ]/);
                            maxDepth = query.length - 1;
                            $.each(query, function(depth, value) {
                                var camelCaseValue = (depth != maxDepth)
                                        ? value + query[depth + 1].charAt(0).toUpperCase() + query[depth + 1].slice(1)
                                        : query
                                    ;
                                if( $.isPlainObject( object[camelCaseValue] ) && (depth != maxDepth) ) {
                                    object = object[camelCaseValue];
                                }
                                else if( object[camelCaseValue] !== undefined ) {
                                    found = object[camelCaseValue];
                                    return false;
                                }
                                else if( $.isPlainObject( object[value] ) && (depth != maxDepth) ) {
                                    object = object[value];
                                }
                                else if( object[value] !== undefined ) {
                                    found = object[value];
                                    return false;
                                }
                                else {
                                    module.error(error.method, query);
                                    return false;
                                }
                            });
                        }
                        if ( $.isFunction( found ) ) {
                            response = found.apply(context, passedArguments);
                        }
                        else if(found !== undefined) {
                            response = found;
                        }
                        if($.isArray(returnedValue)) {
                            returnedValue.push(response);
                        }
                        else if(returnedValue !== undefined) {
                            returnedValue = [returnedValue, response];
                        }
                        else if(response !== undefined) {
                            returnedValue = response;
                        }
                        return found;
                    }
                };

                if(methodInvoked) {
                    if(instance === undefined) {
                        module.initialize();
                    }
                    module.invoke(query);
                }
                else {
                    if(instance !== undefined) {
                        instance.invoke('destroy');
                    }
                    module.initialize();
                }
            })
        ;

        return (returnedValue !== undefined)
            ? returnedValue
            : this
            ;
    };

    $.fn.checkbox.settings = {

        name                : 'Checkbox',
        namespace           : 'checkbox',

        debug               : false,
        verbose             : true,
        performance         : true,

        // delegated event context
        uncheckable         : 'auto',
        fireOnInit          : false,

        onChange            : function(){},

        beforeChecked       : function(){},
        beforeUnchecked     : function(){},
        beforeDeterminate   : function(){},
        beforeIndeterminate : function(){},

        onChecked           : function(){},
        onUnchecked         : function(){},

        onDeterminate       : function() {},
        onIndeterminate     : function() {},

        onEnabled           : function(){},
        onDisabled          : function(){},

        className       : {
            checked       : 'checked',
            indeterminate : 'indeterminate',
            disabled      : 'disabled',
            hidden        : 'hidden',
            radio         : 'radio',
            readOnly      : 'read-only'
        },

        error     : {
            method       : 'The method you called is not defined'
        },

        selector : {
            checkbox : '.ui.checkbox',
            label    : 'label, .box',
            input    : 'input[type="checkbox"], input[type="radio"]',
            link     : 'a[href]'
        }

    };

})( jQuery, window, document );

/*!
 * # Semantic UI 2.1.6 - Dimmer
 * http://github.com/semantic-org/semantic-ui/
 *
 *
 * Copyright 2015 Contributors
 * Released under the MIT license
 * http://opensource.org/licenses/MIT
 *
 */

;(function ( $, window, document, undefined ) {

    "use strict";

    $.fn.dimmer = function(parameters) {
        var
            $allModules     = $(this),

            time            = new Date().getTime(),
            performance     = [],

            query           = arguments[0],
            methodInvoked   = (typeof query == 'string'),
            queryArguments  = [].slice.call(arguments, 1),

            returnedValue
            ;

        $allModules
            .each(function() {
                var
                    settings        = ( $.isPlainObject(parameters) )
                        ? $.extend(true, {}, $.fn.dimmer.settings, parameters)
                        : $.extend({}, $.fn.dimmer.settings),

                    selector        = settings.selector,
                    namespace       = settings.namespace,
                    className       = settings.className,
                    error           = settings.error,

                    eventNamespace  = '.' + namespace,
                    moduleNamespace = 'module-' + namespace,
                    moduleSelector  = $allModules.selector || '',

                    clickEvent      = ('ontouchstart' in document.documentElement)
                        ? 'touchstart'
                        : 'click',

                    $module = $(this),
                    $dimmer,
                    $dimmable,

                    element   = this,
                    instance  = $module.data(moduleNamespace),
                    module
                    ;

                module = {

                    preinitialize: function() {
                        if( module.is.dimmer() ) {

                            $dimmable = $module.parent();
                            $dimmer   = $module;
                        }
                        else {
                            $dimmable = $module;
                            if( module.has.dimmer() ) {
                                if(settings.dimmerName) {
                                    $dimmer = $dimmable.find(selector.dimmer).filter('.' + settings.dimmerName);
                                }
                                else {
                                    $dimmer = $dimmable.find(selector.dimmer);
                                }
                            }
                            else {
                                $dimmer = module.create();
                            }
                        }
                    },

                    initialize: function() {
                        module.debug('Initializing dimmer', settings);

                        module.bind.events();
                        module.set.dimmable();
                        module.instantiate();
                    },

                    instantiate: function() {
                        module.verbose('Storing instance of module', module);
                        instance = module;
                        $module
                            .data(moduleNamespace, instance)
                        ;
                    },

                    destroy: function() {
                        module.verbose('Destroying previous module', $dimmer);
                        module.unbind.events();
                        module.remove.variation();
                        $dimmable
                            .off(eventNamespace)
                        ;
                    },

                    bind: {
                        events: function() {
                            if(settings.on == 'hover') {
                                $dimmable
                                    .on('mouseenter' + eventNamespace, module.show)
                                    .on('mouseleave' + eventNamespace, module.hide)
                                ;
                            }
                            else if(settings.on == 'click') {
                                $dimmable
                                    .on(clickEvent + eventNamespace, module.toggle)
                                ;
                            }
                            if( module.is.page() ) {
                                module.debug('Setting as a page dimmer', $dimmable);
                                module.set.pageDimmer();
                            }

                            if( module.is.closable() ) {
                                module.verbose('Adding dimmer close event', $dimmer);
                                $dimmable
                                    .on(clickEvent + eventNamespace, selector.dimmer, module.event.click)
                                ;
                            }
                        }
                    },

                    unbind: {
                        events: function() {
                            $module
                                .removeData(moduleNamespace)
                            ;
                        }
                    },

                    event: {
                        click: function(event) {
                            module.verbose('Determining if event occured on dimmer', event);
                            if( $dimmer.find(event.target).length === 0 || $(event.target).is(selector.content) ) {
                                module.hide();
                                event.stopImmediatePropagation();
                            }
                        }
                    },

                    addContent: function(element) {
                        var
                            $content = $(element)
                            ;
                        module.debug('Add content to dimmer', $content);
                        if($content.parent()[0] !== $dimmer[0]) {
                            $content.detach().appendTo($dimmer);
                        }
                    },

                    create: function() {
                        var
                            $element = $( settings.template.dimmer() )
                            ;
                        if(settings.variation) {
                            module.debug('Creating dimmer with variation', settings.variation);
                            $element.addClass(settings.variation);
                        }
                        if(settings.dimmerName) {
                            module.debug('Creating named dimmer', settings.dimmerName);
                            $element.addClass(settings.dimmerName);
                        }
                        $element
                            .appendTo($dimmable)
                        ;
                        return $element;
                    },

                    show: function(callback) {
                        callback = $.isFunction(callback)
                            ? callback
                            : function(){}
                        ;
                        module.debug('Showing dimmer', $dimmer, settings);
                        if( (!module.is.dimmed() || module.is.animating()) && module.is.enabled() ) {
                            module.animate.show(callback);
                            settings.onShow.call(element);
                            settings.onChange.call(element);
                        }
                        else {
                            module.debug('Dimmer is already shown or disabled');
                        }
                    },

                    hide: function(callback) {
                        callback = $.isFunction(callback)
                            ? callback
                            : function(){}
                        ;
                        if( module.is.dimmed() || module.is.animating() ) {
                            module.debug('Hiding dimmer', $dimmer);
                            module.animate.hide(callback);
                            settings.onHide.call(element);
                            settings.onChange.call(element);
                        }
                        else {
                            module.debug('Dimmer is not visible');
                        }
                    },

                    toggle: function() {
                        module.verbose('Toggling dimmer visibility', $dimmer);
                        if( !module.is.dimmed() ) {
                            module.show();
                        }
                        else {
                            module.hide();
                        }
                    },

                    animate: {
                        show: function(callback) {
                            callback = $.isFunction(callback)
                                ? callback
                                : function(){}
                            ;
                            if(settings.useCSS && $.fn.transition !== undefined && $dimmer.transition('is supported')) {
                                if(settings.opacity !== 'auto') {
                                    module.set.opacity();
                                }
                                $dimmer
                                    .transition({
                                        animation   : settings.transition + ' in',
                                        queue       : false,
                                        duration    : module.get.duration(),
                                        useFailSafe : true,
                                        onStart     : function() {
                                            module.set.dimmed();
                                        },
                                        onComplete  : function() {
                                            module.set.active();
                                            callback();
                                        }
                                    })
                                ;
                            }
                            else {
                                module.verbose('Showing dimmer animation with javascript');
                                module.set.dimmed();
                                if(settings.opacity == 'auto') {
                                    settings.opacity = 0.8;
                                }
                                $dimmer
                                    .stop()
                                    .css({
                                        opacity : 0,
                                        width   : '100%',
                                        height  : '100%'
                                    })
                                    .fadeTo(module.get.duration(), settings.opacity, function() {
                                        $dimmer.removeAttr('style');
                                        module.set.active();
                                        callback();
                                    })
                                ;
                            }
                        },
                        hide: function(callback) {
                            callback = $.isFunction(callback)
                                ? callback
                                : function(){}
                            ;
                            if(settings.useCSS && $.fn.transition !== undefined && $dimmer.transition('is supported')) {
                                module.verbose('Hiding dimmer with css');
                                $dimmer
                                    .transition({
                                        animation   : settings.transition + ' out',
                                        queue       : false,
                                        duration    : module.get.duration(),
                                        useFailSafe : true,
                                        onStart     : function() {
                                            module.remove.dimmed();
                                        },
                                        onComplete  : function() {
                                            module.remove.active();
                                            callback();
                                        }
                                    })
                                ;
                            }
                            else {
                                module.verbose('Hiding dimmer with javascript');
                                module.remove.dimmed();
                                $dimmer
                                    .stop()
                                    .fadeOut(module.get.duration(), function() {
                                        module.remove.active();
                                        $dimmer.removeAttr('style');
                                        callback();
                                    })
                                ;
                            }
                        }
                    },

                    get: {
                        dimmer: function() {
                            return $dimmer;
                        },
                        duration: function() {
                            if(typeof settings.duration == 'object') {
                                if( module.is.active() ) {
                                    return settings.duration.hide;
                                }
                                else {
                                    return settings.duration.show;
                                }
                            }
                            return settings.duration;
                        }
                    },

                    has: {
                        dimmer: function() {
                            if(settings.dimmerName) {
                                return ($module.find(selector.dimmer).filter('.' + settings.dimmerName).length > 0);
                            }
                            else {
                                return ( $module.find(selector.dimmer).length > 0 );
                            }
                        }
                    },

                    is: {
                        active: function() {
                            return $dimmer.hasClass(className.active);
                        },
                        animating: function() {
                            return ( $dimmer.is(':animated') || $dimmer.hasClass(className.animating) );
                        },
                        closable: function() {
                            if(settings.closable == 'auto') {
                                if(settings.on == 'hover') {
                                    return false;
                                }
                                return true;
                            }
                            return settings.closable;
                        },
                        dimmer: function() {
                            return $module.hasClass(className.dimmer);
                        },
                        dimmable: function() {
                            return $module.hasClass(className.dimmable);
                        },
                        dimmed: function() {
                            return $dimmable.hasClass(className.dimmed);
                        },
                        disabled: function() {
                            return $dimmable.hasClass(className.disabled);
                        },
                        enabled: function() {
                            return !module.is.disabled();
                        },
                        page: function () {
                            return $dimmable.is('body');
                        },
                        pageDimmer: function() {
                            return $dimmer.hasClass(className.pageDimmer);
                        }
                    },

                    can: {
                        show: function() {
                            return !$dimmer.hasClass(className.disabled);
                        }
                    },

                    set: {
                        opacity: function(opacity) {
                            var
                                color      = $dimmer.css('background-color'),
                                colorArray = color.split(','),
                                isRGBA     = (colorArray && colorArray.length == 4)
                                ;
                            opacity    = settings.opacity === 0 ? 0 : settings.opacity || opacity;
                            if(isRGBA) {
                                colorArray[3] = opacity + ')';
                                color         = colorArray.join(',');
                            }
                            else {
                                color = 'rgba(0, 0, 0, ' + opacity + ')';
                            }
                            module.debug('Setting opacity to', opacity);
                            $dimmer.css('background-color', color);
                        },
                        active: function() {
                            $dimmer.addClass(className.active);
                        },
                        dimmable: function() {
                            $dimmable.addClass(className.dimmable);
                        },
                        dimmed: function() {
                            $dimmable.addClass(className.dimmed);
                        },
                        pageDimmer: function() {
                            $dimmer.addClass(className.pageDimmer);
                        },
                        disabled: function() {
                            $dimmer.addClass(className.disabled);
                        },
                        variation: function(variation) {
                            variation = variation || settings.variation;
                            if(variation) {
                                $dimmer.addClass(variation);
                            }
                        }
                    },

                    remove: {
                        active: function() {
                            $dimmer
                                .removeClass(className.active)
                            ;
                        },
                        dimmed: function() {
                            $dimmable.removeClass(className.dimmed);
                        },
                        disabled: function() {
                            $dimmer.removeClass(className.disabled);
                        },
                        variation: function(variation) {
                            variation = variation || settings.variation;
                            if(variation) {
                                $dimmer.removeClass(variation);
                            }
                        }
                    },

                    setting: function(name, value) {
                        module.debug('Changing setting', name, value);
                        if( $.isPlainObject(name) ) {
                            $.extend(true, settings, name);
                        }
                        else if(value !== undefined) {
                            settings[name] = value;
                        }
                        else {
                            return settings[name];
                        }
                    },
                    internal: function(name, value) {
                        if( $.isPlainObject(name) ) {
                            $.extend(true, module, name);
                        }
                        else if(value !== undefined) {
                            module[name] = value;
                        }
                        else {
                            return module[name];
                        }
                    },
                    debug: function() {
                        if(settings.debug) {
                            if(settings.performance) {
                                module.performance.log(arguments);
                            }
                            else {
                                module.debug = Function.prototype.bind.call(console.info, console, settings.name + ':');
                                module.debug.apply(console, arguments);
                            }
                        }
                    },
                    verbose: function() {
                        if(settings.verbose && settings.debug) {
                            if(settings.performance) {
                                module.performance.log(arguments);
                            }
                            else {
                                module.verbose = Function.prototype.bind.call(console.info, console, settings.name + ':');
                                module.verbose.apply(console, arguments);
                            }
                        }
                    },
                    error: function() {
                        module.error = Function.prototype.bind.call(console.error, console, settings.name + ':');
                        module.error.apply(console, arguments);
                    },
                    performance: {
                        log: function(message) {
                            var
                                currentTime,
                                executionTime,
                                previousTime
                                ;
                            if(settings.performance) {
                                currentTime   = new Date().getTime();
                                previousTime  = time || currentTime;
                                executionTime = currentTime - previousTime;
                                time          = currentTime;
                                performance.push({
                                    'Name'           : message[0],
                                    'Arguments'      : [].slice.call(message, 1) || '',
                                    'Element'        : element,
                                    'Execution Time' : executionTime
                                });
                            }
                            clearTimeout(module.performance.timer);
                            module.performance.timer = setTimeout(module.performance.display, 500);
                        },
                        display: function() {
                            var
                                title = settings.name + ':',
                                totalTime = 0
                                ;
                            time = false;
                            clearTimeout(module.performance.timer);
                            $.each(performance, function(index, data) {
                                totalTime += data['Execution Time'];
                            });
                            title += ' ' + totalTime + 'ms';
                            if(moduleSelector) {
                                title += ' \'' + moduleSelector + '\'';
                            }
                            if($allModules.length > 1) {
                                title += ' ' + '(' + $allModules.length + ')';
                            }
                            if( (console.group !== undefined || console.table !== undefined) && performance.length > 0) {
                                console.groupCollapsed(title);
                                if(console.table) {
                                    console.table(performance);
                                }
                                else {
                                    $.each(performance, function(index, data) {
                                        console.log(data['Name'] + ': ' + data['Execution Time']+'ms');
                                    });
                                }
                                console.groupEnd();
                            }
                            performance = [];
                        }
                    },
                    invoke: function(query, passedArguments, context) {
                        var
                            object = instance,
                            maxDepth,
                            found,
                            response
                            ;
                        passedArguments = passedArguments || queryArguments;
                        context         = element         || context;
                        if(typeof query == 'string' && object !== undefined) {
                            query    = query.split(/[\. ]/);
                            maxDepth = query.length - 1;
                            $.each(query, function(depth, value) {
                                var camelCaseValue = (depth != maxDepth)
                                        ? value + query[depth + 1].charAt(0).toUpperCase() + query[depth + 1].slice(1)
                                        : query
                                    ;
                                if( $.isPlainObject( object[camelCaseValue] ) && (depth != maxDepth) ) {
                                    object = object[camelCaseValue];
                                }
                                else if( object[camelCaseValue] !== undefined ) {
                                    found = object[camelCaseValue];
                                    return false;
                                }
                                else if( $.isPlainObject( object[value] ) && (depth != maxDepth) ) {
                                    object = object[value];
                                }
                                else if( object[value] !== undefined ) {
                                    found = object[value];
                                    return false;
                                }
                                else {
                                    module.error(error.method, query);
                                    return false;
                                }
                            });
                        }
                        if ( $.isFunction( found ) ) {
                            response = found.apply(context, passedArguments);
                        }
                        else if(found !== undefined) {
                            response = found;
                        }
                        if($.isArray(returnedValue)) {
                            returnedValue.push(response);
                        }
                        else if(returnedValue !== undefined) {
                            returnedValue = [returnedValue, response];
                        }
                        else if(response !== undefined) {
                            returnedValue = response;
                        }
                        return found;
                    }
                };

                module.preinitialize();

                if(methodInvoked) {
                    if(instance === undefined) {
                        module.initialize();
                    }
                    module.invoke(query);
                }
                else {
                    if(instance !== undefined) {
                        instance.invoke('destroy');
                    }
                    module.initialize();
                }
            })
        ;

        return (returnedValue !== undefined)
            ? returnedValue
            : this
            ;
    };

    $.fn.dimmer.settings = {

        name        : 'Dimmer',
        namespace   : 'dimmer',

        debug       : false,
        verbose     : false,
        performance : true,

        // name to distinguish between multiple dimmers in context
        dimmerName  : false,

        // whether to add a variation type
        variation   : false,

        // whether to bind close events
        closable    : 'auto',

        // whether to use css animations
        useCSS      : true,

        // css animation to use
        transition  : 'fade',

        // event to bind to
        on          : false,

        // overriding opacity value
        opacity     : 'auto',

        // transition durations
        duration    : {
            show : 500,
            hide : 500
        },

        onChange    : function(){},
        onShow      : function(){},
        onHide      : function(){},

        error   : {
            method   : 'The method you called is not defined.'
        },

        className : {
            active     : 'active',
            animating  : 'animating',
            dimmable   : 'dimmable',
            dimmed     : 'dimmed',
            dimmer     : 'dimmer',
            disabled   : 'disabled',
            hide       : 'hide',
            pageDimmer : 'page',
            show       : 'show'
        },

        selector: {
            dimmer   : '> .ui.dimmer',
            content  : '.ui.dimmer > .content, .ui.dimmer > .content > .center'
        },

        template: {
            dimmer: function() {
                return $('<div />').attr('class', 'ui dimmer');
            }
        }

    };

})( jQuery, window, document );
/*!
 * # Semantic UI 2.1.6 - Dropdown
 * http://github.com/semantic-org/semantic-ui/
 *
 *
 * Copyright 2015 Contributors
 * Released under the MIT license
 * http://opensource.org/licenses/MIT
 *
 */

;(function ( $, window, document, undefined ) {

    "use strict";

    $.fn.dropdown = function(parameters) {
        var
            $allModules    = $(this),
            $document      = $(document),

            moduleSelector = $allModules.selector || '',

            hasTouch       = ('ontouchstart' in document.documentElement),
            time           = new Date().getTime(),
            performance    = [],

            query          = arguments[0],
            methodInvoked  = (typeof query == 'string'),
            queryArguments = [].slice.call(arguments, 1),
            returnedValue
            ;

        $allModules
            .each(function(elementIndex) {
                var
                    settings          = ( $.isPlainObject(parameters) )
                        ? $.extend(true, {}, $.fn.dropdown.settings, parameters)
                        : $.extend({}, $.fn.dropdown.settings),

                    className       = settings.className,
                    message         = settings.message,
                    fields          = settings.fields,
                    keys            = settings.keys,
                    metadata        = settings.metadata,
                    namespace       = settings.namespace,
                    regExp          = settings.regExp,
                    selector        = settings.selector,
                    error           = settings.error,
                    templates       = settings.templates,

                    eventNamespace  = '.' + namespace,
                    moduleNamespace = 'module-' + namespace,

                    $module         = $(this),
                    $context        = $(settings.context),
                    $text           = $module.find(selector.text),
                    $search         = $module.find(selector.search),
                    $input          = $module.find(selector.input),
                    $icon           = $module.find(selector.icon),

                    $combo = ($module.prev().find(selector.text).length > 0)
                        ? $module.prev().find(selector.text)
                        : $module.prev(),

                    $menu           = $module.children(selector.menu),
                    $item           = $menu.find(selector.item),

                    activated       = false,
                    itemActivated   = false,
                    internalChange  = false,
                    element         = this,
                    instance        = $module.data(moduleNamespace),

                    initialLoad,
                    pageLostFocus,
                    elementNamespace,
                    id,
                    selectObserver,
                    menuObserver,
                    module
                    ;

                module = {

                    initialize: function() {
                        module.debug('Initializing dropdown', settings);

                        if( module.is.alreadySetup() ) {
                            module.setup.reference();
                        }
                        else {
                            module.setup.layout();
                            module.refreshData();

                            module.save.defaults();
                            module.restore.selected();

                            module.create.id();
                            module.bind.events();

                            module.observeChanges();
                            module.instantiate();
                        }

                    },

                    instantiate: function() {
                        module.verbose('Storing instance of dropdown', module);
                        instance = module;
                        $module
                            .data(moduleNamespace, module)
                        ;
                    },

                    destroy: function() {
                        module.verbose('Destroying previous dropdown', $module);
                        module.remove.tabbable();
                        $module
                            .off(eventNamespace)
                            .removeData(moduleNamespace)
                        ;
                        $menu
                            .off(eventNamespace)
                        ;
                        $document
                            .off(elementNamespace)
                        ;
                        if(selectObserver) {
                            selectObserver.disconnect();
                        }
                        if(menuObserver) {
                            menuObserver.disconnect();
                        }
                    },

                    observeChanges: function() {
                        if('MutationObserver' in window) {
                            selectObserver = new MutationObserver(function(mutations) {
                                module.debug('<select> modified, recreating menu');
                                module.setup.select();
                            });
                            menuObserver = new MutationObserver(function(mutations) {
                                module.debug('Menu modified, updating selector cache');
                                module.refresh();
                            });
                            if(module.has.input()) {
                                selectObserver.observe($input[0], {
                                    childList : true,
                                    subtree   : true
                                });
                            }
                            if(module.has.menu()) {
                                menuObserver.observe($menu[0], {
                                    childList : true,
                                    subtree   : true
                                });
                            }
                            module.debug('Setting up mutation observer', selectObserver, menuObserver);
                        }
                    },

                    create: {
                        id: function() {
                            id = (Math.random().toString(16) + '000000000').substr(2, 8);
                            elementNamespace = '.' + id;
                            module.verbose('Creating unique id for element', id);
                        },
                        userChoice: function(values) {
                            var
                                $userChoices,
                                $userChoice,
                                isUserValue,
                                html
                                ;
                            values = values || module.get.userValues();
                            if(!values) {
                                return false;
                            }
                            values = $.isArray(values)
                                ? values
                                : [values]
                            ;
                            $.each(values, function(index, value) {
                                if(module.get.item(value) === false) {
                                    html         = settings.templates.addition( module.add.variables(message.addResult, value) );
                                    $userChoice  = $('<div />')
                                        .html(html)
                                        .attr('data-' + metadata.value, value)
                                        .attr('data-' + metadata.text, value)
                                        .addClass(className.addition)
                                        .addClass(className.item)
                                    ;
                                    $userChoices = ($userChoices === undefined)
                                        ? $userChoice
                                        : $userChoices.add($userChoice)
                                    ;
                                    module.verbose('Creating user choices for value', value, $userChoice);
                                }
                            });
                            return $userChoices;
                        },
                        userLabels: function(value) {
                            var
                                userValues = module.get.userValues()
                                ;
                            if(userValues) {
                                module.debug('Adding user labels', userValues);
                                $.each(userValues, function(index, value) {
                                    module.verbose('Adding custom user value');
                                    module.add.label(value, value);
                                });
                            }
                        },
                        menu: function() {
                            $menu = $('<div />')
                                .addClass(className.menu)
                                .appendTo($module)
                            ;
                        }
                    },

                    search: function(query) {
                        query = (query !== undefined)
                            ? query
                            : module.get.query()
                        ;
                        module.verbose('Searching for query', query);
                        module.filter(query);
                    },

                    select: {
                        firstUnfiltered: function() {
                            module.verbose('Selecting first non-filtered element');
                            module.remove.selectedItem();
                            $item
                                .not(selector.unselectable)
                                .eq(0)
                                .addClass(className.selected)
                            ;
                        },
                        nextAvailable: function($selected) {
                            $selected = $selected.eq(0);
                            var
                                $nextAvailable = $selected.nextAll(selector.item).not(selector.unselectable).eq(0),
                                $prevAvailable = $selected.prevAll(selector.item).not(selector.unselectable).eq(0),
                                hasNext        = ($nextAvailable.length > 0)
                                ;
                            if(hasNext) {
                                module.verbose('Moving selection to', $nextAvailable);
                                $nextAvailable.addClass(className.selected);
                            }
                            else {
                                module.verbose('Moving selection to', $prevAvailable);
                                $prevAvailable.addClass(className.selected);
                            }
                        }
                    },

                    setup: {
                        api: function() {
                            var
                                apiSettings = {
                                    debug : settings.debug,
                                    on    : false
                                }
                                ;
                            module.verbose('First request, initializing API');
                            $module
                                .api(apiSettings)
                            ;
                        },
                        layout: function() {
                            if( $module.is('select') ) {
                                module.setup.select();
                                module.setup.returnedObject();
                            }
                            if( !module.has.menu() ) {
                                module.create.menu();
                            }
                            if( module.is.search() && !module.has.search() ) {
                                module.verbose('Adding search input');
                                $search = $('<input />')
                                    .addClass(className.search)
                                    .prop('autocomplete', 'off')
                                    .insertBefore($text)
                                ;
                            }
                            if(settings.allowTab) {
                                module.set.tabbable();
                            }
                        },
                        select: function() {
                            var
                                selectValues  = module.get.selectValues()
                                ;
                            module.debug('Dropdown initialized on a select', selectValues);
                            if( $module.is('select') ) {
                                $input = $module;
                            }
                            // see if select is placed correctly already
                            if($input.parent(selector.dropdown).length > 0) {
                                module.debug('UI dropdown already exists. Creating dropdown menu only');
                                $module = $input.closest(selector.dropdown);
                                if( !module.has.menu() ) {
                                    module.create.menu();
                                }
                                $menu = $module.children(selector.menu);
                                module.setup.menu(selectValues);
                            }
                            else {
                                module.debug('Creating entire dropdown from select');
                                $module = $('<div />')
                                    .attr('class', $input.attr('class') )
                                    .addClass(className.selection)
                                    .addClass(className.dropdown)
                                    .html( templates.dropdown(selectValues) )
                                    .insertBefore($input)
                                ;
                                if($input.hasClass(className.multiple) && $input.prop('multiple') === false) {
                                    module.error(error.missingMultiple);
                                    $input.prop('multiple', true);
                                }
                                if($input.is('[multiple]')) {
                                    module.set.multiple();
                                }
                                if ($input.prop('disabled')) {
                                    module.debug('Disabling dropdown')
                                    $module.addClass(className.disabled)
                                }
                                $input
                                    .removeAttr('class')
                                    .detach()
                                    .prependTo($module)
                                ;
                            }
                            module.refresh();
                        },
                        menu: function(values) {
                            $menu.html( templates.menu(values, fields));
                            $item = $menu.find(selector.item);
                        },
                        reference: function() {
                            module.debug('Dropdown behavior was called on select, replacing with closest dropdown');
                            // replace module reference
                            $module = $module.parent(selector.dropdown);
                            module.refresh();
                            module.setup.returnedObject();
                            // invoke method in context of current instance
                            if(methodInvoked) {
                                instance = module;
                                module.invoke(query);
                            }
                        },
                        returnedObject: function() {
                            var
                                $firstModules = $allModules.slice(0, elementIndex),
                                $lastModules = $allModules.slice(elementIndex + 1)
                                ;
                            // adjust all modules to use correct reference
                            $allModules = $firstModules.add($module).add($lastModules);
                        }
                    },

                    refresh: function() {
                        module.refreshSelectors();
                        module.refreshData();
                    },

                    refreshSelectors: function() {
                        module.verbose('Refreshing selector cache');
                        $text   = $module.find(selector.text);
                        $search = $module.find(selector.search);
                        $input  = $module.find(selector.input);
                        $icon   = $module.find(selector.icon);
                        $combo  = ($module.prev().find(selector.text).length > 0)
                            ? $module.prev().find(selector.text)
                            : $module.prev()
                        ;
                        $menu    = $module.children(selector.menu);
                        $item    = $menu.find(selector.item);
                    },

                    refreshData: function() {
                        module.verbose('Refreshing cached metadata');
                        $item
                            .removeData(metadata.text)
                            .removeData(metadata.value)
                        ;
                        $module
                            .removeData(metadata.defaultText)
                            .removeData(metadata.defaultValue)
                            .removeData(metadata.placeholderText)
                        ;
                    },

                    toggle: function() {
                        module.verbose('Toggling menu visibility');
                        if( !module.is.active() ) {
                            module.show();
                        }
                        else {
                            module.hide();
                        }
                    },

                    show: function(callback) {
                        callback = $.isFunction(callback)
                            ? callback
                            : function(){}
                        ;
                        if( module.can.show() && !module.is.active() ) {
                            module.debug('Showing dropdown');
                            if(module.is.multiple() && !module.has.search() && module.is.allFiltered()) {
                                return true;
                            }
                            if(module.has.message() && !(module.has.maxSelections() || module.has.allResultsFiltered()) ) {
                                module.remove.message();
                            }
                            if(settings.onShow.call(element) !== false) {
                                module.animate.show(function() {
                                    if( module.can.click() ) {
                                        module.bind.intent();
                                    }
                                    module.set.visible();
                                    callback.call(element);
                                });
                            }
                        }
                    },

                    hide: function(callback) {
                        callback = $.isFunction(callback)
                            ? callback
                            : function(){}
                        ;
                        if( module.is.active() ) {
                            module.debug('Hiding dropdown');

                            if(settings.onHide.call(element) !== false) {
                                module.animate.hide(function() {
                                    module.remove.visible();
                                    callback.call(element);
                                });
                            }
                        }
                    },

                    hideOthers: function() {
                        module.verbose('Finding other dropdowns to hide');
                        $allModules
                            .not($module)
                            .has(selector.menu + '.' + className.visible)
                            .dropdown('hide')
                        ;
                    },

                    hideMenu: function() {
                        module.verbose('Hiding menu  instantaneously');
                        module.remove.active();
                        module.remove.visible();
                        $menu.transition('hide');
                    },

                    hideSubMenus: function() {
                        var
                            $subMenus = $menu.children(selector.item).find(selector.menu)
                            ;
                        module.verbose('Hiding sub menus', $subMenus);
                        $subMenus.transition('hide');
                    },

                    bind: {
                        events: function() {
                            if(hasTouch) {
                                module.bind.touchEvents();
                            }
                            module.bind.keyboardEvents();
                            module.bind.inputEvents();
                            module.bind.mouseEvents();
                        },
                        touchEvents: function() {
                            module.debug('Touch device detected binding additional touch events');
                            if( module.is.searchSelection() ) {
                                // do nothing special yet
                            }
                            else if( module.is.single() ) {
                                $module
                                    .on('touchstart' + eventNamespace, module.event.test.toggle)
                                ;
                            }
                            $menu
                                .on('touchstart' + eventNamespace, selector.item, module.event.item.mouseenter)
                            ;
                        },
                        keyboardEvents: function() {
                            module.verbose('Binding keyboard events');
                            $module
                                .on('keydown' + eventNamespace, module.event.keydown)
                            ;
                            if( module.has.search() ) {
                                $module
                                    .on(module.get.inputEvent() + eventNamespace, selector.search, module.event.input)
                                ;
                            }
                            if( module.is.multiple() ) {
                                $document
                                    .on('keydown' + elementNamespace, module.event.document.keydown)
                                ;
                            }
                        },
                        inputEvents: function() {
                            module.verbose('Binding input change events');
                            $module
                                .on('change' + eventNamespace, selector.input, module.event.change)
                            ;
                        },
                        mouseEvents: function() {
                            module.verbose('Binding mouse events');
                            if(module.is.multiple()) {
                                $module
                                    .on('click'   + eventNamespace, selector.label,  module.event.label.click)
                                    .on('click'   + eventNamespace, selector.remove, module.event.remove.click)
                                ;
                            }
                            if( module.is.searchSelection() ) {
                                $module
                                    .on('mousedown' + eventNamespace, selector.menu,   module.event.menu.mousedown)
                                    .on('mouseup'   + eventNamespace, selector.menu,   module.event.menu.mouseup)
                                    .on('click'     + eventNamespace, selector.icon,   module.event.icon.click)
                                    .on('click'     + eventNamespace, selector.search, module.show)
                                    .on('focus'     + eventNamespace, selector.search, module.event.search.focus)
                                    .on('blur'      + eventNamespace, selector.search, module.event.search.blur)
                                    .on('click'     + eventNamespace, selector.text,   module.event.text.focus)
                                ;
                                if(module.is.multiple()) {
                                    $module
                                        .on('click' + eventNamespace, module.event.click)
                                    ;
                                }
                            }
                            else {
                                if(settings.on == 'click') {
                                    $module
                                        .on('click' + eventNamespace, selector.icon, module.event.icon.click)
                                        .on('click' + eventNamespace, module.event.test.toggle)
                                    ;
                                }
                                else if(settings.on == 'hover') {
                                    $module
                                        .on('mouseenter' + eventNamespace, module.delay.show)
                                        .on('mouseleave' + eventNamespace, module.delay.hide)
                                    ;
                                }
                                else {
                                    $module
                                        .on(settings.on + eventNamespace, module.toggle)
                                    ;
                                }
                                $module
                                    .on('mousedown' + eventNamespace, module.event.mousedown)
                                    .on('mouseup'   + eventNamespace, module.event.mouseup)
                                    .on('focus'     + eventNamespace, module.event.focus)
                                    .on('blur'      + eventNamespace, module.event.blur)
                                ;
                            }
                            $menu
                                .on('mouseenter' + eventNamespace, selector.item, module.event.item.mouseenter)
                                .on('mouseleave' + eventNamespace, selector.item, module.event.item.mouseleave)
                                .on('click'      + eventNamespace, selector.item, module.event.item.click)
                            ;
                        },
                        intent: function() {
                            module.verbose('Binding hide intent event to document');
                            if(hasTouch) {
                                $document
                                    .on('touchstart' + elementNamespace, module.event.test.touch)
                                    .on('touchmove'  + elementNamespace, module.event.test.touch)
                                ;
                            }
                            $document
                                .on('click' + elementNamespace, module.event.test.hide)
                            ;
                        }
                    },

                    unbind: {
                        intent: function() {
                            module.verbose('Removing hide intent event from document');
                            if(hasTouch) {
                                $document
                                    .off('touchstart' + elementNamespace)
                                    .off('touchmove' + elementNamespace)
                                ;
                            }
                            $document
                                .off('click' + elementNamespace)
                            ;
                        }
                    },

                    filter: function(query) {
                        var
                            searchTerm = (query !== undefined)
                                ? query
                                : module.get.query(),
                            afterFiltered = function() {
                                if(module.is.multiple()) {
                                    module.filterActive();
                                }
                                module.select.firstUnfiltered();
                                if( module.has.allResultsFiltered() ) {
                                    if( settings.onNoResults.call(element, searchTerm) ) {
                                        if(!settings.allowAdditions) {
                                            module.verbose('All items filtered, showing message', searchTerm);
                                            module.add.message(message.noResults);
                                        }
                                    }
                                    else {
                                        module.verbose('All items filtered, hiding dropdown', searchTerm);
                                        module.hideMenu();
                                    }
                                }
                                else {
                                    module.remove.message();
                                }
                                if(settings.allowAdditions) {
                                    module.add.userSuggestion(query);
                                }
                                if(module.is.searchSelection() && module.can.show() && module.is.focusedOnSearch() ) {
                                    module.show();
                                }
                            }
                            ;
                        if(settings.useLabels && module.has.maxSelections()) {
                            return;
                        }
                        if(settings.apiSettings) {
                            if( module.can.useAPI() ) {
                                module.queryRemote(searchTerm, function() {
                                    afterFiltered();
                                });
                            }
                            else {
                                module.error(error.noAPI);
                            }
                        }
                        else {
                            module.filterItems(searchTerm);
                            afterFiltered();
                        }
                    },

                    queryRemote: function(query, callback) {
                        var
                            apiSettings = {
                                errorDuration        : false,
                                throttle             : settings.throttle,
                                urlData              : {
                                    query: query
                                },
                                onError: function() {
                                    module.add.message(message.serverError);
                                    callback();
                                },
                                onFailure: function() {
                                    module.add.message(message.serverError);
                                    callback();
                                },
                                onSuccess : function(response) {
                                    module.remove.message();
                                    module.setup.menu({
                                        values: response[fields.remoteValues]
                                    });
                                    callback();
                                }
                            }
                            ;
                        if( !$module.api('get request') ) {
                            module.setup.api();
                        }
                        apiSettings = $.extend(true, {}, apiSettings, settings.apiSettings);
                        $module
                            .api('setting', apiSettings)
                            .api('query')
                        ;
                    },

                    filterItems: function(query) {
                        var
                            searchTerm = (query !== undefined)
                                ? query
                                : module.get.query(),
                            results          =  null,
                            escapedTerm      = module.escape.regExp(searchTerm),
                            beginsWithRegExp = new RegExp('^' + escapedTerm, 'igm')
                            ;
                        // avoid loop if we're matching nothing
                        if( module.has.query() ) {
                            results = [];

                            module.verbose('Searching for matching values', searchTerm);
                            $item
                                .each(function(){
                                    var
                                        $choice = $(this),
                                        text,
                                        value
                                        ;
                                    if(settings.match == 'both' || settings.match == 'text') {
                                        text = String(module.get.choiceText($choice, false));
                                        if(text.search(beginsWithRegExp) !== -1) {
                                            results.push(this);
                                            return true;
                                        }
                                        else if(settings.fullTextSearch && module.fuzzySearch(searchTerm, text)) {
                                            results.push(this);
                                            return true;
                                        }
                                    }
                                    if(settings.match == 'both' || settings.match == 'value') {
                                        value = String(module.get.choiceValue($choice, text));

                                        if(value.search(beginsWithRegExp) !== -1) {
                                            results.push(this);
                                            return true;
                                        }
                                        else if(settings.fullTextSearch && module.fuzzySearch(searchTerm, value)) {
                                            results.push(this);
                                            return true;
                                        }
                                    }
                                })
                            ;
                        }
                        module.debug('Showing only matched items', searchTerm);
                        module.remove.filteredItem();
                        if(results) {
                            $item
                                .not(results)
                                .addClass(className.filtered)
                            ;
                        }
                    },

                    fuzzySearch: function(query, term) {
                        var
                            termLength  = term.length,
                            queryLength = query.length
                            ;
                        query = query.toLowerCase();
                        term  = term.toLowerCase();
                        if(queryLength > termLength) {
                            return false;
                        }
                        if(queryLength === termLength) {
                            return (query === term);
                        }
                        search: for (var characterIndex = 0, nextCharacterIndex = 0; characterIndex < queryLength; characterIndex++) {
                            var
                                queryCharacter = query.charCodeAt(characterIndex)
                                ;
                            while(nextCharacterIndex < termLength) {
                                if(term.charCodeAt(nextCharacterIndex++) === queryCharacter) {
                                    continue search;
                                }
                            }
                            return false;
                        }
                        return true;
                    },

                    filterActive: function() {
                        if(settings.useLabels) {
                            $item.filter('.' + className.active)
                                .addClass(className.filtered)
                            ;
                        }
                    },

                    focusSearch: function() {
                        if( module.is.search() && !module.is.focusedOnSearch() ) {
                            $search[0].focus();
                        }
                    },

                    forceSelection: function() {
                        var
                            $currentlySelected = $item.not(className.filtered).filter('.' + className.selected).eq(0),
                            $activeItem        = $item.not(className.filtered).filter('.' + className.active).eq(0),
                            $selectedItem      = ($currentlySelected.length > 0)
                                ? $currentlySelected
                                : $activeItem,
                            hasSelected = ($selectedItem.size() > 0)
                            ;
                        if( module.has.query() ) {
                            if(hasSelected) {
                                module.debug('Forcing partial selection to selected item', $selectedItem);
                                module.event.item.click.call($selectedItem);
                                return;
                            }
                            else {
                                module.remove.searchTerm();
                            }
                        }
                        module.hide();
                    },

                    event: {
                        change: function() {
                            if(!internalChange) {
                                module.debug('Input changed, updating selection');
                                module.set.selected();
                            }
                        },
                        focus: function() {
                            if(settings.showOnFocus && !activated && module.is.hidden() && !pageLostFocus) {
                                module.show();
                            }
                        },
                        click: function(event) {
                            var
                                $target = $(event.target)
                                ;
                            // focus search
                            if($target.is($module) && !module.is.focusedOnSearch()) {
                                module.focusSearch();
                            }
                        },
                        blur: function(event) {
                            pageLostFocus = (document.activeElement === this);
                            if(!activated && !pageLostFocus) {
                                module.remove.activeLabel();
                                module.hide();
                            }
                        },
                        // prevents focus callback from occurring on mousedown
                        mousedown: function() {
                            activated = true;
                        },
                        mouseup: function() {
                            activated = false;
                        },
                        search: {
                            focus: function() {
                                activated = true;
                                if(module.is.multiple()) {
                                    module.remove.activeLabel();
                                }
                                if(settings.showOnFocus) {
                                    module.search();
                                    module.show();
                                }
                            },
                            blur: function(event) {
                                pageLostFocus = (document.activeElement === this);
                                if(!itemActivated && !pageLostFocus) {
                                    if(module.is.multiple()) {
                                        module.remove.activeLabel();
                                        module.hide();
                                    }
                                    else if(settings.forceSelection) {
                                        module.forceSelection();
                                    }
                                    else {
                                        module.hide();
                                    }
                                }
                                else if(pageLostFocus) {
                                    if(settings.forceSelection) {
                                        module.forceSelection();
                                    }
                                }
                            }
                        },
                        icon: {
                            click: function(event) {
                                module.toggle();
                                event.stopPropagation();
                            }
                        },
                        text: {
                            focus: function(event) {
                                activated = true;
                                module.focusSearch();
                            }
                        },
                        input: function(event) {
                            if(module.is.multiple() || module.is.searchSelection()) {
                                module.set.filtered();
                            }
                            clearTimeout(module.timer);
                            module.timer = setTimeout(module.search, settings.delay.search);
                        },
                        label: {
                            click: function(event) {
                                var
                                    $label        = $(this),
                                    $labels       = $module.find(selector.label),
                                    $activeLabels = $labels.filter('.' + className.active),
                                    $nextActive   = $label.nextAll('.' + className.active),
                                    $prevActive   = $label.prevAll('.' + className.active),
                                    $range = ($nextActive.length > 0)
                                        ? $label.nextUntil($nextActive).add($activeLabels).add($label)
                                        : $label.prevUntil($prevActive).add($activeLabels).add($label)
                                    ;
                                if(event.shiftKey) {
                                    $activeLabels.removeClass(className.active);
                                    $range.addClass(className.active);
                                }
                                else if(event.ctrlKey) {
                                    $label.toggleClass(className.active);
                                }
                                else {
                                    $activeLabels.removeClass(className.active);
                                    $label.addClass(className.active);
                                }
                                settings.onLabelSelect.apply(this, $labels.filter('.' + className.active));
                            }
                        },
                        remove: {
                            click: function() {
                                var
                                    $label = $(this).parent()
                                    ;
                                if( $label.hasClass(className.active) ) {
                                    // remove all selected labels
                                    module.remove.activeLabels();
                                }
                                else {
                                    // remove this label only
                                    module.remove.activeLabels( $label );
                                }
                            }
                        },
                        test: {
                            toggle: function(event) {
                                var
                                    toggleBehavior = (module.is.multiple())
                                        ? module.show
                                        : module.toggle
                                    ;
                                if( module.determine.eventOnElement(event, toggleBehavior) ) {
                                    event.preventDefault();
                                }
                            },
                            touch: function(event) {
                                module.determine.eventOnElement(event, function() {
                                    if(event.type == 'touchstart') {
                                        module.timer = setTimeout(function() {
                                            module.hide();
                                        }, settings.delay.touch);
                                    }
                                    else if(event.type == 'touchmove') {
                                        clearTimeout(module.timer);
                                    }
                                });
                                event.stopPropagation();
                            },
                            hide: function(event) {
                                module.determine.eventInModule(event, module.hide);
                            }
                        },
                        menu: {
                            mousedown: function() {
                                itemActivated = true;
                            },
                            mouseup: function() {
                                itemActivated = false;
                            }
                        },
                        item: {
                            mouseenter: function(event) {
                                var
                                    $subMenu    = $(this).children(selector.menu),
                                    $otherMenus = $(this).siblings(selector.item).children(selector.menu)
                                    ;
                                if( $subMenu.length > 0 ) {
                                    clearTimeout(module.itemTimer);
                                    module.itemTimer = setTimeout(function() {
                                        module.verbose('Showing sub-menu', $subMenu);
                                        $.each($otherMenus, function() {
                                            module.animate.hide(false, $(this));
                                        });
                                        module.animate.show(false,  $subMenu);
                                    }, settings.delay.show);
                                    event.preventDefault();
                                }
                            },
                            mouseleave: function(event) {
                                var
                                    $subMenu = $(this).children(selector.menu)
                                    ;
                                if($subMenu.length > 0) {
                                    clearTimeout(module.itemTimer);
                                    module.itemTimer = setTimeout(function() {
                                        module.verbose('Hiding sub-menu', $subMenu);
                                        module.animate.hide(false,  $subMenu);
                                    }, settings.delay.hide);
                                }
                            },
                            touchend: function() {
                            },
                            click: function (event) {
                                var
                                    $choice        = $(this),
                                    $target        = (event)
                                        ? $(event.target)
                                        : $(''),
                                    $subMenu       = $choice.find(selector.menu),
                                    text           = module.get.choiceText($choice),
                                    value          = module.get.choiceValue($choice, text),
                                    hasSubMenu     = ($subMenu.length > 0),
                                    isBubbledEvent = ($subMenu.find($target).length > 0)
                                    ;
                                if(!isBubbledEvent && (!hasSubMenu || settings.allowCategorySelection)) {
                                    if(!settings.useLabels) {
                                        module.remove.filteredItem();
                                        module.remove.searchTerm();
                                        module.set.scrollPosition($choice);
                                    }
                                    module.determine.selectAction.call(this, text, value);
                                }
                            }
                        },

                        document: {
                            // label selection should occur even when element has no focus
                            keydown: function(event) {
                                var
                                    pressedKey    = event.which,
                                    isShortcutKey = module.is.inObject(pressedKey, keys)
                                    ;
                                if(isShortcutKey) {
                                    var
                                        $label            = $module.find(selector.label),
                                        $activeLabel      = $label.filter('.' + className.active),
                                        activeValue       = $activeLabel.data(metadata.value),
                                        labelIndex        = $label.index($activeLabel),
                                        labelCount        = $label.length,
                                        hasActiveLabel    = ($activeLabel.length > 0),
                                        hasMultipleActive = ($activeLabel.length > 1),
                                        isFirstLabel      = (labelIndex === 0),
                                        isLastLabel       = (labelIndex + 1 == labelCount),
                                        isSearch          = module.is.searchSelection(),
                                        isFocusedOnSearch = module.is.focusedOnSearch(),
                                        isFocused         = module.is.focused(),
                                        caretAtStart      = (isFocusedOnSearch && module.get.caretPosition() === 0),
                                        $nextLabel
                                        ;
                                    if(isSearch && !hasActiveLabel && !isFocusedOnSearch) {
                                        return;
                                    }

                                    if(pressedKey == keys.leftArrow) {
                                        // activate previous label
                                        if((isFocused || caretAtStart) && !hasActiveLabel) {
                                            module.verbose('Selecting previous label');
                                            $label.last().addClass(className.active);
                                        }
                                        else if(hasActiveLabel) {
                                            if(!event.shiftKey) {
                                                module.verbose('Selecting previous label');
                                                $label.removeClass(className.active);
                                            }
                                            else {
                                                module.verbose('Adding previous label to selection');
                                            }
                                            if(isFirstLabel && !hasMultipleActive) {
                                                $activeLabel.addClass(className.active);
                                            }
                                            else {
                                                $activeLabel.prev(selector.siblingLabel)
                                                    .addClass(className.active)
                                                    .end()
                                                ;
                                            }
                                            event.preventDefault();
                                        }
                                    }
                                    else if(pressedKey == keys.rightArrow) {
                                        // activate first label
                                        if(isFocused && !hasActiveLabel) {
                                            $label.first().addClass(className.active);
                                        }
                                        // activate next label
                                        if(hasActiveLabel) {
                                            if(!event.shiftKey) {
                                                module.verbose('Selecting next label');
                                                $label.removeClass(className.active);
                                            }
                                            else {
                                                module.verbose('Adding next label to selection');
                                            }
                                            if(isLastLabel) {
                                                if(isSearch) {
                                                    if(!isFocusedOnSearch) {
                                                        module.focusSearch();
                                                    }
                                                    else {
                                                        $label.removeClass(className.active);
                                                    }
                                                }
                                                else if(hasMultipleActive) {
                                                    $activeLabel.next(selector.siblingLabel).addClass(className.active);
                                                }
                                                else {
                                                    $activeLabel.addClass(className.active);
                                                }
                                            }
                                            else {
                                                $activeLabel.next(selector.siblingLabel).addClass(className.active);
                                            }
                                            event.preventDefault();
                                        }
                                    }
                                    else if(pressedKey == keys.deleteKey || pressedKey == keys.backspace) {
                                        if(hasActiveLabel) {
                                            module.verbose('Removing active labels');
                                            if(isLastLabel) {
                                                if(isSearch && !isFocusedOnSearch) {
                                                    module.focusSearch();
                                                }
                                            }
                                            $activeLabel.last().next(selector.siblingLabel).addClass(className.active);
                                            module.remove.activeLabels($activeLabel);
                                            event.preventDefault();
                                        }
                                        else if(caretAtStart && !hasActiveLabel && pressedKey == keys.backspace) {
                                            module.verbose('Removing last label on input backspace');
                                            $activeLabel = $label.last().addClass(className.active);
                                            module.remove.activeLabels($activeLabel);
                                        }
                                    }
                                    else {
                                        $activeLabel.removeClass(className.active);
                                    }
                                }
                            }
                        },

                        keydown: function(event) {
                            var
                                pressedKey    = event.which,
                                isShortcutKey = module.is.inObject(pressedKey, keys)
                                ;
                            if(isShortcutKey) {
                                var
                                    $currentlySelected = $item.not(selector.unselectable).filter('.' + className.selected).eq(0),
                                    $activeItem        = $menu.children('.' + className.active).eq(0),
                                    $selectedItem      = ($currentlySelected.length > 0)
                                        ? $currentlySelected
                                        : $activeItem,
                                    $visibleItems = ($selectedItem.length > 0)
                                        ? $selectedItem.siblings(':not(.' + className.filtered +')').andSelf()
                                        : $menu.children(':not(.' + className.filtered +')'),
                                    $subMenu             = $selectedItem.children(selector.menu),
                                    $parentMenu          = $selectedItem.closest(selector.menu),
                                    inVisibleMenu        = ($parentMenu.hasClass(className.visible) || $parentMenu.hasClass(className.animating) || $parentMenu.parent(selector.menu).length > 0),
                                    hasSubMenu           = ($subMenu.length> 0),
                                    hasSelectedItem      = ($selectedItem.length > 0),
                                    selectedIsSelectable = ($selectedItem.not(selector.unselectable).length > 0),
                                    delimiterPressed     = (pressedKey == keys.delimiter && settings.allowAdditions && module.is.multiple()),
                                    $nextItem,
                                    isSubMenuItem,
                                    newIndex
                                    ;
                                // visible menu keyboard shortcuts
                                if( module.is.visible() ) {

                                    // enter (select or open sub-menu)
                                    if(pressedKey == keys.enter || delimiterPressed) {
                                        if(pressedKey == keys.enter && hasSelectedItem && hasSubMenu && !settings.allowCategorySelection) {
                                            module.verbose('Pressed enter on unselectable category, opening sub menu');
                                            pressedKey = keys.rightArrow;
                                        }
                                        else if(selectedIsSelectable) {
                                            module.verbose('Selecting item from keyboard shortcut', $selectedItem);
                                            module.event.item.click.call($selectedItem, event);
                                            if(module.is.searchSelection()) {
                                                module.remove.searchTerm();
                                            }
                                        }
                                        event.preventDefault();
                                    }

                                    // left arrow (hide sub-menu)
                                    if(pressedKey == keys.leftArrow) {

                                        isSubMenuItem = ($parentMenu[0] !== $menu[0]);

                                        if(isSubMenuItem) {
                                            module.verbose('Left key pressed, closing sub-menu');
                                            module.animate.hide(false,  $parentMenu);
                                            $selectedItem
                                                .removeClass(className.selected)
                                            ;
                                            $parentMenu
                                                .closest(selector.item)
                                                .addClass(className.selected)
                                            ;
                                            event.preventDefault();
                                        }
                                    }

                                    // right arrow (show sub-menu)
                                    if(pressedKey == keys.rightArrow) {
                                        if(hasSubMenu) {
                                            module.verbose('Right key pressed, opening sub-menu');
                                            module.animate.show(false,  $subMenu);
                                            $selectedItem
                                                .removeClass(className.selected)
                                            ;
                                            $subMenu
                                                .find(selector.item).eq(0)
                                                .addClass(className.selected)
                                            ;
                                            event.preventDefault();
                                        }
                                    }

                                    // up arrow (traverse menu up)
                                    if(pressedKey == keys.upArrow) {
                                        $nextItem = (hasSelectedItem && inVisibleMenu)
                                            ? $selectedItem.prevAll(selector.item + ':not(' + selector.unselectable + ')').eq(0)
                                            : $item.eq(0)
                                        ;
                                        if($visibleItems.index( $nextItem ) < 0) {
                                            module.verbose('Up key pressed but reached top of current menu');
                                            event.preventDefault();
                                            return;
                                        }
                                        else {
                                            module.verbose('Up key pressed, changing active item');
                                            $selectedItem
                                                .removeClass(className.selected)
                                            ;
                                            $nextItem
                                                .addClass(className.selected)
                                            ;
                                            module.set.scrollPosition($nextItem);
                                        }
                                        event.preventDefault();
                                    }

                                    // down arrow (traverse menu down)
                                    if(pressedKey == keys.downArrow) {
                                        $nextItem = (hasSelectedItem && inVisibleMenu)
                                            ? $nextItem = $selectedItem.nextAll(selector.item + ':not(' + selector.unselectable + ')').eq(0)
                                            : $item.eq(0)
                                        ;
                                        if($nextItem.length === 0) {
                                            module.verbose('Down key pressed but reached bottom of current menu');
                                            event.preventDefault();
                                            return;
                                        }
                                        else {
                                            module.verbose('Down key pressed, changing active item');
                                            $item
                                                .removeClass(className.selected)
                                            ;
                                            $nextItem
                                                .addClass(className.selected)
                                            ;
                                            module.set.scrollPosition($nextItem);
                                        }
                                        event.preventDefault();
                                    }

                                    // page down (show next page)
                                    if(pressedKey == keys.pageUp) {
                                        module.scrollPage('up');
                                        event.preventDefault();
                                    }
                                    if(pressedKey == keys.pageDown) {
                                        module.scrollPage('down');
                                        event.preventDefault();
                                    }

                                    // escape (close menu)
                                    if(pressedKey == keys.escape) {
                                        module.verbose('Escape key pressed, closing dropdown');
                                        module.hide();
                                    }

                                }
                                else {
                                    // delimiter key
                                    if(delimiterPressed) {
                                        event.preventDefault();
                                    }
                                    // down arrow (open menu)
                                    if(pressedKey == keys.downArrow) {
                                        module.verbose('Down key pressed, showing dropdown');
                                        module.show();
                                        event.preventDefault();
                                    }
                                }
                            }
                            else {
                                if( module.is.selection() && !module.is.search() ) {
                                    module.set.selectedLetter( String.fromCharCode(pressedKey) );
                                }
                            }
                        }
                    },

                    trigger: {
                        change: function() {
                            var
                                events       = document.createEvent('HTMLEvents'),
                                inputElement = $input[0]
                                ;
                            if(inputElement) {
                                module.verbose('Triggering native change event');
                                events.initEvent('change', true, false);
                                inputElement.dispatchEvent(events);
                            }
                        }
                    },

                    determine: {
                        selectAction: function(text, value) {
                            module.verbose('Determining action', settings.action);
                            if( $.isFunction( module.action[settings.action] ) ) {
                                module.verbose('Triggering preset action', settings.action, text, value);
                                module.action[ settings.action ].call(this, text, value);
                            }
                            else if( $.isFunction(settings.action) ) {
                                module.verbose('Triggering user action', settings.action, text, value);
                                settings.action.call(this, text, value);
                            }
                            else {
                                module.error(error.action, settings.action);
                            }
                        },
                        eventInModule: function(event, callback) {
                            var
                                $target    = $(event.target),
                                inDocument = ($target.closest(document.documentElement).length > 0),
                                inModule   = ($target.closest($module).length > 0)
                                ;
                            callback = $.isFunction(callback)
                                ? callback
                                : function(){}
                            ;
                            if(inDocument && !inModule) {
                                module.verbose('Triggering event', callback);
                                callback();
                                return true;
                            }
                            else {
                                module.verbose('Event occurred in dropdown, canceling callback');
                                return false;
                            }
                        },
                        eventOnElement: function(event, callback) {
                            var
                                $target    = $(event.target),
                                $label     = $target.closest(selector.siblingLabel),
                                notOnLabel = ($module.find($label).length === 0),
                                notInMenu  = ($target.closest($menu).length === 0)
                                ;
                            callback = $.isFunction(callback)
                                ? callback
                                : function(){}
                            ;
                            if(notOnLabel && notInMenu) {
                                module.verbose('Triggering event', callback);
                                callback();
                                return true;
                            }
                            else {
                                module.verbose('Event occurred in dropdown menu, canceling callback');
                                return false;
                            }
                        }
                    },

                    action: {

                        nothing: function() {},

                        activate: function(text, value) {
                            value = (value !== undefined)
                                ? value
                                : text
                            ;
                            if( module.can.activate( $(this) ) ) {
                                module.set.selected(value, $(this));
                                if(module.is.multiple() && !module.is.allFiltered()) {
                                    return;
                                }
                                else {
                                    module.hideAndClear();
                                }
                            }
                        },

                        select: function(text, value) {
                            // mimics action.activate but does not select text
                            module.action.activate.call(this);
                        },

                        combo: function(text, value) {
                            value = (value !== undefined)
                                ? value
                                : text
                            ;
                            module.set.selected(value, $(this));
                            module.hideAndClear();
                        },

                        hide: function(text, value) {
                            module.set.value(value);
                            module.hideAndClear();
                        }

                    },

                    get: {
                        id: function() {
                            return id;
                        },
                        defaultText: function() {
                            return $module.data(metadata.defaultText);
                        },
                        defaultValue: function() {
                            return $module.data(metadata.defaultValue);
                        },
                        placeholderText: function() {
                            return $module.data(metadata.placeholderText) || '';
                        },
                        text: function() {
                            return $text.text();
                        },
                        query: function() {
                            return $.trim($search.val());
                        },
                        searchWidth: function(characterCount) {
                            return (characterCount * settings.glyphWidth) + 'em';
                        },
                        selectionCount: function() {
                            var
                                values = module.get.values(),
                                count
                                ;
                            count = ( module.is.multiple() )
                                ? $.isArray(values)
                                ? values.length
                                : 0
                                : (module.get.value() !== '')
                                ? 1
                                : 0
                            ;
                            return count;
                        },
                        transition: function($subMenu) {
                            return (settings.transition == 'auto')
                                ? module.is.upward($subMenu)
                                ? 'slide up'
                                : 'slide down'
                                : settings.transition
                                ;
                        },
                        userValues: function() {
                            var
                                values = module.get.values()
                                ;
                            if(!values) {
                                return false;
                            }
                            values = $.isArray(values)
                                ? values
                                : [values]
                            ;
                            return $.grep(values, function(value) {
                                return (module.get.item(value) === false);
                            });
                        },
                        uniqueArray: function(array) {
                            return $.grep(array, function (value, index) {
                                return $.inArray(value, array) === index;
                            });
                        },
                        caretPosition: function() {
                            var
                                input = $search.get(0),
                                range,
                                rangeLength
                                ;
                            if('selectionStart' in input) {
                                return input.selectionStart;
                            }
                            else if (document.selection) {
                                input.focus();
                                range       = document.selection.createRange();
                                rangeLength = range.text.length;
                                range.moveStart('character', -input.value.length);
                                return range.text.length - rangeLength;
                            }
                        },
                        value: function() {
                            var
                                value = ($input.length > 0)
                                    ? $input.val()
                                    : $module.data(metadata.value)
                                ;
                            // prevents placeholder element from being selected when multiple
                            if($.isArray(value) && value.length === 1 && value[0] === '') {
                                return '';
                            }
                            return value;
                        },
                        values: function() {
                            var
                                value = module.get.value()
                                ;
                            if(value === '') {
                                return '';
                            }
                            return ( !module.has.selectInput() && module.is.multiple() )
                                ? (typeof value == 'string') // delimited string
                                ? value.split(settings.delimiter)
                                : ''
                                : value
                                ;
                        },
                        remoteValues: function() {
                            var
                                values = module.get.values(),
                                remoteValues = false
                                ;
                            if(values) {
                                if(typeof values == 'string') {
                                    values = [values];
                                }
                                remoteValues = {};
                                $.each(values, function(index, value) {
                                    var
                                        name = module.read.remoteData(value)
                                        ;
                                    module.verbose('Restoring value from session data', name, value);
                                    remoteValues[value] = (name)
                                        ? name
                                        : value
                                    ;
                                });
                            }
                            return remoteValues;
                        },
                        choiceText: function($choice, preserveHTML) {
                            preserveHTML = (preserveHTML !== undefined)
                                ? preserveHTML
                                : settings.preserveHTML
                            ;
                            if($choice) {
                                if($choice.find(selector.menu).length > 0) {
                                    module.verbose('Retreiving text of element with sub-menu');
                                    $choice = $choice.clone();
                                    $choice.find(selector.menu).remove();
                                    $choice.find(selector.menuIcon).remove();
                                }
                                return ($choice.data(metadata.text) !== undefined)
                                    ? $choice.data(metadata.text)
                                    : (preserveHTML)
                                    ? $.trim($choice.html())
                                    : $.trim($choice.text())
                                    ;
                            }
                        },
                        choiceValue: function($choice, choiceText) {
                            choiceText = choiceText || module.get.choiceText($choice);
                            if(!$choice) {
                                return false;
                            }
                            return ($choice.data(metadata.value) !== undefined)
                                ? String( $choice.data(metadata.value) )
                                : (typeof choiceText === 'string')
                                ? $.trim(choiceText.toLowerCase())
                                : String(choiceText)
                                ;
                        },
                        inputEvent: function() {
                            var
                                input = $search[0]
                                ;
                            if(input) {
                                return (input.oninput !== undefined)
                                    ? 'input'
                                    : (input.onpropertychange !== undefined)
                                    ? 'propertychange'
                                    : 'keyup'
                                    ;
                            }
                            return false;
                        },
                        selectValues: function() {
                            var
                                select = {}
                                ;
                            select.values = [];
                            $module
                                .find('option')
                                .each(function() {
                                    var
                                        $option  = $(this),
                                        name     = $option.html(),
                                        disabled = $option.attr('disabled'),
                                        value    = ( $option.attr('value') !== undefined )
                                            ? $option.attr('value')
                                            : name
                                        ;
                                    if(settings.placeholder === 'auto' && value === '') {
                                        select.placeholder = name;
                                    }
                                    else {
                                        select.values.push({
                                            name     : name,
                                            value    : value,
                                            disabled : disabled
                                        });
                                    }
                                })
                            ;
                            if(settings.placeholder && settings.placeholder !== 'auto') {
                                module.debug('Setting placeholder value to', settings.placeholder);
                                select.placeholder = settings.placeholder;
                            }
                            if(settings.sortSelect) {
                                select.values.sort(function(a, b) {
                                    return (a.name > b.name)
                                        ? 1
                                        : -1
                                        ;
                                });
                                module.debug('Retrieved and sorted values from select', select);
                            }
                            else {
                                module.debug('Retreived values from select', select);
                            }
                            return select;
                        },
                        activeItem: function() {
                            return $item.filter('.'  + className.active);
                        },
                        selectedItem: function() {
                            var
                                $selectedItem = $item.not(selector.unselectable).filter('.'  + className.selected)
                                ;
                            return ($selectedItem.length > 0)
                                ? $selectedItem
                                : $item.eq(0)
                                ;
                        },
                        itemWithAdditions: function(value) {
                            var
                                $items       = module.get.item(value),
                                $userItems   = module.create.userChoice(value),
                                hasUserItems = ($userItems && $userItems.length > 0)
                                ;
                            if(hasUserItems) {
                                $items = ($items.length > 0)
                                    ? $items.add($userItems)
                                    : $userItems
                                ;
                            }
                            return $items;
                        },
                        item: function(value, strict) {
                            var
                                $selectedItem = false,
                                shouldSearch,
                                isMultiple
                                ;
                            value = (value !== undefined)
                                ? value
                                : ( module.get.values() !== undefined)
                                ? module.get.values()
                                : module.get.text()
                            ;
                            shouldSearch = (isMultiple)
                                ? (value.length > 0)
                                : (value !== undefined && value !== null)
                            ;
                            isMultiple = (module.is.multiple() && $.isArray(value));
                            strict     = (value === '' || value === 0)
                                ? true
                                : strict || false
                            ;
                            if(shouldSearch) {
                                $item
                                    .each(function() {
                                        var
                                            $choice       = $(this),
                                            optionText    = module.get.choiceText($choice),
                                            optionValue   = module.get.choiceValue($choice, optionText)
                                            ;
                                        // safe early exit
                                        if(optionValue === null || optionValue === undefined) {
                                            return;
                                        }
                                        if(isMultiple) {
                                            if($.inArray( String(optionValue), value) !== -1 || $.inArray(optionText, value) !== -1) {
                                                $selectedItem = ($selectedItem)
                                                    ? $selectedItem.add($choice)
                                                    : $choice
                                                ;
                                            }
                                        }
                                        else if(strict) {
                                            module.verbose('Ambiguous dropdown value using strict type check', $choice, value);
                                            if( optionValue === value || optionText === value) {
                                                $selectedItem = $choice;
                                                return true;
                                            }
                                        }
                                        else {
                                            if( String(optionValue) == String(value) || optionText == value) {
                                                module.verbose('Found select item by value', optionValue, value);
                                                $selectedItem = $choice;
                                                return true;
                                            }
                                        }
                                    })
                                ;
                            }
                            return $selectedItem;
                        }
                    },

                    check: {
                        maxSelections: function(selectionCount) {
                            if(settings.maxSelections) {
                                selectionCount = (selectionCount !== undefined)
                                    ? selectionCount
                                    : module.get.selectionCount()
                                ;
                                if(selectionCount >= settings.maxSelections) {
                                    module.debug('Maximum selection count reached');
                                    if(settings.useLabels) {
                                        $item.addClass(className.filtered);
                                        module.add.message(message.maxSelections);
                                    }
                                    return true;
                                }
                                else {
                                    module.verbose('No longer at maximum selection count');
                                    module.remove.message();
                                    module.remove.filteredItem();
                                    if(module.is.searchSelection()) {
                                        module.filterItems();
                                    }
                                    return false;
                                }
                            }
                            return true;
                        }
                    },

                    restore: {
                        defaults: function() {
                            module.clear();
                            module.restore.defaultText();
                            module.restore.defaultValue();
                        },
                        defaultText: function() {
                            var
                                defaultText     = module.get.defaultText(),
                                placeholderText = module.get.placeholderText
                                ;
                            if(defaultText === placeholderText) {
                                module.debug('Restoring default placeholder text', defaultText);
                                module.set.placeholderText(defaultText);
                            }
                            else {
                                module.debug('Restoring default text', defaultText);
                                module.set.text(defaultText);
                            }
                        },
                        defaultValue: function() {
                            var
                                defaultValue = module.get.defaultValue()
                                ;
                            if(defaultValue !== undefined) {
                                module.debug('Restoring default value', defaultValue);
                                if(defaultValue !== '') {
                                    module.set.value(defaultValue);
                                    module.set.selected();
                                }
                                else {
                                    module.remove.activeItem();
                                    module.remove.selectedItem();
                                }
                            }
                        },
                        labels: function() {
                            if(settings.allowAdditions) {
                                if(!settings.useLabels) {
                                    module.error(error.labels);
                                    settings.useLabels = true;
                                }
                                module.debug('Restoring selected values');
                                module.create.userLabels();
                            }
                            module.check.maxSelections();
                        },
                        selected: function() {
                            module.restore.values();
                            if(module.is.multiple()) {
                                module.debug('Restoring previously selected values and labels');
                                module.restore.labels();
                            }
                            else {
                                module.debug('Restoring previously selected values');
                            }
                        },
                        values: function() {
                            // prevents callbacks from occuring on initial load
                            module.set.initialLoad();
                            if(settings.apiSettings) {
                                if(settings.saveRemoteData) {
                                    module.restore.remoteValues();
                                }
                                else {
                                    module.clearValue();
                                }
                            }
                            else {
                                module.set.selected();
                            }
                            module.remove.initialLoad();
                        },
                        remoteValues: function() {
                            var
                                values = module.get.remoteValues()
                                ;
                            module.debug('Recreating selected from session data', values);
                            if(values) {
                                if( module.is.single() ) {
                                    $.each(values, function(value, name) {
                                        module.set.text(name);
                                    });
                                }
                                else {
                                    $.each(values, function(value, name) {
                                        module.add.label(value, name);
                                    });
                                }
                            }
                        }
                    },

                    read: {
                        remoteData: function(value) {
                            var
                                name
                                ;
                            if(window.Storage === undefined) {
                                module.error(error.noStorage);
                                return;
                            }
                            name = sessionStorage.getItem(value);
                            return (name !== undefined)
                                ? name
                                : false
                                ;
                        }
                    },

                    save: {
                        defaults: function() {
                            module.save.defaultText();
                            module.save.placeholderText();
                            module.save.defaultValue();
                        },
                        defaultValue: function() {
                            var
                                value = module.get.value()
                                ;
                            module.verbose('Saving default value as', value);
                            $module.data(metadata.defaultValue, value);
                        },
                        defaultText: function() {
                            var
                                text = module.get.text()
                                ;
                            module.verbose('Saving default text as', text);
                            $module.data(metadata.defaultText, text);
                        },
                        placeholderText: function() {
                            var
                                text
                                ;
                            if(settings.placeholder !== false && $text.hasClass(className.placeholder)) {
                                text = module.get.text();
                                module.verbose('Saving placeholder text as', text);
                                $module.data(metadata.placeholderText, text);
                            }
                        },
                        remoteData: function(name, value) {
                            if(window.Storage === undefined) {
                                module.error(error.noStorage);
                                return;
                            }
                            module.verbose('Saving remote data to session storage', value, name);
                            sessionStorage.setItem(value, name);
                        }
                    },

                    clear: function() {
                        if(module.is.multiple()) {
                            module.remove.labels();
                        }
                        else {
                            module.remove.activeItem();
                            module.remove.selectedItem();
                        }
                        module.set.placeholderText();
                        module.clearValue();
                    },

                    clearValue: function() {
                        module.set.value('');
                    },

                    scrollPage: function(direction, $selectedItem) {
                        var
                            $currentItem  = $selectedItem || module.get.selectedItem(),
                            $menu         = $currentItem.closest(selector.menu),
                            menuHeight    = $menu.outerHeight(),
                            currentScroll = $menu.scrollTop(),
                            itemHeight    = $item.eq(0).outerHeight(),
                            itemsPerPage  = Math.floor(menuHeight / itemHeight),
                            maxScroll     = $menu.prop('scrollHeight'),
                            newScroll     = (direction == 'up')
                                ? currentScroll - (itemHeight * itemsPerPage)
                                : currentScroll + (itemHeight * itemsPerPage),
                            $selectableItem = $item.not(selector.unselectable),
                            isWithinRange,
                            $nextSelectedItem,
                            elementIndex
                            ;
                        elementIndex      = (direction == 'up')
                            ? $selectableItem.index($currentItem) - itemsPerPage
                            : $selectableItem.index($currentItem) + itemsPerPage
                        ;
                        isWithinRange = (direction == 'up')
                            ? (elementIndex >= 0)
                            : (elementIndex < $selectableItem.length)
                        ;
                        $nextSelectedItem = (isWithinRange)
                            ? $selectableItem.eq(elementIndex)
                            : (direction == 'up')
                            ? $selectableItem.first()
                            : $selectableItem.last()
                        ;
                        if($nextSelectedItem.length > 0) {
                            module.debug('Scrolling page', direction, $nextSelectedItem);
                            $currentItem
                                .removeClass(className.selected)
                            ;
                            $nextSelectedItem
                                .addClass(className.selected)
                            ;
                            $menu
                                .scrollTop(newScroll)
                            ;
                        }
                    },

                    set: {
                        filtered: function() {
                            var
                                isMultiple       = module.is.multiple(),
                                isSearch         = module.is.searchSelection(),
                                isSearchMultiple = (isMultiple && isSearch),
                                searchValue      = (isSearch)
                                    ? module.get.query()
                                    : '',
                                hasSearchValue   = (typeof searchValue === 'string' && searchValue.length > 0),
                                searchWidth      = module.get.searchWidth(searchValue.length),
                                valueIsSet       = searchValue !== ''
                                ;
                            if(isMultiple && hasSearchValue) {
                                module.verbose('Adjusting input width', searchWidth, settings.glyphWidth);
                                $search.css('width', searchWidth);
                            }
                            if(hasSearchValue || (isSearchMultiple && valueIsSet)) {
                                module.verbose('Hiding placeholder text');
                                $text.addClass(className.filtered);
                            }
                            else if(!isMultiple || (isSearchMultiple && !valueIsSet)) {
                                module.verbose('Showing placeholder text');
                                $text.removeClass(className.filtered);
                            }
                        },
                        loading: function() {
                            $module.addClass(className.loading);
                        },
                        placeholderText: function(text) {
                            text = text || module.get.placeholderText();
                            module.debug('Setting placeholder text', text);
                            module.set.text(text);
                            $text.addClass(className.placeholder);
                        },
                        tabbable: function() {
                            if( module.has.search() ) {
                                module.debug('Added tabindex to searchable dropdown');
                                $search
                                    .val('')
                                    .attr('tabindex', 0)
                                ;
                                $menu
                                    .attr('tabindex', -1)
                                ;
                            }
                            else {
                                module.debug('Added tabindex to dropdown');
                                if( $module.attr('tabindex') === undefined) {
                                    $module
                                        .attr('tabindex', 0)
                                    ;
                                    $menu
                                        .attr('tabindex', -1)
                                    ;
                                }
                            }
                        },
                        initialLoad: function() {
                            module.verbose('Setting initial load');
                            initialLoad = true;
                        },
                        activeItem: function($item) {
                            if( settings.allowAdditions && $item.filter(selector.addition).length > 0 ) {
                                $item.addClass(className.filtered);
                            }
                            else {
                                $item.addClass(className.active);
                            }
                        },
                        scrollPosition: function($item, forceScroll) {
                            var
                                edgeTolerance = 5,
                                $menu,
                                hasActive,
                                offset,
                                itemHeight,
                                itemOffset,
                                menuOffset,
                                menuScroll,
                                menuHeight,
                                abovePage,
                                belowPage
                                ;

                            $item       = $item || module.get.selectedItem();
                            $menu       = $item.closest(selector.menu);
                            hasActive   = ($item && $item.length > 0);
                            forceScroll = (forceScroll !== undefined)
                                ? forceScroll
                                : false
                            ;
                            if($item && $menu.length > 0 && hasActive) {
                                itemOffset = $item.position().top;

                                $menu.addClass(className.loading);
                                menuScroll = $menu.scrollTop();
                                menuOffset = $menu.offset().top;
                                itemOffset = $item.offset().top;
                                offset     = menuScroll - menuOffset + itemOffset;
                                if(!forceScroll) {
                                    menuHeight = $menu.height();
                                    belowPage  = menuScroll + menuHeight < (offset + edgeTolerance);
                                    abovePage  = ((offset - edgeTolerance) < menuScroll);
                                }
                                module.debug('Scrolling to active item', offset);
                                if(forceScroll || abovePage || belowPage) {
                                    $menu.scrollTop(offset);
                                }
                                $menu.removeClass(className.loading);
                            }
                        },
                        text: function(text) {
                            if(settings.action !== 'select') {
                                if(settings.action == 'combo') {
                                    module.debug('Changing combo button text', text, $combo);
                                    if(settings.preserveHTML) {
                                        $combo.html(text);
                                    }
                                    else {
                                        $combo.text(text);
                                    }
                                }
                                else {
                                    if(text !== module.get.placeholderText()) {
                                        $text.removeClass(className.placeholder);
                                    }
                                    module.debug('Changing text', text, $text);
                                    $text
                                        .removeClass(className.filtered)
                                    ;
                                    if(settings.preserveHTML) {
                                        $text.html(text);
                                    }
                                    else {
                                        $text.text(text);
                                    }
                                }
                            }
                        },
                        selectedLetter: function(letter) {
                            var
                                $selectedItem         = $item.filter('.' + className.selected),
                                alreadySelectedLetter = $selectedItem.length > 0 && module.has.firstLetter($selectedItem, letter),
                                $nextValue            = false,
                                $nextItem
                                ;
                            // check next of same letter
                            if(alreadySelectedLetter) {
                                $nextItem = $selectedItem.nextAll($item).eq(0);
                                if( module.has.firstLetter($nextItem, letter) ) {
                                    $nextValue  = $nextItem;
                                }
                            }
                            // check all values
                            if(!$nextValue) {
                                $item
                                    .each(function(){
                                        if(module.has.firstLetter($(this), letter)) {
                                            $nextValue = $(this);
                                            return false;
                                        }
                                    })
                                ;
                            }
                            // set next value
                            if($nextValue) {
                                module.verbose('Scrolling to next value with letter', letter);
                                module.set.scrollPosition($nextValue);
                                $selectedItem.removeClass(className.selected);
                                $nextValue.addClass(className.selected);
                            }
                        },
                        direction: function($menu) {
                            if(settings.direction == 'auto') {
                                if(module.is.onScreen($menu)) {
                                    module.remove.upward($menu);
                                }
                                else {
                                    module.set.upward($menu);
                                }
                            }
                            else if(settings.direction == 'upward') {
                                module.set.upward($menu);
                            }
                        },
                        upward: function($menu) {
                            var $element = $menu || $module;
                            $element.addClass(className.upward);
                        },
                        value: function(value, text, $selected) {
                            var
                                hasInput     = ($input.length > 0),
                                isAddition   = !module.has.value(value),
                                currentValue = module.get.values(),
                                stringValue  = (value !== undefined)
                                    ? String(value)
                                    : value,
                                newValue
                                ;
                            if(hasInput) {
                                if(stringValue == currentValue) {
                                    module.verbose('Skipping value update already same value', value, currentValue);
                                    if(!module.is.initialLoad()) {
                                        return;
                                    }
                                }

                                if( module.is.single() && module.has.selectInput() && module.can.extendSelect() ) {
                                    module.debug('Adding user option', value);
                                    module.add.optionValue(value);
                                }
                                module.debug('Updating input value', value, currentValue);
                                internalChange = true;
                                $input
                                    .val(value)
                                ;
                                if(settings.fireOnInit === false && module.is.initialLoad()) {
                                    module.debug('Input native change event ignored on initial load');
                                }
                                else {
                                    module.trigger.change();
                                }
                                internalChange = false;
                            }
                            else {
                                module.verbose('Storing value in metadata', value, $input);
                                if(value !== currentValue) {
                                    $module.data(metadata.value, stringValue);
                                }
                            }
                            if(settings.fireOnInit === false && module.is.initialLoad()) {
                                module.verbose('No callback on initial load', settings.onChange);
                            }
                            else {
                                settings.onChange.call(element, value, text, $selected);
                            }
                        },
                        active: function() {
                            $module
                                .addClass(className.active)
                            ;
                        },
                        multiple: function() {
                            $module.addClass(className.multiple);
                        },
                        visible: function() {
                            $module.addClass(className.visible);
                        },
                        exactly: function(value, $selectedItem) {
                            module.debug('Setting selected to exact values');
                            module.clear();
                            module.set.selected(value, $selectedItem);
                        },
                        selected: function(value, $selectedItem) {
                            var
                                isMultiple = module.is.multiple(),
                                $userSelectedItem
                                ;
                            $selectedItem = (settings.allowAdditions)
                                ? $selectedItem || module.get.itemWithAdditions(value)
                                : $selectedItem || module.get.item(value)
                            ;
                            if(!$selectedItem) {
                                return;
                            }
                            module.debug('Setting selected menu item to', $selectedItem);
                            if(module.is.single()) {
                                module.remove.activeItem();
                                module.remove.selectedItem();
                            }
                            else if(settings.useLabels) {
                                module.remove.selectedItem();
                            }
                            // select each item
                            $selectedItem
                                .each(function() {
                                    var
                                        $selected      = $(this),
                                        selectedText   = module.get.choiceText($selected),
                                        selectedValue  = module.get.choiceValue($selected, selectedText),

                                        isFiltered     = $selected.hasClass(className.filtered),
                                        isActive       = $selected.hasClass(className.active),
                                        isUserValue    = $selected.hasClass(className.addition),
                                        shouldAnimate  = (isMultiple && $selectedItem.length == 1)
                                        ;
                                    if(isMultiple) {
                                        if(!isActive || isUserValue) {
                                            if(settings.apiSettings && settings.saveRemoteData) {
                                                module.save.remoteData(selectedText, selectedValue);
                                            }
                                            if(settings.useLabels) {
                                                module.add.value(selectedValue, selectedText, $selected);
                                                module.add.label(selectedValue, selectedText, shouldAnimate);
                                                module.set.activeItem($selected);
                                                module.filterActive();
                                                module.select.nextAvailable($selectedItem);
                                            }
                                            else {
                                                module.add.value(selectedValue, selectedText, $selected);
                                                module.set.text(module.add.variables(message.count));
                                                module.set.activeItem($selected);
                                            }
                                        }
                                        else if(!isFiltered) {
                                            module.debug('Selected active value, removing label');
                                            module.remove.selected(selectedValue);
                                        }
                                    }
                                    else {
                                        if(settings.apiSettings && settings.saveRemoteData) {
                                            module.save.remoteData(selectedText, selectedValue);
                                        }
                                        module.set.text(selectedText);
                                        module.set.value(selectedValue, selectedText, $selected);
                                        $selected
                                            .addClass(className.active)
                                            .addClass(className.selected)
                                        ;
                                    }
                                })
                            ;
                        }
                    },

                    add: {
                        label: function(value, text, shouldAnimate) {
                            var
                                $next  = module.is.searchSelection()
                                    ? $search
                                    : $text,
                                $label
                                ;
                            $label =  $('<a />')
                                .addClass(className.label)
                                .attr('data-value', value)
                                .html(templates.label(value, text))
                            ;
                            $label = settings.onLabelCreate.call($label, value, text);

                            if(module.has.label(value)) {
                                module.debug('Label already exists, skipping', value);
                                return;
                            }
                            if(settings.label.variation) {
                                $label.addClass(settings.label.variation);
                            }
                            if(shouldAnimate === true) {
                                module.debug('Animating in label', $label);
                                $label
                                    .addClass(className.hidden)
                                    .insertBefore($next)
                                    .transition(settings.label.transition, settings.label.duration)
                                ;
                            }
                            else {
                                module.debug('Adding selection label', $label);
                                $label
                                    .insertBefore($next)
                                ;
                            }
                        },
                        message: function(message) {
                            var
                                $message = $menu.children(selector.message),
                                html     = settings.templates.message(module.add.variables(message))
                                ;
                            if($message.length > 0) {
                                $message
                                    .html(html)
                                ;
                            }
                            else {
                                $message = $('<div/>')
                                    .html(html)
                                    .addClass(className.message)
                                    .appendTo($menu)
                                ;
                            }
                        },
                        optionValue: function(value) {
                            var
                                $option   = $input.find('option[value="' + value + '"]'),
                                hasOption = ($option.length > 0)
                                ;
                            if(hasOption) {
                                return;
                            }
                            // temporarily disconnect observer
                            if(selectObserver) {
                                selectObserver.disconnect();
                                module.verbose('Temporarily disconnecting mutation observer', value);
                            }
                            if( module.is.single() ) {
                                module.verbose('Removing previous user addition');
                                $input.find('option.' + className.addition).remove();
                            }
                            $('<option/>')
                                .prop('value', value)
                                .addClass(className.addition)
                                .html(value)
                                .appendTo($input)
                            ;
                            module.verbose('Adding user addition as an <option>', value);
                            if(selectObserver) {
                                selectObserver.observe($input[0], {
                                    childList : true,
                                    subtree   : true
                                });
                            }
                        },
                        userSuggestion: function(value) {
                            var
                                $addition         = $menu.children(selector.addition),
                                $existingItem     = module.get.item(value),
                                alreadyHasValue   = $existingItem && $existingItem.not(selector.addition).length,
                                hasUserSuggestion = $addition.length > 0,
                                html
                                ;
                            if(settings.useLabels && module.has.maxSelections()) {
                                return;
                            }
                            if(value === '' || alreadyHasValue) {
                                $addition.remove();
                                return;
                            }
                            $item
                                .removeClass(className.selected)
                            ;
                            if(hasUserSuggestion) {
                                html = settings.templates.addition( module.add.variables(message.addResult, value) );
                                $addition
                                    .html(html)
                                    .attr('data-' + metadata.value, value)
                                    .attr('data-' + metadata.text, value)
                                    .removeClass(className.filtered)
                                    .addClass(className.selected)
                                ;
                                module.verbose('Replacing user suggestion with new value', $addition);
                            }
                            else {
                                $addition = module.create.userChoice(value);
                                $addition
                                    .prependTo($menu)
                                    .addClass(className.selected)
                                ;
                                module.verbose('Adding item choice to menu corresponding with user choice addition', $addition);
                            }
                        },
                        variables: function(message, term) {
                            var
                                hasCount    = (message.search('{count}') !== -1),
                                hasMaxCount = (message.search('{maxCount}') !== -1),
                                hasTerm     = (message.search('{term}') !== -1),
                                values,
                                count,
                                query
                                ;
                            module.verbose('Adding templated variables to message', message);
                            if(hasCount) {
                                count  = module.get.selectionCount();
                                message = message.replace('{count}', count);
                            }
                            if(hasMaxCount) {
                                count  = module.get.selectionCount();
                                message = message.replace('{maxCount}', settings.maxSelections);
                            }
                            if(hasTerm) {
                                query   = term || module.get.query();
                                message = message.replace('{term}', query);
                            }
                            return message;
                        },
                        value: function(addedValue, addedText, $selectedItem) {
                            var
                                currentValue = module.get.values(),
                                newValue
                                ;
                            if(addedValue === '') {
                                module.debug('Cannot select blank values from multiselect');
                                return;
                            }
                            // extend current array
                            if($.isArray(currentValue)) {
                                newValue = currentValue.concat([addedValue]);
                                newValue = module.get.uniqueArray(newValue);
                            }
                            else {
                                newValue = [addedValue];
                            }
                            // add values
                            if( module.has.selectInput() ) {
                                if(module.can.extendSelect()) {
                                    module.debug('Adding value to select', addedValue, newValue, $input);
                                    module.add.optionValue(addedValue);
                                }
                            }
                            else {
                                newValue = newValue.join(settings.delimiter);
                                module.debug('Setting hidden input to delimited value', newValue, $input);
                            }

                            if(settings.fireOnInit === false && module.is.initialLoad()) {
                                module.verbose('Skipping onadd callback on initial load', settings.onAdd);
                            }
                            else {
                                settings.onAdd.call(element, addedValue, addedText, $selectedItem);
                            }
                            module.set.value(newValue, addedValue, addedText, $selectedItem);
                            module.check.maxSelections();
                        }
                    },

                    remove: {
                        active: function() {
                            $module.removeClass(className.active);
                        },
                        activeLabel: function() {
                            $module.find(selector.label).removeClass(className.active);
                        },
                        loading: function() {
                            $module.removeClass(className.loading);
                        },
                        initialLoad: function() {
                            initialLoad = false;
                        },
                        upward: function($menu) {
                            var $element = $menu || $module;
                            $element.removeClass(className.upward);
                        },
                        visible: function() {
                            $module.removeClass(className.visible);
                        },
                        activeItem: function() {
                            $item.removeClass(className.active);
                        },
                        filteredItem: function() {
                            if(settings.useLabels && module.has.maxSelections() ) {
                                return;
                            }
                            if(settings.useLabels && module.is.multiple()) {
                                $item.not('.' + className.active).removeClass(className.filtered);
                            }
                            else {
                                $item.removeClass(className.filtered);
                            }
                        },
                        optionValue: function(value) {
                            var
                                $option   = $input.find('option[value="' + value + '"]'),
                                hasOption = ($option.length > 0)
                                ;
                            if(!hasOption || !$option.hasClass(className.addition)) {
                                return;
                            }
                            // temporarily disconnect observer
                            if(selectObserver) {
                                selectObserver.disconnect();
                                module.verbose('Temporarily disconnecting mutation observer', value);
                            }
                            $option.remove();
                            module.verbose('Removing user addition as an <option>', value);
                            if(selectObserver) {
                                selectObserver.observe($input[0], {
                                    childList : true,
                                    subtree   : true
                                });
                            }
                        },
                        message: function() {
                            $menu.children(selector.message).remove();
                        },
                        searchTerm: function() {
                            module.verbose('Cleared search term');
                            $search.val('');
                            module.set.filtered();
                        },
                        selected: function(value, $selectedItem) {
                            $selectedItem = (settings.allowAdditions)
                                ? $selectedItem || module.get.itemWithAdditions(value)
                                : $selectedItem || module.get.item(value)
                            ;

                            if(!$selectedItem) {
                                return false;
                            }

                            $selectedItem
                                .each(function() {
                                    var
                                        $selected     = $(this),
                                        selectedText  = module.get.choiceText($selected),
                                        selectedValue = module.get.choiceValue($selected, selectedText)
                                        ;
                                    if(module.is.multiple()) {
                                        if(settings.useLabels) {
                                            module.remove.value(selectedValue, selectedText, $selected);
                                            module.remove.label(selectedValue);
                                        }
                                        else {
                                            module.remove.value(selectedValue, selectedText, $selected);
                                            if(module.get.selectionCount() === 0) {
                                                module.set.placeholderText();
                                            }
                                            else {
                                                module.set.text(module.add.variables(message.count));
                                            }
                                        }
                                    }
                                    else {
                                        module.remove.value(selectedValue, selectedText, $selected);
                                    }
                                    $selected
                                        .removeClass(className.filtered)
                                        .removeClass(className.active)
                                    ;
                                    if(settings.useLabels) {
                                        $selected.removeClass(className.selected);
                                    }
                                })
                            ;
                        },
                        selectedItem: function() {
                            $item.removeClass(className.selected);
                        },
                        value: function(removedValue, removedText, $removedItem) {
                            var
                                values = module.get.values(),
                                newValue
                                ;
                            if( module.has.selectInput() ) {
                                module.verbose('Input is <select> removing selected option', removedValue);
                                newValue = module.remove.arrayValue(removedValue, values);
                                module.remove.optionValue(removedValue);
                            }
                            else {
                                module.verbose('Removing from delimited values', removedValue);
                                newValue = module.remove.arrayValue(removedValue, values);
                                newValue = newValue.join(settings.delimiter);
                            }
                            if(settings.fireOnInit === false && module.is.initialLoad()) {
                                module.verbose('No callback on initial load', settings.onRemove);
                            }
                            else {
                                settings.onRemove.call(element, removedValue, removedText, $removedItem);
                            }
                            module.set.value(newValue, removedText, $removedItem);
                            module.check.maxSelections();
                        },
                        arrayValue: function(removedValue, values) {
                            if( !$.isArray(values) ) {
                                values = [values];
                            }
                            values = $.grep(values, function(value){
                                return (removedValue != value);
                            });
                            module.verbose('Removed value from delimited string', removedValue, values);
                            return values;
                        },
                        label: function(value, shouldAnimate) {
                            var
                                $labels       = $module.find(selector.label),
                                $removedLabel = $labels.filter('[data-value="' + value +'"]')
                                ;
                            module.verbose('Removing label', $removedLabel);
                            $removedLabel.remove();
                        },
                        activeLabels: function($activeLabels) {
                            $activeLabels = $activeLabels || $module.find(selector.label).filter('.' + className.active);
                            module.verbose('Removing active label selections', $activeLabels);
                            module.remove.labels($activeLabels);
                        },
                        labels: function($labels) {
                            $labels = $labels || $module.find(selector.label);
                            module.verbose('Removing labels', $labels);
                            $labels
                                .each(function(){
                                    var
                                        $label      = $(this),
                                        value       = $label.data(metadata.value),
                                        stringValue = (value !== undefined)
                                            ? String(value)
                                            : value,
                                        isUserValue = module.is.userValue(stringValue)
                                        ;
                                    if(settings.onLabelRemove.call($label, value) === false) {
                                        module.debug('Label remove callback cancelled removal');
                                        return;
                                    }
                                    if(isUserValue) {
                                        module.remove.value(stringValue);
                                        module.remove.label(stringValue);
                                    }
                                    else {
                                        // selected will also remove label
                                        module.remove.selected(stringValue);
                                    }
                                })
                            ;
                        },
                        tabbable: function() {
                            if( module.has.search() ) {
                                module.debug('Searchable dropdown initialized');
                                $search
                                    .removeAttr('tabindex')
                                ;
                                $menu
                                    .removeAttr('tabindex')
                                ;
                            }
                            else {
                                module.debug('Simple selection dropdown initialized');
                                $module
                                    .removeAttr('tabindex')
                                ;
                                $menu
                                    .removeAttr('tabindex')
                                ;
                            }
                        }
                    },

                    has: {
                        search: function() {
                            return ($search.length > 0);
                        },
                        selectInput: function() {
                            return ( $input.is('select') );
                        },
                        firstLetter: function($item, letter) {
                            var
                                text,
                                firstLetter
                                ;
                            if(!$item || $item.length === 0 || typeof letter !== 'string') {
                                return false;
                            }
                            text        = module.get.choiceText($item, false);
                            letter      = letter.toLowerCase();
                            firstLetter = String(text).charAt(0).toLowerCase();
                            return (letter == firstLetter);
                        },
                        input: function() {
                            return ($input.length > 0);
                        },
                        items: function() {
                            return ($item.length > 0);
                        },
                        menu: function() {
                            return ($menu.length > 0);
                        },
                        message: function() {
                            return ($menu.children(selector.message).length !== 0);
                        },
                        label: function(value) {
                            var
                                $labels = $module.find(selector.label)
                                ;
                            return ($labels.filter('[data-value="' + value +'"]').length > 0);
                        },
                        maxSelections: function() {
                            return (settings.maxSelections && module.get.selectionCount() >= settings.maxSelections);
                        },
                        allResultsFiltered: function() {
                            return ($item.filter(selector.unselectable).length === $item.length);
                        },
                        query: function() {
                            return (module.get.query() !== '');
                        },
                        value: function(value) {
                            var
                                values   = module.get.values(),
                                hasValue = $.isArray(values)
                                    ? values && ($.inArray(value, values) !== -1)
                                    : (values == value)
                                ;
                            return (hasValue)
                                ? true
                                : false
                                ;
                        }
                    },

                    is: {
                        active: function() {
                            return $module.hasClass(className.active);
                        },
                        alreadySetup: function() {
                            return ($module.is('select') && $module.parent(selector.dropdown).length > 0  && $module.prev().length === 0);
                        },
                        animating: function($subMenu) {
                            return ($subMenu)
                                ? $subMenu.transition && $subMenu.transition('is animating')
                                : $menu.transition    && $menu.transition('is animating')
                                ;
                        },
                        disabled: function() {
                            return $module.hasClass(className.disabled);
                        },
                        focused: function() {
                            return (document.activeElement === $module[0]);
                        },
                        focusedOnSearch: function() {
                            return (document.activeElement === $search[0]);
                        },
                        allFiltered: function() {
                            return( (module.is.multiple() || module.has.search()) && !module.has.message() && module.has.allResultsFiltered() );
                        },
                        hidden: function($subMenu) {
                            return !module.is.visible($subMenu);
                        },
                        initialLoad: function() {
                            return initialLoad;
                        },
                        onScreen: function($subMenu) {
                            var
                                $currentMenu   = $subMenu || $menu,
                                canOpenDownward = true,
                                onScreen = {},
                                calculations
                                ;
                            $currentMenu.addClass(className.loading);
                            calculations = {
                                context: {
                                    scrollTop : $context.scrollTop(),
                                    height    : $context.outerHeight()
                                },
                                menu : {
                                    offset: $currentMenu.offset(),
                                    height: $currentMenu.outerHeight()
                                }
                            };
                            onScreen = {
                                above : (calculations.context.scrollTop) <= calculations.menu.offset.top - calculations.menu.height,
                                below : (calculations.context.scrollTop + calculations.context.height) >= calculations.menu.offset.top + calculations.menu.height
                            };
                            if(onScreen.below) {
                                module.verbose('Dropdown can fit in context downward', onScreen);
                                canOpenDownward = true;
                            }
                            else if(!onScreen.below && !onScreen.above) {
                                module.verbose('Dropdown cannot fit in either direction, favoring downward', onScreen);
                                canOpenDownward = true;
                            }
                            else {
                                module.verbose('Dropdown cannot fit below, opening upward', onScreen);
                                canOpenDownward = false;
                            }
                            $currentMenu.removeClass(className.loading);
                            return canOpenDownward;
                        },
                        inObject: function(needle, object) {
                            var
                                found = false
                                ;
                            $.each(object, function(index, property) {
                                if(property == needle) {
                                    found = true;
                                    return true;
                                }
                            });
                            return found;
                        },
                        multiple: function() {
                            return $module.hasClass(className.multiple);
                        },
                        single: function() {
                            return !module.is.multiple();
                        },
                        selectMutation: function(mutations) {
                            var
                                selectChanged = false
                                ;
                            $.each(mutations, function(index, mutation) {
                                if(mutation.target && $(mutation.target).is('select')) {
                                    selectChanged = true;
                                    return true;
                                }
                            });
                            return selectChanged;
                        },
                        search: function() {
                            return $module.hasClass(className.search);
                        },
                        searchSelection: function() {
                            return ( module.has.search() && $search.parent(selector.dropdown).length === 1 );
                        },
                        selection: function() {
                            return $module.hasClass(className.selection);
                        },
                        userValue: function(value) {
                            return ($.inArray(value, module.get.userValues()) !== -1);
                        },
                        upward: function($menu) {
                            var $element = $menu || $module;
                            return $element.hasClass(className.upward);
                        },
                        visible: function($subMenu) {
                            return ($subMenu)
                                ? $subMenu.hasClass(className.visible)
                                : $menu.hasClass(className.visible)
                                ;
                        }
                    },

                    can: {
                        activate: function($item) {
                            if(settings.useLabels) {
                                return true;
                            }
                            if(!module.has.maxSelections()) {
                                return true;
                            }
                            if(module.has.maxSelections() && $item.hasClass(className.active)) {
                                return true;
                            }
                            return false;
                        },
                        click: function() {
                            return (hasTouch || settings.on == 'click');
                        },
                        extendSelect: function() {
                            return settings.allowAdditions || settings.apiSettings;
                        },
                        show: function() {
                            return !module.is.disabled() && (module.has.items() || module.has.message());
                        },
                        useAPI: function() {
                            return $.fn.api !== undefined;
                        }
                    },

                    animate: {
                        show: function(callback, $subMenu) {
                            var
                                $currentMenu = $subMenu || $menu,
                                start = ($subMenu)
                                    ? function() {}
                                    : function() {
                                    module.hideSubMenus();
                                    module.hideOthers();
                                    module.set.active();
                                },
                                transition
                                ;
                            callback = $.isFunction(callback)
                                ? callback
                                : function(){}
                            ;
                            module.verbose('Doing menu show animation', $currentMenu);
                            module.set.direction($subMenu);
                            transition = module.get.transition($subMenu);
                            if( module.is.selection() ) {
                                module.set.scrollPosition(module.get.selectedItem(), true);
                            }
                            if( module.is.hidden($currentMenu) || module.is.animating($currentMenu) ) {
                                if(transition == 'none') {
                                    start();
                                    $currentMenu.transition('show');
                                    callback.call(element);
                                }
                                else if($.fn.transition !== undefined && $module.transition('is supported')) {
                                    $currentMenu
                                        .transition({
                                            animation  : transition + ' in',
                                            debug      : settings.debug,
                                            verbose    : settings.verbose,
                                            duration   : settings.duration,
                                            queue      : true,
                                            onStart    : start,
                                            onComplete : function() {
                                                callback.call(element);
                                            }
                                        })
                                    ;
                                }
                                else {
                                    module.error(error.noTransition, transition);
                                }
                            }
                        },
                        hide: function(callback, $subMenu) {
                            var
                                $currentMenu = $subMenu || $menu,
                                duration = ($subMenu)
                                    ? (settings.duration * 0.9)
                                    : settings.duration,
                                start = ($subMenu)
                                    ? function() {}
                                    : function() {
                                    if( module.can.click() ) {
                                        module.unbind.intent();
                                    }
                                    module.remove.active();
                                },
                                transition = module.get.transition($subMenu)
                                ;
                            callback = $.isFunction(callback)
                                ? callback
                                : function(){}
                            ;
                            if( module.is.visible($currentMenu) || module.is.animating($currentMenu) ) {
                                module.verbose('Doing menu hide animation', $currentMenu);

                                if(transition == 'none') {
                                    start();
                                    $currentMenu.transition('hide');
                                    callback.call(element);
                                }
                                else if($.fn.transition !== undefined && $module.transition('is supported')) {
                                    $currentMenu
                                        .transition({
                                            animation  : transition + ' out',
                                            duration   : settings.duration,
                                            debug      : settings.debug,
                                            verbose    : settings.verbose,
                                            queue      : true,
                                            onStart    : start,
                                            onComplete : function() {
                                                if(settings.direction == 'auto') {
                                                    module.remove.upward($subMenu);
                                                }
                                                callback.call(element);
                                            }
                                        })
                                    ;
                                }
                                else {
                                    module.error(error.transition);
                                }
                            }
                        }
                    },

                    hideAndClear: function() {
                        module.remove.searchTerm();
                        if( module.has.maxSelections() ) {
                            return;
                        }
                        if(module.has.search()) {
                            module.hide(function() {
                                module.remove.filteredItem();
                            });
                        }
                        else {
                            module.hide();
                        }
                    },

                    delay: {
                        show: function() {
                            module.verbose('Delaying show event to ensure user intent');
                            clearTimeout(module.timer);
                            module.timer = setTimeout(module.show, settings.delay.show);
                        },
                        hide: function() {
                            module.verbose('Delaying hide event to ensure user intent');
                            clearTimeout(module.timer);
                            module.timer = setTimeout(module.hide, settings.delay.hide);
                        }
                    },

                    escape: {
                        regExp: function(text) {
                            text =  String(text);
                            return text.replace(regExp.escape, '\\$&');
                        }
                    },

                    setting: function(name, value) {
                        module.debug('Changing setting', name, value);
                        if( $.isPlainObject(name) ) {
                            $.extend(true, settings, name);
                        }
                        else if(value !== undefined) {
                            settings[name] = value;
                        }
                        else {
                            return settings[name];
                        }
                    },
                    internal: function(name, value) {
                        if( $.isPlainObject(name) ) {
                            $.extend(true, module, name);
                        }
                        else if(value !== undefined) {
                            module[name] = value;
                        }
                        else {
                            return module[name];
                        }
                    },
                    debug: function() {
                        if(settings.debug) {
                            if(settings.performance) {
                                module.performance.log(arguments);
                            }
                            else {
                                module.debug = Function.prototype.bind.call(console.info, console, settings.name + ':');
                                module.debug.apply(console, arguments);
                            }
                        }
                    },
                    verbose: function() {
                        if(settings.verbose && settings.debug) {
                            if(settings.performance) {
                                module.performance.log(arguments);
                            }
                            else {
                                module.verbose = Function.prototype.bind.call(console.info, console, settings.name + ':');
                                module.verbose.apply(console, arguments);
                            }
                        }
                    },
                    error: function() {
                        module.error = Function.prototype.bind.call(console.error, console, settings.name + ':');
                        module.error.apply(console, arguments);
                    },
                    performance: {
                        log: function(message) {
                            var
                                currentTime,
                                executionTime,
                                previousTime
                                ;
                            if(settings.performance) {
                                currentTime   = new Date().getTime();
                                previousTime  = time || currentTime;
                                executionTime = currentTime - previousTime;
                                time          = currentTime;
                                performance.push({
                                    'Name'           : message[0],
                                    'Arguments'      : [].slice.call(message, 1) || '',
                                    'Element'        : element,
                                    'Execution Time' : executionTime
                                });
                            }
                            clearTimeout(module.performance.timer);
                            module.performance.timer = setTimeout(module.performance.display, 500);
                        },
                        display: function() {
                            var
                                title = settings.name + ':',
                                totalTime = 0
                                ;
                            time = false;
                            clearTimeout(module.performance.timer);
                            $.each(performance, function(index, data) {
                                totalTime += data['Execution Time'];
                            });
                            title += ' ' + totalTime + 'ms';
                            if(moduleSelector) {
                                title += ' \'' + moduleSelector + '\'';
                            }
                            if( (console.group !== undefined || console.table !== undefined) && performance.length > 0) {
                                console.groupCollapsed(title);
                                if(console.table) {
                                    console.table(performance);
                                }
                                else {
                                    $.each(performance, function(index, data) {
                                        console.log(data['Name'] + ': ' + data['Execution Time']+'ms');
                                    });
                                }
                                console.groupEnd();
                            }
                            performance = [];
                        }
                    },
                    invoke: function(query, passedArguments, context) {
                        var
                            object = instance,
                            maxDepth,
                            found,
                            response
                            ;
                        passedArguments = passedArguments || queryArguments;
                        context         = element         || context;
                        if(typeof query == 'string' && object !== undefined) {
                            query    = query.split(/[\. ]/);
                            maxDepth = query.length - 1;
                            $.each(query, function(depth, value) {
                                var camelCaseValue = (depth != maxDepth)
                                        ? value + query[depth + 1].charAt(0).toUpperCase() + query[depth + 1].slice(1)
                                        : query
                                    ;
                                if( $.isPlainObject( object[camelCaseValue] ) && (depth != maxDepth) ) {
                                    object = object[camelCaseValue];
                                }
                                else if( object[camelCaseValue] !== undefined ) {
                                    found = object[camelCaseValue];
                                    return false;
                                }
                                else if( $.isPlainObject( object[value] ) && (depth != maxDepth) ) {
                                    object = object[value];
                                }
                                else if( object[value] !== undefined ) {
                                    found = object[value];
                                    return false;
                                }
                                else {
                                    module.error(error.method, query);
                                    return false;
                                }
                            });
                        }
                        if ( $.isFunction( found ) ) {
                            response = found.apply(context, passedArguments);
                        }
                        else if(found !== undefined) {
                            response = found;
                        }
                        if($.isArray(returnedValue)) {
                            returnedValue.push(response);
                        }
                        else if(returnedValue !== undefined) {
                            returnedValue = [returnedValue, response];
                        }
                        else if(response !== undefined) {
                            returnedValue = response;
                        }
                        return found;
                    }
                };

                if(methodInvoked) {
                    if(instance === undefined) {
                        module.initialize();
                    }
                    module.invoke(query);
                }
                else {
                    if(instance !== undefined) {
                        instance.invoke('destroy');
                    }
                    module.initialize();
                }
            })
        ;
        return (returnedValue !== undefined)
            ? returnedValue
            : $allModules
            ;
    };

    $.fn.dropdown.settings = {

        debug                  : false,
        verbose                : false,
        performance            : true,

        on                     : 'click',    // what event should show menu action on item selection
        action                 : 'activate', // action on item selection (nothing, activate, select, combo, hide, function(){})


        apiSettings            : false,
        saveRemoteData         : true,      // Whether remote name/value pairs should be stored in sessionStorage to allow remote data to be restored on page refresh
        throttle               : 200,       // How long to wait after last user input to search remotely

        context                : window,      // Context to use when determining if on screen
        direction              : 'auto',     // Whether dropdown should always open in one direction
        keepOnScreen           : true,       // Whether dropdown should check whether it is on screen before showing

        match                  : 'both',     // what to match against with search selection (both, text, or label)
        fullTextSearch         : false,      // search anywhere in value

        placeholder            : 'auto',     // whether to convert blank <select> values to placeholder text
        preserveHTML           : true,       // preserve html when selecting value
        sortSelect             : false,      // sort selection on init

        forceSelection         : true,       // force a choice on blur with search selection
        allowAdditions         : false,      // whether multiple select should allow user added values

        maxSelections          : false,      // When set to a number limits the number of selections to this count
        useLabels              : true,       // whether multiple select should filter currently active selections from choices
        delimiter              : ',',        // when multiselect uses normal <input> the values will be delimited with this character

        showOnFocus            : true,       // show menu on focus
        allowTab               : true,       // add tabindex to element
        allowCategorySelection : false,      // allow elements with sub-menus to be selected

        fireOnInit             : false,      // Whether callbacks should fire when initializing dropdown values

        transition             : 'auto',     // auto transition will slide down or up based on direction
        duration               : 200,        // duration of transition

        glyphWidth             : 1.0714,     // widest glyph width in em (W is 1.0714 em) used to calculate multiselect input width

        // label settings on multi-select
        label: {
            transition : 'scale',
            duration   : 200,
            variation  : false
        },

        // delay before event
        delay : {
            hide   : 300,
            show   : 200,
            search : 20,
            touch  : 50
        },

        /* Callbacks */
        onChange      : function(value, text, $selected){},
        onAdd         : function(value, text, $selected){},
        onRemove      : function(value, text, $selected){},

        onLabelSelect : function($selectedLabels){},
        onLabelCreate : function(value, text) { return $(this); },
        onLabelRemove : function(value) { return true; },
        onNoResults   : function(searchTerm) { return true; },
        onShow        : function(){},
        onHide        : function(){},

        /* Component */
        name           : 'Dropdown',
        namespace      : 'dropdown',

        message: {
            addResult     : 'Add <b>{term}</b>',
            count         : '{count} selected',
            maxSelections : 'Max {maxCount} selections',
            noResults     : StrackLang["No_Filter_Project"],
            serverError   : 'There was an error contacting the server'
        },

        error : {
            action          : 'You called a dropdown action that was not defined',
            alreadySetup    : 'Once a select has been initialized behaviors must be called on the created ui dropdown',
            labels          : 'Allowing user additions currently requires the use of labels.',
            missingMultiple : '<select> requires multiple property to be set to correctly preserve multiple values',
            method          : 'The method you called is not defined.',
            noAPI           : 'The API module is required to load resources remotely',
            noStorage       : 'Saving remote data requires session storage',
            noTransition    : 'This module requires ui transitions <https://github.com/Semantic-Org/UI-Transition>'
        },

        regExp : {
            escape   : /[-[\]{}()*+?.,\\^$|#\s]/g,
        },

        metadata : {
            defaultText     : 'defaultText',
            defaultValue    : 'defaultValue',
            placeholderText : 'placeholder',
            text            : 'text',
            value           : 'value'
        },

        // property names for remote query
        fields: {
            remoteValues : 'results', // grouping for api results
            values       : 'values', // grouping for all dropdown values
            name         : 'name',   // displayed dropdown text
            value        : 'value'   // actual dropdown value
        },

        keys : {
            backspace  : 8,
            delimiter  : 188, // comma
            deleteKey  : 46,
            enter      : 13,
            escape     : 27,
            pageUp     : 33,
            pageDown   : 34,
            leftArrow  : 37,
            upArrow    : 38,
            rightArrow : 39,
            downArrow  : 40
        },

        selector : {
            addition     : '.addition',
            dropdown     : '.ui.dropdown',
            icon         : '> .dropdown.icon',
            input        : '> input[type="hidden"], > select',
            item         : '.item',
            label        : '> .label',
            remove       : '> .label > .delete.icon',
            siblingLabel : '.label',
            menu         : '.menu',
            message      : '.message',
            menuIcon     : '.dropdown.icon',
            search       : 'input.search, .menu > .search > input',
            text         : '> .text:not(.icon)',
            unselectable : '.disabled, .filtered'
        },

        className : {
            active      : 'active',
            addition    : 'addition',
            animating   : 'animating',
            disabled    : 'disabled',
            dropdown    : 'ui dropdown',
            filtered    : 'filtered',
            hidden      : 'hidden transition',
            item        : 'item',
            label       : 'ui label',
            loading     : 'loading',
            menu        : 'menu',
            message     : 'message',
            multiple    : 'multiple',
            placeholder : 'default',
            search      : 'search',
            selected    : 'selected',
            selection   : 'selection',
            upward      : 'upward',
            visible     : 'visible'
        }

    };

    /* Templates */
    $.fn.dropdown.settings.templates = {

        // generates dropdown from select values
        dropdown: function(select) {
            var
                placeholder = select.placeholder || false,
                values      = select.values || {},
                html        = ''
                ;
            html +=  '<i class="dropdown icon"></i>';
            if(select.placeholder) {
                html += '<div class="default text">' + placeholder + '</div>';
            }
            else {
                html += '<div class="text"></div>';
            }
            html += '<div class="menu">';
            $.each(select.values, function(index, option) {
                html += (option.disabled)
                    ? '<div class="disabled item" data-value="' + option.value + '">' + option.name + '</div>'
                    : '<div class="item" data-value="' + option.value + '">' + option.name + '</div>'
                ;
            });
            html += '</div>';
            return html;
        },

        // generates just menu from select
        menu: function(response, fields) {
            var
                values = response[fields.values] || {},
                html   = ''
                ;
            $.each(values, function(index, option) {
                html += '<div class="item" data-value="' + option[fields.value] + '">' + option[fields.name] + '</div>';
            });
            return html;
        },

        // generates label for multiselect
        label: function(value, text) {
            return text + '<i class="delete icon"></i>';
        },


        // generates messages like "No results"
        message: function(message) {
            return message;
        },

        // generates user addition to selection menu
        addition: function(choice) {
            return choice;
        }

    };

})( jQuery, window, document );

/*!
 * # Semantic UI 2.1.6 - Video
 * http://github.com/semantic-org/semantic-ui/
 *
 *
 * Copyright 2015 Contributors
 * Released under the MIT license
 * http://opensource.org/licenses/MIT
 *
 */

;(function ($, window, document, undefined) {

    "use strict";

    $.fn.embed = function(parameters) {

        var
            $allModules     = $(this),

            moduleSelector  = $allModules.selector || '',

            time            = new Date().getTime(),
            performance     = [],

            query           = arguments[0],
            methodInvoked   = (typeof query == 'string'),
            queryArguments  = [].slice.call(arguments, 1),

            returnedValue
            ;

        $allModules
            .each(function() {
                var
                    settings        = ( $.isPlainObject(parameters) )
                        ? $.extend(true, {}, $.fn.embed.settings, parameters)
                        : $.extend({}, $.fn.embed.settings),

                    selector        = settings.selector,
                    className       = settings.className,
                    sources         = settings.sources,
                    error           = settings.error,
                    metadata        = settings.metadata,
                    namespace       = settings.namespace,
                    templates       = settings.templates,

                    eventNamespace  = '.' + namespace,
                    moduleNamespace = 'module-' + namespace,

                    $window         = $(window),
                    $module         = $(this),
                    $placeholder    = $module.find(selector.placeholder),
                    $icon           = $module.find(selector.icon),
                    $embed          = $module.find(selector.embed),

                    element         = this,
                    instance        = $module.data(moduleNamespace),
                    module
                    ;

                module = {

                    initialize: function() {
                        module.debug('Initializing embed');
                        module.determine.autoplay();
                        module.create();
                        module.bind.events();
                        module.instantiate();
                    },

                    instantiate: function() {
                        module.verbose('Storing instance of module', module);
                        instance = module;
                        $module
                            .data(moduleNamespace, module)
                        ;
                    },

                    destroy: function() {
                        module.verbose('Destroying previous instance of embed');
                        module.reset();
                        $module
                            .removeData(moduleNamespace)
                            .off(eventNamespace)
                        ;
                    },

                    refresh: function() {
                        module.verbose('Refreshing selector cache');
                        $placeholder = $module.find(selector.placeholder);
                        $icon        = $module.find(selector.icon);
                        $embed       = $module.find(selector.embed);
                    },

                    bind: {
                        events: function() {
                            if( module.has.placeholder() ) {
                                module.debug('Adding placeholder events');
                                $module
                                    .on('click' + eventNamespace, selector.placeholder, module.createAndShow)
                                    .on('click' + eventNamespace, selector.icon, module.createAndShow)
                                ;
                            }
                        }
                    },

                    create: function() {
                        var
                            placeholder = module.get.placeholder()
                            ;
                        if(placeholder) {
                            module.createPlaceholder();
                        }
                        else {
                            module.createAndShow();
                        }
                    },

                    createPlaceholder: function(placeholder) {
                        var
                            icon  = module.get.icon(),
                            url   = module.get.url(),
                            embed = module.generate.embed(url)
                            ;
                        placeholder = placeholder || module.get.placeholder();
                        $module.html( templates.placeholder(placeholder, icon) );
                        module.debug('Creating placeholder for embed', placeholder, icon);
                    },

                    createEmbed: function(url) {
                        module.refresh();
                        url = url || module.get.url();
                        $embed = $('<div/>')
                            .addClass(className.embed)
                            .html( module.generate.embed(url) )
                            .appendTo($module)
                        ;
                        settings.onCreate.call(element, url);
                        module.debug('Creating embed object', $embed);
                    },

                    createAndShow: function() {
                        module.createEmbed();
                        module.show();
                    },

                    // sets new embed
                    change: function(source, id, url) {
                        module.debug('Changing video to ', source, id, url);
                        $module
                            .data(metadata.source, source)
                            .data(metadata.id, id)
                            .data(metadata.url, url)
                        ;
                        module.create();
                    },

                    // clears embed
                    reset: function() {
                        module.debug('Clearing embed and showing placeholder');
                        module.remove.active();
                        module.remove.embed();
                        module.showPlaceholder();
                        settings.onReset.call(element);
                    },

                    // shows current embed
                    show: function() {
                        module.debug('Showing embed');
                        module.set.active();
                        settings.onDisplay.call(element);
                    },

                    hide: function() {
                        module.debug('Hiding embed');
                        module.showPlaceholder();
                    },

                    showPlaceholder: function() {
                        module.debug('Showing placeholder image');
                        module.remove.active();
                        settings.onPlaceholderDisplay.call(element);
                    },

                    get: {
                        id: function() {
                            return settings.id || $module.data(metadata.id);
                        },
                        placeholder: function() {
                            return settings.placeholder || $module.data(metadata.placeholder);
                        },
                        icon: function() {
                            return (settings.icon)
                                ? settings.icon
                                : ($module.data(metadata.icon) !== undefined)
                                ? $module.data(metadata.icon)
                                : module.determine.icon()
                                ;
                        },
                        source: function(url) {
                            return (settings.source)
                                ? settings.source
                                : ($module.data(metadata.source) !== undefined)
                                ? $module.data(metadata.source)
                                : module.determine.source()
                                ;
                        },
                        type: function() {
                            var source = module.get.source();
                            return (sources[source] !== undefined)
                                ? sources[source].type
                                : false
                                ;
                        },
                        url: function() {
                            return (settings.url)
                                ? settings.url
                                : ($module.data(metadata.url) !== undefined)
                                ? $module.data(metadata.url)
                                : module.determine.url()
                                ;
                        }
                    },

                    determine: {
                        autoplay: function() {
                            if(module.should.autoplay()) {
                                settings.autoplay = true;
                            }
                        },
                        source: function(url) {
                            var
                                matchedSource = false
                                ;
                            url = url || module.get.url();
                            if(url) {
                                $.each(sources, function(name, source) {
                                    if(url.search(source.domain) !== -1) {
                                        matchedSource = name;
                                        return false;
                                    }
                                });
                            }
                            return matchedSource;
                        },
                        icon: function() {
                            var
                                source = module.get.source()
                                ;
                            return (sources[source] !== undefined)
                                ? sources[source].icon
                                : false
                                ;
                        },
                        url: function() {
                            var
                                id     = settings.id     || $module.data(metadata.id),
                                source = settings.source || $module.data(metadata.source),
                                url
                                ;
                            url = (sources[source] !== undefined)
                                ? sources[source].url.replace('{id}', id)
                                : false
                            ;
                            if(url) {
                                $module.data(metadata.url, url);
                            }
                            return url;
                        }
                    },


                    set: {
                        active: function() {
                            $module.addClass(className.active);
                        }
                    },

                    remove: {
                        active: function() {
                            $module.removeClass(className.active);
                        },
                        embed: function() {
                            $embed.empty();
                        }
                    },

                    encode: {
                        parameters: function(parameters) {
                            var
                                urlString = [],
                                index
                                ;
                            for (index in parameters) {
                                urlString.push( encodeURIComponent(index) + '=' + encodeURIComponent( parameters[index] ) );
                            }
                            return urlString.join('&amp;');
                        }
                    },

                    generate: {
                        embed: function(url) {
                            module.debug('Generating embed html');
                            var
                                source = module.get.source(),
                                html,
                                parameters
                                ;
                            url = module.get.url(url);
                            if(url) {
                                parameters = module.generate.parameters(source);
                                html       = templates.iframe(url, parameters);
                            }
                            else {
                                module.error(error.noURL, $module);
                            }
                            return html;
                        },
                        parameters: function(source, extraParameters) {
                            var
                                parameters = (sources[source] && sources[source].parameters !== undefined)
                                    ? sources[source].parameters(settings)
                                    : {}
                                ;
                            extraParameters = extraParameters || settings.parameters;
                            if(extraParameters) {
                                parameters = $.extend({}, parameters, extraParameters);
                            }
                            parameters = settings.onEmbed(parameters);
                            return module.encode.parameters(parameters);
                        }
                    },

                    has: {
                        placeholder: function() {
                            return settings.placeholder || $module.data(metadata.placeholder);
                        }
                    },

                    should: {
                        autoplay: function() {
                            return (settings.autoplay === 'auto')
                                ? (settings.placeholder || $module.data(metadata.placeholder) !== undefined)
                                : settings.autoplay
                                ;
                        }
                    },

                    is: {
                        video: function() {
                            return module.get.type() == 'video';
                        }
                    },

                    setting: function(name, value) {
                        module.debug('Changing setting', name, value);
                        if( $.isPlainObject(name) ) {
                            $.extend(true, settings, name);
                        }
                        else if(value !== undefined) {
                            settings[name] = value;
                        }
                        else {
                            return settings[name];
                        }
                    },
                    internal: function(name, value) {
                        if( $.isPlainObject(name) ) {
                            $.extend(true, module, name);
                        }
                        else if(value !== undefined) {
                            module[name] = value;
                        }
                        else {
                            return module[name];
                        }
                    },
                    debug: function() {
                        if(settings.debug) {
                            if(settings.performance) {
                                module.performance.log(arguments);
                            }
                            else {
                                module.debug = Function.prototype.bind.call(console.info, console, settings.name + ':');
                                module.debug.apply(console, arguments);
                            }
                        }
                    },
                    verbose: function() {
                        if(settings.verbose && settings.debug) {
                            if(settings.performance) {
                                module.performance.log(arguments);
                            }
                            else {
                                module.verbose = Function.prototype.bind.call(console.info, console, settings.name + ':');
                                module.verbose.apply(console, arguments);
                            }
                        }
                    },
                    error: function() {
                        module.error = Function.prototype.bind.call(console.error, console, settings.name + ':');
                        module.error.apply(console, arguments);
                    },
                    performance: {
                        log: function(message) {
                            var
                                currentTime,
                                executionTime,
                                previousTime
                                ;
                            if(settings.performance) {
                                currentTime   = new Date().getTime();
                                previousTime  = time || currentTime;
                                executionTime = currentTime - previousTime;
                                time          = currentTime;
                                performance.push({
                                    'Name'           : message[0],
                                    'Arguments'      : [].slice.call(message, 1) || '',
                                    'Element'        : element,
                                    'Execution Time' : executionTime
                                });
                            }
                            clearTimeout(module.performance.timer);
                            module.performance.timer = setTimeout(module.performance.display, 500);
                        },
                        display: function() {
                            var
                                title = settings.name + ':',
                                totalTime = 0
                                ;
                            time = false;
                            clearTimeout(module.performance.timer);
                            $.each(performance, function(index, data) {
                                totalTime += data['Execution Time'];
                            });
                            title += ' ' + totalTime + 'ms';
                            if(moduleSelector) {
                                title += ' \'' + moduleSelector + '\'';
                            }
                            if($allModules.length > 1) {
                                title += ' ' + '(' + $allModules.length + ')';
                            }
                            if( (console.group !== undefined || console.table !== undefined) && performance.length > 0) {
                                console.groupCollapsed(title);
                                if(console.table) {
                                    console.table(performance);
                                }
                                else {
                                    $.each(performance, function(index, data) {
                                        console.log(data['Name'] + ': ' + data['Execution Time']+'ms');
                                    });
                                }
                                console.groupEnd();
                            }
                            performance = [];
                        }
                    },
                    invoke: function(query, passedArguments, context) {
                        var
                            object = instance,
                            maxDepth,
                            found,
                            response
                            ;
                        passedArguments = passedArguments || queryArguments;
                        context         = element         || context;
                        if(typeof query == 'string' && object !== undefined) {
                            query    = query.split(/[\. ]/);
                            maxDepth = query.length - 1;
                            $.each(query, function(depth, value) {
                                var camelCaseValue = (depth != maxDepth)
                                        ? value + query[depth + 1].charAt(0).toUpperCase() + query[depth + 1].slice(1)
                                        : query
                                    ;
                                if( $.isPlainObject( object[camelCaseValue] ) && (depth != maxDepth) ) {
                                    object = object[camelCaseValue];
                                }
                                else if( object[camelCaseValue] !== undefined ) {
                                    found = object[camelCaseValue];
                                    return false;
                                }
                                else if( $.isPlainObject( object[value] ) && (depth != maxDepth) ) {
                                    object = object[value];
                                }
                                else if( object[value] !== undefined ) {
                                    found = object[value];
                                    return false;
                                }
                                else {
                                    module.error(error.method, query);
                                    return false;
                                }
                            });
                        }
                        if ( $.isFunction( found ) ) {
                            response = found.apply(context, passedArguments);
                        }
                        else if(found !== undefined) {
                            response = found;
                        }
                        if($.isArray(returnedValue)) {
                            returnedValue.push(response);
                        }
                        else if(returnedValue !== undefined) {
                            returnedValue = [returnedValue, response];
                        }
                        else if(response !== undefined) {
                            returnedValue = response;
                        }
                        return found;
                    }
                };

                if(methodInvoked) {
                    if(instance === undefined) {
                        module.initialize();
                    }
                    module.invoke(query);
                }
                else {
                    if(instance !== undefined) {
                        instance.invoke('destroy');
                    }
                    module.initialize();
                }
            })
        ;
        return (returnedValue !== undefined)
            ? returnedValue
            : this
            ;
    };

    $.fn.embed.settings = {

        name        : 'Embed',
        namespace   : 'embed',

        debug       : false,
        verbose     : false,
        performance : true,

        icon     : false,
        source   : false,
        url      : false,
        id       : false,

        // standard video settings
        autoplay  : 'auto',
        color     : '#444444',
        hd        : true,
        brandedUI : false,

        // additional parameters to include with the embed
        parameters: false,

        onDisplay            : function() {},
        onPlaceholderDisplay : function() {},
        onReset              : function() {},
        onCreate             : function(url) {},
        onEmbed              : function(parameters) {
            return parameters;
        },

        metadata    : {
            id          : 'id',
            icon        : 'icon',
            placeholder : 'placeholder',
            source      : 'source',
            url         : 'url'
        },

        error : {
            noURL  : 'No URL specified',
            method : 'The method you called is not defined'
        },

        className : {
            active : 'active',
            embed  : 'embed'
        },

        selector : {
            embed       : '.embed',
            placeholder : '.placeholder',
            icon        : '.icon'
        },

        sources: {
            youtube: {
                name   : 'youtube',
                type   : 'video',
                icon   : 'video play',
                domain : 'youtube.com',
                url    : '//www.youtube.com/embed/{id}',
                parameters: function(settings) {
                    return {
                        autohide       : !settings.brandedUI,
                        autoplay       : settings.autoplay,
                        color          : settings.colors || undefined,
                        hq             : settings.hd,
                        jsapi          : settings.api,
                        modestbranding : !settings.brandedUI
                    };
                }
            },
            vimeo: {
                name   : 'vimeo',
                type   : 'video',
                icon   : 'video play',
                domain : 'vimeo.com',
                url    : '//player.vimeo.com/video/{id}',
                parameters: function(settings) {
                    return {
                        api      : settings.api,
                        autoplay : settings.autoplay,
                        byline   : settings.brandedUI,
                        color    : settings.colors || undefined,
                        portrait : settings.brandedUI,
                        title    : settings.brandedUI
                    };
                }
            }
        },

        templates: {
            iframe : function(url, parameters) {
                return ''
                    + '<iframe src="' + url + '?' + parameters + '"'
                    + ' width="100%" height="100%"'
                    + ' frameborder="0" scrolling="no" webkitAllowFullScreen mozallowfullscreen allowFullScreen></iframe>'
                    ;
            },
            placeholder : function(image, icon) {
                var
                    html = ''
                    ;
                if(icon) {
                    html += '<i class="' + icon + ' icon"></i>';
                }
                if(image) {
                    html += '<img class="placeholder" src="' + image + '">';
                }
                return html;
            }
        },

        // NOT YET IMPLEMENTED
        api     : true,
        onPause : function() {},
        onPlay  : function() {},
        onStop  : function() {}

    };



})( jQuery, window, document );

/*!
 * # Semantic UI 2.1.6 - Modal
 * http://github.com/semantic-org/semantic-ui/
 *
 *
 * Copyright 2015 Contributors
 * Released under the MIT license
 * http://opensource.org/licenses/MIT
 *
 */

;(function ( $, window, document, undefined ) {

    "use strict";

    $.fn.modal = function(parameters) {
        var
            $allModules    = $(this),
            $window        = $(window),
            $document      = $(document),
            $body          = $('body'),

            moduleSelector = $allModules.selector || '',

            time           = new Date().getTime(),
            performance    = [],

            query          = arguments[0],
            methodInvoked  = (typeof query == 'string'),
            queryArguments = [].slice.call(arguments, 1),

            requestAnimationFrame = window.requestAnimationFrame
                || window.mozRequestAnimationFrame
                || window.webkitRequestAnimationFrame
                || window.msRequestAnimationFrame
                || function(callback) { setTimeout(callback, 0); },

            returnedValue
            ;

        $allModules
            .each(function() {
                var
                    settings    = ( $.isPlainObject(parameters) )
                        ? $.extend(true, {}, $.fn.modal.settings, parameters)
                        : $.extend({}, $.fn.modal.settings),

                    selector        = settings.selector,
                    className       = settings.className,
                    namespace       = settings.namespace,
                    error           = settings.error,

                    eventNamespace  = '.' + namespace,
                    moduleNamespace = 'module-' + namespace,

                    $module         = $(this),
                    $context        = $(settings.context),
                    $close          = $module.find(selector.close),

                    $allModals,
                    $otherModals,
                    $focusedElement,
                    $dimmable,
                    $dimmer,

                    element         = this,
                    instance        = $module.data(moduleNamespace),

                    elementNamespace,
                    id,
                    observer,
                    module
                    ;
                module  = {

                    initialize: function() {
                        module.verbose('Initializing dimmer', $context);

                        module.create.id();
                        module.create.dimmer();
                        module.refreshModals();

                        module.bind.events();
                        if(settings.observeChanges) {
                            module.observeChanges();
                        }
                        module.instantiate();
                    },

                    instantiate: function() {
                        module.verbose('Storing instance of modal');
                        instance = module;
                        $module
                            .data(moduleNamespace, instance)
                        ;
                    },

                    create: {
                        dimmer: function() {
                            var
                                defaultSettings = {
                                    debug      : settings.debug,
                                    dimmerName : 'modals',
                                    duration   : {
                                        show     : settings.duration,
                                        hide     : settings.duration
                                    }
                                },
                                dimmerSettings = $.extend(true, defaultSettings, settings.dimmerSettings)
                                ;
                            if(settings.inverted) {
                                dimmerSettings.variation = (dimmerSettings.variation !== undefined)
                                    ? dimmerSettings.variation + ' inverted'
                                    : 'inverted'
                                ;
                            }
                            if($.fn.dimmer === undefined) {
                                module.error(error.dimmer);
                                return;
                            }
                            module.debug('Creating dimmer with settings', dimmerSettings);
                            $dimmable = $context.dimmer(dimmerSettings);
                            if(settings.detachable) {
                                module.verbose('Modal is detachable, moving content into dimmer');
                                $dimmable.dimmer('add content', $module);
                            }
                            else {
                                module.set.undetached();
                            }
                            if(settings.blurring) {
                                $dimmable.addClass(className.blurring);
                            }
                            $dimmer = $dimmable.dimmer('get dimmer');
                        },
                        id: function() {
                            id = (Math.random().toString(16) + '000000000').substr(2,8);
                            elementNamespace = '.' + id;
                            module.verbose('Creating unique id for element', id);
                        }
                    },

                    destroy: function() {
                        module.verbose('Destroying previous modal');
                        $module
                            .removeData(moduleNamespace)
                            .off(eventNamespace)
                        ;
                        $window.off(elementNamespace);
                        $close.off(eventNamespace);
                        $context.dimmer('destroy');
                    },

                    observeChanges: function() {
                        if('MutationObserver' in window) {
                            observer = new MutationObserver(function(mutations) {
                                module.debug('DOM tree modified, refreshing');
                                module.refresh();
                            });
                            observer.observe(element, {
                                childList : true,
                                subtree   : true
                            });
                            module.debug('Setting up mutation observer', observer);
                        }
                    },

                    refresh: function() {
                        module.remove.scrolling();
                        module.cacheSizes();
                        module.set.screenHeight();
                        module.set.type();
                        module.set.position();
                    },

                    refreshModals: function() {
                        $otherModals = $module.siblings(selector.modal);
                        $allModals   = $otherModals.add($module);
                    },

                    attachEvents: function(selector, event) {
                        var
                            $toggle = $(selector)
                            ;
                        event = $.isFunction(module[event])
                            ? module[event]
                            : module.toggle
                        ;
                        if($toggle.length > 0) {
                            module.debug('Attaching modal events to element', selector, event);
                            $toggle
                                .off(eventNamespace)
                                .on('click' + eventNamespace, event)
                            ;
                        }
                        else {
                            module.error(error.notFound, selector);
                        }
                    },

                    bind: {
                        events: function() {
                            module.verbose('Attaching events');
                            $module
                                .on('click' + eventNamespace, selector.close, module.event.close)
                                .on('click' + eventNamespace, selector.approve, module.event.approve)
                                .on('click' + eventNamespace, selector.deny, module.event.deny)
                            ;
                            $window
                                .on('resize' + elementNamespace, module.event.resize)
                            ;
                        }
                    },

                    get: {
                        id: function() {
                            return (Math.random().toString(16) + '000000000').substr(2,8);
                        }
                    },

                    event: {
                        approve: function() {
                            if(settings.onApprove.call(element, $(this)) === false) {
                                module.verbose('Approve callback returned false cancelling hide');
                                return;
                            }
                            module.hide();
                        },
                        deny: function() {
                            if(settings.onDeny.call(element, $(this)) === false) {
                                module.verbose('Deny callback returned false cancelling hide');
                                return;
                            }
                            module.hide();
                        },
                        close: function() {
                            module.hide();
                        },
                        click: function(event) {
                            var
                                $target   = $(event.target),
                                isInModal = ($target.closest(selector.modal).length > 0),
                                isInDOM   = $.contains(document.documentElement, event.target)
                                ;
                            if(!isInModal && isInDOM) {
                                module.debug('Dimmer clicked, hiding all modals');
                                if( module.is.active() ) {
                                    module.remove.clickaway();
                                    if(settings.allowMultiple) {
                                        module.hide();
                                    }
                                    else {
                                        module.hideAll();
                                    }
                                }
                            }
                        },
                        debounce: function(method, delay) {
                            clearTimeout(module.timer);
                            module.timer = setTimeout(method, delay);
                        },
                        keyboard: function(event) {
                            var
                                keyCode   = event.which,
                                escapeKey = 27
                                ;
                            if(keyCode == escapeKey) {
                                if(settings.closable) {
                                    module.debug('Escape key pressed hiding modal');
                                    module.hide();
                                }
                                else {
                                    module.debug('Escape key pressed, but closable is set to false');
                                }
                                event.preventDefault();
                            }
                        },
                        resize: function() {
                            if( $dimmable.dimmer('is active') ) {
                                requestAnimationFrame(module.refresh);
                            }
                        }
                    },

                    toggle: function() {
                        if( module.is.active() || module.is.animating() ) {
                            module.hide();
                        }
                        else {
                            module.show();
                        }
                    },

                    show: function(callback) {
                        callback = $.isFunction(callback)
                            ? callback
                            : function(){}
                        ;
                        module.refreshModals();
                        module.showModal(callback);
                    },

                    hide: function(callback) {
                        callback = $.isFunction(callback)
                            ? callback
                            : function(){}
                        ;
                        module.refreshModals();
                        module.hideModal(callback);
                    },

                    showModal: function(callback) {
                        callback = $.isFunction(callback)
                            ? callback
                            : function(){}
                        ;
                        if( module.is.animating() || !module.is.active() ) {

                            module.showDimmer();
                            module.cacheSizes();
                            module.set.position();
                            module.set.screenHeight();
                            module.set.type();
                            module.set.clickaway();

                            if( !settings.allowMultiple && module.others.active() ) {
                                module.hideOthers(module.showModal);
                            }
                            else {
                                settings.onShow.call(element);
                                if(settings.transition && $.fn.transition !== undefined && $module.transition('is supported')) {
                                    module.debug('Showing modal with css animations');
                                    $module
                                        .transition({
                                            debug       : settings.debug,
                                            animation   : settings.transition + ' in',
                                            queue       : settings.queue,
                                            duration    : settings.duration,
                                            useFailSafe : true,
                                            onComplete : function() {
                                                settings.onVisible.apply(element);
                                                module.add.keyboardShortcuts();
                                                module.save.focus();
                                                module.set.active();
                                                if(settings.autofocus) {
                                                    module.set.autofocus();
                                                }
                                                callback();
                                            }
                                        })
                                    ;
                                }
                                else {
                                    module.error(error.noTransition);
                                }
                            }
                        }
                        else {
                            module.debug('Modal is already visible');
                        }
                    },

                    hideModal: function(callback, keepDimmed) {
                        callback = $.isFunction(callback)
                            ? callback
                            : function(){}
                        ;
                        module.debug('Hiding modal');
                        if(settings.onHide.call(element, $(this)) === false) {
                            module.verbose('Hide callback returned false cancelling hide');
                            return;
                        }

                        if( module.is.animating() || module.is.active() ) {
                            if(settings.transition && $.fn.transition !== undefined && $module.transition('is supported')) {
                                module.remove.active();
                                $module
                                    .transition({
                                        debug       : settings.debug,
                                        animation   : settings.transition + ' out',
                                        queue       : settings.queue,
                                        duration    : settings.duration,
                                        useFailSafe : true,
                                        onStart     : function() {
                                            if(!module.others.active() && !keepDimmed) {
                                                module.hideDimmer();
                                            }
                                            module.remove.keyboardShortcuts();
                                        },
                                        onComplete : function() {
                                            settings.onHidden.call(element);
                                            module.restore.focus();
                                            callback();
                                        }
                                    })
                                ;
                            }
                            else {
                                module.error(error.noTransition);
                            }
                        }
                    },

                    showDimmer: function() {
                        if($dimmable.dimmer('is animating') || !$dimmable.dimmer('is active') ) {
                            module.debug('Showing dimmer');
                            $dimmable.dimmer('show');
                        }
                        else {
                            module.debug('Dimmer already visible');
                        }
                    },

                    hideDimmer: function() {
                        if( $dimmable.dimmer('is animating') || ($dimmable.dimmer('is active')) ) {
                            $dimmable.dimmer('hide', function() {
                                module.remove.clickaway();
                                module.remove.screenHeight();
                            });
                        }
                        else {
                            module.debug('Dimmer is not visible cannot hide');
                            return;
                        }
                    },

                    hideAll: function(callback) {
                        var
                            $visibleModals = $allModals.filter('.' + className.active + ', .' + className.animating)
                            ;
                        callback = $.isFunction(callback)
                            ? callback
                            : function(){}
                        ;
                        if( $visibleModals.length > 0 ) {
                            module.debug('Hiding all visible modals');
                            module.hideDimmer();
                            $visibleModals
                                .modal('hide modal', callback)
                            ;
                        }
                    },

                    hideOthers: function(callback) {
                        var
                            $visibleModals = $otherModals.filter('.' + className.active + ', .' + className.animating)
                            ;
                        callback = $.isFunction(callback)
                            ? callback
                            : function(){}
                        ;
                        if( $visibleModals.length > 0 ) {
                            module.debug('Hiding other modals', $otherModals);
                            $visibleModals
                                .modal('hide modal', callback, true)
                            ;
                        }
                    },

                    others: {
                        active: function() {
                            return ($otherModals.filter('.' + className.active).length > 0);
                        },
                        animating: function() {
                            return ($otherModals.filter('.' + className.animating).length > 0);
                        }
                    },


                    add: {
                        keyboardShortcuts: function() {
                            module.verbose('Adding keyboard shortcuts');
                            $document
                                .on('keyup' + eventNamespace, module.event.keyboard)
                            ;
                        }
                    },

                    save: {
                        focus: function() {
                            $focusedElement = $(document.activeElement).blur();
                        }
                    },

                    restore: {
                        focus: function() {
                            if($focusedElement && $focusedElement.length > 0) {
                                $focusedElement.focus();
                            }
                        }
                    },

                    remove: {
                        active: function() {
                            $module.removeClass(className.active);
                        },
                        clickaway: function() {
                            if(settings.closable) {
                                $dimmer
                                    .off('click' + elementNamespace)
                                ;
                            }
                        },
                        bodyStyle: function() {
                            if($body.attr('style') === '') {
                                module.verbose('Removing style attribute');
                                $body.removeAttr('style');
                            }
                        },
                        screenHeight: function() {
                            module.debug('Removing page height');
                            $body
                                .css('height', '')
                            ;
                        },
                        keyboardShortcuts: function() {
                            module.verbose('Removing keyboard shortcuts');
                            $document
                                .off('keyup' + eventNamespace)
                            ;
                        },
                        scrolling: function() {
                            $dimmable.removeClass(className.scrolling);
                            $module.removeClass(className.scrolling);
                        }
                    },

                    cacheSizes: function() {
                        var
                            modalHeight = $module.outerHeight()
                            ;
                        if(module.cache === undefined || modalHeight !== 0) {
                            module.cache = {
                                pageHeight    : $(document).outerHeight(),
                                height        : modalHeight + settings.offset,
                                contextHeight : (settings.context == 'body')
                                    ? $(window).height()
                                    : $dimmable.height()
                            };
                        }
                        module.debug('Caching modal and container sizes', module.cache);
                    },

                    can: {
                        fit: function() {
                            return ( ( module.cache.height + (settings.padding * 2) ) < module.cache.contextHeight);
                        }
                    },

                    is: {
                        active: function() {
                            return $module.hasClass(className.active);
                        },
                        animating: function() {
                            return $module.transition('is supported')
                                ? $module.transition('is animating')
                                : $module.is(':visible')
                                ;
                        },
                        scrolling: function() {
                            return $dimmable.hasClass(className.scrolling);
                        },
                        modernBrowser: function() {
                            // appName for IE11 reports 'Netscape' can no longer use
                            return !(window.ActiveXObject || "ActiveXObject" in window);
                        }
                    },

                    set: {
                        autofocus: function() {
                            var
                                $inputs    = $module.find(':input').filter(':visible'),
                                $autofocus = $inputs.filter('[autofocus]'),
                                $input     = ($autofocus.length > 0)
                                    ? $autofocus.first()
                                    : $inputs.first()
                                ;
                            if($input.length > 0) {
                                $input.focus();
                            }
                        },
                        clickaway: function() {
                            if(settings.closable) {
                                $dimmer
                                    .on('click' + elementNamespace, module.event.click)
                                ;
                            }
                        },
                        screenHeight: function() {
                            if( module.can.fit() ) {
                                $body.css('height', '');
                            }
                            else {
                                module.debug('Modal is taller than page content, resizing page height');
                                $body
                                    .css('height', module.cache.height + (settings.padding * 2) )
                                ;
                            }
                        },
                        active: function() {
                            $module.addClass(className.active);
                        },
                        scrolling: function() {
                            $dimmable.addClass(className.scrolling);
                            $module.addClass(className.scrolling);
                        },
                        type: function() {
                            if(module.can.fit()) {
                                module.verbose('Modal fits on screen');
                                if(!module.others.active() && !module.others.animating()) {
                                    module.remove.scrolling();
                                }
                            }
                            else {
                                module.verbose('Modal cannot fit on screen setting to scrolling');
                                module.set.scrolling();
                            }
                        },
                        position: function() {
                            module.verbose('Centering modal on page', module.cache);
                            if(module.can.fit()) {
                                $module
                                    .css({
                                        top: '',
                                        marginTop: -(module.cache.height / 2)
                                    })
                                ;
                            }
                            else {
                                $module
                                    .css({
                                        marginTop : '',
                                        top       : $document.scrollTop()
                                    })
                                ;
                            }
                        },
                        undetached: function() {
                            $dimmable.addClass(className.undetached);
                        }
                    },

                    setting: function(name, value) {
                        module.debug('Changing setting', name, value);
                        if( $.isPlainObject(name) ) {
                            $.extend(true, settings, name);
                        }
                        else if(value !== undefined) {
                            settings[name] = value;
                        }
                        else {
                            return settings[name];
                        }
                    },
                    internal: function(name, value) {
                        if( $.isPlainObject(name) ) {
                            $.extend(true, module, name);
                        }
                        else if(value !== undefined) {
                            module[name] = value;
                        }
                        else {
                            return module[name];
                        }
                    },
                    debug: function() {
                        if(settings.debug) {
                            if(settings.performance) {
                                module.performance.log(arguments);
                            }
                            else {
                                module.debug = Function.prototype.bind.call(console.info, console, settings.name + ':');
                                module.debug.apply(console, arguments);
                            }
                        }
                    },
                    verbose: function() {
                        if(settings.verbose && settings.debug) {
                            if(settings.performance) {
                                module.performance.log(arguments);
                            }
                            else {
                                module.verbose = Function.prototype.bind.call(console.info, console, settings.name + ':');
                                module.verbose.apply(console, arguments);
                            }
                        }
                    },
                    error: function() {
                        module.error = Function.prototype.bind.call(console.error, console, settings.name + ':');
                        module.error.apply(console, arguments);
                    },
                    performance: {
                        log: function(message) {
                            var
                                currentTime,
                                executionTime,
                                previousTime
                                ;
                            if(settings.performance) {
                                currentTime   = new Date().getTime();
                                previousTime  = time || currentTime;
                                executionTime = currentTime - previousTime;
                                time          = currentTime;
                                performance.push({
                                    'Name'           : message[0],
                                    'Arguments'      : [].slice.call(message, 1) || '',
                                    'Element'        : element,
                                    'Execution Time' : executionTime
                                });
                            }
                            clearTimeout(module.performance.timer);
                            module.performance.timer = setTimeout(module.performance.display, 500);
                        },
                        display: function() {
                            var
                                title = settings.name + ':',
                                totalTime = 0
                                ;
                            time = false;
                            clearTimeout(module.performance.timer);
                            $.each(performance, function(index, data) {
                                totalTime += data['Execution Time'];
                            });
                            title += ' ' + totalTime + 'ms';
                            if(moduleSelector) {
                                title += ' \'' + moduleSelector + '\'';
                            }
                            if( (console.group !== undefined || console.table !== undefined) && performance.length > 0) {
                                console.groupCollapsed(title);
                                if(console.table) {
                                    console.table(performance);
                                }
                                else {
                                    $.each(performance, function(index, data) {
                                        console.log(data['Name'] + ': ' + data['Execution Time']+'ms');
                                    });
                                }
                                console.groupEnd();
                            }
                            performance = [];
                        }
                    },
                    invoke: function(query, passedArguments, context) {
                        var
                            object = instance,
                            maxDepth,
                            found,
                            response
                            ;
                        passedArguments = passedArguments || queryArguments;
                        context         = element         || context;
                        if(typeof query == 'string' && object !== undefined) {
                            query    = query.split(/[\. ]/);
                            maxDepth = query.length - 1;
                            $.each(query, function(depth, value) {
                                var camelCaseValue = (depth != maxDepth)
                                        ? value + query[depth + 1].charAt(0).toUpperCase() + query[depth + 1].slice(1)
                                        : query
                                    ;
                                if( $.isPlainObject( object[camelCaseValue] ) && (depth != maxDepth) ) {
                                    object = object[camelCaseValue];
                                }
                                else if( object[camelCaseValue] !== undefined ) {
                                    found = object[camelCaseValue];
                                    return false;
                                }
                                else if( $.isPlainObject( object[value] ) && (depth != maxDepth) ) {
                                    object = object[value];
                                }
                                else if( object[value] !== undefined ) {
                                    found = object[value];
                                    return false;
                                }
                                else {
                                    return false;
                                }
                            });
                        }
                        if ( $.isFunction( found ) ) {
                            response = found.apply(context, passedArguments);
                        }
                        else if(found !== undefined) {
                            response = found;
                        }
                        if($.isArray(returnedValue)) {
                            returnedValue.push(response);
                        }
                        else if(returnedValue !== undefined) {
                            returnedValue = [returnedValue, response];
                        }
                        else if(response !== undefined) {
                            returnedValue = response;
                        }
                        return found;
                    }
                };

                if(methodInvoked) {
                    if(instance === undefined) {
                        module.initialize();
                    }
                    module.invoke(query);
                }
                else {
                    if(instance !== undefined) {
                        instance.invoke('destroy');
                    }
                    module.initialize();
                }
            })
        ;

        return (returnedValue !== undefined)
            ? returnedValue
            : this
            ;
    };

    $.fn.modal.settings = {

        name           : 'Modal',
        namespace      : 'modal',

        debug          : false,
        verbose        : false,
        performance    : true,

        observeChanges : false,

        allowMultiple  : false,
        detachable     : true,
        closable       : true,
        autofocus      : true,

        inverted       : false,
        blurring       : false,

        dimmerSettings : {
            closable : false,
            useCSS   : true
        },


        context    : 'body',

        queue      : false,
        duration   : 500,
        offset     : 0,
        transition : 'scale',

        // padding with edge of page
        padding    : 50,

        // called before show animation
        onShow     : function(){},

        // called after show animation
        onVisible  : function(){},

        // called before hide animation
        onHide     : function(){ return true; },

        // called after hide animation
        onHidden   : function(){},

        // called after approve selector match
        onApprove  : function(){ return true; },

        // called after deny selector match
        onDeny     : function(){ return true; },

        selector    : {
            close    : '> .close',
            approve  : '.actions .positive, .actions .approve, .actions .ok',
            deny     : '.actions .negative, .actions .deny, .actions .cancel',
            modal    : '.ui.modal'
        },
        error : {
            dimmer    : 'UI Dimmer, a required component is not included in this page',
            method    : 'The method you called is not defined.',
            notFound  : 'The element you specified could not be found'
        },
        className : {
            active     : 'active',
            animating  : 'animating',
            blurring   : 'blurring',
            scrolling  : 'scrolling',
            undetached : 'undetached'
        }
    };


})( jQuery, window, document );

/*!
 * # Semantic UI 2.1.6 - Nag
 * http://github.com/semantic-org/semantic-ui/
 *
 *
 * Copyright 2015 Contributors
 * Released under the MIT license
 * http://opensource.org/licenses/MIT
 *
 */

;(function ($, window, document, undefined) {

    "use strict";

    $.fn.nag = function(parameters) {
        var
            $allModules    = $(this),
            moduleSelector = $allModules.selector || '',

            time           = new Date().getTime(),
            performance    = [],

            query          = arguments[0],
            methodInvoked  = (typeof query == 'string'),
            queryArguments = [].slice.call(arguments, 1),
            returnedValue
            ;
        $allModules
            .each(function() {
                var
                    settings          = ( $.isPlainObject(parameters) )
                        ? $.extend(true, {}, $.fn.nag.settings, parameters)
                        : $.extend({}, $.fn.nag.settings),

                    className       = settings.className,
                    selector        = settings.selector,
                    error           = settings.error,
                    namespace       = settings.namespace,

                    eventNamespace  = '.' + namespace,
                    moduleNamespace = namespace + '-module',

                    $module         = $(this),

                    $close          = $module.find(selector.close),
                    $context        = (settings.context)
                        ? $(settings.context)
                        : $('body'),

                    element         = this,
                    instance        = $module.data(moduleNamespace),

                    moduleOffset,
                    moduleHeight,

                    contextWidth,
                    contextHeight,
                    contextOffset,

                    yOffset,
                    yPosition,

                    timer,
                    module,

                    requestAnimationFrame = window.requestAnimationFrame
                        || window.mozRequestAnimationFrame
                        || window.webkitRequestAnimationFrame
                        || window.msRequestAnimationFrame
                        || function(callback) { setTimeout(callback, 0); }
                    ;
                module = {

                    initialize: function() {
                        module.verbose('Initializing element');

                        $module
                            .on('click' + eventNamespace, selector.close, module.dismiss)
                            .data(moduleNamespace, module)
                        ;

                        if(settings.detachable && $module.parent()[0] !== $context[0]) {
                            $module
                                .detach()
                                .prependTo($context)
                            ;
                        }

                        if(settings.displayTime > 0) {
                            setTimeout(module.hide, settings.displayTime);
                        }
                        module.show();
                    },

                    destroy: function() {
                        module.verbose('Destroying instance');
                        $module
                            .removeData(moduleNamespace)
                            .off(eventNamespace)
                        ;
                    },

                    show: function() {
                        if( module.should.show() && !$module.is(':visible') ) {
                            module.debug('Showing nag', settings.animation.show);
                            if(settings.animation.show == 'fade') {
                                $module
                                    .fadeIn(settings.duration, settings.easing)
                                ;
                            }
                            else {
                                $module
                                    .slideDown(settings.duration, settings.easing)
                                ;
                            }
                        }
                    },

                    hide: function() {
                        module.debug('Showing nag', settings.animation.hide);
                        if(settings.animation.show == 'fade') {
                            $module
                                .fadeIn(settings.duration, settings.easing)
                            ;
                        }
                        else {
                            $module
                                .slideUp(settings.duration, settings.easing)
                            ;
                        }
                    },

                    onHide: function() {
                        module.debug('Removing nag', settings.animation.hide);
                        $module.remove();
                        if (settings.onHide) {
                            settings.onHide();
                        }
                    },

                    dismiss: function(event) {
                        if(settings.storageMethod) {
                            module.storage.set(settings.key, settings.value);
                        }
                        module.hide();
                        event.stopImmediatePropagation();
                        event.preventDefault();
                    },

                    should: {
                        show: function() {
                            if(settings.persist) {
                                module.debug('Persistent nag is set, can show nag');
                                return true;
                            }
                            if( module.storage.get(settings.key) != settings.value.toString() ) {
                                module.debug('Stored value is not set, can show nag', module.storage.get(settings.key));
                                return true;
                            }
                            module.debug('Stored value is set, cannot show nag', module.storage.get(settings.key));
                            return false;
                        }
                    },

                    get: {
                        storageOptions: function() {
                            var
                                options = {}
                                ;
                            if(settings.expires) {
                                options.expires = settings.expires;
                            }
                            if(settings.domain) {
                                options.domain = settings.domain;
                            }
                            if(settings.path) {
                                options.path = settings.path;
                            }
                            return options;
                        }
                    },

                    clear: function() {
                        module.storage.remove(settings.key);
                    },

                    storage: {
                        set: function(key, value) {
                            var
                                options = module.get.storageOptions()
                                ;
                            if(settings.storageMethod == 'localstorage' && window.localStorage !== undefined) {
                                window.localStorage.setItem(key, value);
                                module.debug('Value stored using local storage', key, value);
                            }
                            else if(settings.storageMethod == 'sessionstorage' && window.sessionStorage !== undefined) {
                                window.sessionStorage.setItem(key, value);
                                module.debug('Value stored using session storage', key, value);
                            }
                            else if($.cookie !== undefined) {
                                $.cookie(key, value, options);
                                module.debug('Value stored using cookie', key, value, options);
                            }
                            else {
                                module.error(error.noCookieStorage);
                                return;
                            }
                        },
                        get: function(key, value) {
                            var
                                storedValue
                                ;
                            if(settings.storageMethod == 'localstorage' && window.localStorage !== undefined) {
                                storedValue = window.localStorage.getItem(key);
                            }
                            else if(settings.storageMethod == 'sessionstorage' && window.sessionStorage !== undefined) {
                                storedValue = window.sessionStorage.getItem(key);
                            }
                            // get by cookie
                            else if($.cookie !== undefined) {
                                storedValue = $.cookie(key);
                            }
                            else {
                                module.error(error.noCookieStorage);
                            }
                            if(storedValue == 'undefined' || storedValue == 'null' || storedValue === undefined || storedValue === null) {
                                storedValue = undefined;
                            }
                            return storedValue;
                        },
                        remove: function(key) {
                            var
                                options = module.get.storageOptions()
                                ;
                            if(settings.storageMethod == 'localstorage' && window.localStorage !== undefined) {
                                window.localStorage.removeItem(key);
                            }
                            else if(settings.storageMethod == 'sessionstorage' && window.sessionStorage !== undefined) {
                                window.sessionStorage.removeItem(key);
                            }
                            // store by cookie
                            else if($.cookie !== undefined) {
                                $.removeCookie(key, options);
                            }
                            else {
                                module.error(error.noStorage);
                            }
                        }
                    },

                    setting: function(name, value) {
                        module.debug('Changing setting', name, value);
                        if( $.isPlainObject(name) ) {
                            $.extend(true, settings, name);
                        }
                        else if(value !== undefined) {
                            settings[name] = value;
                        }
                        else {
                            return settings[name];
                        }
                    },
                    internal: function(name, value) {
                        if( $.isPlainObject(name) ) {
                            $.extend(true, module, name);
                        }
                        else if(value !== undefined) {
                            module[name] = value;
                        }
                        else {
                            return module[name];
                        }
                    },
                    debug: function() {
                        if(settings.debug) {
                            if(settings.performance) {
                                module.performance.log(arguments);
                            }
                            else {
                                module.debug = Function.prototype.bind.call(console.info, console, settings.name + ':');
                                module.debug.apply(console, arguments);
                            }
                        }
                    },
                    verbose: function() {
                        if(settings.verbose && settings.debug) {
                            if(settings.performance) {
                                module.performance.log(arguments);
                            }
                            else {
                                module.verbose = Function.prototype.bind.call(console.info, console, settings.name + ':');
                                module.verbose.apply(console, arguments);
                            }
                        }
                    },
                    error: function() {
                        module.error = Function.prototype.bind.call(console.error, console, settings.name + ':');
                        module.error.apply(console, arguments);
                    },
                    performance: {
                        log: function(message) {
                            var
                                currentTime,
                                executionTime,
                                previousTime
                                ;
                            if(settings.performance) {
                                currentTime   = new Date().getTime();
                                previousTime  = time || currentTime;
                                executionTime = currentTime - previousTime;
                                time          = currentTime;
                                performance.push({
                                    'Name'           : message[0],
                                    'Arguments'      : [].slice.call(message, 1) || '',
                                    'Element'        : element,
                                    'Execution Time' : executionTime
                                });
                            }
                            clearTimeout(module.performance.timer);
                            module.performance.timer = setTimeout(module.performance.display, 500);
                        },
                        display: function() {
                            var
                                title = settings.name + ':',
                                totalTime = 0
                                ;
                            time = false;
                            clearTimeout(module.performance.timer);
                            $.each(performance, function(index, data) {
                                totalTime += data['Execution Time'];
                            });
                            title += ' ' + totalTime + 'ms';
                            if(moduleSelector) {
                                title += ' \'' + moduleSelector + '\'';
                            }
                            if( (console.group !== undefined || console.table !== undefined) && performance.length > 0) {
                                console.groupCollapsed(title);
                                if(console.table) {
                                    console.table(performance);
                                }
                                else {
                                    $.each(performance, function(index, data) {
                                        console.log(data['Name'] + ': ' + data['Execution Time']+'ms');
                                    });
                                }
                                console.groupEnd();
                            }
                            performance = [];
                        }
                    },
                    invoke: function(query, passedArguments, context) {
                        var
                            object = instance,
                            maxDepth,
                            found,
                            response
                            ;
                        passedArguments = passedArguments || queryArguments;
                        context         = element         || context;
                        if(typeof query == 'string' && object !== undefined) {
                            query    = query.split(/[\. ]/);
                            maxDepth = query.length - 1;
                            $.each(query, function(depth, value) {
                                var camelCaseValue = (depth != maxDepth)
                                        ? value + query[depth + 1].charAt(0).toUpperCase() + query[depth + 1].slice(1)
                                        : query
                                    ;
                                if( $.isPlainObject( object[camelCaseValue] ) && (depth != maxDepth) ) {
                                    object = object[camelCaseValue];
                                }
                                else if( object[camelCaseValue] !== undefined ) {
                                    found = object[camelCaseValue];
                                    return false;
                                }
                                else if( $.isPlainObject( object[value] ) && (depth != maxDepth) ) {
                                    object = object[value];
                                }
                                else if( object[value] !== undefined ) {
                                    found = object[value];
                                    return false;
                                }
                                else {
                                    module.error(error.method, query);
                                    return false;
                                }
                            });
                        }
                        if ( $.isFunction( found ) ) {
                            response = found.apply(context, passedArguments);
                        }
                        else if(found !== undefined) {
                            response = found;
                        }
                        if($.isArray(returnedValue)) {
                            returnedValue.push(response);
                        }
                        else if(returnedValue !== undefined) {
                            returnedValue = [returnedValue, response];
                        }
                        else if(response !== undefined) {
                            returnedValue = response;
                        }
                        return found;
                    }
                };

                if(methodInvoked) {
                    if(instance === undefined) {
                        module.initialize();
                    }
                    module.invoke(query);
                }
                else {
                    if(instance !== undefined) {
                        instance.invoke('destroy');
                    }
                    module.initialize();
                }
            })
        ;

        return (returnedValue !== undefined)
            ? returnedValue
            : this
            ;
    };

    $.fn.nag.settings = {

        name        : 'Nag',

        debug       : false,
        verbose     : false,
        performance : true,

        namespace   : 'Nag',

        // allows cookie to be overriden
        persist     : false,

        // set to zero to require manually dismissal, otherwise hides on its own
        displayTime : 0,

        animation   : {
            show : 'slide',
            hide : 'slide'
        },

        context       : false,
        detachable    : false,

        expires       : 30,
        domain        : false,
        path          : '/',

        // type of storage to use
        storageMethod : 'cookie',

        // value to store in dismissed localstorage/cookie
        key           : 'nag',
        value         : 'dismiss',

        error: {
            noCookieStorage : '$.cookie is not included. A storage solution is required.',
            noStorage       : 'Neither $.cookie or store is defined. A storage solution is required for storing state',
            method          : 'The method you called is not defined.'
        },

        className     : {
            bottom : 'bottom',
            fixed  : 'fixed'
        },

        selector      : {
            close : '.close.icon'
        },

        speed         : 500,
        easing        : 'easeOutQuad',

        onHide: function() {}

    };

})( jQuery, window, document );

/*!
 * # Semantic UI 2.1.6 - Popup
 * http://github.com/semantic-org/semantic-ui/
 *
 *
 * Copyright 2015 Contributors
 * Released under the MIT license
 * http://opensource.org/licenses/MIT
 *
 */

;(function ($, window, document, undefined) {

    "use strict";

    $.fn.popup = function(parameters) {
        var
            $allModules    = $(this),
            $document      = $(document),
            $window        = $(window),
            $body          = $('body'),

            moduleSelector = $allModules.selector || '',

            hasTouch       = (true),
            time           = new Date().getTime(),
            performance    = [],

            query          = arguments[0],
            methodInvoked  = (typeof query == 'string'),
            queryArguments = [].slice.call(arguments, 1),

            returnedValue
            ;
        $allModules
            .each(function() {
                var
                    settings        = ( $.isPlainObject(parameters) )
                        ? $.extend(true, {}, $.fn.popup.settings, parameters)
                        : $.extend({}, $.fn.popup.settings),

                    selector           = settings.selector,
                    className          = settings.className,
                    error              = settings.error,
                    metadata           = settings.metadata,
                    namespace          = settings.namespace,

                    eventNamespace     = '.' + settings.namespace,
                    moduleNamespace    = 'module-' + namespace,

                    $module            = $(this),
                    $context           = $(settings.context),
                    $target            = (settings.target)
                        ? $(settings.target)
                        : $module,

                    $popup,
                    $offsetParent,

                    searchDepth        = 0,
                    triedPositions     = false,
                    openedWithTouch    = false,

                    element            = this,
                    instance           = $module.data(moduleNamespace),

                    elementNamespace,
                    id,
                    module
                    ;

                module = {

                    // binds events
                    initialize: function() {
                        module.debug('Initializing', $module);
                        module.createID();
                        module.bind.events();
                        if( !module.exists() && settings.preserve) {
                            module.create();
                        }
                        module.instantiate();
                    },

                    instantiate: function() {
                        module.verbose('Storing instance', module);
                        instance = module;
                        $module
                            .data(moduleNamespace, instance)
                        ;
                    },

                    refresh: function() {
                        if(settings.popup) {
                            $popup = $(settings.popup).eq(0);
                        }
                        else {
                            if(settings.inline) {
                                $popup = $target.nextAll(selector.popup).eq(0);
                                settings.popup = $popup;
                            }
                        }
                        if(settings.popup) {
                            $popup.addClass(className.loading);
                            $offsetParent = module.get.offsetParent();
                            $popup.removeClass(className.loading);
                            if(settings.movePopup && module.has.popup() && module.get.offsetParent($popup)[0] !== $offsetParent[0]) {
                                module.debug('Moving popup to the same offset parent as activating element');
                                $popup
                                    .detach()
                                    .appendTo($offsetParent)
                                ;
                            }
                        }
                        else {
                            $offsetParent = (settings.inline)
                                ? module.get.offsetParent($target)
                                : module.has.popup()
                                ? module.get.offsetParent($popup)
                                : $body
                            ;
                        }
                        if( $offsetParent.is('html') && $offsetParent[0] !== $body[0] ) {
                            module.debug('Setting page as offset parent');
                            $offsetParent = $body;
                        }
                        if( module.get.variation() ) {
                            module.set.variation();
                        }
                    },

                    reposition: function() {
                        module.refresh();
                        module.set.position();
                    },

                    destroy: function() {
                        module.debug('Destroying previous module');
                        // remove element only if was created dynamically
                        if($popup && !settings.preserve) {
                            module.removePopup();
                        }
                        // clear all timeouts
                        clearTimeout(module.hideTimer);
                        clearTimeout(module.showTimer);
                        // remove events
                        $window.off(elementNamespace);
                        $module
                            .off(eventNamespace)
                            .removeData(moduleNamespace)
                        ;
                    },

                    event: {
                        start:  function(event) {
                            var
                                delay = ($.isPlainObject(settings.delay))
                                    ? settings.delay.show
                                    : settings.delay
                                ;
                            clearTimeout(module.hideTimer);
                            if(!openedWithTouch) {
                                module.showTimer = setTimeout(module.show, delay);
                            }
                        },
                        end:  function() {
                            var
                                delay = ($.isPlainObject(settings.delay))
                                    ? settings.delay.hide
                                    : settings.delay
                                ;
                            clearTimeout(module.showTimer);
                            module.hideTimer = setTimeout(module.hide, delay);
                        },
                        touchstart: function(event) {
                            openedWithTouch = true;
                            module.show();
                        },
                        resize: function() {
                            if( module.is.visible() ) {
                                module.set.position();
                            }
                        },
                        hideGracefully: function(event) {
                            // don't close on clicks inside popup
                            if(event && $(event.target).closest(selector.popup).length === 0) {
                                module.debug('Click occurred outside popup hiding popup');
                                module.hide();
                            }
                            else {
                                module.debug('Click was inside popup, keeping popup open');
                            }
                        }
                    },

                    // generates popup html from metadata
                    create: function() {
                        var
                            html      = module.get.html(),
                            title     = module.get.title(),
                            content   = module.get.content()
                            ;

                        if(html || content || title) {
                            module.debug('Creating pop-up html');
                            if(!html) {
                                html = settings.templates.popup({
                                    title   : title,
                                    content : content
                                });
                            }
                            $popup = $('<div/>')
                                .addClass(className.popup)
                                .data(metadata.activator, $module)
                                .html(html)
                            ;
                            if(settings.inline) {
                                module.verbose('Inserting popup element inline', $popup);
                                $popup
                                    .insertAfter($module)
                                ;
                            }
                            else {
                                module.verbose('Appending popup element to body', $popup);
                                $popup
                                    .appendTo( $context )
                                ;
                            }
                            module.refresh();
                            module.set.variation();

                            if(settings.hoverable) {
                                module.bind.popup();
                            }
                            settings.onCreate.call($popup, element);
                        }
                        else if($target.next(selector.popup).length !== 0) {
                            module.verbose('Pre-existing popup found');
                            settings.inline = true;
                            settings.popups  = $target.next(selector.popup).data(metadata.activator, $module);
                            module.refresh();
                            if(settings.hoverable) {
                                module.bind.popup();
                            }
                        }
                        else if(settings.popup) {
                            $(settings.popup).data(metadata.activator, $module);
                            module.verbose('Used popup specified in settings');
                            module.refresh();
                            if(settings.hoverable) {
                                module.bind.popup();
                            }
                        }
                        else {
                            module.debug('No content specified skipping display', element);
                        }
                    },

                    createID: function() {
                        id = (Math.random().toString(16) + '000000000').substr(2,8);
                        elementNamespace = '.' + id;
                        module.verbose('Creating unique id for element', id);
                    },

                    // determines popup state
                    toggle: function() {
                        module.debug('Toggling pop-up');
                        if( module.is.hidden() ) {
                            module.debug('Popup is hidden, showing pop-up');
                            module.unbind.close();
                            module.show();
                        }
                        else {
                            module.debug('Popup is visible, hiding pop-up');
                            module.hide();
                        }
                    },

                    show: function(callback) {
                        callback = callback || function(){};
                        module.debug('Showing pop-up', settings.transition);
                        if(module.is.hidden() && !( module.is.active() && module.is.dropdown()) ) {
                            if( !module.exists() ) {
                                module.create();
                            }
                            if(settings.onShow.call($popup, element) === false) {
                                module.debug('onShow callback returned false, cancelling popup animation');
                                return;
                            }
                            else if(!settings.preserve && !settings.popup) {
                                module.refresh();
                            }
                            if( $popup && module.set.position() ) {
                                module.save.conditions();
                                if(settings.exclusive) {
                                    module.hideAll();
                                }
                                module.animate.show(callback);
                            }
                        }
                    },


                    hide: function(callback) {
                        callback = callback || function(){};
                        if( module.is.visible() || module.is.animating() ) {
                            if(settings.onHide.call($popup, element) === false) {
                                module.debug('onHide callback returned false, cancelling popup animation');
                                return;
                            }
                            module.remove.visible();
                            module.unbind.close();
                            module.restore.conditions();
                            module.animate.hide(callback);
                        }
                    },

                    hideAll: function() {
                        $(selector.popup)
                            .filter('.' + className.visible)
                            .each(function() {
                                $(this)
                                    .data(metadata.activator)
                                    .popup('hide')
                                ;
                            })
                        ;
                    },
                    exists: function() {
                        if(!$popup) {
                            return false;
                        }
                        if(settings.inline || settings.popup) {
                            return ( module.has.popup() );
                        }
                        else {
                            return ( $popup.closest($context).length >= 1 )
                                ? true
                                : false
                                ;
                        }
                    },

                    removePopup: function() {
                        if( module.has.popup() && !settings.popup) {
                            module.debug('Removing popup', $popup);
                            $popup.remove();
                            $popup = undefined;
                            settings.onRemove.call($popup, element);
                        }
                    },

                    save: {
                        conditions: function() {
                            module.cache = {
                                title: $module.attr('title')
                            };
                            if (module.cache.title) {
                                $module.removeAttr('title');
                            }
                            module.verbose('Saving original attributes', module.cache.title);
                        }
                    },
                    restore: {
                        conditions: function() {
                            if(module.cache && module.cache.title) {
                                $module.attr('title', module.cache.title);
                                module.verbose('Restoring original attributes', module.cache.title);
                            }
                            return true;
                        }
                    },
                    animate: {
                        show: function(callback) {
                            callback = $.isFunction(callback) ? callback : function(){};
                            if(settings.transition && $.fn.transition !== undefined && $module.transition('is supported')) {
                                module.set.visible();
                                $popup
                                    .transition({
                                        animation  : settings.transition + ' in',
                                        queue      : false,
                                        debug      : settings.debug,
                                        verbose    : settings.verbose,
                                        duration   : settings.duration,
                                        onComplete : function() {
                                            module.bind.close();
                                            callback.call($popup, element);
                                            settings.onVisible.call($popup, element);
                                        }
                                    })
                                ;
                            }
                            else {
                                module.error(error.noTransition);
                            }
                        },
                        hide: function(callback) {
                            callback = $.isFunction(callback) ? callback : function(){};
                            module.debug('Hiding pop-up');
                            if(settings.onHide.call($popup, element) === false) {
                                module.debug('onHide callback returned false, cancelling popup animation');
                                return;
                            }
                            if(settings.transition && $.fn.transition !== undefined && $module.transition('is supported')) {
                                $popup
                                    .transition({
                                        animation  : settings.transition + ' out',
                                        queue      : false,
                                        duration   : settings.duration,
                                        debug      : settings.debug,
                                        verbose    : settings.verbose,
                                        onComplete : function() {
                                            module.reset();
                                            callback.call($popup, element);
                                            settings.onHidden.call($popup, element);
                                        }
                                    })
                                ;
                            }
                            else {
                                module.error(error.noTransition);
                            }
                        }
                    },

                    change: {
                        content: function(html) {
                            $popup.html(html);
                        }
                    },

                    get: {
                        html: function() {
                            $module.removeData(metadata.html);
                            return $module.data(metadata.html) || settings.html;
                        },
                        title: function() {
                            $module.removeData(metadata.title);
                            return $module.data(metadata.title) || settings.title;
                        },
                        content: function() {
                            $module.removeData(metadata.content);
                            return $module.data(metadata.content) || $module.attr('title') || settings.content;
                        },
                        variation: function() {
                            $module.removeData(metadata.variation);
                            return $module.data(metadata.variation) || settings.variation;
                        },
                        popup: function() {
                            return $popup;
                        },
                        popupOffset: function() {
                            return $popup.offset();
                        },
                        calculations: function() {
                            var
                                targetElement  = $target[0],
                                targetPosition = (settings.inline || (settings.popup && settings.movePopup))
                                    ? $target.position()
                                    : $target.offset(),
                                calculations = {},
                                screen
                                ;
                            calculations = {
                                // element which is launching popup
                                target : {
                                    element : $target[0],
                                    width   : $target.outerWidth(),
                                    height  : $target.outerHeight(),
                                    top     : targetPosition.top,
                                    left    : targetPosition.left,
                                    margin  : {}
                                },
                                // popup itself
                                popup : {
                                    width  : $popup.outerWidth(),
                                    height : $popup.outerHeight()
                                },
                                // offset container (or 3d context)
                                parent : {
                                    width  : $offsetParent.outerWidth(),
                                    height : $offsetParent.outerHeight()
                                },
                                // screen boundaries
                                screen : {
                                    scroll: {
                                        top  : $window.scrollTop(),
                                        left : $window.scrollLeft()
                                    },
                                    width  : $window.width(),
                                    height : $window.height()
                                }
                            };

                            // add in container calcs if fluid
                            if( settings.setFluidWidth && module.is.fluid() ) {
                                calculations.container = {
                                    width: $popup.parent().outerWidth()
                                };
                                calculations.popup.width = calculations.container.width;
                            }

                            // add in margins if inline
                            calculations.target.margin.top = (settings.inline)
                                ? parseInt( window.getComputedStyle(targetElement).getPropertyValue('margin-top'), 10)
                                : 0
                            ;
                            calculations.target.margin.left = (settings.inline)
                                ? module.is.rtl()
                                ? parseInt( window.getComputedStyle(targetElement).getPropertyValue('margin-right'), 10)
                                : parseInt( window.getComputedStyle(targetElement).getPropertyValue('margin-left') , 10)
                                : 0
                            ;
                            // calculate screen boundaries
                            screen = calculations.screen;
                            calculations.boundary = {
                                top    : screen.scroll.top,
                                bottom : screen.scroll.top + screen.height,
                                left   : screen.scroll.left,
                                right  : screen.scroll.left + screen.width
                            };
                            return calculations;
                        },
                        id: function() {
                            return id;
                        },
                        startEvent: function() {
                            if(settings.on == 'hover') {
                                return 'mouseenter';
                            }
                            else if(settings.on == 'focus') {
                                return 'focus';
                            }
                            return false;
                        },
                        scrollEvent: function() {
                            return 'scroll';
                        },
                        endEvent: function() {
                            if(settings.on == 'hover') {
                                return 'mouseleave';
                            }
                            else if(settings.on == 'focus') {
                                return 'blur';
                            }
                            return false;
                        },
                        distanceFromBoundary: function(offset, calculations) {
                            var
                                distanceFromBoundary = {},
                                popup,
                                boundary
                                ;
                            offset       = offset       || module.get.offset();
                            calculations = calculations || module.get.calculations();

                            // shorthand
                            popup        = calculations.popup;
                            boundary     = calculations.boundary;

                            if(offset) {
                                distanceFromBoundary = {
                                    top    : (offset.top - boundary.top),
                                    left   : (offset.left - boundary.left),
                                    right  : (boundary.right - (offset.left + popup.width) ),
                                    bottom : (boundary.bottom - (offset.top + popup.height) )
                                };
                                module.verbose('Distance from boundaries determined', offset, distanceFromBoundary);
                            }
                            return distanceFromBoundary;
                        },
                        offsetParent: function($target) {
                            var
                                element = ($target !== undefined)
                                    ? $target[0]
                                    : $module[0],
                                parentNode = element.parentNode,
                                $node    = $(parentNode)
                                ;
                            if(parentNode) {
                                var
                                    is2D     = ($node.css('transform') === 'none'),
                                    isStatic = ($node.css('position') === 'static'),
                                    isHTML   = $node.is('html')
                                    ;
                                while(parentNode && !isHTML && isStatic && is2D) {
                                    parentNode = parentNode.parentNode;
                                    $node    = $(parentNode);
                                    is2D     = ($node.css('transform') === 'none');
                                    isStatic = ($node.css('position') === 'static');
                                    isHTML   = $node.is('html');
                                }
                            }
                            return ($node && $node.length > 0)
                                ? $node
                                : $()
                                ;
                        },
                        positions: function() {
                            return {
                                'top left'      : false,
                                'top center'    : false,
                                'top right'     : false,
                                'bottom left'   : false,
                                'bottom center' : false,
                                'bottom right'  : false,
                                'left center'   : false,
                                'right center'  : false
                            };
                        },
                        nextPosition: function(position) {
                            var
                                positions          = position.split(' '),
                                verticalPosition   = positions[0],
                                horizontalPosition = positions[1],
                                opposite = {
                                    top    : 'bottom',
                                    bottom : 'top',
                                    left   : 'right',
                                    right  : 'left'
                                },
                                adjacent = {
                                    left   : 'center',
                                    center : 'right',
                                    right  : 'left'
                                },
                                backup = {
                                    'top left'      : 'top center',
                                    'top center'    : 'top right',
                                    'top right'     : 'right center',
                                    'right center'  : 'bottom right',
                                    'bottom right'  : 'bottom center',
                                    'bottom center' : 'bottom left',
                                    'bottom left'   : 'left center',
                                    'left center'   : 'top left'
                                },
                                adjacentsAvailable = (verticalPosition == 'top' || verticalPosition == 'bottom'),
                                oppositeTried = false,
                                adjacentTried = false,
                                nextPosition  = false
                                ;
                            if(!triedPositions) {
                                module.verbose('All available positions available');
                                triedPositions = module.get.positions();
                            }

                            module.debug('Recording last position tried', position);
                            triedPositions[position] = true;

                            if(settings.prefer === 'opposite') {
                                nextPosition  = [opposite[verticalPosition], horizontalPosition];
                                nextPosition  = nextPosition.join(' ');
                                oppositeTried = (triedPositions[nextPosition] === true);
                                module.debug('Trying opposite strategy', nextPosition);
                            }
                            if((settings.prefer === 'adjacent') && adjacentsAvailable ) {
                                nextPosition  = [verticalPosition, adjacent[horizontalPosition]];
                                nextPosition  = nextPosition.join(' ');
                                adjacentTried = (triedPositions[nextPosition] === true);
                                module.debug('Trying adjacent strategy', nextPosition);
                            }
                            if(adjacentTried || oppositeTried) {
                                module.debug('Using backup position', nextPosition);
                                nextPosition = backup[position];
                            }
                            return nextPosition;
                        }
                    },

                    set: {
                        position: function(position, calculations) {

                            // exit conditions
                            if($target.length === 0 || $popup.length === 0) {
                                module.error(error.notFound);
                                return;
                            }
                            var
                                offset,
                                distanceAway,
                                target,
                                popup,
                                parent,
                                positioning,
                                popupOffset,
                                distanceFromBoundary
                                ;

                            calculations = calculations || module.get.calculations();
                            position     = position     || $module.data(metadata.position) || settings.position;

                            offset       = $module.data(metadata.offset) || settings.offset;
                            distanceAway = settings.distanceAway;

                            // shorthand
                            target = calculations.target;
                            popup  = calculations.popup;
                            parent = calculations.parent;

                            if(target.width === 0 && target.height === 0 && !(target.element instanceof SVGGraphicsElement)) {
                                module.debug('Popup target is hidden, no action taken');
                                return false;
                            }

                            if(settings.inline) {
                                module.debug('Adding margin to calculation', target.margin);
                                if(position == 'left center' || position == 'right center') {
                                    offset       +=  target.margin.top;
                                    distanceAway += -target.margin.left;
                                }
                                else if (position == 'top left' || position == 'top center' || position == 'top right') {
                                    offset       += target.margin.left;
                                    distanceAway -= target.margin.top;
                                }
                                else {
                                    offset       += target.margin.left;
                                    distanceAway += target.margin.top;
                                }
                            }

                            module.debug('Determining popup position from calculations', position, calculations);

                            if (module.is.rtl()) {
                                position = position.replace(/left|right/g, function (match) {
                                    return (match == 'left')
                                        ? 'right'
                                        : 'left'
                                        ;
                                });
                                module.debug('RTL: Popup position updated', position);
                            }

                            // if last attempt use specified last resort position
                            if(searchDepth == settings.maxSearchDepth && typeof settings.lastResort === 'string') {
                                position = settings.lastResort;
                            }

                            switch (position) {
                                case 'top left':
                                    positioning = {
                                        top    : 'auto',
                                        bottom : parent.height - target.top + distanceAway,
                                        left   : target.left + offset,
                                        right  : 'auto'
                                    };
                                    break;
                                case 'top center':
                                    positioning = {
                                        bottom : parent.height - target.top + distanceAway,
                                        left   : target.left + (target.width / 2) - (popup.width / 2) + offset,
                                        top    : 'auto',
                                        right  : 'auto'
                                    };
                                    break;
                                case 'top right':
                                    positioning = {
                                        bottom :  parent.height - target.top + distanceAway,
                                        right  :  parent.width - target.left - target.width - offset,
                                        top    : 'auto',
                                        left   : 'auto'
                                    };
                                    break;
                                case 'left center':
                                    positioning = {
                                        top    : target.top + (target.height / 2) - (popup.height / 2) + offset,
                                        right  : parent.width - target.left + distanceAway,
                                        left   : 'auto',
                                        bottom : 'auto'
                                    };
                                    break;
                                case 'right center':
                                    positioning = {
                                        top    : target.top + (target.height / 2) - (popup.height / 2) + offset,
                                        left   : target.left + target.width + distanceAway,
                                        bottom : 'auto',
                                        right  : 'auto'
                                    };
                                    break;
                                case 'bottom left':
                                    positioning = {
                                        top    : target.top + target.height + distanceAway,
                                        left   : target.left + offset,
                                        bottom : 'auto',
                                        right  : 'auto'
                                    };
                                    break;
                                case 'bottom center':
                                    positioning = {
                                        top    : target.top + target.height + distanceAway,
                                        left   : target.left + (target.width / 2) - (popup.width / 2) + offset,
                                        bottom : 'auto',
                                        right  : 'auto'
                                    };
                                    break;
                                case 'bottom right':
                                    positioning = {
                                        top    : target.top + target.height + distanceAway,
                                        right  : parent.width - target.left  - target.width - offset,
                                        left   : 'auto',
                                        bottom : 'auto'
                                    };
                                    break;
                            }
                            if(positioning === undefined) {
                                module.error(error.invalidPosition, position);
                            }

                            module.debug('Calculated popup positioning values', positioning);

                            // tentatively place on stage
                            $popup
                                .css(positioning)
                                .removeClass(className.position)
                                .addClass(position)
                                .addClass(className.loading)
                            ;

                            popupOffset = module.get.popupOffset();

                            // see if any boundaries are surpassed with this tentative position
                            distanceFromBoundary = module.get.distanceFromBoundary(popupOffset, calculations);

                            if( module.is.offstage(distanceFromBoundary, position) ) {
                                module.debug('Position is outside viewport', position);
                                if(searchDepth < settings.maxSearchDepth) {
                                    searchDepth++;
                                    position = module.get.nextPosition(position);
                                    module.debug('Trying new position', position);
                                    return ($popup)
                                        ? module.set.position(position, calculations)
                                        : false
                                        ;
                                }
                                else {
                                    if(settings.lastResort) {
                                        module.debug('No position found, showing with last position');
                                    }
                                    else {
                                        module.debug('Popup could not find a position to display', $popup);
                                        module.error(error.cannotPlace, element);
                                        module.remove.attempts();
                                        module.remove.loading();
                                        module.reset();
                                        return false;
                                    }
                                }
                            }
                            module.debug('Position is on stage', position);
                            module.remove.attempts();
                            module.remove.loading();
                            if( settings.setFluidWidth && module.is.fluid() ) {
                                module.set.fluidWidth(calculations);
                            }
                            return true;
                        },

                        fluidWidth: function(calculations) {
                            calculations = calculations || module.get.calculations();
                            module.debug('Automatically setting element width to parent width', calculations.parent.width);
                            $popup.css('width', calculations.container.width);
                        },

                        variation: function(variation) {
                            variation = variation || module.get.variation();
                            if(variation && module.has.popup() ) {
                                module.verbose('Adding variation to popup', variation);
                                $popup.addClass(variation);
                            }
                        },

                        visible: function() {
                            $module.addClass(className.visible);
                        }
                    },

                    remove: {
                        loading: function() {
                            $popup.removeClass(className.loading);
                        },
                        variation: function(variation) {
                            variation = variation || module.get.variation();
                            if(variation) {
                                module.verbose('Removing variation', variation);
                                $popup.removeClass(variation);
                            }
                        },
                        visible: function() {
                            $module.removeClass(className.visible);
                        },
                        attempts: function() {
                            module.verbose('Resetting all searched positions');
                            searchDepth    = 0;
                            triedPositions = false;
                        }
                    },

                    bind: {
                        events: function() {
                            module.debug('Binding popup events to module');
                            if(settings.on == 'click') {
                                $module
                                    .on('click' + eventNamespace, module.toggle)
                                ;
                            }
                            if(settings.on == 'hover' && hasTouch) {
                                $module
                                    .on('touchstart' + eventNamespace, module.event.touchstart)
                                ;
                            }
                            if( module.get.startEvent() ) {
                                $module
                                    .on(module.get.startEvent() + eventNamespace, module.event.start)
                                    .on(module.get.endEvent() + eventNamespace, module.event.end)
                                ;
                            }
                            if(settings.target) {
                                module.debug('Target set to element', $target);
                            }
                            $window.on('resize' + elementNamespace, module.event.resize);
                        },
                        popup: function() {
                            module.verbose('Allowing hover events on popup to prevent closing');
                            if( $popup && module.has.popup() ) {
                                $popup
                                    .on('mouseenter' + eventNamespace, module.event.start)
                                    .on('mouseleave' + eventNamespace, module.event.end)
                                ;
                            }
                        },
                        close: function() {
                            if(settings.hideOnScroll === true || (settings.hideOnScroll == 'auto' && settings.on != 'click'))   {
                                $document
                                    .one(module.get.scrollEvent() + elementNamespace, module.event.hideGracefully)
                                ;
                                $context
                                    .one(module.get.scrollEvent() + elementNamespace, module.event.hideGracefully)
                                ;
                            }
                            if(settings.on == 'hover' && openedWithTouch) {
                                module.verbose('Binding popup close event to document');
                                $document
                                    .on('touchstart' + elementNamespace, function(event) {
                                        module.verbose('Touched away from popup');
                                        module.event.hideGracefully.call(element, event);
                                    })
                                ;
                            }
                            if(settings.on == 'click' && settings.closable) {
                                module.verbose('Binding popup close event to document');
                                $document
                                    .on('click' + elementNamespace, function(event) {
                                        module.verbose('Clicked away from popup');
                                        module.event.hideGracefully.call(element, event);
                                    })
                                ;
                            }
                        }
                    },

                    unbind: {
                        close: function() {
                            if(settings.hideOnScroll === true || (settings.hideOnScroll == 'auto' && settings.on != 'click')) {
                                $document
                                    .off('scroll' + elementNamespace, module.hide)
                                ;
                                $context
                                    .off('scroll' + elementNamespace, module.hide)
                                ;
                            }
                            if(settings.on == 'hover' && openedWithTouch) {
                                $document
                                    .off('touchstart' + elementNamespace)
                                ;
                                openedWithTouch = false;
                            }
                            if(settings.on == 'click' && settings.closable) {
                                module.verbose('Removing close event from document');
                                $document
                                    .off('click' + elementNamespace)
                                ;
                            }
                        }
                    },

                    has: {
                        popup: function() {
                            return ($popup && $popup.length > 0);
                        }
                    },

                    is: {
                        offstage: function(distanceFromBoundary, position) {
                            var
                                offstage = []
                                ;
                            // return boundaries that have been surpassed
                            $.each(distanceFromBoundary, function(direction, distance) {
                                if(distance < -settings.jitter) {
                                    module.debug('Position exceeds allowable distance from edge', direction, distance, position);
                                    offstage.push(direction);
                                }
                            });
                            if(offstage.length > 0) {
                                return true;
                            }
                            else {
                                return false;
                            }
                        },
                        active: function() {
                            return $module.hasClass(className.active);
                        },
                        animating: function() {
                            return ( $popup && $popup.hasClass(className.animating) );
                        },
                        fluid: function() {
                            return ( $popup && $popup.hasClass(className.fluid));
                        },
                        visible: function() {
                            return $popup && $popup.hasClass(className.visible);
                        },
                        dropdown: function() {
                            return $module.hasClass(className.dropdown);
                        },
                        hidden: function() {
                            return !module.is.visible();
                        },
                        rtl: function () {
                            return $module.css('direction') == 'rtl';
                        }
                    },

                    reset: function() {
                        module.remove.visible();
                        if(settings.preserve) {
                            if($.fn.transition !== undefined) {
                                $popup
                                    .transition('remove transition')
                                ;
                            }
                        }
                        else {
                            module.removePopup();
                        }
                    },

                    setting: function(name, value) {
                        if( $.isPlainObject(name) ) {
                            $.extend(true, settings, name);
                        }
                        else if(value !== undefined) {
                            settings[name] = value;
                        }
                        else {
                            return settings[name];
                        }
                    },
                    internal: function(name, value) {
                        if( $.isPlainObject(name) ) {
                            $.extend(true, module, name);
                        }
                        else if(value !== undefined) {
                            module[name] = value;
                        }
                        else {
                            return module[name];
                        }
                    },
                    debug: function() {
                        if(settings.debug) {
                            if(settings.performance) {
                                module.performance.log(arguments);
                            }
                            else {
                                module.debug = Function.prototype.bind.call(console.info, console, settings.name + ':');
                                module.debug.apply(console, arguments);
                            }
                        }
                    },
                    verbose: function() {
                        if(settings.verbose && settings.debug) {
                            if(settings.performance) {
                                module.performance.log(arguments);
                            }
                            else {
                                module.verbose = Function.prototype.bind.call(console.info, console, settings.name + ':');
                                module.verbose.apply(console, arguments);
                            }
                        }
                    },
                    error: function() {
                        module.error = Function.prototype.bind.call(console.error, console, settings.name + ':');
                        module.error.apply(console, arguments);
                    },
                    performance: {
                        log: function(message) {
                            var
                                currentTime,
                                executionTime,
                                previousTime
                                ;
                            if(settings.performance) {
                                currentTime   = new Date().getTime();
                                previousTime  = time || currentTime;
                                executionTime = currentTime - previousTime;
                                time          = currentTime;
                                performance.push({
                                    'Name'           : message[0],
                                    'Arguments'      : [].slice.call(message, 1) || '',
                                    'Element'        : element,
                                    'Execution Time' : executionTime
                                });
                            }
                            clearTimeout(module.performance.timer);
                            module.performance.timer = setTimeout(module.performance.display, 500);
                        },
                        display: function() {
                            var
                                title = settings.name + ':',
                                totalTime = 0
                                ;
                            time = false;
                            clearTimeout(module.performance.timer);
                            $.each(performance, function(index, data) {
                                totalTime += data['Execution Time'];
                            });
                            title += ' ' + totalTime + 'ms';
                            if(moduleSelector) {
                                title += ' \'' + moduleSelector + '\'';
                            }
                            if( (console.group !== undefined || console.table !== undefined) && performance.length > 0) {
                                console.groupCollapsed(title);
                                if(console.table) {
                                    console.table(performance);
                                }
                                else {
                                    $.each(performance, function(index, data) {
                                        console.log(data['Name'] + ': ' + data['Execution Time']+'ms');
                                    });
                                }
                                console.groupEnd();
                            }
                            performance = [];
                        }
                    },
                    invoke: function(query, passedArguments, context) {
                        var
                            object = instance,
                            maxDepth,
                            found,
                            response
                            ;
                        passedArguments = passedArguments || queryArguments;
                        context         = element         || context;
                        if(typeof query == 'string' && object !== undefined) {
                            query    = query.split(/[\. ]/);
                            maxDepth = query.length - 1;
                            $.each(query, function(depth, value) {
                                var camelCaseValue = (depth != maxDepth)
                                        ? value + query[depth + 1].charAt(0).toUpperCase() + query[depth + 1].slice(1)
                                        : query
                                    ;
                                if( $.isPlainObject( object[camelCaseValue] ) && (depth != maxDepth) ) {
                                    object = object[camelCaseValue];
                                }
                                else if( object[camelCaseValue] !== undefined ) {
                                    found = object[camelCaseValue];
                                    return false;
                                }
                                else if( $.isPlainObject( object[value] ) && (depth != maxDepth) ) {
                                    object = object[value];
                                }
                                else if( object[value] !== undefined ) {
                                    found = object[value];
                                    return false;
                                }
                                else {
                                    return false;
                                }
                            });
                        }
                        if ( $.isFunction( found ) ) {
                            response = found.apply(context, passedArguments);
                        }
                        else if(found !== undefined) {
                            response = found;
                        }
                        if($.isArray(returnedValue)) {
                            returnedValue.push(response);
                        }
                        else if(returnedValue !== undefined) {
                            returnedValue = [returnedValue, response];
                        }
                        else if(response !== undefined) {
                            returnedValue = response;
                        }
                        return found;
                    }
                };

                if(methodInvoked) {
                    if(instance === undefined) {
                        module.initialize();
                    }
                    module.invoke(query);
                }
                else {
                    if(instance !== undefined) {
                        instance.invoke('destroy');
                    }
                    module.initialize();
                }
            })
        ;

        return (returnedValue !== undefined)
            ? returnedValue
            : this
            ;
    };

    $.fn.popup.settings = {

        name         : 'Popup',

        // module settings
        debug        : false,
        verbose      : false,
        performance  : true,
        namespace    : 'popup',

        // callback only when element added to dom
        onCreate     : function(){},

        // callback before element removed from dom
        onRemove     : function(){},

        // callback before show animation
        onShow       : function(){},

        // callback after show animation
        onVisible    : function(){},

        // callback before hide animation
        onHide       : function(){},

        // callback after hide animation
        onHidden     : function(){},

        // when to show popup
        on           : 'hover',

        // whether to add touchstart events when using hover
        addTouchEvents : true,

        // default position relative to element
        position     : 'top left',

        // name of variation to use
        variation    : '',

        // whether popup should be moved to context
        movePopup      : true,

        // element which popup should be relative to
        target         : false,

        // jq selector or element that should be used as popup
        popup          : false,

        // popup should remain inline next to activator
        inline         : false,

        // popup should be removed from page on hide
        preserve       : false,

        // popup should not close when being hovered on
        hoverable      : false,

        // explicitly set content
        content      : false,

        // explicitly set html
        html         : false,

        // explicitly set title
        title        : false,

        // whether automatically close on clickaway when on click
        closable     : true,

        // automatically hide on scroll
        hideOnScroll : 'auto',

        // hide other popups on show
        exclusive    : false,

        // context to attach popups
        context      : 'body',

        // position to prefer when calculating new position
        prefer       : 'opposite',

        // specify position to appear even if it doesn't fit
        lastResort   : false,

        // delay used to prevent accidental refiring of animations due to user error
        delay        : {
            show : 50,
            hide : 70
        },

        // whether fluid variation should assign width explicitly
        setFluidWidth  : true,

        // transition settings
        duration       : 200,
        transition     : 'scale',

        // distance away from activating element in px
        distanceAway   : 0,

        // number of pixels an element is allowed to be "offstage" for a position to be chosen (allows for rounding)
        jitter         : 2,

        // offset on aligning axis from calculated position
        offset         : 0,

        // maximum times to look for a position before failing (9 positions total)
        maxSearchDepth : 15,

        error: {
            invalidPosition : 'The position you specified is not a valid position',
            cannotPlace     : 'Popup does not fit within the boundaries of the viewport',
            method          : 'The method you called is not defined.',
            noTransition    : 'This module requires ui transitions <https://github.com/Semantic-Org/UI-Transition>',
            notFound        : 'The target or popup you specified does not exist on the page'
        },

        metadata: {
            activator : 'activator',
            content   : 'content',
            html      : 'html',
            offset    : 'offset',
            position  : 'position',
            title     : 'title',
            variation : 'variation'
        },

        className   : {
            active    : 'active',
            animating : 'animating',
            dropdown  : 'dropdown',
            fluid     : 'fluid',
            loading   : 'loading',
            popup     : 'ui popup',
            position  : 'top left center bottom right',
            visible   : 'visible'
        },

        selector    : {
            popup    : '.ui.popup'
        },

        templates: {
            escape: function(string) {
                var
                    badChars     = /[&<>"'`]/g,
                    shouldEscape = /[&<>"'`]/,
                    escape       = {
                        "&": "&amp;",
                        "<": "&lt;",
                        ">": "&gt;",
                        '"': "&quot;",
                        "'": "&#x27;",
                        "`": "&#x60;"
                    },
                    escapedChar  = function(chr) {
                        return escape[chr];
                    }
                    ;
                if(shouldEscape.test(string)) {
                    return string.replace(badChars, escapedChar);
                }
                return string;
            },
            popup: function(text) {
                var
                    html   = '',
                    escape = $.fn.popup.settings.templates.escape
                    ;
                if(typeof text !== undefined) {
                    if(typeof text.title !== undefined && text.title) {
                        text.title = escape(text.title);
                        html += '<div class="header">' + text.title + '</div>';
                    }
                    if(typeof text.content !== undefined && text.content) {
                        text.content = escape(text.content);
                        html += '<div class="content">' + text.content + '</div>';
                    }
                }
                return html;
            }
        }

    };


})( jQuery, window, document );

/*!
 * # Semantic UI 2.1.6 - Progress
 * http://github.com/semantic-org/semantic-ui/
 *
 *
 * Copyright 2015 Contributors
 * Released under the MIT license
 * http://opensource.org/licenses/MIT
 *
 */

;(function ( $, window, document, undefined ) {

    "use strict";

    $.fn.progress = function(parameters) {
        var
            $allModules    = $(this),

            moduleSelector = $allModules.selector || '',

            time           = new Date().getTime(),
            performance    = [],

            query          = arguments[0],
            methodInvoked  = (typeof query == 'string'),
            queryArguments = [].slice.call(arguments, 1),

            returnedValue
            ;

        $allModules
            .each(function() {
                var
                    settings          = ( $.isPlainObject(parameters) )
                        ? $.extend(true, {}, $.fn.progress.settings, parameters)
                        : $.extend({}, $.fn.progress.settings),

                    className       = settings.className,
                    metadata        = settings.metadata,
                    namespace       = settings.namespace,
                    selector        = settings.selector,
                    error           = settings.error,

                    eventNamespace  = '.' + namespace,
                    moduleNamespace = 'module-' + namespace,

                    $module         = $(this),
                    $bar            = $(this).find(selector.bar),
                    $progress       = $(this).find(selector.progress),
                    $label          = $(this).find(selector.label),

                    element         = this,
                    instance        = $module.data(moduleNamespace),

                    animating = false,
                    transitionEnd,
                    module
                    ;

                module = {

                    initialize: function() {
                        module.debug('Initializing progress bar', settings);

                        module.set.duration();
                        module.set.transitionEvent();

                        module.read.metadata();
                        module.read.settings();

                        module.instantiate();
                    },

                    instantiate: function() {
                        module.verbose('Storing instance of progress', module);
                        instance = module;
                        $module
                            .data(moduleNamespace, module)
                        ;
                    },
                    destroy: function() {
                        module.verbose('Destroying previous progress for', $module);
                        clearInterval(instance.interval);
                        module.remove.state();
                        $module.removeData(moduleNamespace);
                        instance = undefined;
                    },

                    reset: function() {
                        module.set.percent(0);
                        module.set.value(0);
                    },

                    complete: function() {
                        if(module.percent === undefined || module.percent < 100) {
                            module.set.percent(100);
                        }
                    },

                    read: {
                        metadata: function() {
                            var
                                data = {
                                    percent : $module.data(metadata.percent),
                                    total   : $module.data(metadata.total),
                                    value   : $module.data(metadata.value)
                                }
                                ;
                            if(data.percent) {
                                module.debug('Current percent value set from metadata', data.percent);
                                module.set.percent(data.percent);
                            }
                            if(data.total) {
                                module.debug('Total value set from metadata', data.total);
                                module.set.total(data.total);
                            }
                            if(data.value) {
                                module.debug('Current value set from metadata', data.value);
                                module.set.value(data.value);
                                module.set.progress(data.value);
                            }
                        },
                        settings: function() {
                            if(settings.total !== false) {
                                module.debug('Current total set in settings', settings.total);
                                module.set.total(settings.total);
                            }
                            if(settings.value !== false) {
                                module.debug('Current value set in settings', settings.value);
                                module.set.value(settings.value);
                                module.set.progress(module.value);
                            }
                            if(settings.percent !== false) {
                                module.debug('Current percent set in settings', settings.percent);
                                module.set.percent(settings.percent);
                            }
                        }
                    },

                    increment: function(incrementValue) {
                        var
                            maxValue,
                            startValue,
                            newValue
                            ;
                        if( module.has.total() ) {
                            startValue     = module.get.value();
                            incrementValue = incrementValue || 1;

                            newValue       = startValue + incrementValue;
                            maxValue       = module.get.total();

                            module.debug('Incrementing value', startValue, newValue, maxValue);
                            if(newValue > maxValue ) {
                                module.debug('Value cannot increment above total', maxValue);
                                newValue = maxValue;
                            }
                        }
                        else {
                            startValue     = module.get.percent();
                            incrementValue = incrementValue || module.get.randomValue();

                            newValue       = startValue + incrementValue;
                            maxValue       = 100;

                            module.debug('Incrementing percentage by', startValue, newValue);
                            if(newValue > maxValue ) {
                                module.debug('Value cannot increment above 100 percent');
                                newValue = maxValue;
                            }
                        }
                        module.set.progress(newValue);
                    },
                    decrement: function(decrementValue) {
                        var
                            total     = module.get.total(),
                            startValue,
                            newValue
                            ;
                        if(total) {
                            startValue     =  module.get.value();
                            decrementValue =  decrementValue || 1;
                            newValue       =  startValue - decrementValue;
                            module.debug('Decrementing value by', decrementValue, startValue);
                        }
                        else {
                            startValue     =  module.get.percent();
                            decrementValue =  decrementValue || module.get.randomValue();
                            newValue       =  startValue - decrementValue;
                            module.debug('Decrementing percentage by', decrementValue, startValue);
                        }

                        if(newValue < 0) {
                            module.debug('Value cannot decrement below 0');
                            newValue = 0;
                        }
                        module.set.progress(newValue);
                    },

                    has: {
                        total: function() {
                            return (module.get.total() !== false);
                        }
                    },

                    get: {
                        text: function(templateText) {
                            var
                                value   = module.value                || 0,
                                total   = module.total                || 0,
                                percent = (animating)
                                    ? module.get.displayPercent()
                                    : module.percent || 0,
                                left = (module.total > 0)
                                    ? (total - value)
                                    : (100 - percent)
                                ;
                            templateText = templateText || '';
                            templateText = templateText
                                .replace('{value}', value)
                                .replace('{total}', total)
                                .replace('{left}', left)
                                .replace('{percent}', percent)
                            ;
                            module.debug('Adding variables to progress bar text', templateText);
                            return templateText;
                        },


                        randomValue: function() {
                            module.debug('Generating random increment percentage');
                            return Math.floor((Math.random() * settings.random.max) + settings.random.min);
                        },

                        numericValue: function(value) {
                            return (typeof value === 'string')
                                ? (value.replace(/[^\d.]/g, '') !== '')
                                ? +(value.replace(/[^\d.]/g, ''))
                                : false
                                : value
                                ;
                        },

                        transitionEnd: function() {
                            var
                                element     = document.createElement('element'),
                                transitions = {
                                    'transition'       :'transitionend',
                                    'OTransition'      :'oTransitionEnd',
                                    'MozTransition'    :'transitionend',
                                    'WebkitTransition' :'webkitTransitionEnd'
                                },
                                transition
                                ;
                            for(transition in transitions){
                                if( element.style[transition] !== undefined ){
                                    return transitions[transition];
                                }
                            }
                        },

                        // gets current displayed percentage (if animating values this is the intermediary value)
                        displayPercent: function() {
                            var
                                barWidth       = $bar.width(),
                                totalWidth     = $module.width(),
                                minDisplay     = parseInt($bar.css('min-width'), 10),
                                displayPercent = (barWidth > minDisplay)
                                    ? (barWidth / totalWidth * 100)
                                    : module.percent
                                ;
                            return (settings.precision > 0)
                                ? Math.round(displayPercent * (10 * settings.precision)) / (10 * settings.precision)
                                : Math.round(displayPercent)
                                ;
                        },

                        percent: function() {
                            return module.percent || 0;
                        },
                        value: function() {
                            return module.value || 0;
                        },
                        total: function() {
                            return module.total || false;
                        }
                    },

                    is: {
                        success: function() {
                            return $module.hasClass(className.success);
                        },
                        warning: function() {
                            return $module.hasClass(className.warning);
                        },
                        error: function() {
                            return $module.hasClass(className.error);
                        },
                        active: function() {
                            return $module.hasClass(className.active);
                        },
                        visible: function() {
                            return $module.is(':visible');
                        }
                    },

                    remove: {
                        state: function() {
                            module.verbose('Removing stored state');
                            delete module.total;
                            delete module.percent;
                            delete module.value;
                        },
                        active: function() {
                            module.verbose('Removing active state');
                            $module.removeClass(className.active);
                        },
                        success: function() {
                            module.verbose('Removing success state');
                            $module.removeClass(className.success);
                        },
                        warning: function() {
                            module.verbose('Removing warning state');
                            $module.removeClass(className.warning);
                        },
                        error: function() {
                            module.verbose('Removing error state');
                            $module.removeClass(className.error);
                        }
                    },

                    set: {
                        barWidth: function(value) {
                            if(value > 100) {
                                module.error(error.tooHigh, value);
                            }
                            else if (value < 0) {
                                module.error(error.tooLow, value);
                            }
                            else {
                                $bar
                                    .css('width', value + '%')
                                ;
                                $module
                                    .attr('data-percent', parseInt(value, 10))
                                ;
                            }
                        },
                        duration: function(duration) {
                            duration = duration || settings.duration;
                            duration = (typeof duration == 'number')
                                ? duration + 'ms'
                                : duration
                            ;
                            module.verbose('Setting progress bar transition duration', duration);
                            $bar
                                .css({
                                    'transition-duration':  duration
                                })
                            ;
                        },
                        percent: function(percent) {
                            percent = (typeof percent == 'string')
                                ? +(percent.replace('%', ''))
                                : percent
                            ;
                            // round display percentage
                            percent = (settings.precision > 0)
                                ? Math.round(percent * (10 * settings.precision)) / (10 * settings.precision)
                                : Math.round(percent)
                            ;
                            module.percent = percent;
                            if( !module.has.total() ) {
                                module.value = (settings.precision > 0)
                                    ? Math.round( (percent / 100) * module.total * (10 * settings.precision)) / (10 * settings.precision)
                                    : Math.round( (percent / 100) * module.total * 10) / 10
                                ;
                                if(settings.limitValues) {
                                    module.value = (module.value > 100)
                                        ? 100
                                        : (module.value < 0)
                                        ? 0
                                        : module.value
                                    ;
                                }
                            }
                            module.set.barWidth(percent);
                            module.set.labelInterval();
                            module.set.labels();
                            settings.onChange.call(element, percent, module.value, module.total);
                        },
                        labelInterval: function() {
                            var
                                animationCallback = function() {
                                    module.verbose('Bar finished animating, removing continuous label updates');
                                    clearInterval(module.interval);
                                    animating = false;
                                    module.set.labels();
                                }
                                ;
                            clearInterval(module.interval);
                            $bar.one(transitionEnd + eventNamespace, animationCallback);
                            module.timer = setTimeout(animationCallback, settings.duration + 100);
                            animating = true;
                            module.interval = setInterval(module.set.labels, settings.framerate);
                        },
                        labels: function() {
                            module.verbose('Setting both bar progress and outer label text');
                            module.set.barLabel();
                            module.set.state();
                        },
                        label: function(text) {
                            text = text || '';
                            if(text) {
                                text = module.get.text(text);
                                module.debug('Setting label to text', text);
                                $label.text(text);
                            }
                        },
                        state: function(percent) {
                            percent = (percent !== undefined)
                                ? percent
                                : module.percent
                            ;
                            if(percent === 100) {
                                if(settings.autoSuccess && !(module.is.warning() || module.is.error())) {
                                    module.set.success();
                                    module.debug('Automatically triggering success at 100%');
                                }
                                else {
                                    module.verbose('Reached 100% removing active state');
                                    module.remove.active();
                                }
                            }
                            else if(percent > 0) {
                                module.verbose('Adjusting active progress bar label', percent);
                                module.set.active();
                            }
                            else {
                                module.remove.active();
                                module.set.label(settings.text.active);
                            }
                        },
                        barLabel: function(text) {
                            if(text !== undefined) {
                                $progress.text( module.get.text(text) );
                            }
                            else if(settings.label == 'ratio' && module.total) {
                                module.debug('Adding ratio to bar label');
                                $progress.text( module.get.text(settings.text.ratio) );
                            }
                            else if(settings.label == 'percent') {
                                module.debug('Adding percentage to bar label');
                                $progress.text( module.get.text(settings.text.percent) );
                            }
                        },
                        active: function(text) {
                            text = text || settings.text.active;
                            module.debug('Setting active state');
                            if(settings.showActivity && !module.is.active() ) {
                                $module.addClass(className.active);
                            }
                            module.remove.warning();
                            module.remove.error();
                            module.remove.success();
                            if(text) {
                                module.set.label(text);
                            }
                            settings.onActive.call(element, module.value, module.total);
                        },
                        success : function(text) {
                            text = text || settings.text.success;
                            module.debug('Setting success state');
                            $module.addClass(className.success);
                            module.remove.active();
                            module.remove.warning();
                            module.remove.error();
                            module.complete();
                            if(text) {
                                module.set.label(text);
                            }
                            settings.onSuccess.call(element, module.total);
                        },
                        warning : function(text) {
                            text = text || settings.text.warning;
                            module.debug('Setting warning state');
                            $module.addClass(className.warning);
                            module.remove.active();
                            module.remove.success();
                            module.remove.error();
                            module.complete();
                            if(text) {
                                module.set.label(text);
                            }
                            settings.onWarning.call(element, module.value, module.total);
                        },
                        error : function(text) {
                            text = text || settings.text.error;
                            module.debug('Setting error state');
                            $module.addClass(className.error);
                            module.remove.active();
                            module.remove.success();
                            module.remove.warning();
                            module.complete();
                            if(text) {
                                module.set.label(text);
                            }
                            settings.onError.call(element, module.value, module.total);
                        },
                        transitionEvent: function() {
                            transitionEnd = module.get.transitionEnd();
                        },
                        total: function(totalValue) {
                            module.total = totalValue;
                        },
                        value: function(value) {
                            module.value = value;
                        },
                        progress: function(value) {
                            var
                                numericValue = module.get.numericValue(value),
                                percentComplete
                                ;
                            if(numericValue === false) {
                                module.error(error.nonNumeric, value);
                            }
                            if( module.has.total() ) {
                                module.set.value(numericValue);
                                percentComplete = (numericValue / module.total) * 100;
                                module.debug('Calculating percent complete from total', percentComplete);
                                module.set.percent( percentComplete );
                            }
                            else {
                                percentComplete = numericValue;
                                module.debug('Setting value to exact percentage value', percentComplete);
                                module.set.percent( percentComplete );
                            }
                        }
                    },

                    setting: function(name, value) {
                        module.debug('Changing setting', name, value);
                        if( $.isPlainObject(name) ) {
                            $.extend(true, settings, name);
                        }
                        else if(value !== undefined) {
                            settings[name] = value;
                        }
                        else {
                            return settings[name];
                        }
                    },
                    internal: function(name, value) {
                        if( $.isPlainObject(name) ) {
                            $.extend(true, module, name);
                        }
                        else if(value !== undefined) {
                            module[name] = value;
                        }
                        else {
                            return module[name];
                        }
                    },
                    debug: function() {
                        if(settings.debug) {
                            if(settings.performance) {
                                module.performance.log(arguments);
                            }
                            else {
                                module.debug = Function.prototype.bind.call(console.info, console, settings.name + ':');
                                module.debug.apply(console, arguments);
                            }
                        }
                    },
                    verbose: function() {
                        if(settings.verbose && settings.debug) {
                            if(settings.performance) {
                                module.performance.log(arguments);
                            }
                            else {
                                module.verbose = Function.prototype.bind.call(console.info, console, settings.name + ':');
                                module.verbose.apply(console, arguments);
                            }
                        }
                    },
                    error: function() {
                        module.error = Function.prototype.bind.call(console.error, console, settings.name + ':');
                        module.error.apply(console, arguments);
                    },
                    performance: {
                        log: function(message) {
                            var
                                currentTime,
                                executionTime,
                                previousTime
                                ;
                            if(settings.performance) {
                                currentTime   = new Date().getTime();
                                previousTime  = time || currentTime;
                                executionTime = currentTime - previousTime;
                                time          = currentTime;
                                performance.push({
                                    'Name'           : message[0],
                                    'Arguments'      : [].slice.call(message, 1) || '',
                                    'Element'        : element,
                                    'Execution Time' : executionTime
                                });
                            }
                            clearTimeout(module.performance.timer);
                            module.performance.timer = setTimeout(module.performance.display, 500);
                        },
                        display: function() {
                            var
                                title = settings.name + ':',
                                totalTime = 0
                                ;
                            time = false;
                            clearTimeout(module.performance.timer);
                            $.each(performance, function(index, data) {
                                totalTime += data['Execution Time'];
                            });
                            title += ' ' + totalTime + 'ms';
                            if(moduleSelector) {
                                title += ' \'' + moduleSelector + '\'';
                            }
                            if( (console.group !== undefined || console.table !== undefined) && performance.length > 0) {
                                console.groupCollapsed(title);
                                if(console.table) {
                                    console.table(performance);
                                }
                                else {
                                    $.each(performance, function(index, data) {
                                        console.log(data['Name'] + ': ' + data['Execution Time']+'ms');
                                    });
                                }
                                console.groupEnd();
                            }
                            performance = [];
                        }
                    },
                    invoke: function(query, passedArguments, context) {
                        var
                            object = instance,
                            maxDepth,
                            found,
                            response
                            ;
                        passedArguments = passedArguments || queryArguments;
                        context         = element         || context;
                        if(typeof query == 'string' && object !== undefined) {
                            query    = query.split(/[\. ]/);
                            maxDepth = query.length - 1;
                            $.each(query, function(depth, value) {
                                var camelCaseValue = (depth != maxDepth)
                                        ? value + query[depth + 1].charAt(0).toUpperCase() + query[depth + 1].slice(1)
                                        : query
                                    ;
                                if( $.isPlainObject( object[camelCaseValue] ) && (depth != maxDepth) ) {
                                    object = object[camelCaseValue];
                                }
                                else if( object[camelCaseValue] !== undefined ) {
                                    found = object[camelCaseValue];
                                    return false;
                                }
                                else if( $.isPlainObject( object[value] ) && (depth != maxDepth) ) {
                                    object = object[value];
                                }
                                else if( object[value] !== undefined ) {
                                    found = object[value];
                                    return false;
                                }
                                else {
                                    module.error(error.method, query);
                                    return false;
                                }
                            });
                        }
                        if ( $.isFunction( found ) ) {
                            response = found.apply(context, passedArguments);
                        }
                        else if(found !== undefined) {
                            response = found;
                        }
                        if($.isArray(returnedValue)) {
                            returnedValue.push(response);
                        }
                        else if(returnedValue !== undefined) {
                            returnedValue = [returnedValue, response];
                        }
                        else if(response !== undefined) {
                            returnedValue = response;
                        }
                        return found;
                    }
                };

                if(methodInvoked) {
                    if(instance === undefined) {
                        module.initialize();
                    }
                    module.invoke(query);
                }
                else {
                    if(instance !== undefined) {
                        instance.invoke('destroy');
                    }
                    module.initialize();
                }
            })
        ;

        return (returnedValue !== undefined)
            ? returnedValue
            : this
            ;
    };

    $.fn.progress.settings = {

        name         : 'Progress',
        namespace    : 'progress',

        debug        : false,
        verbose      : false,
        performance  : true,

        random       : {
            min : 2,
            max : 5
        },

        duration     : 300,

        autoSuccess  : true,
        showActivity : true,
        limitValues  : true,

        label        : 'percent',
        precision    : 0,
        framerate    : (1000 / 30), /// 30 fps

        percent      : false,
        total        : false,
        value        : false,

        onChange     : function(percent, value, total){},
        onSuccess    : function(total){},
        onActive     : function(value, total){},
        onError      : function(value, total){},
        onWarning    : function(value, total){},

        error    : {
            method     : 'The method you called is not defined.',
            nonNumeric : 'Progress value is non numeric',
            tooHigh    : 'Value specified is above 100%',
            tooLow     : 'Value specified is below 0%'
        },

        regExp: {
            variable: /\{\$*[A-z0-9]+\}/g
        },

        metadata: {
            percent : 'percent',
            total   : 'total',
            value   : 'value'
        },

        selector : {
            bar      : '> .bar',
            label    : '> .label',
            progress : '.bar > .progress'
        },

        text : {
            active  : false,
            error   : false,
            success : false,
            warning : false,
            percent : '{percent}%',
            ratio   : '{value} of {total}'
        },

        className : {
            active  : 'active',
            error   : 'error',
            success : 'success',
            warning : 'warning'
        }

    };


})( jQuery, window, document );
/*!
 * # Semantic UI 2.1.6 - Rating
 * http://github.com/semantic-org/semantic-ui/
 *
 *
 * Copyright 2015 Contributors
 * Released under the MIT license
 * http://opensource.org/licenses/MIT
 *
 */

;(function ($, window, document, undefined) {

    "use strict";

    $.fn.rating = function(parameters) {
        var
            $allModules     = $(this),
            moduleSelector  = $allModules.selector || '',

            time            = new Date().getTime(),
            performance     = [],

            query           = arguments[0],
            methodInvoked   = (typeof query == 'string'),
            queryArguments  = [].slice.call(arguments, 1),
            returnedValue
            ;
        $allModules
            .each(function() {
                var
                    settings        = ( $.isPlainObject(parameters) )
                        ? $.extend(true, {}, $.fn.rating.settings, parameters)
                        : $.extend({}, $.fn.rating.settings),

                    namespace       = settings.namespace,
                    className       = settings.className,
                    metadata        = settings.metadata,
                    selector        = settings.selector,
                    error           = settings.error,

                    eventNamespace  = '.' + namespace,
                    moduleNamespace = 'module-' + namespace,

                    element         = this,
                    instance        = $(this).data(moduleNamespace),

                    $module         = $(this),
                    $icon           = $module.find(selector.icon),

                    module
                    ;

                module = {

                    initialize: function() {
                        module.verbose('Initializing rating module', settings);

                        if($icon.length === 0) {
                            module.setup.layout();
                        }

                        if(settings.interactive) {
                            module.enable();
                        }
                        else {
                            module.disable();
                        }
                        module.set.rating( module.get.initialRating() );
                        module.instantiate();
                    },

                    instantiate: function() {
                        module.verbose('Instantiating module', settings);
                        instance = module;
                        $module
                            .data(moduleNamespace, module)
                        ;
                    },

                    destroy: function() {
                        module.verbose('Destroying previous instance', instance);
                        module.remove.events();
                        $module
                            .removeData(moduleNamespace)
                        ;
                    },

                    refresh: function() {
                        $icon   = $module.find(selector.icon);
                    },

                    setup: {
                        layout: function() {
                            var
                                maxRating = module.get.maxRating(),
                                html      = $.fn.rating.settings.templates.icon(maxRating)
                                ;
                            module.debug('Generating icon html dynamically');
                            $module
                                .html(html)
                            ;
                            module.refresh();
                        }
                    },

                    event: {
                        mouseenter: function() {
                            var
                                $activeIcon = $(this)
                                ;
                            $activeIcon
                                .nextAll()
                                .removeClass(className.selected)
                            ;
                            $module
                                .addClass(className.selected)
                            ;
                            $activeIcon
                                .addClass(className.selected)
                                .prevAll()
                                .addClass(className.selected)
                            ;
                        },
                        mouseleave: function() {
                            $module
                                .removeClass(className.selected)
                            ;
                            $icon
                                .removeClass(className.selected)
                            ;
                        },
                        click: function() {
                            var
                                $activeIcon   = $(this),
                                currentRating = module.get.rating(),
                                rating        = $icon.index($activeIcon) + 1,
                                canClear      = (settings.clearable == 'auto')
                                    ? ($icon.length === 1)
                                    : settings.clearable
                                ;
                            if(canClear && currentRating == rating) {
                                module.clearRating();
                            }
                            else {
                                module.set.rating( rating );
                            }
                        }
                    },

                    clearRating: function() {
                        module.debug('Clearing current rating');
                        module.set.rating(0);
                    },

                    bind: {
                        events: function() {
                            module.verbose('Binding events');
                            $module
                                .on('mouseenter' + eventNamespace, selector.icon, module.event.mouseenter)
                                .on('mouseleave' + eventNamespace, selector.icon, module.event.mouseleave)
                                .on('click'      + eventNamespace, selector.icon, module.event.click)
                            ;
                        }
                    },

                    remove: {
                        events: function() {
                            module.verbose('Removing events');
                            $module
                                .off(eventNamespace)
                            ;
                        }
                    },

                    enable: function() {
                        module.debug('Setting rating to interactive mode');
                        module.bind.events();
                        $module
                            .removeClass(className.disabled)
                        ;
                    },

                    disable: function() {
                        module.debug('Setting rating to read-only mode');
                        module.remove.events();
                        $module
                            .addClass(className.disabled)
                        ;
                    },

                    get: {
                        initialRating: function() {
                            if($module.data(metadata.rating) !== undefined) {
                                $module.removeData(metadata.rating);
                                return $module.data(metadata.rating);
                            }
                            return settings.initialRating;
                        },
                        maxRating: function() {
                            if($module.data(metadata.maxRating) !== undefined) {
                                $module.removeData(metadata.maxRating);
                                return $module.data(metadata.maxRating);
                            }
                            return settings.maxRating;
                        },
                        rating: function() {
                            var
                                currentRating = $icon.filter('.' + className.active).length
                                ;
                            module.verbose('Current rating retrieved', currentRating);
                            return currentRating;
                        }
                    },

                    set: {
                        rating: function(rating) {
                            var
                                ratingIndex = (rating - 1 >= 0)
                                    ? (rating - 1)
                                    : 0,
                                $activeIcon = $icon.eq(ratingIndex)
                                ;
                            $module
                                .removeClass(className.selected)
                            ;
                            $icon
                                .removeClass(className.selected)
                                .removeClass(className.active)
                            ;
                            if(rating > 0) {
                                module.verbose('Setting current rating to', rating);
                                $activeIcon
                                    .prevAll()
                                    .andSelf()
                                    .addClass(className.active)
                                ;
                            }
                            settings.onRate.call(element, rating);
                        }
                    },

                    setting: function(name, value) {
                        module.debug('Changing setting', name, value);
                        if( $.isPlainObject(name) ) {
                            $.extend(true, settings, name);
                        }
                        else if(value !== undefined) {
                            settings[name] = value;
                        }
                        else {
                            return settings[name];
                        }
                    },
                    internal: function(name, value) {
                        if( $.isPlainObject(name) ) {
                            $.extend(true, module, name);
                        }
                        else if(value !== undefined) {
                            module[name] = value;
                        }
                        else {
                            return module[name];
                        }
                    },
                    debug: function() {
                        if(settings.debug) {
                            if(settings.performance) {
                                module.performance.log(arguments);
                            }
                            else {
                                module.debug = Function.prototype.bind.call(console.info, console, settings.name + ':');
                                module.debug.apply(console, arguments);
                            }
                        }
                    },
                    verbose: function() {
                        if(settings.verbose && settings.debug) {
                            if(settings.performance) {
                                module.performance.log(arguments);
                            }
                            else {
                                module.verbose = Function.prototype.bind.call(console.info, console, settings.name + ':');
                                module.verbose.apply(console, arguments);
                            }
                        }
                    },
                    error: function() {
                        module.error = Function.prototype.bind.call(console.error, console, settings.name + ':');
                        module.error.apply(console, arguments);
                    },
                    performance: {
                        log: function(message) {
                            var
                                currentTime,
                                executionTime,
                                previousTime
                                ;
                            if(settings.performance) {
                                currentTime   = new Date().getTime();
                                previousTime  = time || currentTime;
                                executionTime = currentTime - previousTime;
                                time          = currentTime;
                                performance.push({
                                    'Name'           : message[0],
                                    'Arguments'      : [].slice.call(message, 1) || '',
                                    'Element'        : element,
                                    'Execution Time' : executionTime
                                });
                            }
                            clearTimeout(module.performance.timer);
                            module.performance.timer = setTimeout(module.performance.display, 500);
                        },
                        display: function() {
                            var
                                title = settings.name + ':',
                                totalTime = 0
                                ;
                            time = false;
                            clearTimeout(module.performance.timer);
                            $.each(performance, function(index, data) {
                                totalTime += data['Execution Time'];
                            });
                            title += ' ' + totalTime + 'ms';
                            if(moduleSelector) {
                                title += ' \'' + moduleSelector + '\'';
                            }
                            if($allModules.length > 1) {
                                title += ' ' + '(' + $allModules.length + ')';
                            }
                            if( (console.group !== undefined || console.table !== undefined) && performance.length > 0) {
                                console.groupCollapsed(title);
                                if(console.table) {
                                    console.table(performance);
                                }
                                else {
                                    $.each(performance, function(index, data) {
                                        console.log(data['Name'] + ': ' + data['Execution Time']+'ms');
                                    });
                                }
                                console.groupEnd();
                            }
                            performance = [];
                        }
                    },
                    invoke: function(query, passedArguments, context) {
                        var
                            object = instance,
                            maxDepth,
                            found,
                            response
                            ;
                        passedArguments = passedArguments || queryArguments;
                        context         = element         || context;
                        if(typeof query == 'string' && object !== undefined) {
                            query    = query.split(/[\. ]/);
                            maxDepth = query.length - 1;
                            $.each(query, function(depth, value) {
                                var camelCaseValue = (depth != maxDepth)
                                        ? value + query[depth + 1].charAt(0).toUpperCase() + query[depth + 1].slice(1)
                                        : query
                                    ;
                                if( $.isPlainObject( object[camelCaseValue] ) && (depth != maxDepth) ) {
                                    object = object[camelCaseValue];
                                }
                                else if( object[camelCaseValue] !== undefined ) {
                                    found = object[camelCaseValue];
                                    return false;
                                }
                                else if( $.isPlainObject( object[value] ) && (depth != maxDepth) ) {
                                    object = object[value];
                                }
                                else if( object[value] !== undefined ) {
                                    found = object[value];
                                    return false;
                                }
                                else {
                                    return false;
                                }
                            });
                        }
                        if ( $.isFunction( found ) ) {
                            response = found.apply(context, passedArguments);
                        }
                        else if(found !== undefined) {
                            response = found;
                        }
                        if($.isArray(returnedValue)) {
                            returnedValue.push(response);
                        }
                        else if(returnedValue !== undefined) {
                            returnedValue = [returnedValue, response];
                        }
                        else if(response !== undefined) {
                            returnedValue = response;
                        }
                        return found;
                    }
                };
                if(methodInvoked) {
                    if(instance === undefined) {
                        module.initialize();
                    }
                    module.invoke(query);
                }
                else {
                    if(instance !== undefined) {
                        instance.invoke('destroy');
                    }
                    module.initialize();
                }
            })
        ;

        return (returnedValue !== undefined)
            ? returnedValue
            : this
            ;
    };

    $.fn.rating.settings = {

        name          : 'Rating',
        namespace     : 'rating',

        debug         : false,
        verbose       : false,
        performance   : true,

        initialRating : 0,
        interactive   : true,
        maxRating     : 4,
        clearable     : 'auto',

        onRate        : function(rating){},

        error         : {
            method    : 'The method you called is not defined',
            noMaximum : 'No maximum rating specified. Cannot generate HTML automatically'
        },


        metadata: {
            rating    : 'rating',
            maxRating : 'maxRating'
        },

        className : {
            active   : 'active',
            disabled : 'disabled',
            selected : 'selected',
            loading  : 'loading'
        },

        selector  : {
            icon : '.icon'
        },

        templates: {
            icon: function(maxRating) {
                var
                    icon = 1,
                    html = ''
                    ;
                while(icon <= maxRating) {
                    html += '<i class="icon"></i>';
                    icon++;
                }
                return html;
            }
        }

    };

})( jQuery, window, document );

/*!
 * # Semantic UI 2.1.6 - Search
 * http://github.com/semantic-org/semantic-ui/
 *
 *
 * Copyright 2015 Contributors
 * Released under the MIT license
 * http://opensource.org/licenses/MIT
 *
 */

;(function ($, window, document, undefined) {

    "use strict";

    $.fn.search = function(parameters) {
        var
            $allModules     = $(this),
            moduleSelector  = $allModules.selector || '',

            time            = new Date().getTime(),
            performance     = [],

            query           = arguments[0],
            methodInvoked   = (typeof query == 'string'),
            queryArguments  = [].slice.call(arguments, 1),
            returnedValue
            ;
        $(this)
            .each(function() {
                var
                    settings          = ( $.isPlainObject(parameters) )
                        ? $.extend(true, {}, $.fn.search.settings, parameters)
                        : $.extend({}, $.fn.search.settings),

                    className       = settings.className,
                    metadata        = settings.metadata,
                    regExp          = settings.regExp,
                    fields          = settings.fields,
                    selector        = settings.selector,
                    error           = settings.error,
                    namespace       = settings.namespace,

                    eventNamespace  = '.' + namespace,
                    moduleNamespace = namespace + '-module',

                    $module         = $(this),
                    $prompt         = $module.find(selector.prompt),
                    $searchButton   = $module.find(selector.searchButton),
                    $results        = $module.find(selector.results),
                    $result         = $module.find(selector.result),
                    $category       = $module.find(selector.category),

                    element         = this,
                    instance        = $module.data(moduleNamespace),

                    module
                    ;

                module = {

                    initialize: function() {
                        module.verbose('Initializing module');
                        module.determine.searchFields();
                        module.bind.events();
                        module.set.type();
                        module.create.results();
                        module.instantiate();
                    },
                    instantiate: function() {
                        module.verbose('Storing instance of module', module);
                        instance = module;
                        $module
                            .data(moduleNamespace, module)
                        ;
                    },
                    destroy: function() {
                        module.verbose('Destroying instance');
                        $module
                            .off(eventNamespace)
                            .removeData(moduleNamespace)
                        ;
                    },

                    bind: {
                        events: function() {
                            module.verbose('Binding events to search');
                            if(settings.automatic) {
                                $module
                                    .on(module.get.inputEvent() + eventNamespace, selector.prompt, module.event.input)
                                ;
                                $prompt
                                    .attr('autocomplete', 'off')
                                ;
                            }
                            $module
                            // prompt
                                .on('focus'     + eventNamespace, selector.prompt, module.event.focus)
                                .on('blur'      + eventNamespace, selector.prompt, module.event.blur)
                                .on('keydown'   + eventNamespace, selector.prompt, module.handleKeyboard)
                                // search button
                                .on('click'     + eventNamespace, selector.searchButton, module.query)
                                // results
                                .on('mousedown' + eventNamespace, selector.results, module.event.result.mousedown)
                                .on('mouseup'   + eventNamespace, selector.results, module.event.result.mouseup)
                                .on('click'     + eventNamespace, selector.result,  module.event.result.click)
                            ;
                        }
                    },

                    determine: {
                        searchFields: function() {
                            // this makes sure $.extend does not add specified search fields to default fields
                            // this is the only setting which should not extend defaults
                            if(parameters && parameters.searchFields !== undefined) {
                                settings.searchFields = parameters.searchFields;
                            }
                        }
                    },

                    event: {
                        input: function() {
                            clearTimeout(module.timer);
                            module.timer = setTimeout(module.query, settings.searchDelay);
                        },
                        focus: function() {
                            module.set.focus();
                            if( module.has.minimumCharacters() ) {
                                module.query();
                                if( module.can.show() ) {
                                    module.showResults();
                                }
                            }
                        },
                        blur: function(event) {
                            var
                                pageLostFocus = (document.activeElement === this)
                                ;
                            if(!pageLostFocus && !module.resultsClicked) {
                                module.cancel.query();
                                module.remove.focus();
                                module.timer = setTimeout(module.hideResults, settings.hideDelay);
                            }
                        },
                        result: {
                            mousedown: function() {
                                module.resultsClicked = true;
                            },
                            mouseup: function() {
                                module.resultsClicked = false;
                            },
                            click: function(event) {
                                module.debug('Search result selected');
                                var
                                    $result = $(this),
                                    $title  = $result.find(selector.title).eq(0),
                                    $link   = $result.find('a[href]').eq(0),
                                    href    = $link.attr('href')   || false,
                                    target  = $link.attr('target') || false,
                                    title   = $title.html(),
                                // title is used for result lookup
                                    value   = ($title.length > 0)
                                        ? $title.text()
                                        : false,
                                    results = module.get.results(),
                                    result  = $result.data(metadata.result) || module.get.result(value, results),
                                    returnedValue
                                    ;
                                if( $.isFunction(settings.onSelect) ) {
                                    if(settings.onSelect.call(element, result, results) === false) {
                                        module.debug('Custom onSelect callback cancelled default select action');
                                        return;
                                    }
                                }
                                module.hideResults();
                                if(value) {
                                    module.set.value(value);
                                }
                                if(href) {
                                    module.verbose('Opening search link found in result', $link);
                                    if(target == '_blank' || event.ctrlKey) {
                                        window.open(href);
                                    }
                                    else {
                                        window.location.href = (href);
                                    }
                                }
                            }
                        }
                    },
                    handleKeyboard: function(event) {
                        var
                        // force selector refresh
                            $result      = $module.find(selector.result),
                            $category    = $module.find(selector.category),
                            currentIndex = $result.index( $result.filter('.' + className.active) ),
                            resultSize   = $result.length,

                            keyCode      = event.which,
                            keys         = {
                                backspace : 8,
                                enter     : 13,
                                escape    : 27,
                                upArrow   : 38,
                                downArrow : 40
                            },
                            newIndex
                            ;
                        // search shortcuts
                        if(keyCode == keys.escape) {
                            module.verbose('Escape key pressed, blurring search field');
                            module.trigger.blur();
                        }
                        if( module.is.visible() ) {
                            if(keyCode == keys.enter) {
                                module.verbose('Enter key pressed, selecting active result');
                                if( $result.filter('.' + className.active).length > 0 ) {
                                    module.event.result.click.call($result.filter('.' + className.active), event);
                                    event.preventDefault();
                                    return false;
                                }
                            }
                            else if(keyCode == keys.upArrow) {
                                module.verbose('Up key pressed, changing active result');
                                newIndex = (currentIndex - 1 < 0)
                                    ? currentIndex
                                    : currentIndex - 1
                                ;
                                $category
                                    .removeClass(className.active)
                                ;
                                $result
                                    .removeClass(className.active)
                                    .eq(newIndex)
                                    .addClass(className.active)
                                    .closest($category)
                                    .addClass(className.active)
                                ;
                                event.preventDefault();
                            }
                            else if(keyCode == keys.downArrow) {
                                module.verbose('Down key pressed, changing active result');
                                newIndex = (currentIndex + 1 >= resultSize)
                                    ? currentIndex
                                    : currentIndex + 1
                                ;
                                $category
                                    .removeClass(className.active)
                                ;
                                $result
                                    .removeClass(className.active)
                                    .eq(newIndex)
                                    .addClass(className.active)
                                    .closest($category)
                                    .addClass(className.active)
                                ;
                                event.preventDefault();
                            }
                        }
                        else {
                            // query shortcuts
                            if(keyCode == keys.enter) {
                                module.verbose('Enter key pressed, executing query');
                                module.query();
                                module.set.buttonPressed();
                                $prompt.one('keyup', module.remove.buttonFocus);
                            }
                        }
                    },

                    setup: {
                        api: function() {
                            var
                                apiSettings = {
                                    debug     : settings.debug,
                                    on        : false,
                                    cache     : 'local',
                                    action    : 'search',
                                    onError   : module.error
                                },
                                searchHTML
                                ;
                            module.verbose('First request, initializing API');
                            $module.api(apiSettings);
                        }
                    },

                    can: {
                        useAPI: function() {
                            return $.fn.api !== undefined;
                        },
                        show: function() {
                            return module.is.focused() && !module.is.visible() && !module.is.empty();
                        },
                        transition: function() {
                            return settings.transition && $.fn.transition !== undefined && $module.transition('is supported');
                        }
                    },

                    is: {
                        empty: function() {
                            return ($results.html() === '');
                        },
                        visible: function() {
                            return ($results.filter(':visible').length > 0);
                        },
                        focused: function() {
                            return ($prompt.filter(':focus').length > 0);
                        }
                    },

                    trigger: {
                        blur: function() {
                            var
                                events        = document.createEvent('HTMLEvents'),
                                promptElement = $prompt[0]
                                ;
                            if(promptElement) {
                                module.verbose('Triggering native blur event');
                                events.initEvent('blur', false, false);
                                promptElement.dispatchEvent(events);
                            }
                        }
                    },

                    get: {
                        inputEvent: function() {
                            var
                                prompt = $prompt[0],
                                inputEvent   = (prompt !== undefined && prompt.oninput !== undefined)
                                    ? 'input'
                                    : (prompt !== undefined && prompt.onpropertychange !== undefined)
                                    ? 'propertychange'
                                    : 'keyup'
                                ;
                            return inputEvent;
                        },
                        value: function() {
                            return $prompt.val();
                        },
                        results: function() {
                            var
                                results = $module.data(metadata.results)
                                ;
                            return results;
                        },
                        result: function(value, results) {
                            var
                                lookupFields = ['title', 'id'],
                                result       = false
                                ;
                            value = (value !== undefined)
                                ? value
                                : module.get.value()
                            ;
                            results = (results !== undefined)
                                ? results
                                : module.get.results()
                            ;
                            if(settings.type === 'category') {
                                module.debug('Finding result that matches', value);
                                $.each(results, function(index, category) {
                                    if($.isArray(category.results)) {
                                        result = module.search.object(value, category.results, lookupFields)[0];
                                        // don't continue searching if a result is found
                                        if(result) {
                                            return false;
                                        }
                                    }
                                });
                            }
                            else {
                                module.debug('Finding result in results object', value);
                                result = module.search.object(value, results, lookupFields)[0];
                            }
                            return result || false;
                        },
                    },

                    set: {
                        focus: function() {
                            $module.addClass(className.focus);
                        },
                        loading: function() {
                            $module.addClass(className.loading);
                        },
                        value: function(value) {
                            module.verbose('Setting search input value', value);
                            $prompt
                                .val(value)
                            ;
                        },
                        type: function(type) {
                            type = type || settings.type;
                            if(settings.type == 'category') {
                                $module.addClass(settings.type);
                            }
                        },
                        buttonPressed: function() {
                            $searchButton.addClass(className.pressed);
                        }
                    },

                    remove: {
                        loading: function() {
                            $module.removeClass(className.loading);
                        },
                        focus: function() {
                            $module.removeClass(className.focus);
                        },
                        buttonPressed: function() {
                            $searchButton.removeClass(className.pressed);
                        }
                    },

                    query: function() {
                        var
                            searchTerm = module.get.value(),
                            cache = module.read.cache(searchTerm)
                            ;
                        if( module.has.minimumCharacters() )  {
                            if(cache) {
                                module.debug('Reading result from cache', searchTerm);
                                module.save.results(cache.results);
                                module.addResults(cache.html);
                                module.inject.id(cache.results);
                            }
                            else {
                                module.debug('Querying for', searchTerm);
                                if($.isPlainObject(settings.source) || $.isArray(settings.source)) {
                                    module.search.local(searchTerm);
                                }
                                else if( module.can.useAPI() ) {
                                    module.search.remote(searchTerm);
                                }
                                else {
                                    module.error(error.source);
                                }
                            }
                            settings.onSearchQuery.call(element, searchTerm);
                        }
                        else {
                            module.hideResults();
                        }
                    },

                    search: {
                        local: function(searchTerm) {
                            var
                                results = module.search.object(searchTerm, settings.content),
                                searchHTML
                                ;
                            module.set.loading();
                            module.save.results(results);
                            module.debug('Returned local search results', results);

                            searchHTML = module.generateResults({
                                results: results
                            });
                            module.remove.loading();
                            module.addResults(searchHTML);
                            module.inject.id(results);
                            module.write.cache(searchTerm, {
                                html    : searchHTML,
                                results : results
                            });
                        },
                        remote: function(searchTerm) {
                            var
                                apiSettings = {
                                    onSuccess : function(response) {
                                        module.parse.response.call(element, response, searchTerm);
                                    },
                                    onFailure: function() {
                                        module.displayMessage(error.serverError);
                                    },
                                    urlData: {
                                        query: searchTerm
                                    }
                                }
                                ;
                            if( !$module.api('get request') ) {
                                module.setup.api();
                            }
                            $.extend(true, apiSettings, settings.apiSettings);
                            module.debug('Executing search', apiSettings);
                            module.cancel.query();
                            $module
                                .api('setting', apiSettings)
                                .api('query')
                            ;
                        },
                        object: function(searchTerm, source, searchFields) {
                            var
                                results      = [],
                                fuzzyResults = [],
                                searchExp    = searchTerm.toString().replace(regExp.escape, '\\$&'),
                                matchRegExp  = new RegExp(regExp.beginsWith + searchExp, 'i'),

                            // avoid duplicates when pushing results
                                addResult = function(array, result) {
                                    var
                                        notResult      = ($.inArray(result, results) == -1),
                                        notFuzzyResult = ($.inArray(result, fuzzyResults) == -1)
                                        ;
                                    if(notResult && notFuzzyResult) {
                                        array.push(result);
                                    }
                                }
                                ;
                            source = source || settings.source;
                            searchFields = (searchFields !== undefined)
                                ? searchFields
                                : settings.searchFields
                            ;

                            // search fields should be array to loop correctly
                            if(!$.isArray(searchFields)) {
                                searchFields = [searchFields];
                            }

                            // exit conditions if no source
                            if(source === undefined || source === false) {
                                module.error(error.source);
                                return [];
                            }

                            // iterate through search fields looking for matches
                            $.each(searchFields, function(index, field) {
                                $.each(source, function(label, content) {
                                    var
                                        fieldExists = (typeof content[field] == 'string')
                                        ;
                                    if(fieldExists) {
                                        if( content[field].search(matchRegExp) !== -1) {
                                            // content starts with value (first in results)
                                            addResult(results, content);
                                        }
                                        else if(settings.searchFullText && module.fuzzySearch(searchTerm, content[field]) ) {
                                            // content fuzzy matches (last in results)
                                            addResult(fuzzyResults, content);
                                        }
                                    }
                                });
                            });
                            return $.merge(results, fuzzyResults);
                        }
                    },

                    fuzzySearch: function(query, term) {
                        var
                            termLength  = term.length,
                            queryLength = query.length
                            ;
                        if(typeof query !== 'string') {
                            return false;
                        }
                        query = query.toLowerCase();
                        term  = term.toLowerCase();
                        if(queryLength > termLength) {
                            return false;
                        }
                        if(queryLength === termLength) {
                            return (query === term);
                        }
                        search: for (var characterIndex = 0, nextCharacterIndex = 0; characterIndex < queryLength; characterIndex++) {
                            var
                                queryCharacter = query.charCodeAt(characterIndex)
                                ;
                            while(nextCharacterIndex < termLength) {
                                if(term.charCodeAt(nextCharacterIndex++) === queryCharacter) {
                                    continue search;
                                }
                            }
                            return false;
                        }
                        return true;
                    },

                    parse: {
                        response: function(response, searchTerm) {
                            var
                                searchHTML = module.generateResults(response)
                                ;
                            module.verbose('Parsing server response', response);
                            if(response !== undefined) {
                                if(searchTerm !== undefined && response[fields.results] !== undefined) {
                                    module.addResults(searchHTML);
                                    module.inject.id(response[fields.results]);
                                    module.write.cache(searchTerm, {
                                        html    : searchHTML,
                                        results : response[fields.results]
                                    });
                                    module.save.results(response[fields.results]);
                                }
                            }
                        }
                    },

                    cancel: {
                        query: function() {
                            if( module.can.useAPI() ) {
                                $module.api('abort');
                            }
                        }
                    },

                    has: {
                        minimumCharacters: function() {
                            var
                                searchTerm    = module.get.value(),
                                numCharacters = searchTerm.length
                                ;
                            return (numCharacters >= settings.minCharacters);
                        }
                    },

                    clear: {
                        cache: function(value) {
                            var
                                cache = $module.data(metadata.cache)
                                ;
                            if(!value) {
                                module.debug('Clearing cache', value);
                                $module.removeData(metadata.cache);
                            }
                            else if(value && cache && cache[value]) {
                                module.debug('Removing value from cache', value);
                                delete cache[value];
                                $module.data(metadata.cache, cache);
                            }
                        }
                    },

                    read: {
                        cache: function(name) {
                            var
                                cache = $module.data(metadata.cache)
                                ;
                            if(settings.cache) {
                                module.verbose('Checking cache for generated html for query', name);
                                return (typeof cache == 'object') && (cache[name] !== undefined)
                                    ? cache[name]
                                    : false
                                    ;
                            }
                            return false;
                        }
                    },

                    create: {
                        id: function(resultIndex, categoryIndex) {
                            var
                                resultID      = (resultIndex + 1), // not zero indexed
                                categoryID    = (categoryIndex + 1),
                                firstCharCode,
                                letterID,
                                id
                                ;
                            if(categoryIndex !== undefined) {
                                // start char code for "A"
                                letterID = String.fromCharCode(97 + categoryIndex);
                                id          = letterID + resultID;
                                module.verbose('Creating category result id', id);
                            }
                            else {
                                id = resultID;
                                module.verbose('Creating result id', id);
                            }
                            return id;
                        },
                        results: function() {
                            if($results.length === 0) {
                                $results = $('<div />')
                                    .addClass(className.results)
                                    .appendTo($module)
                                ;
                            }
                        }
                    },

                    inject: {
                        result: function(result, resultIndex, categoryIndex) {
                            module.verbose('Injecting result into results');
                            var
                                $selectedResult = (categoryIndex !== undefined)
                                    ? $results
                                    .children().eq(categoryIndex)
                                    .children(selector.result).eq(resultIndex)
                                    : $results
                                    .children(selector.result).eq(resultIndex)
                                ;
                            module.verbose('Injecting results metadata', $selectedResult);
                            $selectedResult
                                .data(metadata.result, result)
                            ;
                        },
                        id: function(results) {
                            module.debug('Injecting unique ids into results');
                            var
                            // since results may be object, we must use counters
                                categoryIndex = 0,
                                resultIndex   = 0
                                ;
                            if(settings.type === 'category') {
                                // iterate through each category result
                                $.each(results, function(index, category) {
                                    resultIndex = 0;
                                    $.each(category.results, function(index, value) {
                                        var
                                            result = category.results[index]
                                            ;
                                        if(result.id === undefined) {
                                            result.id = module.create.id(resultIndex, categoryIndex);
                                        }
                                        module.inject.result(result, resultIndex, categoryIndex);
                                        resultIndex++;
                                    });
                                    categoryIndex++;
                                });
                            }
                            else {
                                // top level
                                $.each(results, function(index, value) {
                                    var
                                        result = results[index]
                                        ;
                                    if(result.id === undefined) {
                                        result.id = module.create.id(resultIndex);
                                    }
                                    module.inject.result(result, resultIndex);
                                    resultIndex++;
                                });
                            }
                            return results;
                        }
                    },

                    save: {
                        results: function(results) {
                            module.verbose('Saving current search results to metadata', results);
                            $module.data(metadata.results, results);
                        }
                    },

                    write: {
                        cache: function(name, value) {
                            var
                                cache = ($module.data(metadata.cache) !== undefined)
                                    ? $module.data(metadata.cache)
                                    : {}
                                ;
                            if(settings.cache) {
                                module.verbose('Writing generated html to cache', name, value);
                                cache[name] = value;
                                $module
                                    .data(metadata.cache, cache)
                                ;
                            }
                        }
                    },

                    addResults: function(html) {
                        if( $.isFunction(settings.onResultsAdd) ) {
                            if( settings.onResultsAdd.call($results, html) === false ) {
                                module.debug('onResultsAdd callback cancelled default action');
                                return false;
                            }
                        }
                        $results
                            .html(html)
                        ;
                        if( module.can.show() ) {
                            module.showResults();
                        }
                    },

                    showResults: function() {
                        if(!module.is.visible()) {
                            if( module.can.transition() ) {
                                module.debug('Showing results with css animations');
                                $results
                                    .transition({
                                        animation  : settings.transition + ' in',
                                        debug      : settings.debug,
                                        verbose    : settings.verbose,
                                        duration   : settings.duration,
                                        queue      : true
                                    })
                                ;
                            }
                            else {
                                module.debug('Showing results with javascript');
                                $results
                                    .stop()
                                    .fadeIn(settings.duration, settings.easing)
                                ;
                            }
                            settings.onResultsOpen.call($results);
                        }
                    },
                    hideResults: function() {
                        if( module.is.visible() ) {
                            if( module.can.transition() ) {
                                module.debug('Hiding results with css animations');
                                $results
                                    .transition({
                                        animation  : settings.transition + ' out',
                                        debug      : settings.debug,
                                        verbose    : settings.verbose,
                                        duration   : settings.duration,
                                        queue      : true
                                    })
                                ;
                            }
                            else {
                                module.debug('Hiding results with javascript');
                                $results
                                    .stop()
                                    .fadeOut(settings.duration, settings.easing)
                                ;
                            }
                            settings.onResultsClose.call($results);
                        }
                    },

                    generateResults: function(response) {
                        module.debug('Generating html from response', response);
                        var
                            template       = settings.templates[settings.type],
                            isProperObject = ($.isPlainObject(response[fields.results]) && !$.isEmptyObject(response[fields.results])),
                            isProperArray  = ($.isArray(response[fields.results]) && response[fields.results].length > 0),
                            html           = ''
                            ;
                        if(isProperObject || isProperArray ) {
                            if(settings.maxResults > 0) {
                                if(isProperObject) {
                                    if(settings.type == 'standard') {
                                        module.error(error.maxResults);
                                    }
                                }
                                else {
                                    response[fields.results] = response[fields.results].slice(0, settings.maxResults);
                                }
                            }
                            if($.isFunction(template)) {
                                html = template(response, fields);
                            }
                            else {
                                module.error(error.noTemplate, false);
                            }
                        }
                        else {
                            html = module.displayMessage(error.noResults, 'empty');
                        }
                        settings.onResults.call(element, response);
                        return html;
                    },

                    displayMessage: function(text, type) {
                        type = type || 'standard';
                        module.debug('Displaying message', text, type);
                        module.addResults( settings.templates.message(text, type) );
                        return settings.templates.message(text, type);
                    },

                    setting: function(name, value) {
                        if( $.isPlainObject(name) ) {
                            $.extend(true, settings, name);
                        }
                        else if(value !== undefined) {
                            settings[name] = value;
                        }
                        else {
                            return settings[name];
                        }
                    },
                    internal: function(name, value) {
                        if( $.isPlainObject(name) ) {
                            $.extend(true, module, name);
                        }
                        else if(value !== undefined) {
                            module[name] = value;
                        }
                        else {
                            return module[name];
                        }
                    },
                    debug: function() {
                        if(settings.debug) {
                            if(settings.performance) {
                                module.performance.log(arguments);
                            }
                            else {
                                module.debug = Function.prototype.bind.call(console.info, console, settings.name + ':');
                                module.debug.apply(console, arguments);
                            }
                        }
                    },
                    verbose: function() {
                        if(settings.verbose && settings.debug) {
                            if(settings.performance) {
                                module.performance.log(arguments);
                            }
                            else {
                                module.verbose = Function.prototype.bind.call(console.info, console, settings.name + ':');
                                module.verbose.apply(console, arguments);
                            }
                        }
                    },
                    error: function() {
                        module.error = Function.prototype.bind.call(console.error, console, settings.name + ':');
                        module.error.apply(console, arguments);
                    },
                    performance: {
                        log: function(message) {
                            var
                                currentTime,
                                executionTime,
                                previousTime
                                ;
                            if(settings.performance) {
                                currentTime   = new Date().getTime();
                                previousTime  = time || currentTime;
                                executionTime = currentTime - previousTime;
                                time          = currentTime;
                                performance.push({
                                    'Name'           : message[0],
                                    'Arguments'      : [].slice.call(message, 1) || '',
                                    'Element'        : element,
                                    'Execution Time' : executionTime
                                });
                            }
                            clearTimeout(module.performance.timer);
                            module.performance.timer = setTimeout(module.performance.display, 500);
                        },
                        display: function() {
                            var
                                title = settings.name + ':',
                                totalTime = 0
                                ;
                            time = false;
                            clearTimeout(module.performance.timer);
                            $.each(performance, function(index, data) {
                                totalTime += data['Execution Time'];
                            });
                            title += ' ' + totalTime + 'ms';
                            if(moduleSelector) {
                                title += ' \'' + moduleSelector + '\'';
                            }
                            if($allModules.length > 1) {
                                title += ' ' + '(' + $allModules.length + ')';
                            }
                            if( (console.group !== undefined || console.table !== undefined) && performance.length > 0) {
                                console.groupCollapsed(title);
                                if(console.table) {
                                    console.table(performance);
                                }
                                else {
                                    $.each(performance, function(index, data) {
                                        console.log(data['Name'] + ': ' + data['Execution Time']+'ms');
                                    });
                                }
                                console.groupEnd();
                            }
                            performance = [];
                        }
                    },
                    invoke: function(query, passedArguments, context) {
                        var
                            object = instance,
                            maxDepth,
                            found,
                            response
                            ;
                        passedArguments = passedArguments || queryArguments;
                        context         = element         || context;
                        if(typeof query == 'string' && object !== undefined) {
                            query    = query.split(/[\. ]/);
                            maxDepth = query.length - 1;
                            $.each(query, function(depth, value) {
                                var camelCaseValue = (depth != maxDepth)
                                        ? value + query[depth + 1].charAt(0).toUpperCase() + query[depth + 1].slice(1)
                                        : query
                                    ;
                                if( $.isPlainObject( object[camelCaseValue] ) && (depth != maxDepth) ) {
                                    object = object[camelCaseValue];
                                }
                                else if( object[camelCaseValue] !== undefined ) {
                                    found = object[camelCaseValue];
                                    return false;
                                }
                                else if( $.isPlainObject( object[value] ) && (depth != maxDepth) ) {
                                    object = object[value];
                                }
                                else if( object[value] !== undefined ) {
                                    found = object[value];
                                    return false;
                                }
                                else {
                                    return false;
                                }
                            });
                        }
                        if( $.isFunction( found ) ) {
                            response = found.apply(context, passedArguments);
                        }
                        else if(found !== undefined) {
                            response = found;
                        }
                        if($.isArray(returnedValue)) {
                            returnedValue.push(response);
                        }
                        else if(returnedValue !== undefined) {
                            returnedValue = [returnedValue, response];
                        }
                        else if(response !== undefined) {
                            returnedValue = response;
                        }
                        return found;
                    }
                };
                if(methodInvoked) {
                    if(instance === undefined) {
                        module.initialize();
                    }
                    module.invoke(query);
                }
                else {
                    if(instance !== undefined) {
                        instance.invoke('destroy');
                    }
                    module.initialize();
                }

            })
        ;

        return (returnedValue !== undefined)
            ? returnedValue
            : this
            ;
    };

    $.fn.search.settings = {

        name           : 'Search',
        namespace      : 'search',

        debug          : false,
        verbose        : false,
        performance    : true,

        type           : 'standard',
        // template to use (specified in settings.templates)

        minCharacters  : 1,
        // minimum characters required to search

        apiSettings    : false,
        // API config

        source         : false,
        // object to search

        searchFields   : [
            'title',
            'description'
        ],
        // fields to search

        displayField   : '',
        // field to display in standard results template

        searchFullText : true,
        // whether to include fuzzy results in local search

        automatic      : true,
        // whether to add events to prompt automatically

        hideDelay      : 0,
        // delay before hiding menu after blur

        searchDelay    : 200,
        // delay before searching

        maxResults     : 7,
        // maximum results returned from local

        cache          : true,
        // whether to store lookups in local cache

        // transition settings
        transition     : 'scale',
        duration       : 200,
        easing         : 'easeOutExpo',

        // callbacks
        onSelect       : false,
        onResultsAdd   : false,

        onSearchQuery  : function(query){},
        onResults      : function(response){},

        onResultsOpen  : function(){},
        onResultsClose : function(){},

        className: {
            active  : 'active',
            empty   : 'empty',
            focus   : 'focus',
            loading : 'loading',
            results : 'results',
            pressed : 'down'
        },

        error : {
            source      : 'Cannot search. No source used, and Semantic API module was not included',
            noResults   : 'Your search returned no results',
            logging     : 'Error in debug logging, exiting.',
            noEndpoint  : 'No search endpoint was specified',
            noTemplate  : 'A valid template name was not specified.',
            serverError : 'There was an issue querying the server.',
            maxResults  : 'Results must be an array to use maxResults setting',
            method      : 'The method you called is not defined.'
        },

        metadata: {
            cache   : 'cache',
            results : 'results',
            result  : 'result'
        },

        regExp: {
            escape     : /[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g,
            beginsWith : '(?:\s|^)'
        },

        // maps api response attributes to internal representation
        fields: {
            categories      : 'results',     // array of categories (category view)
            categoryName    : 'name',        // name of category (category view)
            categoryResults : 'results',     // array of results (category view)
            description     : 'description', // result description
            image           : 'image',       // result image
            price           : 'price',       // result price
            results         : 'results',     // array of results (standard)
            title           : 'title',       // result title
            url             : 'url',         // result url
            action          : 'action',      // "view more" object name
            actionText      : 'text',        // "view more" text
            actionURL       : 'url'          // "view more" url
        },

        selector : {
            prompt       : '.prompt',
            searchButton : '.search.button',
            results      : '.results',
            category     : '.category',
            result       : '.result',
            title        : '.title, .name'
        },

        templates: {
            escape: function(string) {
                var
                    badChars     = /[&<>"'`]/g,
                    shouldEscape = /[&<>"'`]/,
                    escape       = {
                        "&": "&amp;",
                        "<": "&lt;",
                        ">": "&gt;",
                        '"': "&quot;",
                        "'": "&#x27;",
                        "`": "&#x60;"
                    },
                    escapedChar  = function(chr) {
                        return escape[chr];
                    }
                    ;
                if(shouldEscape.test(string)) {
                    return string.replace(badChars, escapedChar);
                }
                return string;
            },
            message: function(message, type) {
                var
                    html = ''
                    ;
                if(message !== undefined && type !== undefined) {
                    html +=  ''
                        + '<div class="message ' + type + '">'
                    ;
                    // message type
                    if(type == 'empty') {
                        html += ''
                            + '<div class="header">No Results</div class="header">'
                            + '<div class="description">' + message + '</div class="description">'
                        ;
                    }
                    else {
                        html += ' <div class="description">' + message + '</div>';
                    }
                    html += '</div>';
                }
                return html;
            },
            category: function(response, fields) {
                var
                    html = '',
                    escape = $.fn.search.settings.templates.escape
                    ;
                if(response[fields.categoryResults] !== undefined) {

                    // each category
                    $.each(response[fields.categoryResults], function(index, category) {
                        if(category[fields.results] !== undefined && category.results.length > 0) {

                            html  += '<div class="category">';

                            if(category[fields.categoryName] !== undefined) {
                                html += '<div class="name">' + category[fields.categoryName] + '</div>';
                            }

                            // each item inside category
                            $.each(category.results, function(index, result) {
                                if(result[fields.url]) {
                                    html  += '<a class="result" href="' + result[fields.url] + '">';
                                }
                                else {
                                    html  += '<a class="result">';
                                }
                                if(result[fields.image] !== undefined) {
                                    html += ''
                                        + '<div class="image">'
                                        + ' <img src="' + result[fields.image] + '">'
                                        + '</div>'
                                    ;
                                }
                                html += '<div class="content">';
                                if(result[fields.price] !== undefined) {
                                    html += '<div class="price">' + result[fields.price] + '</div>';
                                }
                                if(result[fields.title] !== undefined) {
                                    html += '<div class="title">' + result[fields.title] + '</div>';
                                }
                                if(result[fields.description] !== undefined) {
                                    html += '<div class="description">' + result[fields.description] + '</div>';
                                }
                                html  += ''
                                    + '</div>'
                                ;
                                html += '</a>';
                            });
                            html  += ''
                                + '</div>'
                            ;
                        }
                    });
                    if(response[fields.action]) {
                        html += ''
                            + '<a href="' + response[fields.action][fields.actionURL] + '" class="action">'
                            +   response[fields.action][fields.actionText]
                            + '</a>';
                    }
                    return html;
                }
                return false;
            },
            standard: function(response, fields) {
                var
                    html = ''
                    ;
                if(response[fields.results] !== undefined) {

                    // each result
                    $.each(response[fields.results], function(index, result) {
                        if(result[fields.url]) {
                            html  += '<a class="result" href="' + result[fields.url] + '">';
                        }
                        else {
                            html  += '<a class="result">';
                        }
                        if(result[fields.image] !== undefined) {
                            html += ''
                                + '<div class="image">'
                                + ' <img src="' + result[fields.image] + '">'
                                + '</div>'
                            ;
                        }
                        html += '<div class="content">';
                        if(result[fields.price] !== undefined) {
                            html += '<div class="price">' + result[fields.price] + '</div>';
                        }
                        if(result[fields.title] !== undefined) {
                            html += '<div class="title">' + result[fields.title] + '</div>';
                        }
                        if(result[fields.description] !== undefined) {
                            html += '<div class="description">' + result[fields.description] + '</div>';
                        }
                        html  += ''
                            + '</div>'
                        ;
                        html += '</a>';
                    });

                    if(response[fields.action]) {
                        html += ''
                            + '<a href="' + response[fields.action][fields.actionURL] + '" class="action">'
                            +   response[fields.action][fields.actionText]
                            + '</a>';
                    }
                    return html;
                }
                return false;
            }
        }
    };

})( jQuery, window, document );

/*!
 * # Semantic UI 2.1.6 - Shape
 * http://github.com/semantic-org/semantic-ui/
 *
 *
 * Copyright 2015 Contributors
 * Released under the MIT license
 * http://opensource.org/licenses/MIT
 *
 */

;(function ( $, window, document, undefined ) {

    "use strict";

    $.fn.shape = function(parameters) {
        var
            $allModules     = $(this),
            $body           = $('body'),

            time            = new Date().getTime(),
            performance     = [],

            query           = arguments[0],
            methodInvoked   = (typeof query == 'string'),
            queryArguments  = [].slice.call(arguments, 1),

            requestAnimationFrame = window.requestAnimationFrame
                || window.mozRequestAnimationFrame
                || window.webkitRequestAnimationFrame
                || window.msRequestAnimationFrame
                || function(callback) { setTimeout(callback, 0); },

            returnedValue
            ;

        $allModules
            .each(function() {
                var
                    moduleSelector = $allModules.selector || '',
                    settings       = ( $.isPlainObject(parameters) )
                        ? $.extend(true, {}, $.fn.shape.settings, parameters)
                        : $.extend({}, $.fn.shape.settings),

                // internal aliases
                    namespace     = settings.namespace,
                    selector      = settings.selector,
                    error         = settings.error,
                    className     = settings.className,

                // define namespaces for modules
                    eventNamespace  = '.' + namespace,
                    moduleNamespace = 'module-' + namespace,

                // selector cache
                    $module       = $(this),
                    $sides        = $module.find(selector.sides),
                    $side         = $module.find(selector.side),

                // private variables
                    nextIndex = false,
                    $activeSide,
                    $nextSide,

                // standard module
                    element       = this,
                    instance      = $module.data(moduleNamespace),
                    module
                    ;

                module = {

                    initialize: function() {
                        module.verbose('Initializing module for', element);
                        module.set.defaultSide();
                        module.instantiate();
                    },

                    instantiate: function() {
                        module.verbose('Storing instance of module', module);
                        instance = module;
                        $module
                            .data(moduleNamespace, instance)
                        ;
                    },

                    destroy: function() {
                        module.verbose('Destroying previous module for', element);
                        $module
                            .removeData(moduleNamespace)
                            .off(eventNamespace)
                        ;
                    },

                    refresh: function() {
                        module.verbose('Refreshing selector cache for', element);
                        $module = $(element);
                        $sides  = $(this).find(selector.shape);
                        $side   = $(this).find(selector.side);
                    },

                    repaint: function() {
                        module.verbose('Forcing repaint event');
                        var
                            shape          = $sides[0] || document.createElement('div'),
                            fakeAssignment = shape.offsetWidth
                            ;
                    },

                    animate: function(propertyObject, callback) {
                        module.verbose('Animating box with properties', propertyObject);
                        callback = callback || function(event) {
                                module.verbose('Executing animation callback');
                                if(event !== undefined) {
                                    event.stopPropagation();
                                }
                                module.reset();
                                module.set.active();
                            };
                        settings.beforeChange.call($nextSide[0]);
                        if(module.get.transitionEvent()) {
                            module.verbose('Starting CSS animation');
                            $module
                                .addClass(className.animating)
                            ;
                            $sides
                                .css(propertyObject)
                                .one(module.get.transitionEvent(), callback)
                            ;
                            module.set.duration(settings.duration);
                            requestAnimationFrame(function() {
                                $module
                                    .addClass(className.animating)
                                ;
                                $activeSide
                                    .addClass(className.hidden)
                                ;
                            });
                        }
                        else {
                            callback();
                        }
                    },

                    queue: function(method) {
                        module.debug('Queueing animation of', method);
                        $sides
                            .one(module.get.transitionEvent(), function() {
                                module.debug('Executing queued animation');
                                setTimeout(function(){
                                    $module.shape(method);
                                }, 0);
                            })
                        ;
                    },

                    reset: function() {
                        module.verbose('Animating states reset');
                        $module
                            .removeClass(className.animating)
                            .attr('style', '')
                            .removeAttr('style')
                        ;
                        // removeAttr style does not consistently work in safari
                        $sides
                            .attr('style', '')
                            .removeAttr('style')
                        ;
                        $side
                            .attr('style', '')
                            .removeAttr('style')
                            .removeClass(className.hidden)
                        ;
                        $nextSide
                            .removeClass(className.animating)
                            .attr('style', '')
                            .removeAttr('style')
                        ;
                    },

                    is: {
                        complete: function() {
                            return ($side.filter('.' + className.active)[0] == $nextSide[0]);
                        },
                        animating: function() {
                            return $module.hasClass(className.animating);
                        }
                    },

                    set: {

                        defaultSide: function() {
                            $activeSide = $module.find('.' + settings.className.active);
                            $nextSide   = ( $activeSide.next(selector.side).length > 0 )
                                ? $activeSide.next(selector.side)
                                : $module.find(selector.side).first()
                            ;
                            nextIndex = false;
                            module.verbose('Active side set to', $activeSide);
                            module.verbose('Next side set to', $nextSide);
                        },

                        duration: function(duration) {
                            duration = duration || settings.duration;
                            duration = (typeof duration == 'number')
                                ? duration + 'ms'
                                : duration
                            ;
                            module.verbose('Setting animation duration', duration);
                            if(settings.duration || settings.duration === 0) {
                                $sides.add($side)
                                    .css({
                                        '-webkit-transition-duration': duration,
                                        '-moz-transition-duration': duration,
                                        '-ms-transition-duration': duration,
                                        '-o-transition-duration': duration,
                                        'transition-duration': duration
                                    })
                                ;
                            }
                        },

                        currentStageSize: function() {
                            var
                                $activeSide = $module.find('.' + settings.className.active),
                                width       = $activeSide.outerWidth(true),
                                height      = $activeSide.outerHeight(true)
                                ;
                            $module
                                .css({
                                    width: width,
                                    height: height
                                })
                            ;
                        },

                        stageSize: function() {
                            var
                                $clone      = $module.clone().addClass(className.loading),
                                $activeSide = $clone.find('.' + settings.className.active),
                                $nextSide   = (nextIndex)
                                    ? $clone.find(selector.side).eq(nextIndex)
                                    : ( $activeSide.next(selector.side).length > 0 )
                                    ? $activeSide.next(selector.side)
                                    : $clone.find(selector.side).first(),
                                newSize = {}
                                ;
                            module.set.currentStageSize();
                            $activeSide.removeClass(className.active);
                            $nextSide.addClass(className.active);
                            $clone.insertAfter($module);
                            newSize = {
                                width  : $nextSide.outerWidth(true),
                                height : $nextSide.outerHeight(true)
                            };
                            $clone.remove();
                            $module
                                .css(newSize)
                            ;
                            module.verbose('Resizing stage to fit new content', newSize);
                        },

                        nextSide: function(selector) {
                            nextIndex = selector;
                            $nextSide = $side.filter(selector);
                            nextIndex = $side.index($nextSide);
                            if($nextSide.length === 0) {
                                module.set.defaultSide();
                                module.error(error.side);
                            }
                            module.verbose('Next side manually set to', $nextSide);
                        },

                        active: function() {
                            module.verbose('Setting new side to active', $nextSide);
                            $side
                                .removeClass(className.active)
                            ;
                            $nextSide
                                .addClass(className.active)
                            ;
                            settings.onChange.call($nextSide[0]);
                            module.set.defaultSide();
                        }
                    },

                    flip: {

                        up: function() {
                            if(module.is.complete() && !module.is.animating() && !settings.allowRepeats) {
                                module.debug('Side already visible', $nextSide);
                                return;
                            }
                            if( !module.is.animating()) {
                                module.debug('Flipping up', $nextSide);
                                module.set.stageSize();
                                module.stage.above();
                                module.animate( module.get.transform.up() );
                            }
                            else {
                                module.queue('flip up');
                            }
                        },

                        down: function() {
                            if(module.is.complete() && !module.is.animating() && !settings.allowRepeats) {
                                module.debug('Side already visible', $nextSide);
                                return;
                            }
                            if( !module.is.animating()) {
                                module.debug('Flipping down', $nextSide);
                                module.set.stageSize();
                                module.stage.below();
                                module.animate( module.get.transform.down() );
                            }
                            else {
                                module.queue('flip down');
                            }
                        },

                        left: function() {
                            if(module.is.complete() && !module.is.animating() && !settings.allowRepeats) {
                                module.debug('Side already visible', $nextSide);
                                return;
                            }
                            if( !module.is.animating()) {
                                module.debug('Flipping left', $nextSide);
                                module.set.stageSize();
                                module.stage.left();
                                module.animate(module.get.transform.left() );
                            }
                            else {
                                module.queue('flip left');
                            }
                        },

                        right: function() {
                            if(module.is.complete() && !module.is.animating() && !settings.allowRepeats) {
                                module.debug('Side already visible', $nextSide);
                                return;
                            }
                            if( !module.is.animating()) {
                                module.debug('Flipping right', $nextSide);
                                module.set.stageSize();
                                module.stage.right();
                                module.animate(module.get.transform.right() );
                            }
                            else {
                                module.queue('flip right');
                            }
                        },

                        over: function() {
                            if(module.is.complete() && !module.is.animating() && !settings.allowRepeats) {
                                module.debug('Side already visible', $nextSide);
                                return;
                            }
                            if( !module.is.animating()) {
                                module.debug('Flipping over', $nextSide);
                                module.set.stageSize();
                                module.stage.behind();
                                module.animate(module.get.transform.over() );
                            }
                            else {
                                module.queue('flip over');
                            }
                        },

                        back: function() {
                            if(module.is.complete() && !module.is.animating() && !settings.allowRepeats) {
                                module.debug('Side already visible', $nextSide);
                                return;
                            }
                            if( !module.is.animating()) {
                                module.debug('Flipping back', $nextSide);
                                module.set.stageSize();
                                module.stage.behind();
                                module.animate(module.get.transform.back() );
                            }
                            else {
                                module.queue('flip back');
                            }
                        }

                    },

                    get: {

                        transform: {
                            up: function() {
                                var
                                    translate = {
                                        y: -(($activeSide.outerHeight(true) - $nextSide.outerHeight(true)) / 2),
                                        z: -($activeSide.outerHeight(true) / 2)
                                    }
                                    ;
                                return {
                                    transform: 'translateY(' + translate.y + 'px) translateZ('+ translate.z + 'px) rotateX(-90deg)'
                                };
                            },

                            down: function() {
                                var
                                    translate = {
                                        y: -(($activeSide.outerHeight(true) - $nextSide.outerHeight(true)) / 2),
                                        z: -($activeSide.outerHeight(true) / 2)
                                    }
                                    ;
                                return {
                                    transform: 'translateY(' + translate.y + 'px) translateZ('+ translate.z + 'px) rotateX(90deg)'
                                };
                            },

                            left: function() {
                                var
                                    translate = {
                                        x : -(($activeSide.outerWidth(true) - $nextSide.outerWidth(true)) / 2),
                                        z : -($activeSide.outerWidth(true) / 2)
                                    }
                                    ;
                                return {
                                    transform: 'translateX(' + translate.x + 'px) translateZ(' + translate.z + 'px) rotateY(90deg)'
                                };
                            },

                            right: function() {
                                var
                                    translate = {
                                        x : -(($activeSide.outerWidth(true) - $nextSide.outerWidth(true)) / 2),
                                        z : -($activeSide.outerWidth(true) / 2)
                                    }
                                    ;
                                return {
                                    transform: 'translateX(' + translate.x + 'px) translateZ(' + translate.z + 'px) rotateY(-90deg)'
                                };
                            },

                            over: function() {
                                var
                                    translate = {
                                        x : -(($activeSide.outerWidth(true) - $nextSide.outerWidth(true)) / 2)
                                    }
                                    ;
                                return {
                                    transform: 'translateX(' + translate.x + 'px) rotateY(180deg)'
                                };
                            },

                            back: function() {
                                var
                                    translate = {
                                        x : -(($activeSide.outerWidth(true) - $nextSide.outerWidth(true)) / 2)
                                    }
                                    ;
                                return {
                                    transform: 'translateX(' + translate.x + 'px) rotateY(-180deg)'
                                };
                            }
                        },

                        transitionEvent: function() {
                            var
                                element     = document.createElement('element'),
                                transitions = {
                                    'transition'       :'transitionend',
                                    'OTransition'      :'oTransitionEnd',
                                    'MozTransition'    :'transitionend',
                                    'WebkitTransition' :'webkitTransitionEnd'
                                },
                                transition
                                ;
                            for(transition in transitions){
                                if( element.style[transition] !== undefined ){
                                    return transitions[transition];
                                }
                            }
                        },

                        nextSide: function() {
                            return ( $activeSide.next(selector.side).length > 0 )
                                ? $activeSide.next(selector.side)
                                : $module.find(selector.side).first()
                                ;
                        }

                    },

                    stage: {

                        above: function() {
                            var
                                box = {
                                    origin : (($activeSide.outerHeight(true) - $nextSide.outerHeight(true)) / 2),
                                    depth  : {
                                        active : ($nextSide.outerHeight(true) / 2),
                                        next   : ($activeSide.outerHeight(true) / 2)
                                    }
                                }
                                ;
                            module.verbose('Setting the initial animation position as above', $nextSide, box);
                            $sides
                                .css({
                                    'transform' : 'translateZ(-' + box.depth.active + 'px)'
                                })
                            ;
                            $activeSide
                                .css({
                                    'transform' : 'rotateY(0deg) translateZ(' + box.depth.active + 'px)'
                                })
                            ;
                            $nextSide
                                .addClass(className.animating)
                                .css({
                                    'top'       : box.origin + 'px',
                                    'transform' : 'rotateX(90deg) translateZ(' + box.depth.next + 'px)'
                                })
                            ;
                        },

                        below: function() {
                            var
                                box = {
                                    origin : (($activeSide.outerHeight(true) - $nextSide.outerHeight(true)) / 2),
                                    depth  : {
                                        active : ($nextSide.outerHeight(true) / 2),
                                        next   : ($activeSide.outerHeight(true) / 2)
                                    }
                                }
                                ;
                            module.verbose('Setting the initial animation position as below', $nextSide, box);
                            $sides
                                .css({
                                    'transform' : 'translateZ(-' + box.depth.active + 'px)'
                                })
                            ;
                            $activeSide
                                .css({
                                    'transform' : 'rotateY(0deg) translateZ(' + box.depth.active + 'px)'
                                })
                            ;
                            $nextSide
                                .addClass(className.animating)
                                .css({
                                    'top'       : box.origin + 'px',
                                    'transform' : 'rotateX(-90deg) translateZ(' + box.depth.next + 'px)'
                                })
                            ;
                        },

                        left: function() {
                            var
                                height = {
                                    active : $activeSide.outerWidth(true),
                                    next   : $nextSide.outerWidth(true)
                                },
                                box = {
                                    origin : ( ( height.active - height.next ) / 2),
                                    depth  : {
                                        active : (height.next / 2),
                                        next   : (height.active / 2)
                                    }
                                }
                                ;
                            module.verbose('Setting the initial animation position as left', $nextSide, box);
                            $sides
                                .css({
                                    'transform' : 'translateZ(-' + box.depth.active + 'px)'
                                })
                            ;
                            $activeSide
                                .css({
                                    'transform' : 'rotateY(0deg) translateZ(' + box.depth.active + 'px)'
                                })
                            ;
                            $nextSide
                                .addClass(className.animating)
                                .css({
                                    'left'      : box.origin + 'px',
                                    'transform' : 'rotateY(-90deg) translateZ(' + box.depth.next + 'px)'
                                })
                            ;
                        },

                        right: function() {
                            var
                                height = {
                                    active : $activeSide.outerWidth(true),
                                    next   : $nextSide.outerWidth(true)
                                },
                                box = {
                                    origin : ( ( height.active - height.next ) / 2),
                                    depth  : {
                                        active : (height.next / 2),
                                        next   : (height.active / 2)
                                    }
                                }
                                ;
                            module.verbose('Setting the initial animation position as left', $nextSide, box);
                            $sides
                                .css({
                                    'transform' : 'translateZ(-' + box.depth.active + 'px)'
                                })
                            ;
                            $activeSide
                                .css({
                                    'transform' : 'rotateY(0deg) translateZ(' + box.depth.active + 'px)'
                                })
                            ;
                            $nextSide
                                .addClass(className.animating)
                                .css({
                                    'left'      : box.origin + 'px',
                                    'transform' : 'rotateY(90deg) translateZ(' + box.depth.next + 'px)'
                                })
                            ;
                        },

                        behind: function() {
                            var
                                height = {
                                    active : $activeSide.outerWidth(true),
                                    next   : $nextSide.outerWidth(true)
                                },
                                box = {
                                    origin : ( ( height.active - height.next ) / 2),
                                    depth  : {
                                        active : (height.next / 2),
                                        next   : (height.active / 2)
                                    }
                                }
                                ;
                            module.verbose('Setting the initial animation position as behind', $nextSide, box);
                            $activeSide
                                .css({
                                    'transform' : 'rotateY(0deg)'
                                })
                            ;
                            $nextSide
                                .addClass(className.animating)
                                .css({
                                    'left'      : box.origin + 'px',
                                    'transform' : 'rotateY(-180deg)'
                                })
                            ;
                        }
                    },
                    setting: function(name, value) {
                        module.debug('Changing setting', name, value);
                        if( $.isPlainObject(name) ) {
                            $.extend(true, settings, name);
                        }
                        else if(value !== undefined) {
                            settings[name] = value;
                        }
                        else {
                            return settings[name];
                        }
                    },
                    internal: function(name, value) {
                        if( $.isPlainObject(name) ) {
                            $.extend(true, module, name);
                        }
                        else if(value !== undefined) {
                            module[name] = value;
                        }
                        else {
                            return module[name];
                        }
                    },
                    debug: function() {
                        if(settings.debug) {
                            if(settings.performance) {
                                module.performance.log(arguments);
                            }
                            else {
                                module.debug = Function.prototype.bind.call(console.info, console, settings.name + ':');
                                module.debug.apply(console, arguments);
                            }
                        }
                    },
                    verbose: function() {
                        if(settings.verbose && settings.debug) {
                            if(settings.performance) {
                                module.performance.log(arguments);
                            }
                            else {
                                module.verbose = Function.prototype.bind.call(console.info, console, settings.name + ':');
                                module.verbose.apply(console, arguments);
                            }
                        }
                    },
                    error: function() {
                        module.error = Function.prototype.bind.call(console.error, console, settings.name + ':');
                        module.error.apply(console, arguments);
                    },
                    performance: {
                        log: function(message) {
                            var
                                currentTime,
                                executionTime,
                                previousTime
                                ;
                            if(settings.performance) {
                                currentTime   = new Date().getTime();
                                previousTime  = time || currentTime;
                                executionTime = currentTime - previousTime;
                                time          = currentTime;
                                performance.push({
                                    'Name'           : message[0],
                                    'Arguments'      : [].slice.call(message, 1) || '',
                                    'Element'        : element,
                                    'Execution Time' : executionTime
                                });
                            }
                            clearTimeout(module.performance.timer);
                            module.performance.timer = setTimeout(module.performance.display, 500);
                        },
                        display: function() {
                            var
                                title = settings.name + ':',
                                totalTime = 0
                                ;
                            time = false;
                            clearTimeout(module.performance.timer);
                            $.each(performance, function(index, data) {
                                totalTime += data['Execution Time'];
                            });
                            title += ' ' + totalTime + 'ms';
                            if(moduleSelector) {
                                title += ' \'' + moduleSelector + '\'';
                            }
                            if($allModules.length > 1) {
                                title += ' ' + '(' + $allModules.length + ')';
                            }
                            if( (console.group !== undefined || console.table !== undefined) && performance.length > 0) {
                                console.groupCollapsed(title);
                                if(console.table) {
                                    console.table(performance);
                                }
                                else {
                                    $.each(performance, function(index, data) {
                                        console.log(data['Name'] + ': ' + data['Execution Time']+'ms');
                                    });
                                }
                                console.groupEnd();
                            }
                            performance = [];
                        }
                    },
                    invoke: function(query, passedArguments, context) {
                        var
                            object = instance,
                            maxDepth,
                            found,
                            response
                            ;
                        passedArguments = passedArguments || queryArguments;
                        context         = element         || context;
                        if(typeof query == 'string' && object !== undefined) {
                            query    = query.split(/[\. ]/);
                            maxDepth = query.length - 1;
                            $.each(query, function(depth, value) {
                                var camelCaseValue = (depth != maxDepth)
                                        ? value + query[depth + 1].charAt(0).toUpperCase() + query[depth + 1].slice(1)
                                        : query
                                    ;
                                if( $.isPlainObject( object[camelCaseValue] ) && (depth != maxDepth) ) {
                                    object = object[camelCaseValue];
                                }
                                else if( object[camelCaseValue] !== undefined ) {
                                    found = object[camelCaseValue];
                                    return false;
                                }
                                else if( $.isPlainObject( object[value] ) && (depth != maxDepth) ) {
                                    object = object[value];
                                }
                                else if( object[value] !== undefined ) {
                                    found = object[value];
                                    return false;
                                }
                                else {
                                    return false;
                                }
                            });
                        }
                        if ( $.isFunction( found ) ) {
                            response = found.apply(context, passedArguments);
                        }
                        else if(found !== undefined) {
                            response = found;
                        }
                        if($.isArray(returnedValue)) {
                            returnedValue.push(response);
                        }
                        else if(returnedValue !== undefined) {
                            returnedValue = [returnedValue, response];
                        }
                        else if(response !== undefined) {
                            returnedValue = response;
                        }
                        return found;
                    }
                };

                if(methodInvoked) {
                    if(instance === undefined) {
                        module.initialize();
                    }
                    module.invoke(query);
                }
                else {
                    if(instance !== undefined) {
                        instance.invoke('destroy');
                    }
                    module.initialize();
                }
            })
        ;

        return (returnedValue !== undefined)
            ? returnedValue
            : this
            ;
    };

    $.fn.shape.settings = {

        // module info
        name : 'Shape',

        // debug content outputted to console
        debug      : false,

        // verbose debug output
        verbose    : false,

        // performance data output
        performance: true,

        // event namespace
        namespace  : 'shape',

        // callback occurs on side change
        beforeChange : function() {},
        onChange     : function() {},

        // allow animation to same side
        allowRepeats: false,

        // animation duration
        duration   : false,

        // possible errors
        error: {
            side   : 'You tried to switch to a side that does not exist.',
            method : 'The method you called is not defined'
        },

        // classnames used
        className   : {
            animating : 'animating',
            hidden    : 'hidden',
            loading   : 'loading',
            active    : 'active'
        },

        // selectors used
        selector    : {
            sides : '.sides',
            side  : '.side'
        }

    };


})( jQuery, window, document );
/*!
 * # Semantic UI 2.1.6 - Sidebar
 * http://github.com/semantic-org/semantic-ui/
 *
 *
 * Copyright 2015 Contributors
 * Released under the MIT license
 * http://opensource.org/licenses/MIT
 *
 */

;(function ( $, window, document, undefined ) {

    "use strict";

    $.fn.sidebar = function(parameters) {
        var
            $allModules     = $(this),
            $window         = $(window),
            $document       = $(document),
            $html           = $('html'),
            $head           = $('head'),

            moduleSelector  = $allModules.selector || '',

            time            = new Date().getTime(),
            performance     = [],

            query           = arguments[0],
            methodInvoked   = (typeof query == 'string'),
            queryArguments  = [].slice.call(arguments, 1),

            requestAnimationFrame = window.requestAnimationFrame
                || window.mozRequestAnimationFrame
                || window.webkitRequestAnimationFrame
                || window.msRequestAnimationFrame
                || function(callback) { setTimeout(callback, 0); },

            returnedValue
            ;

        $allModules
            .each(function() {
                var
                    settings        = ( $.isPlainObject(parameters) )
                        ? $.extend(true, {}, $.fn.sidebar.settings, parameters)
                        : $.extend({}, $.fn.sidebar.settings),

                    selector        = settings.selector,
                    className       = settings.className,
                    namespace       = settings.namespace,
                    regExp          = settings.regExp,
                    error           = settings.error,

                    eventNamespace  = '.' + namespace,
                    moduleNamespace = 'module-' + namespace,

                    $module         = $(this),
                    $context        = $(settings.context),

                    $sidebars       = $module.children(selector.sidebar),
                    $fixed          = $context.children(selector.fixed),
                    $pusher         = $context.children(selector.pusher),
                    $style,

                    element         = this,
                    instance        = $module.data(moduleNamespace),

                    elementNamespace,
                    id,
                    currentScroll,
                    transitionEvent,

                    module
                    ;

                module      = {

                    initialize: function() {
                        module.debug('Initializing sidebar', parameters);

                        module.create.id();

                        transitionEvent = module.get.transitionEvent();

                        if(module.is.ios()) {
                            module.set.ios();
                        }

                        // avoids locking rendering if initialized in onReady
                        if(settings.delaySetup) {
                            requestAnimationFrame(module.setup.layout);
                        }
                        else {
                            module.setup.layout();
                        }

                        requestAnimationFrame(function() {
                            module.setup.cache();
                        });

                        module.instantiate();
                    },

                    instantiate: function() {
                        module.verbose('Storing instance of module', module);
                        instance = module;
                        $module
                            .data(moduleNamespace, module)
                        ;
                    },

                    create: {
                        id: function() {
                            id = (Math.random().toString(16) + '000000000').substr(2,8);
                            elementNamespace = '.' + id;
                            module.verbose('Creating unique id for element', id);
                        }
                    },

                    destroy: function() {
                        module.verbose('Destroying previous module for', $module);
                        $module
                            .off(eventNamespace)
                            .removeData(moduleNamespace)
                        ;
                        if(module.is.ios()) {
                            module.remove.ios();
                        }
                        // bound by uuid
                        $context.off(elementNamespace);
                        $window.off(elementNamespace);
                        $document.off(elementNamespace);
                    },

                    event: {
                        clickaway: function(event) {
                            var
                                clickedInPusher = ($pusher.find(event.target).length > 0 || $pusher.is(event.target)),
                                clickedContext  = ($context.is(event.target))
                                ;
                            if(clickedInPusher) {
                                module.verbose('User clicked on dimmed page');
                                module.hide();
                            }
                            if(clickedContext) {
                                module.verbose('User clicked on dimmable context (scaled out page)');
                                module.hide();
                            }
                        },
                        touch: function(event) {
                            //event.stopPropagation();
                        },
                        containScroll: function(event) {
                            if(element.scrollTop <= 0)  {
                                element.scrollTop = 1;
                            }
                            if((element.scrollTop + element.offsetHeight) >= element.scrollHeight) {
                                element.scrollTop = element.scrollHeight - element.offsetHeight - 1;
                            }
                        },
                        scroll: function(event) {
                            if( $(event.target).closest(selector.sidebar).length === 0 ) {
                                event.preventDefault();
                            }
                        }
                    },

                    bind: {
                        clickaway: function() {
                            module.verbose('Adding clickaway events to context', $context);
                            if(settings.closable) {
                                $context
                                    .on('click'    + elementNamespace, module.event.clickaway)
                                    .on('touchend' + elementNamespace, module.event.clickaway)
                                ;
                            }
                        },
                        scrollLock: function() {
                            if(settings.scrollLock) {
                                module.debug('Disabling page scroll');
                                $window
                                    .on('DOMMouseScroll' + elementNamespace, module.event.scroll)
                                ;
                            }
                            module.verbose('Adding events to contain sidebar scroll');
                            $document
                                .on('touchmove' + elementNamespace, module.event.touch)
                            ;
                            $module
                                .on('scroll' + eventNamespace, module.event.containScroll)
                            ;
                        }
                    },
                    unbind: {
                        clickaway: function() {
                            module.verbose('Removing clickaway events from context', $context);
                            $context.off(elementNamespace);
                        },
                        scrollLock: function() {
                            module.verbose('Removing scroll lock from page');
                            $document.off(elementNamespace);
                            $window.off(elementNamespace);
                            $module.off('scroll' + eventNamespace);
                        }
                    },

                    add: {
                        inlineCSS: function() {
                            var
                                width     = module.cache.width  || $module.outerWidth(),
                                height    = module.cache.height || $module.outerHeight(),
                                isRTL     = module.is.rtl(),
                                direction = module.get.direction(),
                                distance  = {
                                    left   : width,
                                    right  : -width,
                                    top    : height,
                                    bottom : -height
                                },
                                style
                                ;

                            if(isRTL){
                                module.verbose('RTL detected, flipping widths');
                                distance.left = -width;
                                distance.right = width;
                            }

                            style  = '<style>';

                            if(direction === 'left' || direction === 'right') {
                                module.debug('Adding CSS rules for animation distance', width);
                                style  += ''
                                    + ' .ui.visible.' + direction + '.sidebar ~ .fixed,'
                                    + ' .ui.visible.' + direction + '.sidebar ~ .pusher {'
                                    + '   -webkit-transform: translate3d('+ distance[direction] + 'px, 0, 0);'
                                    + '           transform: translate3d('+ distance[direction] + 'px, 0, 0);'
                                    + ' }'
                                ;
                            }
                            else if(direction === 'top' || direction == 'bottom') {
                                style  += ''
                                    + ' .ui.visible.' + direction + '.sidebar ~ .fixed,'
                                    + ' .ui.visible.' + direction + '.sidebar ~ .pusher {'
                                    + '   -webkit-transform: translate3d(0, ' + distance[direction] + 'px, 0);'
                                    + '           transform: translate3d(0, ' + distance[direction] + 'px, 0);'
                                    + ' }'
                                ;
                            }

                            /* IE is only browser not to create context with transforms */
                            /* https://www.w3.org/Bugs/Public/show_bug.cgi?id=16328 */
                            if( module.is.ie() ) {
                                if(direction === 'left' || direction === 'right') {
                                    module.debug('Adding CSS rules for animation distance', width);
                                    style  += ''
                                        + ' body.pushable > .ui.visible.' + direction + '.sidebar ~ .pusher:after {'
                                        + '   -webkit-transform: translate3d('+ distance[direction] + 'px, 0, 0);'
                                        + '           transform: translate3d('+ distance[direction] + 'px, 0, 0);'
                                        + ' }'
                                    ;
                                }
                                else if(direction === 'top' || direction == 'bottom') {
                                    style  += ''
                                        + ' body.pushable > .ui.visible.' + direction + '.sidebar ~ .pusher:after {'
                                        + '   -webkit-transform: translate3d(0, ' + distance[direction] + 'px, 0);'
                                        + '           transform: translate3d(0, ' + distance[direction] + 'px, 0);'
                                        + ' }'
                                    ;
                                }
                                /* opposite sides visible forces content overlay */
                                style += ''
                                    + ' body.pushable > .ui.visible.left.sidebar ~ .ui.visible.right.sidebar ~ .pusher:after,'
                                    + ' body.pushable > .ui.visible.right.sidebar ~ .ui.visible.left.sidebar ~ .pusher:after {'
                                    + '   -webkit-transform: translate3d(0px, 0, 0);'
                                    + '           transform: translate3d(0px, 0, 0);'
                                    + ' }'
                                ;
                            }
                            style += '</style>';
                            $style = $(style)
                                .appendTo($head)
                            ;
                            module.debug('Adding sizing css to head', $style);
                        }
                    },

                    refresh: function() {
                        module.verbose('Refreshing selector cache');
                        $context  = $(settings.context);
                        $sidebars = $context.children(selector.sidebar);
                        $pusher   = $context.children(selector.pusher);
                        $fixed    = $context.children(selector.fixed);
                        module.clear.cache();
                    },

                    refreshSidebars: function() {
                        module.verbose('Refreshing other sidebars');
                        $sidebars = $context.children(selector.sidebar);
                    },

                    repaint: function() {
                        module.verbose('Forcing repaint event');
                        element.style.display = 'none';
                        var ignored = element.offsetHeight;
                        element.scrollTop = element.scrollTop;
                        element.style.display = '';
                    },

                    setup: {
                        cache: function() {
                            module.cache = {
                                width  : $module.outerWidth(),
                                height : $module.outerHeight(),
                                rtl    : ($module.css('direction') == 'rtl')
                            };
                        },
                        layout: function() {
                            if( $context.children(selector.pusher).length === 0 ) {
                                module.debug('Adding wrapper element for sidebar');
                                module.error(error.pusher);
                                $pusher = $('<div class="pusher" />');
                                $context
                                    .children()
                                    .not(selector.omitted)
                                    .not($sidebars)
                                    .wrapAll($pusher)
                                ;
                                module.refresh();
                            }
                            if($module.nextAll(selector.pusher).length === 0 || $module.nextAll(selector.pusher)[0] !== $pusher[0]) {
                                module.debug('Moved sidebar to correct parent element');
                                module.error(error.movedSidebar, element);
                                $module.detach().prependTo($context);
                                module.refresh();
                            }
                            module.clear.cache();
                            module.set.pushable();
                            module.set.direction();
                        }
                    },

                    attachEvents: function(selector, event) {
                        var
                            $toggle = $(selector)
                            ;
                        event = $.isFunction(module[event])
                            ? module[event]
                            : module.toggle
                        ;
                        if($toggle.length > 0) {
                            module.debug('Attaching sidebar events to element', selector, event);
                            $toggle
                                .on('click' + eventNamespace, event)
                            ;
                        }
                        else {
                            module.error(error.notFound, selector);
                        }
                    },

                    show: function(callback) {
                        callback = $.isFunction(callback)
                            ? callback
                            : function(){}
                        ;
                        if(module.is.hidden()) {
                            module.refreshSidebars();
                            if(settings.overlay)  {
                                module.error(error.overlay);
                                settings.transition = 'overlay';
                            }
                            module.refresh();
                            if(module.othersActive()) {
                                module.debug('Other sidebars currently visible');
                                if(settings.exclusive) {
                                    // if not overlay queue animation after hide
                                    if(settings.transition != 'overlay') {
                                        module.hideOthers(module.show);
                                        return;
                                    }
                                    else {
                                        module.hideOthers();
                                    }
                                }
                                else {
                                    settings.transition = 'overlay';
                                }
                            }
                            module.pushPage(function() {
                                callback.call(element);
                                settings.onShow.call(element);
                            });
                            settings.onChange.call(element);
                            settings.onVisible.call(element);
                        }
                        else {
                            module.debug('Sidebar is already visible');
                        }
                    },

                    hide: function(callback) {
                        callback = $.isFunction(callback)
                            ? callback
                            : function(){}
                        ;
                        if(module.is.visible() || module.is.animating()) {
                            module.debug('Hiding sidebar', callback);
                            module.refreshSidebars();
                            module.pullPage(function() {
                                callback.call(element);
                                settings.onHidden.call(element);
                            });
                            settings.onChange.call(element);
                            settings.onHide.call(element);
                        }
                    },

                    othersAnimating: function() {
                        return ($sidebars.not($module).filter('.' + className.animating).length > 0);
                    },
                    othersVisible: function() {
                        return ($sidebars.not($module).filter('.' + className.visible).length > 0);
                    },
                    othersActive: function() {
                        return(module.othersVisible() || module.othersAnimating());
                    },

                    hideOthers: function(callback) {
                        var
                            $otherSidebars = $sidebars.not($module).filter('.' + className.visible),
                            sidebarCount   = $otherSidebars.length,
                            callbackCount  = 0
                            ;
                        callback = callback || function(){};
                        $otherSidebars
                            .sidebar('hide', function() {
                                callbackCount++;
                                if(callbackCount == sidebarCount) {
                                    callback();
                                }
                            })
                        ;
                    },

                    toggle: function() {
                        module.verbose('Determining toggled direction');
                        if(module.is.hidden()) {
                            module.show();
                        }
                        else {
                            module.hide();
                        }
                    },

                    pushPage: function(callback) {
                        var
                            transition = module.get.transition(),
                            $transition = (transition === 'overlay' || module.othersActive())
                                ? $module
                                : $pusher,
                            animate,
                            dim,
                            transitionEnd
                            ;
                        callback = $.isFunction(callback)
                            ? callback
                            : function(){}
                        ;
                        if(settings.transition == 'scale down') {
                            module.scrollToTop();
                        }
                        module.set.transition(transition);
                        module.repaint();
                        animate = function() {
                            module.bind.clickaway();
                            module.add.inlineCSS();
                            module.set.animating();
                            module.set.visible();
                        };
                        dim = function() {
                            module.set.dimmed();
                        };
                        transitionEnd = function(event) {
                            if( event.target == $transition[0] ) {
                                $transition.off(transitionEvent + elementNamespace, transitionEnd);
                                module.remove.animating();
                                module.bind.scrollLock();
                                callback.call(element);
                            }
                        };
                        $transition.off(transitionEvent + elementNamespace);
                        $transition.on(transitionEvent + elementNamespace, transitionEnd);
                        requestAnimationFrame(animate);
                        if(settings.dimPage && !module.othersVisible()) {
                            requestAnimationFrame(dim);
                        }
                    },

                    pullPage: function(callback) {
                        var
                            transition = module.get.transition(),
                            $transition = (transition == 'overlay' || module.othersActive())
                                ? $module
                                : $pusher,
                            animate,
                            transitionEnd
                            ;
                        callback = $.isFunction(callback)
                            ? callback
                            : function(){}
                        ;
                        module.verbose('Removing context push state', module.get.direction());

                        module.unbind.clickaway();
                        module.unbind.scrollLock();

                        animate = function() {
                            module.set.transition(transition);
                            module.set.animating();
                            module.remove.visible();
                            if(settings.dimPage && !module.othersVisible()) {
                                $pusher.removeClass(className.dimmed);
                            }
                        };
                        transitionEnd = function(event) {
                            if( event.target == $transition[0] ) {
                                $transition.off(transitionEvent + elementNamespace, transitionEnd);
                                module.remove.animating();
                                module.remove.transition();
                                module.remove.inlineCSS();
                                if(transition == 'scale down' || (settings.returnScroll && module.is.mobile()) ) {
                                    module.scrollBack();
                                }
                                callback.call(element);
                            }
                        };
                        $transition.off(transitionEvent + elementNamespace);
                        $transition.on(transitionEvent + elementNamespace, transitionEnd);
                        requestAnimationFrame(animate);
                    },

                    scrollToTop: function() {
                        module.verbose('Scrolling to top of page to avoid animation issues');
                        currentScroll = $(window).scrollTop();
                        $module.scrollTop(0);
                        window.scrollTo(0, 0);
                    },

                    scrollBack: function() {
                        module.verbose('Scrolling back to original page position');
                        window.scrollTo(0, currentScroll);
                    },

                    clear: {
                        cache: function() {
                            module.verbose('Clearing cached dimensions');
                            module.cache = {};
                        }
                    },

                    set: {

                        // ios only (scroll on html not document). This prevent auto-resize canvas/scroll in ios
                        ios: function() {
                            $html.addClass(className.ios);
                        },

                        // container
                        pushed: function() {
                            $context.addClass(className.pushed);
                        },
                        pushable: function() {
                            $context.addClass(className.pushable);
                        },

                        // pusher
                        dimmed: function() {
                            $pusher.addClass(className.dimmed);
                        },

                        // sidebar
                        active: function() {
                            $module.addClass(className.active);
                        },
                        animating: function() {
                            $module.addClass(className.animating);
                        },
                        transition: function(transition) {
                            transition = transition || module.get.transition();
                            $module.addClass(transition);
                        },
                        direction: function(direction) {
                            direction = direction || module.get.direction();
                            $module.addClass(className[direction]);
                        },
                        visible: function() {
                            $module.addClass(className.visible);
                        },
                        overlay: function() {
                            $module.addClass(className.overlay);
                        }
                    },
                    remove: {

                        inlineCSS: function() {
                            module.debug('Removing inline css styles', $style);
                            if($style && $style.length > 0) {
                                $style.remove();
                            }
                        },

                        // ios scroll on html not document
                        ios: function() {
                            $html.removeClass(className.ios);
                        },

                        // context
                        pushed: function() {
                            $context.removeClass(className.pushed);
                        },
                        pushable: function() {
                            $context.removeClass(className.pushable);
                        },

                        // sidebar
                        active: function() {
                            $module.removeClass(className.active);
                        },
                        animating: function() {
                            $module.removeClass(className.animating);
                        },
                        transition: function(transition) {
                            transition = transition || module.get.transition();
                            $module.removeClass(transition);
                        },
                        direction: function(direction) {
                            direction = direction || module.get.direction();
                            $module.removeClass(className[direction]);
                        },
                        visible: function() {
                            $module.removeClass(className.visible);
                        },
                        overlay: function() {
                            $module.removeClass(className.overlay);
                        }
                    },

                    get: {
                        direction: function() {
                            if($module.hasClass(className.top)) {
                                return className.top;
                            }
                            else if($module.hasClass(className.right)) {
                                return className.right;
                            }
                            else if($module.hasClass(className.bottom)) {
                                return className.bottom;
                            }
                            return className.left;
                        },
                        transition: function() {
                            var
                                direction = module.get.direction(),
                                transition
                                ;
                            transition = ( module.is.mobile() )
                                ? (settings.mobileTransition == 'auto')
                                ? settings.defaultTransition.mobile[direction]
                                : settings.mobileTransition
                                : (settings.transition == 'auto')
                                ? settings.defaultTransition.computer[direction]
                                : settings.transition
                            ;
                            module.verbose('Determined transition', transition);
                            return transition;
                        },
                        transitionEvent: function() {
                            var
                                element     = document.createElement('element'),
                                transitions = {
                                    'transition'       :'transitionend',
                                    'OTransition'      :'oTransitionEnd',
                                    'MozTransition'    :'transitionend',
                                    'WebkitTransition' :'webkitTransitionEnd'
                                },
                                transition
                                ;
                            for(transition in transitions){
                                if( element.style[transition] !== undefined ){
                                    return transitions[transition];
                                }
                            }
                        }
                    },

                    is: {

                        ie: function() {
                            var
                                isIE11 = (!(window.ActiveXObject) && 'ActiveXObject' in window),
                                isIE   = ('ActiveXObject' in window)
                                ;
                            return (isIE11 || isIE);
                        },

                        ios: function() {
                            var
                                userAgent      = navigator.userAgent,
                                isIOS          = userAgent.match(regExp.ios),
                                isMobileChrome = userAgent.match(regExp.mobileChrome)
                                ;
                            if(isIOS && !isMobileChrome) {
                                module.verbose('Browser was found to be iOS', userAgent);
                                return true;
                            }
                            else {
                                return false;
                            }
                        },
                        mobile: function() {
                            var
                                userAgent    = navigator.userAgent,
                                isMobile     = userAgent.match(regExp.mobile)
                                ;
                            if(isMobile) {
                                module.verbose('Browser was found to be mobile', userAgent);
                                return true;
                            }
                            else {
                                module.verbose('Browser is not mobile, using regular transition', userAgent);
                                return false;
                            }
                        },
                        hidden: function() {
                            return !module.is.visible();
                        },
                        visible: function() {
                            return $module.hasClass(className.visible);
                        },
                        // alias
                        open: function() {
                            return module.is.visible();
                        },
                        closed: function() {
                            return module.is.hidden();
                        },
                        vertical: function() {
                            return $module.hasClass(className.top);
                        },
                        animating: function() {
                            return $context.hasClass(className.animating);
                        },
                        rtl: function () {
                            if(module.cache.rtl === undefined) {
                                module.cache.rtl = ($module.css('direction') == 'rtl');
                            }
                            return module.cache.rtl;
                        }
                    },

                    setting: function(name, value) {
                        module.debug('Changing setting', name, value);
                        if( $.isPlainObject(name) ) {
                            $.extend(true, settings, name);
                        }
                        else if(value !== undefined) {
                            settings[name] = value;
                        }
                        else {
                            return settings[name];
                        }
                    },
                    internal: function(name, value) {
                        if( $.isPlainObject(name) ) {
                            $.extend(true, module, name);
                        }
                        else if(value !== undefined) {
                            module[name] = value;
                        }
                        else {
                            return module[name];
                        }
                    },
                    debug: function() {
                        if(settings.debug) {
                            if(settings.performance) {
                                module.performance.log(arguments);
                            }
                            else {
                                module.debug = Function.prototype.bind.call(console.info, console, settings.name + ':');
                                module.debug.apply(console, arguments);
                            }
                        }
                    },
                    verbose: function() {
                        if(settings.verbose && settings.debug) {
                            if(settings.performance) {
                                module.performance.log(arguments);
                            }
                            else {
                                module.verbose = Function.prototype.bind.call(console.info, console, settings.name + ':');
                                module.verbose.apply(console, arguments);
                            }
                        }
                    },
                    error: function() {
                        module.error = Function.prototype.bind.call(console.error, console, settings.name + ':');
                        module.error.apply(console, arguments);
                    },
                    performance: {
                        log: function(message) {
                            var
                                currentTime,
                                executionTime,
                                previousTime
                                ;
                            if(settings.performance) {
                                currentTime   = new Date().getTime();
                                previousTime  = time || currentTime;
                                executionTime = currentTime - previousTime;
                                time          = currentTime;
                                performance.push({
                                    'Name'           : message[0],
                                    'Arguments'      : [].slice.call(message, 1) || '',
                                    'Element'        : element,
                                    'Execution Time' : executionTime
                                });
                            }
                            clearTimeout(module.performance.timer);
                            module.performance.timer = setTimeout(module.performance.display, 500);
                        },
                        display: function() {
                            var
                                title = settings.name + ':',
                                totalTime = 0
                                ;
                            time = false;
                            clearTimeout(module.performance.timer);
                            $.each(performance, function(index, data) {
                                totalTime += data['Execution Time'];
                            });
                            title += ' ' + totalTime + 'ms';
                            if(moduleSelector) {
                                title += ' \'' + moduleSelector + '\'';
                            }
                            if( (console.group !== undefined || console.table !== undefined) && performance.length > 0) {
                                console.groupCollapsed(title);
                                if(console.table) {
                                    console.table(performance);
                                }
                                else {
                                    $.each(performance, function(index, data) {
                                        console.log(data['Name'] + ': ' + data['Execution Time']+'ms');
                                    });
                                }
                                console.groupEnd();
                            }
                            performance = [];
                        }
                    },
                    invoke: function(query, passedArguments, context) {
                        var
                            object = instance,
                            maxDepth,
                            found,
                            response
                            ;
                        passedArguments = passedArguments || queryArguments;
                        context         = element         || context;
                        if(typeof query == 'string' && object !== undefined) {
                            query    = query.split(/[\. ]/);
                            maxDepth = query.length - 1;
                            $.each(query, function(depth, value) {
                                var camelCaseValue = (depth != maxDepth)
                                        ? value + query[depth + 1].charAt(0).toUpperCase() + query[depth + 1].slice(1)
                                        : query
                                    ;
                                if( $.isPlainObject( object[camelCaseValue] ) && (depth != maxDepth) ) {
                                    object = object[camelCaseValue];
                                }
                                else if( object[camelCaseValue] !== undefined ) {
                                    found = object[camelCaseValue];
                                    return false;
                                }
                                else if( $.isPlainObject( object[value] ) && (depth != maxDepth) ) {
                                    object = object[value];
                                }
                                else if( object[value] !== undefined ) {
                                    found = object[value];
                                    return false;
                                }
                                else {
                                    module.error(error.method, query);
                                    return false;
                                }
                            });
                        }
                        if ( $.isFunction( found ) ) {
                            response = found.apply(context, passedArguments);
                        }
                        else if(found !== undefined) {
                            response = found;
                        }
                        if($.isArray(returnedValue)) {
                            returnedValue.push(response);
                        }
                        else if(returnedValue !== undefined) {
                            returnedValue = [returnedValue, response];
                        }
                        else if(response !== undefined) {
                            returnedValue = response;
                        }
                        return found;
                    }
                }
                ;

                if(methodInvoked) {
                    if(instance === undefined) {
                        module.initialize();
                    }
                    module.invoke(query);
                }
                else {
                    if(instance !== undefined) {
                        module.invoke('destroy');
                    }
                    module.initialize();
                }
            });

        return (returnedValue !== undefined)
            ? returnedValue
            : this
            ;
    };

    $.fn.sidebar.settings = {

        name              : 'Sidebar',
        namespace         : 'sidebar',

        debug             : false,
        verbose           : false,
        performance       : true,

        transition        : 'auto',
        mobileTransition  : 'auto',

        defaultTransition : {
            computer: {
                left   : 'uncover',
                right  : 'uncover',
                top    : 'overlay',
                bottom : 'overlay'
            },
            mobile: {
                left   : 'uncover',
                right  : 'uncover',
                top    : 'overlay',
                bottom : 'overlay'
            }
        },

        context           : 'body',
        exclusive         : false,
        closable          : true,
        dimPage           : true,
        scrollLock        : false,
        returnScroll      : false,
        delaySetup        : false,

        duration          : 500,

        onChange          : function(){},
        onShow            : function(){},
        onHide            : function(){},

        onHidden          : function(){},
        onVisible         : function(){},

        className         : {
            active    : 'active',
            animating : 'animating',
            dimmed    : 'dimmed',
            ios       : 'ios',
            pushable  : 'pushable',
            pushed    : 'pushed',
            right     : 'right',
            top       : 'top',
            left      : 'left',
            bottom    : 'bottom',
            visible   : 'visible'
        },

        selector: {
            fixed   : '.fixed',
            omitted : 'script, link, style, .ui.modal, .ui.dimmer, .ui.nag, .ui.fixed',
            pusher  : '.pusher',
            sidebar : '.ui.sidebar'
        },

        regExp: {
            ios          : /(iPad|iPhone|iPod)/g,
            mobileChrome : /(CriOS)/g,
            mobile       : /Mobile|iP(hone|od|ad)|Android|BlackBerry|IEMobile|Kindle|NetFront|Silk-Accelerated|(hpw|web)OS|Fennec|Minimo|Opera M(obi|ini)|Blazer|Dolfin|Dolphin|Skyfire|Zune/g
        },

        error   : {
            method       : 'The method you called is not defined.',
            pusher       : 'Had to add pusher element. For optimal performance make sure body content is inside a pusher element',
            movedSidebar : 'Had to move sidebar. For optimal performance make sure sidebar and pusher are direct children of your body tag',
            overlay      : 'The overlay setting is no longer supported, use animation: overlay',
            notFound     : 'There were no elements that matched the specified selector'
        }

    };


})( jQuery, window, document );

/*!
 * # Semantic UI 2.1.6 - Sticky
 * http://github.com/semantic-org/semantic-ui/
 *
 *
 * Copyright 2015 Contributors
 * Released under the MIT license
 * http://opensource.org/licenses/MIT
 *
 */

;(function ( $, window, document, undefined ) {

    "use strict";

    $.fn.sticky = function(parameters) {
        var
            $allModules    = $(this),
            moduleSelector = $allModules.selector || '',

            time           = new Date().getTime(),
            performance    = [],

            query          = arguments[0],
            methodInvoked  = (typeof query == 'string'),
            queryArguments = [].slice.call(arguments, 1),
            returnedValue
            ;

        $allModules
            .each(function() {
                var
                    settings              = ( $.isPlainObject(parameters) )
                        ? $.extend(true, {}, $.fn.sticky.settings, parameters)
                        : $.extend({}, $.fn.sticky.settings),

                    className             = settings.className,
                    namespace             = settings.namespace,
                    error                 = settings.error,

                    eventNamespace        = '.' + namespace,
                    moduleNamespace       = 'module-' + namespace,

                    $module               = $(this),
                    $window               = $(window),
                    $scroll               = $(settings.scrollContext),
                    $container,
                    $context,

                    selector              = $module.selector || '',
                    instance              = $module.data(moduleNamespace),

                    requestAnimationFrame = window.requestAnimationFrame
                        || window.mozRequestAnimationFrame
                        || window.webkitRequestAnimationFrame
                        || window.msRequestAnimationFrame
                        || function(callback) { setTimeout(callback, 0); },

                    element         = this,
                    observer,
                    module
                    ;

                module      = {

                    initialize: function() {

                        module.determineContainer();
                        module.determineContext();
                        module.verbose('Initializing sticky', settings, $container);

                        module.save.positions();
                        module.checkErrors();
                        module.bind.events();

                        if(settings.observeChanges) {
                            module.observeChanges();
                        }
                        module.instantiate();
                    },

                    instantiate: function() {
                        module.verbose('Storing instance of module', module);
                        instance = module;
                        $module
                            .data(moduleNamespace, module)
                        ;
                    },

                    destroy: function() {
                        module.verbose('Destroying previous instance');
                        module.reset();
                        if(observer) {
                            observer.disconnect();
                        }
                        $window
                            .off('load' + eventNamespace, module.event.load)
                            .off('resize' + eventNamespace, module.event.resize)
                        ;
                        $scroll
                            .off('scrollchange' + eventNamespace, module.event.scrollchange)
                        ;
                        $module.removeData(moduleNamespace);
                    },

                    observeChanges: function() {
                        var
                            context = $context[0]
                            ;
                        if('MutationObserver' in window) {
                            observer = new MutationObserver(function(mutations) {
                                clearTimeout(module.timer);
                                module.timer = setTimeout(function() {
                                    module.verbose('DOM tree modified, updating sticky menu', mutations);
                                    module.refresh();
                                }, 100);
                            });
                            observer.observe(element, {
                                childList : true,
                                subtree   : true
                            });
                            observer.observe(context, {
                                childList : true,
                                subtree   : true
                            });
                            module.debug('Setting up mutation observer', observer);
                        }
                    },

                    determineContainer: function() {
                        $container = $module.offsetParent();
                    },

                    determineContext: function() {
                        if(settings.context) {
                            $context = $(settings.context);
                        }
                        else {
                            $context = $container;
                        }
                        if($context.length === 0) {
                            module.error(error.invalidContext, settings.context, $module);
                            return;
                        }
                    },

                    checkErrors: function() {
                        if( module.is.hidden() ) {
                            module.error(error.visible, $module);
                        }
                        if(module.cache.element.height > module.cache.context.height) {
                            module.reset();
                            module.error(error.elementSize, $module);
                            return;
                        }
                    },

                    bind: {
                        events: function() {
                            $window
                                .on('load' + eventNamespace, module.event.load)
                                .on('resize' + eventNamespace, module.event.resize)
                            ;
                            // pub/sub pattern
                            $scroll
                                .off('scroll' + eventNamespace)
                                .on('scroll' + eventNamespace, module.event.scroll)
                                .on('scrollchange' + eventNamespace, module.event.scrollchange)
                            ;
                        }
                    },

                    event: {
                        load: function() {
                            module.verbose('Page contents finished loading');
                            requestAnimationFrame(module.refresh);
                        },
                        resize: function() {
                            module.verbose('Window resized');
                            requestAnimationFrame(module.refresh);
                        },
                        scroll: function() {
                            requestAnimationFrame(function() {
                                $scroll.triggerHandler('scrollchange' + eventNamespace, $scroll.scrollTop() );
                            });
                        },
                        scrollchange: function(event, scrollPosition) {
                            module.stick(scrollPosition);
                            settings.onScroll.call(element);
                        }
                    },

                    refresh: function(hardRefresh) {
                        module.reset();
                        if(!settings.context) {
                            module.determineContext();
                        }
                        if(hardRefresh) {
                            module.determineContainer();
                        }
                        module.save.positions();
                        module.stick();
                        settings.onReposition.call(element);
                    },

                    supports: {
                        sticky: function() {
                            var
                                $element = $('<div/>'),
                                element = $element[0]
                                ;
                            $element.addClass(className.supported);
                            return($element.css('position').match('sticky'));
                        }
                    },

                    save: {
                        lastScroll: function(scroll) {
                            module.lastScroll = scroll;
                        },
                        elementScroll: function(scroll) {
                            module.elementScroll = scroll;
                        },
                        positions: function() {
                            var
                                scrollContext = {
                                    height : $scroll.height()
                                },
                                element = {
                                    margin: {
                                        top    : parseInt($module.css('margin-top'), 10),
                                        bottom : parseInt($module.css('margin-bottom'), 10),
                                    },
                                    offset : $module.offset(),
                                    width  : $module.outerWidth(),
                                    height : $module.outerHeight()
                                },
                                context = {
                                    offset : $context.offset(),
                                    height : $context.outerHeight()
                                },
                                container = {
                                    height: $container.outerHeight()
                                }
                                ;
                            if( !module.is.standardScroll() ) {
                                module.debug('Non-standard scroll. Removing scroll offset from element offset');

                                scrollContext.top  = $scroll.scrollTop();
                                scrollContext.left = $scroll.scrollLeft();

                                element.offset.top  += scrollContext.top;
                                context.offset.top  += scrollContext.top;
                                element.offset.left += scrollContext.left;
                                context.offset.left += scrollContext.left;
                            }
                            module.cache = {
                                fits : ( element.height < scrollContext.height ),
                                scrollContext : {
                                    height : scrollContext.height
                                },
                                element: {
                                    margin : element.margin,
                                    top    : element.offset.top - element.margin.top,
                                    left   : element.offset.left,
                                    width  : element.width,
                                    height : element.height,
                                    bottom : element.offset.top + element.height
                                },
                                context: {
                                    top           : context.offset.top,
                                    height        : context.height,
                                    bottom        : context.offset.top + context.height
                                }
                            };
                            module.set.containerSize();
                            module.set.size();
                            module.stick();
                            module.debug('Caching element positions', module.cache);
                        }
                    },

                    get: {
                        direction: function(scroll) {
                            var
                                direction = 'down'
                                ;
                            scroll = scroll || $scroll.scrollTop();
                            if(module.lastScroll !== undefined) {
                                if(module.lastScroll < scroll) {
                                    direction = 'down';
                                }
                                else if(module.lastScroll > scroll) {
                                    direction = 'up';
                                }
                            }
                            return direction;
                        },
                        scrollChange: function(scroll) {
                            scroll = scroll || $scroll.scrollTop();
                            return (module.lastScroll)
                                ? (scroll - module.lastScroll)
                                : 0
                                ;
                        },
                        currentElementScroll: function() {
                            if(module.elementScroll) {
                                return module.elementScroll;
                            }
                            return ( module.is.top() )
                                ? Math.abs(parseInt($module.css('top'), 10))    || 0
                                : Math.abs(parseInt($module.css('bottom'), 10)) || 0
                                ;
                        },

                        elementScroll: function(scroll) {
                            scroll = scroll || $scroll.scrollTop();
                            var
                                element        = module.cache.element,
                                scrollContext  = module.cache.scrollContext,
                                delta          = module.get.scrollChange(scroll),
                                maxScroll      = (element.height - scrollContext.height + settings.offset),
                                elementScroll  = module.get.currentElementScroll(),
                                possibleScroll = (elementScroll + delta)
                                ;
                            if(module.cache.fits || possibleScroll < 0) {
                                elementScroll = 0;
                            }
                            else if(possibleScroll > maxScroll ) {
                                elementScroll = maxScroll;
                            }
                            else {
                                elementScroll = possibleScroll;
                            }
                            return elementScroll;
                        }
                    },

                    remove: {
                        lastScroll: function() {
                            delete module.lastScroll;
                        },
                        elementScroll: function(scroll) {
                            delete module.elementScroll;
                        },
                        offset: function() {
                            $module.css('margin-top', '');
                        }
                    },

                    set: {
                        offset: function() {
                            module.verbose('Setting offset on element', settings.offset);
                            $module
                                .css('margin-top', settings.offset)
                            ;
                        },
                        containerSize: function() {
                            var
                                tagName = $container.get(0).tagName
                                ;
                            if(tagName === 'HTML' || tagName == 'body') {
                                // this can trigger for too many reasons
                                //module.error(error.container, tagName, $module);
                                module.determineContainer();
                            }
                            else {
                                if( Math.abs($container.outerHeight() - module.cache.context.height) > settings.jitter) {
                                    module.debug('Context has padding, specifying exact height for container', module.cache.context.height);
                                    $container.css({
                                        height: module.cache.context.height
                                    });
                                }
                            }
                        },
                        minimumSize: function() {
                            var
                                element   = module.cache.element
                                ;
                            $container
                                .css('min-height', element.height)
                            ;
                        },
                        scroll: function(scroll) {
                            module.debug('Setting scroll on element', scroll);
                            if(module.elementScroll == scroll) {
                                return;
                            }
                            if( module.is.top() ) {
                                $module
                                    .css('bottom', '')
                                    .css('top', -scroll)
                                ;
                            }
                            if( module.is.bottom() ) {
                                $module
                                    .css('top', '')
                                    .css('bottom', scroll)
                                ;
                            }
                        },
                        size: function() {
                            if(module.cache.element.height !== 0 && module.cache.element.width !== 0) {
                                element.style.setProperty('width',  module.cache.element.width  + 'px', 'important');
                                element.style.setProperty('height', module.cache.element.height + 'px', 'important');
                            }
                        }
                    },

                    is: {
                        standardScroll: function() {
                            return ($scroll[0] == window);
                        },
                        top: function() {
                            return $module.hasClass(className.top);
                        },
                        bottom: function() {
                            return $module.hasClass(className.bottom);
                        },
                        initialPosition: function() {
                            return (!module.is.fixed() && !module.is.bound());
                        },
                        hidden: function() {
                            return (!$module.is(':visible'));
                        },
                        bound: function() {
                            return $module.hasClass(className.bound);
                        },
                        fixed: function() {
                            return $module.hasClass(className.fixed);
                        }
                    },

                    stick: function(scroll) {
                        var
                            cachedPosition = scroll || $scroll.scrollTop(),
                            cache          = module.cache,
                            fits           = cache.fits,
                            element        = cache.element,
                            scrollContext  = cache.scrollContext,
                            context        = cache.context,
                            offset         = (module.is.bottom() && settings.pushing)
                                ? settings.bottomOffset
                                : settings.offset,
                            scroll         = {
                                top    : cachedPosition + offset,
                                bottom : cachedPosition + offset + scrollContext.height
                            },
                            direction      = module.get.direction(scroll.top),
                            elementScroll  = (fits)
                                ? 0
                                : module.get.elementScroll(scroll.top),

                        // shorthand
                            doesntFit      = !fits,
                            elementVisible = (element.height !== 0)
                            ;

                        if(elementVisible) {

                            if( module.is.initialPosition() ) {
                                if(scroll.top >= context.bottom) {
                                    module.debug('Initial element position is bottom of container');
                                    module.bindBottom();
                                }
                                else if(scroll.top > element.top) {
                                    if( (element.height + scroll.top - elementScroll) >= context.bottom ) {
                                        module.debug('Initial element position is bottom of container');
                                        module.bindBottom();
                                    }
                                    else {
                                        module.debug('Initial element position is fixed');
                                        module.fixTop();
                                    }
                                }

                            }
                            else if( module.is.fixed() ) {

                                // currently fixed top
                                if( module.is.top() ) {
                                    if( scroll.top <= element.top ) {
                                        module.debug('Fixed element reached top of container');
                                        module.setInitialPosition();
                                    }
                                    else if( (element.height + scroll.top - elementScroll) >= context.bottom ) {
                                        module.debug('Fixed element reached bottom of container');
                                        module.bindBottom();
                                    }
                                    // scroll element if larger than screen
                                    else if(doesntFit) {
                                        module.set.scroll(elementScroll);
                                        module.save.lastScroll(scroll.top);
                                        module.save.elementScroll(elementScroll);
                                    }
                                }

                                // currently fixed bottom
                                else if(module.is.bottom() ) {

                                    // top edge
                                    if( (scroll.bottom - element.height) <= element.top) {
                                        module.debug('Bottom fixed rail has reached top of container');
                                        module.setInitialPosition();
                                    }
                                    // bottom edge
                                    else if(scroll.bottom >= context.bottom) {
                                        module.debug('Bottom fixed rail has reached bottom of container');
                                        module.bindBottom();
                                    }
                                    // scroll element if larger than screen
                                    else if(doesntFit) {
                                        module.set.scroll(elementScroll);
                                        module.save.lastScroll(scroll.top);
                                        module.save.elementScroll(elementScroll);
                                    }

                                }
                            }
                            else if( module.is.bottom() ) {
                                if( scroll.top <= element.top ) {
                                    module.debug('Jumped from bottom fixed to top fixed, most likely used home/end button');
                                    module.setInitialPosition();
                                }
                                else {
                                    if(settings.pushing) {
                                        if(module.is.bound() && scroll.bottom <= context.bottom ) {
                                            module.debug('Fixing bottom attached element to bottom of browser.');
                                            module.fixBottom();
                                        }
                                    }
                                    else {
                                        if(module.is.bound() && (scroll.top <= context.bottom - element.height) ) {
                                            module.debug('Fixing bottom attached element to top of browser.');
                                            module.fixTop();
                                        }
                                    }
                                }
                            }
                        }
                    },

                    bindTop: function() {
                        module.debug('Binding element to top of parent container');
                        module.remove.offset();
                        $module
                            .css({
                                left         : '',
                                top          : '',
                                marginBottom : ''
                            })
                            .removeClass(className.fixed)
                            .removeClass(className.bottom)
                            .addClass(className.bound)
                            .addClass(className.top)
                        ;
                        settings.onTop.call(element);
                        settings.onUnstick.call(element);
                    },
                    bindBottom: function() {
                        module.debug('Binding element to bottom of parent container');
                        module.remove.offset();
                        $module
                            .css({
                                left         : '',
                                top          : ''
                            })
                            .removeClass(className.fixed)
                            .removeClass(className.top)
                            .addClass(className.bound)
                            .addClass(className.bottom)
                        ;
                        settings.onBottom.call(element);
                        settings.onUnstick.call(element);
                    },

                    setInitialPosition: function() {
                        module.debug('Returning to initial position');
                        module.unfix();
                        module.unbind();
                    },


                    fixTop: function() {
                        module.debug('Fixing element to top of page');
                        module.set.minimumSize();
                        module.set.offset();
                        $module
                            .css({
                                left         : module.cache.element.left,
                                bottom       : '',
                                marginBottom : ''
                            })
                            .removeClass(className.bound)
                            .removeClass(className.bottom)
                            .addClass(className.fixed)
                            .addClass(className.top)
                        ;
                        settings.onStick.call(element);
                    },

                    fixBottom: function() {
                        module.debug('Sticking element to bottom of page');
                        module.set.minimumSize();
                        module.set.offset();
                        $module
                            .css({
                                left         : module.cache.element.left,
                                bottom       : '',
                                marginBottom : ''
                            })
                            .removeClass(className.bound)
                            .removeClass(className.top)
                            .addClass(className.fixed)
                            .addClass(className.bottom)
                        ;
                        settings.onStick.call(element);
                    },

                    unbind: function() {
                        if( module.is.bound() ) {
                            module.debug('Removing container bound position on element');
                            module.remove.offset();
                            $module
                                .removeClass(className.bound)
                                .removeClass(className.top)
                                .removeClass(className.bottom)
                            ;
                        }
                    },

                    unfix: function() {
                        if( module.is.fixed() ) {
                            module.debug('Removing fixed position on element');
                            module.remove.offset();
                            $module
                                .removeClass(className.fixed)
                                .removeClass(className.top)
                                .removeClass(className.bottom)
                            ;
                            settings.onUnstick.call(element);
                        }
                    },

                    reset: function() {
                        module.debug('Reseting elements position');
                        module.unbind();
                        module.unfix();
                        module.resetCSS();
                        module.remove.offset();
                        module.remove.lastScroll();
                    },

                    resetCSS: function() {
                        $module
                            .css({
                                width  : '',
                                height : ''
                            })
                        ;
                        $container
                            .css({
                                height: ''
                            })
                        ;
                    },

                    setting: function(name, value) {
                        if( $.isPlainObject(name) ) {
                            $.extend(true, settings, name);
                        }
                        else if(value !== undefined) {
                            settings[name] = value;
                        }
                        else {
                            return settings[name];
                        }
                    },
                    internal: function(name, value) {
                        if( $.isPlainObject(name) ) {
                            $.extend(true, module, name);
                        }
                        else if(value !== undefined) {
                            module[name] = value;
                        }
                        else {
                            return module[name];
                        }
                    },
                    debug: function() {
                        if(settings.debug) {
                            if(settings.performance) {
                                module.performance.log(arguments);
                            }
                            else {
                                module.debug = Function.prototype.bind.call(console.info, console, settings.name + ':');
                                module.debug.apply(console, arguments);
                            }
                        }
                    },
                    verbose: function() {
                        if(settings.verbose && settings.debug) {
                            if(settings.performance) {
                                module.performance.log(arguments);
                            }
                            else {
                                module.verbose = Function.prototype.bind.call(console.info, console, settings.name + ':');
                                module.verbose.apply(console, arguments);
                            }
                        }
                    },
                    error: function() {
                        module.error = Function.prototype.bind.call(console.error, console, settings.name + ':');
                        module.error.apply(console, arguments);
                    },
                    performance: {
                        log: function(message) {
                            var
                                currentTime,
                                executionTime,
                                previousTime
                                ;
                            if(settings.performance) {
                                currentTime   = new Date().getTime();
                                previousTime  = time || currentTime;
                                executionTime = currentTime - previousTime;
                                time          = currentTime;
                                performance.push({
                                    'Name'           : message[0],
                                    'Arguments'      : [].slice.call(message, 1) || '',
                                    'Element'        : element,
                                    'Execution Time' : executionTime
                                });
                            }
                            clearTimeout(module.performance.timer);
                            module.performance.timer = setTimeout(module.performance.display, 0);
                        },
                        display: function() {
                            var
                                title = settings.name + ':',
                                totalTime = 0
                                ;
                            time = false;
                            clearTimeout(module.performance.timer);
                            $.each(performance, function(index, data) {
                                totalTime += data['Execution Time'];
                            });
                            title += ' ' + totalTime + 'ms';
                            if(moduleSelector) {
                                title += ' \'' + moduleSelector + '\'';
                            }
                            if( (console.group !== undefined || console.table !== undefined) && performance.length > 0) {
                                console.groupCollapsed(title);
                                if(console.table) {
                                    console.table(performance);
                                }
                                else {
                                    $.each(performance, function(index, data) {
                                        console.log(data['Name'] + ': ' + data['Execution Time']+'ms');
                                    });
                                }
                                console.groupEnd();
                            }
                            performance = [];
                        }
                    },
                    invoke: function(query, passedArguments, context) {
                        var
                            object = instance,
                            maxDepth,
                            found,
                            response
                            ;
                        passedArguments = passedArguments || queryArguments;
                        context         = element         || context;
                        if(typeof query == 'string' && object !== undefined) {
                            query    = query.split(/[\. ]/);
                            maxDepth = query.length - 1;
                            $.each(query, function(depth, value) {
                                var camelCaseValue = (depth != maxDepth)
                                        ? value + query[depth + 1].charAt(0).toUpperCase() + query[depth + 1].slice(1)
                                        : query
                                    ;
                                if( $.isPlainObject( object[camelCaseValue] ) && (depth != maxDepth) ) {
                                    object = object[camelCaseValue];
                                }
                                else if( object[camelCaseValue] !== undefined ) {
                                    found = object[camelCaseValue];
                                    return false;
                                }
                                else if( $.isPlainObject( object[value] ) && (depth != maxDepth) ) {
                                    object = object[value];
                                }
                                else if( object[value] !== undefined ) {
                                    found = object[value];
                                    return false;
                                }
                                else {
                                    return false;
                                }
                            });
                        }
                        if ( $.isFunction( found ) ) {
                            response = found.apply(context, passedArguments);
                        }
                        else if(found !== undefined) {
                            response = found;
                        }
                        if($.isArray(returnedValue)) {
                            returnedValue.push(response);
                        }
                        else if(returnedValue !== undefined) {
                            returnedValue = [returnedValue, response];
                        }
                        else if(response !== undefined) {
                            returnedValue = response;
                        }
                        return found;
                    }
                };

                if(methodInvoked) {
                    if(instance === undefined) {
                        module.initialize();
                    }
                    module.invoke(query);
                }
                else {
                    if(instance !== undefined) {
                        instance.invoke('destroy');
                    }
                    module.initialize();
                }
            })
        ;

        return (returnedValue !== undefined)
            ? returnedValue
            : this
            ;
    };

    $.fn.sticky.settings = {

        name           : 'Sticky',
        namespace      : 'sticky',

        debug          : false,
        verbose        : true,
        performance    : true,

        // whether to stick in the opposite direction on scroll up
        pushing        : false,

        context        : false,

        // Context to watch scroll events
        scrollContext  : window,

        // Offset to adjust scroll
        offset         : 0,

        // Offset to adjust scroll when attached to bottom of screen
        bottomOffset   : 0,

        jitter         : 5, // will only set container height if difference between context and container is larger than this number

        // Whether to automatically observe changes with Mutation Observers
        observeChanges : false,

        // Called when position is recalculated
        onReposition   : function(){},

        // Called on each scroll
        onScroll       : function(){},

        // Called when element is stuck to viewport
        onStick        : function(){},

        // Called when element is unstuck from viewport
        onUnstick      : function(){},

        // Called when element reaches top of context
        onTop          : function(){},

        // Called when element reaches bottom of context
        onBottom       : function(){},

        error         : {
            container      : 'Sticky element must be inside a relative container',
            visible        : 'Element is hidden, you must call refresh after element becomes visible',
            method         : 'The method you called is not defined.',
            invalidContext : 'Context specified does not exist',
            elementSize    : 'Sticky element is larger than its container, cannot create sticky.'
        },

        className : {
            bound     : 'bound',
            fixed     : 'fixed',
            supported : 'native',
            top       : 'top',
            bottom    : 'bottom'
        }

    };

})( jQuery, window, document );
/*!
 * # Semantic UI 2.1.6 - Tab
 * http://github.com/semantic-org/semantic-ui/
 *
 *
 * Copyright 2015 Contributors
 * Released under the MIT license
 * http://opensource.org/licenses/MIT
 *
 */

;(function ($, window, document, undefined) {

    "use strict";

    $.fn.tab = function(parameters) {

        var
        // use window context if none specified
            $allModules     = $.isFunction(this)
                ? $(window)
                : $(this),

            moduleSelector  = $allModules.selector || '',
            time            = new Date().getTime(),
            performance     = [],

            query           = arguments[0],
            methodInvoked   = (typeof query == 'string'),
            queryArguments  = [].slice.call(arguments, 1),

            initializedHistory = false,
            returnedValue
            ;

        $allModules
            .each(function() {
                var

                    settings        = ( $.isPlainObject(parameters) )
                        ? $.extend(true, {}, $.fn.tab.settings, parameters)
                        : $.extend({}, $.fn.tab.settings),

                    className       = settings.className,
                    metadata        = settings.metadata,
                    selector        = settings.selector,
                    error           = settings.error,

                    eventNamespace  = '.' + settings.namespace,
                    moduleNamespace = 'module-' + settings.namespace,

                    $module         = $(this),
                    $context,
                    $tabs,

                    cache           = {},
                    firstLoad       = true,
                    recursionDepth  = 0,
                    element         = this,
                    instance        = $module.data(moduleNamespace),

                    activeTabPath,
                    parameterArray,
                    module,

                    historyEvent

                    ;

                module = {

                    initialize: function() {
                        module.debug('Initializing tab menu item', $module);
                        module.fix.callbacks();
                        module.determineTabs();

                        module.debug('Determining tabs', settings.context, $tabs);
                        // set up automatic routing
                        if(settings.auto) {
                            module.set.auto();
                        }
                        module.bind.events();

                        if(settings.history && !initializedHistory) {
                            module.initializeHistory();
                            initializedHistory = true;
                        }

                        module.instantiate();
                    },

                    instantiate: function () {
                        module.verbose('Storing instance of module', module);
                        instance = module;
                        $module
                            .data(moduleNamespace, module)
                        ;
                    },

                    destroy: function() {
                        module.debug('Destroying tabs', $module);
                        $module
                            .removeData(moduleNamespace)
                            .off(eventNamespace)
                        ;
                    },

                    bind: {
                        events: function() {
                            // if using $.tab don't add events
                            if( !$.isWindow( element ) ) {
                                module.debug('Attaching tab activation events to element', $module);
                                $module
                                    .on('click' + eventNamespace, module.event.click)
                                ;
                            }
                        }
                    },

                    determineTabs: function() {
                        var
                            $reference
                            ;

                        // determine tab context
                        if(settings.context === 'parent') {
                            if($module.closest(selector.ui).length > 0) {
                                $reference = $module.closest(selector.ui);
                                module.verbose('Using closest UI element as parent', $reference);
                            }
                            else {
                                $reference = $module;
                            }
                            $context = $reference.parent();
                            module.verbose('Determined parent element for creating context', $context);
                        }
                        else if(settings.context) {
                            $context = $(settings.context);
                            module.verbose('Using selector for tab context', settings.context, $context);
                        }
                        else {
                            $context = $('body');
                        }
                        // find tabs
                        if(settings.childrenOnly) {
                            $tabs = $context.children(selector.tabs);
                            module.debug('Searching tab context children for tabs', $context, $tabs);
                        }
                        else {
                            $tabs = $context.find(selector.tabs);
                            module.debug('Searching tab context for tabs', $context, $tabs);
                        }
                    },

                    fix: {
                        callbacks: function() {
                            if( $.isPlainObject(parameters) && (parameters.onTabLoad || parameters.onTabInit) ) {
                                if(parameters.onTabLoad) {
                                    parameters.onLoad = parameters.onTabLoad;
                                    delete parameters.onTabLoad;
                                    module.error(error.legacyLoad, parameters.onLoad);
                                }
                                if(parameters.onTabInit) {
                                    parameters.onFirstLoad = parameters.onTabInit;
                                    delete parameters.onTabInit;
                                    module.error(error.legacyInit, parameters.onFirstLoad);
                                }
                                settings = $.extend(true, {}, $.fn.tab.settings, parameters);
                            }
                        }
                    },

                    initializeHistory: function() {
                        module.debug('Initializing page state');
                        if( $.address === undefined ) {
                            module.error(error.state);
                            return false;
                        }
                        else {
                            if(settings.historyType == 'state') {
                                module.debug('Using HTML5 to manage state');
                                if(settings.path !== false) {
                                    $.address
                                        .history(true)
                                        .state(settings.path)
                                    ;
                                }
                                else {
                                    module.error(error.path);
                                    return false;
                                }
                            }
                            $.address
                                .bind('change', module.event.history.change)
                            ;
                        }
                    },

                    event: {
                        click: function(event) {
                            var
                                tabPath = $(this).data(metadata.tab)
                                ;
                            if(tabPath !== undefined) {
                                if(settings.history) {
                                    module.verbose('Updating page state', event);
                                    $.address.value(tabPath);
                                }
                                else {
                                    module.verbose('Changing tab', event);
                                    module.changeTab(tabPath);
                                }
                                event.preventDefault();
                            }
                            else {
                                module.debug('No tab specified');
                            }
                        },
                        history: {
                            change: function(event) {
                                var
                                    tabPath   = event.pathNames.join('/') || module.get.initialPath(),
                                    pageTitle = settings.templates.determineTitle(tabPath) || false
                                    ;
                                module.performance.display();
                                module.debug('History change event', tabPath, event);
                                historyEvent = event;
                                if(tabPath !== undefined) {
                                    module.changeTab(tabPath);
                                }
                                if(pageTitle) {
                                    $.address.title(pageTitle);
                                }
                            }
                        }
                    },

                    refresh: function() {
                        if(activeTabPath) {
                            module.debug('Refreshing tab', activeTabPath);
                            module.changeTab(activeTabPath);
                        }
                    },

                    cache: {

                        read: function(cacheKey) {
                            return (cacheKey !== undefined)
                                ? cache[cacheKey]
                                : false
                                ;
                        },
                        add: function(cacheKey, content) {
                            cacheKey = cacheKey || activeTabPath;
                            module.debug('Adding cached content for', cacheKey);
                            cache[cacheKey] = content;
                        },
                        remove: function(cacheKey) {
                            cacheKey = cacheKey || activeTabPath;
                            module.debug('Removing cached content for', cacheKey);
                            delete cache[cacheKey];
                        }
                    },

                    set: {
                        auto: function() {
                            var
                                url = (typeof settings.path == 'string')
                                    ? settings.path.replace(/\/$/, '') + '/{$tab}'
                                    : '/{$tab}'
                                ;
                            module.verbose('Setting up automatic tab retrieval from server', url);
                            if($.isPlainObject(settings.apiSettings)) {
                                settings.apiSettings.url = url;
                            }
                            else {
                                settings.apiSettings = {
                                    url: url
                                };
                            }
                        },
                        loading: function(tabPath) {
                            var
                                $tab      = module.get.tabElement(tabPath),
                                isLoading = $tab.hasClass(className.loading)
                                ;
                            if(!isLoading) {
                                module.verbose('Setting loading state for', $tab);
                                $tab
                                    .addClass(className.loading)
                                    .siblings($tabs)
                                    .removeClass(className.active + ' ' + className.loading)
                                ;
                                if($tab.length > 0) {
                                    settings.onRequest.call($tab[0], tabPath);
                                }
                            }
                        },
                        state: function(state) {
                            $.address.value(state);
                        }
                    },

                    changeTab: function(tabPath) {
                        var
                            pushStateAvailable = (window.history && window.history.pushState),
                            shouldIgnoreLoad   = (pushStateAvailable && settings.ignoreFirstLoad && firstLoad),
                            remoteContent      = (settings.auto || $.isPlainObject(settings.apiSettings) ),
                        // only add default path if not remote content
                            pathArray = (remoteContent && !shouldIgnoreLoad)
                                ? module.utilities.pathToArray(tabPath)
                                : module.get.defaultPathArray(tabPath)
                            ;
                        tabPath = module.utilities.arrayToPath(pathArray);
                        $.each(pathArray, function(index, tab) {
                            var
                                currentPathArray   = pathArray.slice(0, index + 1),
                                currentPath        = module.utilities.arrayToPath(currentPathArray),

                                isTab              = module.is.tab(currentPath),
                                isLastIndex        = (index + 1 == pathArray.length),

                                $tab               = module.get.tabElement(currentPath),
                                $anchor,
                                nextPathArray,
                                nextPath,
                                isLastTab
                                ;
                            module.verbose('Looking for tab', tab);
                            if(isTab) {
                                module.verbose('Tab was found', tab);
                                // scope up
                                activeTabPath  = currentPath;
                                parameterArray = module.utilities.filterArray(pathArray, currentPathArray);

                                if(isLastIndex) {
                                    isLastTab = true;
                                }
                                else {
                                    nextPathArray = pathArray.slice(0, index + 2);
                                    nextPath      = module.utilities.arrayToPath(nextPathArray);
                                    isLastTab     = ( !module.is.tab(nextPath) );
                                    if(isLastTab) {
                                        module.verbose('Tab parameters found', nextPathArray);
                                    }
                                }
                                if(isLastTab && remoteContent) {
                                    if(!shouldIgnoreLoad) {
                                        module.activate.navigation(currentPath);
                                        module.fetch.content(currentPath, tabPath);
                                    }
                                    else {
                                        module.debug('Ignoring remote content on first tab load', currentPath);
                                        firstLoad = false;
                                        module.cache.add(tabPath, $tab.html());
                                        module.activate.all(currentPath);
                                        settings.onFirstLoad.call($tab[0], currentPath, parameterArray, historyEvent);
                                        settings.onLoad.call($tab[0], currentPath, parameterArray, historyEvent);
                                    }
                                    return false;
                                }
                                else {
                                    module.debug('Opened local tab', currentPath);
                                    module.activate.all(currentPath);
                                    if( !module.cache.read(currentPath) ) {
                                        module.cache.add(currentPath, true);
                                        module.debug('First time tab loaded calling tab init');
                                        settings.onFirstLoad.call($tab[0], currentPath, parameterArray, historyEvent);
                                    }
                                    settings.onLoad.call($tab[0], currentPath, parameterArray, historyEvent);
                                }

                            }
                            else if(tabPath.search('/') == -1 && tabPath !== '') {
                                // look for in page anchor
                                $anchor     = $('#' + tabPath + ', a[name="' + tabPath + '"]');
                                currentPath = $anchor.closest('[data-tab]').data(metadata.tab);
                                $tab        = module.get.tabElement(currentPath);
                                // if anchor exists use parent tab
                                if($anchor && $anchor.length > 0 && currentPath) {
                                    module.debug('Anchor link used, opening parent tab', $tab, $anchor);
                                    if( !$tab.hasClass(className.active) ) {
                                        setTimeout(function() {
                                            module.scrollTo($anchor);
                                        }, 0);
                                    }
                                    module.activate.all(currentPath);
                                    if( !module.cache.read(currentPath) ) {
                                        module.cache.add(currentPath, true);
                                        module.debug('First time tab loaded calling tab init');
                                        settings.onFirstLoad.call($tab[0], currentPath, parameterArray, historyEvent);
                                    }
                                    settings.onLoad.call($tab[0], currentPath, parameterArray, historyEvent);
                                    return false;
                                }
                            }
                            else {
                                module.error(error.missingTab, $module, $context, currentPath);
                                return false;
                            }
                        });
                    },

                    scrollTo: function($element) {
                        var
                            scrollOffset = ($element && $element.length > 0)
                                ? $element.offset().top
                                : false
                            ;
                        if(scrollOffset !== false) {
                            module.debug('Forcing scroll to an in-page link in a hidden tab', scrollOffset, $element);
                            $(document).scrollTop(scrollOffset);
                        }
                    },

                    update: {
                        content: function(tabPath, html, evaluateScripts) {
                            var
                                $tab = module.get.tabElement(tabPath),
                                tab  = $tab[0]
                                ;
                            evaluateScripts = (evaluateScripts !== undefined)
                                ? evaluateScripts
                                : settings.evaluateScripts
                            ;
                            if(evaluateScripts) {
                                module.debug('Updating HTML and evaluating inline scripts', tabPath, html);
                                $tab.html(html);
                            }
                            else {
                                module.debug('Updating HTML', tabPath, html);
                                tab.innerHTML = html;
                            }
                        }
                    },

                    fetch: {

                        content: function(tabPath, fullTabPath) {
                            var
                                $tab        = module.get.tabElement(tabPath),
                                apiSettings = {
                                    dataType         : 'html',
                                    encodeParameters : false,
                                    on               : 'now',
                                    cache            : settings.alwaysRefresh,
                                    headers          : {
                                        'X-Remote': true
                                    },
                                    onSuccess : function(response) {
                                        module.cache.add(fullTabPath, response);
                                        module.update.content(tabPath, response);
                                        if(tabPath == activeTabPath) {
                                            module.debug('Content loaded', tabPath);
                                            module.activate.tab(tabPath);
                                        }
                                        else {
                                            module.debug('Content loaded in background', tabPath);
                                        }
                                        settings.onFirstLoad.call($tab[0], tabPath, parameterArray, historyEvent);
                                        settings.onLoad.call($tab[0], tabPath, parameterArray, historyEvent);
                                    },
                                    urlData: {
                                        tab: fullTabPath
                                    }
                                },
                                request         = $tab.api('get request') || false,
                                existingRequest = ( request && request.state() === 'pending' ),
                                requestSettings,
                                cachedContent
                                ;

                            fullTabPath   = fullTabPath || tabPath;
                            cachedContent = module.cache.read(fullTabPath);


                            if(settings.cache && cachedContent) {
                                module.activate.tab(tabPath);
                                module.debug('Adding cached content', fullTabPath);
                                if(settings.evaluateScripts == 'once') {
                                    module.update.content(tabPath, cachedContent, false);
                                }
                                else {
                                    module.update.content(tabPath, cachedContent);
                                }
                                settings.onLoad.call($tab[0], tabPath, parameterArray, historyEvent);
                            }
                            else if(existingRequest) {
                                module.set.loading(tabPath);
                                module.debug('Content is already loading', fullTabPath);
                            }
                            else if($.api !== undefined) {
                                requestSettings = $.extend(true, {}, settings.apiSettings, apiSettings);
                                module.debug('Retrieving remote content', fullTabPath, requestSettings);
                                module.set.loading(tabPath);
                                $tab.api(requestSettings);
                            }
                            else {
                                module.error(error.api);
                            }
                        }
                    },

                    activate: {
                        all: function(tabPath) {
                            module.activate.tab(tabPath);
                            module.activate.navigation(tabPath);
                        },
                        tab: function(tabPath) {
                            var
                                $tab     = module.get.tabElement(tabPath),
                                isActive = $tab.hasClass(className.active)
                                ;
                            module.verbose('Showing tab content for', $tab);
                            if(!isActive) {
                                $tab
                                    .addClass(className.active)
                                    .siblings($tabs)
                                    .removeClass(className.active + ' ' + className.loading)
                                ;
                                if($tab.length > 0) {
                                    settings.onVisible.call($tab[0], tabPath);
                                }
                            }
                        },
                        navigation: function(tabPath) {
                            var
                                $navigation = module.get.navElement(tabPath),
                                isActive    = $navigation.hasClass(className.active)
                                ;
                            module.verbose('Activating tab navigation for', $navigation, tabPath);
                            if(!isActive) {
                                $navigation
                                    .addClass(className.active)
                                    .siblings($allModules)
                                    .removeClass(className.active + ' ' + className.loading)
                                ;
                            }
                        }
                    },

                    deactivate: {
                        all: function() {
                            module.deactivate.navigation();
                            module.deactivate.tabs();
                        },
                        navigation: function() {
                            $allModules
                                .removeClass(className.active)
                            ;
                        },
                        tabs: function() {
                            $tabs
                                .removeClass(className.active + ' ' + className.loading)
                            ;
                        }
                    },

                    is: {
                        tab: function(tabName) {
                            return (tabName !== undefined)
                                ? ( module.get.tabElement(tabName).length > 0 )
                                : false
                                ;
                        }
                    },

                    get: {
                        initialPath: function() {
                            return $allModules.eq(0).data(metadata.tab) || $tabs.eq(0).data(metadata.tab);
                        },
                        path: function() {
                            return $.address.value();
                        },
                        // adds default tabs to tab path
                        defaultPathArray: function(tabPath) {
                            return module.utilities.pathToArray( module.get.defaultPath(tabPath) );
                        },
                        defaultPath: function(tabPath) {
                            var
                                $defaultNav = $allModules.filter('[data-' + metadata.tab + '^="' + tabPath + '/"]').eq(0),
                                defaultTab  = $defaultNav.data(metadata.tab) || false
                                ;
                            if( defaultTab ) {
                                module.debug('Found default tab', defaultTab);
                                if(recursionDepth < settings.maxDepth) {
                                    recursionDepth++;
                                    return module.get.defaultPath(defaultTab);
                                }
                                module.error(error.recursion);
                            }
                            else {
                                module.debug('No default tabs found for', tabPath, $tabs);
                            }
                            recursionDepth = 0;
                            return tabPath;
                        },
                        navElement: function(tabPath) {
                            tabPath = tabPath || activeTabPath;
                            return $allModules.filter('[data-' + metadata.tab + '="' + tabPath + '"]');
                        },
                        tabElement: function(tabPath) {
                            var
                                $fullPathTab,
                                $simplePathTab,
                                tabPathArray,
                                lastTab
                                ;
                            tabPath        = tabPath || activeTabPath;
                            tabPathArray   = module.utilities.pathToArray(tabPath);
                            lastTab        = module.utilities.last(tabPathArray);
                            $fullPathTab   = $tabs.filter('[data-' + metadata.tab + '="' + tabPath + '"]');
                            $simplePathTab = $tabs.filter('[data-' + metadata.tab + '="' + lastTab + '"]');
                            return ($fullPathTab.length > 0)
                                ? $fullPathTab
                                : $simplePathTab
                                ;
                        },
                        tab: function() {
                            return activeTabPath;
                        }
                    },

                    utilities: {
                        filterArray: function(keepArray, removeArray) {
                            return $.grep(keepArray, function(keepValue) {
                                return ( $.inArray(keepValue, removeArray) == -1);
                            });
                        },
                        last: function(array) {
                            return $.isArray(array)
                                ? array[ array.length - 1]
                                : false
                                ;
                        },
                        pathToArray: function(pathName) {
                            if(pathName === undefined) {
                                pathName = activeTabPath;
                            }
                            return typeof pathName == 'string'
                                ? pathName.split('/')
                                : [pathName]
                                ;
                        },
                        arrayToPath: function(pathArray) {
                            return $.isArray(pathArray)
                                ? pathArray.join('/')
                                : false
                                ;
                        }
                    },

                    setting: function(name, value) {
                        module.debug('Changing setting', name, value);
                        if( $.isPlainObject(name) ) {
                            $.extend(true, settings, name);
                        }
                        else if(value !== undefined) {
                            settings[name] = value;
                        }
                        else {
                            return settings[name];
                        }
                    },
                    internal: function(name, value) {
                        if( $.isPlainObject(name) ) {
                            $.extend(true, module, name);
                        }
                        else if(value !== undefined) {
                            module[name] = value;
                        }
                        else {
                            return module[name];
                        }
                    },
                    debug: function() {
                        if(settings.debug) {
                            if(settings.performance) {
                                module.performance.log(arguments);
                            }
                            else {
                                module.debug = Function.prototype.bind.call(console.info, console, settings.name + ':');
                                module.debug.apply(console, arguments);
                            }
                        }
                    },
                    verbose: function() {
                        if(settings.verbose && settings.debug) {
                            if(settings.performance) {
                                module.performance.log(arguments);
                            }
                            else {
                                module.verbose = Function.prototype.bind.call(console.info, console, settings.name + ':');
                                module.verbose.apply(console, arguments);
                            }
                        }
                    },
                    error: function() {
                        module.error = Function.prototype.bind.call(console.error, console, settings.name + ':');
                        module.error.apply(console, arguments);
                    },
                    performance: {
                        log: function(message) {
                            var
                                currentTime,
                                executionTime,
                                previousTime
                                ;
                            if(settings.performance) {
                                currentTime   = new Date().getTime();
                                previousTime  = time || currentTime;
                                executionTime = currentTime - previousTime;
                                time          = currentTime;
                                performance.push({
                                    'Name'           : message[0],
                                    'Arguments'      : [].slice.call(message, 1) || '',
                                    'Element'        : element,
                                    'Execution Time' : executionTime
                                });
                            }
                            clearTimeout(module.performance.timer);
                            module.performance.timer = setTimeout(module.performance.display, 500);
                        },
                        display: function() {
                            var
                                title = settings.name + ':',
                                totalTime = 0
                                ;
                            time = false;
                            clearTimeout(module.performance.timer);
                            $.each(performance, function(index, data) {
                                totalTime += data['Execution Time'];
                            });
                            title += ' ' + totalTime + 'ms';
                            if(moduleSelector) {
                                title += ' \'' + moduleSelector + '\'';
                            }
                            if( (console.group !== undefined || console.table !== undefined) && performance.length > 0) {
                                console.groupCollapsed(title);
                                if(console.table) {
                                    console.table(performance);
                                }
                                else {
                                    $.each(performance, function(index, data) {
                                        console.log(data['Name'] + ': ' + data['Execution Time']+'ms');
                                    });
                                }
                                console.groupEnd();
                            }
                            performance = [];
                        }
                    },
                    invoke: function(query, passedArguments, context) {
                        var
                            object = instance,
                            maxDepth,
                            found,
                            response
                            ;
                        passedArguments = passedArguments || queryArguments;
                        context         = element         || context;
                        if(typeof query == 'string' && object !== undefined) {
                            query    = query.split(/[\. ]/);
                            maxDepth = query.length - 1;
                            $.each(query, function(depth, value) {
                                var camelCaseValue = (depth != maxDepth)
                                        ? value + query[depth + 1].charAt(0).toUpperCase() + query[depth + 1].slice(1)
                                        : query
                                    ;
                                if( $.isPlainObject( object[camelCaseValue] ) && (depth != maxDepth) ) {
                                    object = object[camelCaseValue];
                                }
                                else if( object[camelCaseValue] !== undefined ) {
                                    found = object[camelCaseValue];
                                    return false;
                                }
                                else if( $.isPlainObject( object[value] ) && (depth != maxDepth) ) {
                                    object = object[value];
                                }
                                else if( object[value] !== undefined ) {
                                    found = object[value];
                                    return false;
                                }
                                else {
                                    module.error(error.method, query);
                                    return false;
                                }
                            });
                        }
                        if ( $.isFunction( found ) ) {
                            response = found.apply(context, passedArguments);
                        }
                        else if(found !== undefined) {
                            response = found;
                        }
                        if($.isArray(returnedValue)) {
                            returnedValue.push(response);
                        }
                        else if(returnedValue !== undefined) {
                            returnedValue = [returnedValue, response];
                        }
                        else if(response !== undefined) {
                            returnedValue = response;
                        }
                        return found;
                    }
                };
                if(methodInvoked) {
                    if(instance === undefined) {
                        module.initialize();
                    }
                    module.invoke(query);
                }
                else {
                    if(instance !== undefined) {
                        instance.invoke('destroy');
                    }
                    module.initialize();
                }
            })
        ;
        return (returnedValue !== undefined)
            ? returnedValue
            : this
            ;

    };

// shortcut for tabbed content with no defined navigation
    $.tab = function() {
        $(window).tab.apply(this, arguments);
    };

    $.fn.tab.settings = {

        name            : 'Tab',
        namespace       : 'tab',

        debug           : false,
        verbose         : false,
        performance     : true,

        auto            : false,  // uses pjax style endpoints fetching content from same url with remote-content headers
        history         : false,  // use browser history
        historyType     : 'hash', // #/ or html5 state
        path            : false,  // base path of url

        context         : false,  // specify a context that tabs must appear inside
        childrenOnly    : false,  // use only tabs that are children of context
        maxDepth        : 25,     // max depth a tab can be nested

        alwaysRefresh   : false,  // load tab content new every tab click
        cache           : true,   // cache the content requests to pull locally
        ignoreFirstLoad : false,  // don't load remote content on first load

        apiSettings     : false,  // settings for api call
        evaluateScripts : 'once', // whether inline scripts should be parsed (true/false/once). Once will not re-evaluate on cached content

        onFirstLoad : function(tabPath, parameterArray, historyEvent) {}, // called first time loaded
        onLoad      : function(tabPath, parameterArray, historyEvent) {}, // called on every load
        onVisible   : function(tabPath, parameterArray, historyEvent) {}, // called every time tab visible
        onRequest   : function(tabPath, parameterArray, historyEvent) {}, // called ever time a tab beings loading remote content

        templates    : {
            determineTitle: function(tabArray) {} // returns page title for path
        },

        error: {
            api        : 'You attempted to load content without API module',
            method     : 'The method you called is not defined',
            missingTab : 'Activated tab cannot be found. Tabs are case-sensitive.',
            noContent  : 'The tab you specified is missing a content url.',
            path       : 'History enabled, but no path was specified',
            recursion  : 'Max recursive depth reached',
            legacyInit : 'onTabInit has been renamed to onFirstLoad in 2.0, please adjust your code.',
            legacyLoad : 'onTabLoad has been renamed to onLoad in 2.0. Please adjust your code',
            state      : 'History requires Asual\'s Address library <https://github.com/asual/jquery-address>'
        },

        metadata : {
            tab    : 'tab',
            loaded : 'loaded',
            promise: 'promise'
        },

        className   : {
            loading : 'loading',
            active  : 'active'
        },

        selector    : {
            tabs : '.ui.tab',
            ui   : '.ui'
        }

    };

})( jQuery, window, document );

/*!
 * # Semantic UI 2.1.6 - Transition
 * http://github.com/semantic-org/semantic-ui/
 *
 *
 * Copyright 2015 Contributors
 * Released under the MIT license
 * http://opensource.org/licenses/MIT
 *
 */

;(function ( $, window, document, undefined ) {

    "use strict";

    $.fn.transition = function() {
        var
            $allModules     = $(this),
            moduleSelector  = $allModules.selector || '',

            time            = new Date().getTime(),
            performance     = [],

            moduleArguments = arguments,
            query           = moduleArguments[0],
            queryArguments  = [].slice.call(arguments, 1),
            methodInvoked   = (typeof query === 'string'),

            requestAnimationFrame = window.requestAnimationFrame
                || window.mozRequestAnimationFrame
                || window.webkitRequestAnimationFrame
                || window.msRequestAnimationFrame
                || function(callback) { setTimeout(callback, 0); },

            returnedValue
            ;
        $allModules
            .each(function(index) {
                var
                    $module  = $(this),
                    element  = this,

                // set at run time
                    settings,
                    instance,

                    error,
                    className,
                    metadata,
                    animationEnd,
                    animationName,

                    namespace,
                    moduleNamespace,
                    eventNamespace,
                    module
                    ;

                module = {

                    initialize: function() {

                        // get full settings
                        settings        = module.get.settings.apply(element, moduleArguments);

                        // shorthand
                        className       = settings.className;
                        error           = settings.error;
                        metadata        = settings.metadata;

                        // define namespace
                        eventNamespace  = '.' + settings.namespace;
                        moduleNamespace = 'module-' + settings.namespace;
                        instance        = $module.data(moduleNamespace) || module;

                        // get vendor specific events
                        animationEnd    = module.get.animationEndEvent();

                        if(methodInvoked) {
                            methodInvoked = module.invoke(query);
                        }

                        // method not invoked, lets run an animation
                        if(methodInvoked === false) {
                            module.verbose('Converted arguments into settings object', settings);
                            if(settings.interval) {
                                module.delay(settings.animate);
                            }
                            else  {
                                module.animate();
                            }
                            module.instantiate();
                        }
                    },

                    instantiate: function() {
                        module.verbose('Storing instance of module', module);
                        instance = module;
                        $module
                            .data(moduleNamespace, instance)
                        ;
                    },

                    destroy: function() {
                        module.verbose('Destroying previous module for', element);
                        $module
                            .removeData(moduleNamespace)
                        ;
                    },

                    refresh: function() {
                        module.verbose('Refreshing display type on next animation');
                        delete module.displayType;
                    },

                    forceRepaint: function() {
                        module.verbose('Forcing element repaint');
                        var
                            $parentElement = $module.parent(),
                            $nextElement = $module.next()
                            ;
                        if($nextElement.length === 0) {
                            $module.detach().appendTo($parentElement);
                        }
                        else {
                            $module.detach().insertBefore($nextElement);
                        }
                    },

                    repaint: function() {
                        module.verbose('Repainting element');
                        var
                            fakeAssignment = element.offsetWidth
                            ;
                    },

                    delay: function(interval) {
                        var
                            direction = module.get.animationDirection(),
                            shouldReverse,
                            delay
                            ;
                        if(!direction) {
                            direction = module.can.transition()
                                ? module.get.direction()
                                : 'static'
                            ;
                        }
                        interval = (interval !== undefined)
                            ? interval
                            : settings.interval
                        ;
                        shouldReverse = (settings.reverse == 'auto' && direction == className.outward);
                        delay = (shouldReverse || settings.reverse == true)
                            ? ($allModules.length - index) * settings.interval
                            : index * settings.interval
                        ;
                        module.debug('Delaying animation by', delay);
                        setTimeout(module.animate, delay);
                    },

                    animate: function(overrideSettings) {
                        settings = overrideSettings || settings;
                        if(!module.is.supported()) {
                            module.error(error.support);
                            return false;
                        }
                        module.debug('Preparing animation', settings.animation);
                        if(module.is.animating()) {
                            if(settings.queue) {
                                if(!settings.allowRepeats && module.has.direction() && module.is.occurring() && module.queuing !== true) {
                                    module.debug('Animation is currently occurring, preventing queueing same animation', settings.animation);
                                }
                                else {
                                    module.queue(settings.animation);
                                }
                                return false;
                            }
                            else if(!settings.allowRepeats && module.is.occurring()) {
                                module.debug('Animation is already occurring, will not execute repeated animation', settings.animation);
                                return false;
                            }
                            else {
                                module.debug('New animation started, completing previous early', settings.animation);
                                instance.complete();
                            }
                        }
                        if( module.can.animate() ) {
                            module.set.animating(settings.animation);
                        }
                        else {
                            module.error(error.noAnimation, settings.animation, element);
                        }
                    },

                    reset: function() {
                        module.debug('Resetting animation to beginning conditions');
                        module.remove.animationCallbacks();
                        module.restore.conditions();
                        module.remove.animating();
                    },

                    queue: function(animation) {
                        module.debug('Queueing animation of', animation);
                        module.queuing = true;
                        $module
                            .one(animationEnd + '.queue' + eventNamespace, function() {
                                module.queuing = false;
                                module.repaint();
                                module.animate.apply(this, settings);
                            })
                        ;
                    },

                    complete: function (event) {
                        module.debug('Animation complete', settings.animation);
                        module.remove.completeCallback();
                        module.remove.failSafe();
                        if(!module.is.looping()) {
                            if( module.is.outward() ) {
                                module.verbose('Animation is outward, hiding element');
                                module.restore.conditions();
                                module.hide();
                            }
                            else if( module.is.inward() ) {
                                module.verbose('Animation is outward, showing element');
                                module.restore.conditions();
                                module.show();
                            }
                            else {
                                module.verbose('Static animation completed');
                                module.restore.conditions();
                                settings.onComplete.call(element);
                            }
                        }
                    },

                    force: {
                        visible: function() {
                            var
                                style          = $module.attr('style'),
                                userStyle      = module.get.userStyle(),
                                displayType    = module.get.displayType(),
                                overrideStyle  = userStyle + 'display: ' + displayType + ' !important;',
                                currentDisplay = $module.css('display'),
                                emptyStyle     = (style === undefined || style === '')
                                ;
                            if(currentDisplay !== displayType) {
                                module.verbose('Overriding default display to show element', displayType);
                                $module
                                    .attr('style', overrideStyle)
                                ;
                            }
                            else if(emptyStyle) {
                                $module.removeAttr('style');
                            }
                        },
                        hidden: function() {
                            var
                                style          = $module.attr('style'),
                                currentDisplay = $module.css('display'),
                                emptyStyle     = (style === undefined || style === '')
                                ;
                            if(currentDisplay !== 'none' && !module.is.hidden()) {
                                module.verbose('Overriding default display to hide element');
                                $module
                                    .css('display', 'none')
                                ;
                            }
                            else if(emptyStyle) {
                                $module
                                    .removeAttr('style')
                                ;
                            }
                        }
                    },

                    has: {
                        direction: function(animation) {
                            var
                                hasDirection = false
                                ;
                            animation = animation || settings.animation;
                            if(typeof animation === 'string') {
                                animation = animation.split(' ');
                                $.each(animation, function(index, word){
                                    if(word === className.inward || word === className.outward) {
                                        hasDirection = true;
                                    }
                                });
                            }
                            return hasDirection;
                        },
                        inlineDisplay: function() {
                            var
                                style = $module.attr('style') || ''
                                ;
                            return $.isArray(style.match(/display.*?;/, ''));
                        }
                    },

                    set: {
                        animating: function(animation) {
                            var
                                animationClass,
                                direction
                                ;
                            // remove previous callbacks
                            module.remove.completeCallback();

                            // determine exact animation
                            animation      = animation || settings.animation;
                            animationClass = module.get.animationClass(animation);

                            // save animation class in cache to restore class names
                            module.save.animation(animationClass);

                            // override display if necessary so animation appears visibly
                            module.force.visible();

                            module.remove.hidden();
                            module.remove.direction();

                            module.start.animation(animationClass);

                        },
                        duration: function(animationName, duration) {
                            duration = duration || settings.duration;
                            duration = (typeof duration == 'number')
                                ? duration + 'ms'
                                : duration
                            ;
                            if(duration || duration === 0) {
                                module.verbose('Setting animation duration', duration);
                                $module
                                    .css({
                                        'animation-duration':  duration
                                    })
                                ;
                            }
                        },
                        direction: function(direction) {
                            direction = direction || module.get.direction();
                            if(direction == className.inward) {
                                module.set.inward();
                            }
                            else {
                                module.set.outward();
                            }
                        },
                        looping: function() {
                            module.debug('Transition set to loop');
                            $module
                                .addClass(className.looping)
                            ;
                        },
                        hidden: function() {
                            $module
                                .addClass(className.transition)
                                .addClass(className.hidden)
                            ;
                        },
                        inward: function() {
                            module.debug('Setting direction to inward');
                            $module
                                .removeClass(className.outward)
                                .addClass(className.inward)
                            ;
                        },
                        outward: function() {
                            module.debug('Setting direction to outward');
                            $module
                                .removeClass(className.inward)
                                .addClass(className.outward)
                            ;
                        },
                        visible: function() {
                            $module
                                .addClass(className.transition)
                                .addClass(className.visible)
                            ;
                        }
                    },

                    start: {
                        animation: function(animationClass) {
                            animationClass = animationClass || module.get.animationClass();
                            module.debug('Starting tween', animationClass);
                            $module
                                .addClass(animationClass)
                                .one(animationEnd + '.complete' + eventNamespace, module.complete)
                            ;
                            if(settings.useFailSafe) {
                                module.add.failSafe();
                            }
                            module.set.duration(settings.duration);
                            settings.onStart.call(element);
                        }
                    },

                    save: {
                        animation: function(animation) {
                            if(!module.cache) {
                                module.cache = {};
                            }
                            module.cache.animation = animation;
                        },
                        displayType: function(displayType) {
                            if(displayType !== 'none') {
                                $module.data(metadata.displayType, displayType);
                            }
                        },
                        transitionExists: function(animation, exists) {
                            $.fn.transition.exists[animation] = exists;
                            module.verbose('Saving existence of transition', animation, exists);
                        }
                    },

                    restore: {
                        conditions: function() {
                            var
                                animation = module.get.currentAnimation()
                                ;
                            if(animation) {
                                $module
                                    .removeClass(animation)
                                ;
                                module.verbose('Removing animation class', module.cache);
                            }
                            module.remove.duration();
                        }
                    },

                    add: {
                        failSafe: function() {
                            var
                                duration = module.get.duration()
                                ;
                            module.timer = setTimeout(function() {
                                $module.triggerHandler(animationEnd);
                            }, duration + settings.failSafeDelay);
                            module.verbose('Adding fail safe timer', module.timer);
                        }
                    },

                    remove: {
                        animating: function() {
                            $module.removeClass(className.animating);
                        },
                        animationCallbacks: function() {
                            module.remove.queueCallback();
                            module.remove.completeCallback();
                        },
                        queueCallback: function() {
                            $module.off('.queue' + eventNamespace);
                        },
                        completeCallback: function() {
                            $module.off('.complete' + eventNamespace);
                        },
                        display: function() {
                            $module.css('display', '');
                        },
                        direction: function() {
                            $module
                                .removeClass(className.inward)
                                .removeClass(className.outward)
                            ;
                        },
                        duration: function() {
                            $module
                                .css('animation-duration', '')
                            ;
                        },
                        failSafe: function() {
                            module.verbose('Removing fail safe timer', module.timer);
                            if(module.timer) {
                                clearTimeout(module.timer);
                            }
                        },
                        hidden: function() {
                            $module.removeClass(className.hidden);
                        },
                        visible: function() {
                            $module.removeClass(className.visible);
                        },
                        looping: function() {
                            module.debug('Transitions are no longer looping');
                            if( module.is.looping() ) {
                                module.reset();
                                $module
                                    .removeClass(className.looping)
                                ;
                            }
                        },
                        transition: function() {
                            $module
                                .removeClass(className.visible)
                                .removeClass(className.hidden)
                            ;
                        }
                    },
                    get: {
                        settings: function(animation, duration, onComplete) {
                            // single settings object
                            if(typeof animation == 'object') {
                                return $.extend(true, {}, $.fn.transition.settings, animation);
                            }
                            // all arguments provided
                            else if(typeof onComplete == 'function') {
                                return $.extend({}, $.fn.transition.settings, {
                                    animation  : animation,
                                    onComplete : onComplete,
                                    duration   : duration
                                });
                            }
                            // only duration provided
                            else if(typeof duration == 'string' || typeof duration == 'number') {
                                return $.extend({}, $.fn.transition.settings, {
                                    animation : animation,
                                    duration  : duration
                                });
                            }
                            // duration is actually settings object
                            else if(typeof duration == 'object') {
                                return $.extend({}, $.fn.transition.settings, duration, {
                                    animation : animation
                                });
                            }
                            // duration is actually callback
                            else if(typeof duration == 'function') {
                                return $.extend({}, $.fn.transition.settings, {
                                    animation  : animation,
                                    onComplete : duration
                                });
                            }
                            // only animation provided
                            else {
                                return $.extend({}, $.fn.transition.settings, {
                                    animation : animation
                                });
                            }
                            return $.fn.transition.settings;
                        },
                        animationClass: function(animation) {
                            var
                                animationClass = animation || settings.animation,
                                directionClass = (module.can.transition() && !module.has.direction())
                                    ? module.get.direction() + ' '
                                    : ''
                                ;
                            return className.animating + ' '
                                + className.transition + ' '
                                + directionClass
                                + animationClass
                                ;
                        },
                        currentAnimation: function() {
                            return (module.cache && module.cache.animation !== undefined)
                                ? module.cache.animation
                                : false
                                ;
                        },
                        currentDirection: function() {
                            return module.is.inward()
                                ? className.inward
                                : className.outward
                                ;
                        },
                        direction: function() {
                            return module.is.hidden() || !module.is.visible()
                                ? className.inward
                                : className.outward
                                ;
                        },
                        animationDirection: function(animation) {
                            var
                                direction
                                ;
                            animation = animation || settings.animation;
                            if(typeof animation === 'string') {
                                animation = animation.split(' ');
                                // search animation name for out/in class
                                $.each(animation, function(index, word){
                                    if(word === className.inward) {
                                        direction = className.inward;
                                    }
                                    else if(word === className.outward) {
                                        direction = className.outward;
                                    }
                                });
                            }
                            // return found direction
                            if(direction) {
                                return direction;
                            }
                            return false;
                        },
                        duration: function(duration) {
                            duration = duration || settings.duration;
                            if(duration === false) {
                                duration = $module.css('animation-duration') || 0;
                            }
                            return (typeof duration === 'string')
                                ? (duration.indexOf('ms') > -1)
                                ? parseFloat(duration)
                                : parseFloat(duration) * 1000
                                : duration
                                ;
                        },
                        displayType: function() {
                            if(settings.displayType) {
                                return settings.displayType;
                            }
                            if($module.data(metadata.displayType) === undefined) {
                                // create fake element to determine display state
                                module.can.transition(true);
                            }
                            return $module.data(metadata.displayType);
                        },
                        userStyle: function(style) {
                            style = style || $module.attr('style') || '';
                            return style.replace(/display.*?;/, '');
                        },
                        transitionExists: function(animation) {
                            return $.fn.transition.exists[animation];
                        },
                        animationStartEvent: function() {
                            var
                                element     = document.createElement('div'),
                                animations  = {
                                    'animation'       :'animationstart',
                                    'OAnimation'      :'oAnimationStart',
                                    'MozAnimation'    :'mozAnimationStart',
                                    'WebkitAnimation' :'webkitAnimationStart'
                                },
                                animation
                                ;
                            for(animation in animations){
                                if( element.style[animation] !== undefined ){
                                    return animations[animation];
                                }
                            }
                            return false;
                        },
                        animationEndEvent: function() {
                            var
                                element     = document.createElement('div'),
                                animations  = {
                                    'animation'       :'animationend',
                                    'OAnimation'      :'oAnimationEnd',
                                    'MozAnimation'    :'mozAnimationEnd',
                                    'WebkitAnimation' :'webkitAnimationEnd'
                                },
                                animation
                                ;
                            for(animation in animations){
                                if( element.style[animation] !== undefined ){
                                    return animations[animation];
                                }
                            }
                            return false;
                        }

                    },

                    can: {
                        transition: function(forced) {
                            var
                                animation         = settings.animation,
                                transitionExists  = module.get.transitionExists(animation),
                                elementClass,
                                tagName,
                                $clone,
                                currentAnimation,
                                inAnimation,
                                directionExists,
                                displayType
                                ;
                            if( transitionExists === undefined || forced) {
                                module.verbose('Determining whether animation exists');
                                elementClass = $module.attr('class');
                                tagName      = $module.prop('tagName');

                                $clone = $('<' + tagName + ' />').addClass( elementClass ).insertAfter($module);
                                currentAnimation = $clone
                                    .addClass(animation)
                                    .removeClass(className.inward)
                                    .removeClass(className.outward)
                                    .addClass(className.animating)
                                    .addClass(className.transition)
                                    .css('animationName')
                                ;
                                inAnimation = $clone
                                    .addClass(className.inward)
                                    .css('animationName')
                                ;
                                displayType = $clone
                                    .attr('class', elementClass)
                                    .removeAttr('style')
                                    .removeClass(className.hidden)
                                    .removeClass(className.visible)
                                    .show()
                                    .css('display')
                                ;
                                module.verbose('Determining final display state', displayType);
                                module.save.displayType(displayType);

                                $clone.remove();
                                if(currentAnimation != inAnimation) {
                                    module.debug('Direction exists for animation', animation);
                                    directionExists = true;
                                }
                                else if(currentAnimation == 'none' || !currentAnimation) {
                                    module.debug('No animation defined in css', animation);
                                    return;
                                }
                                else {
                                    module.debug('Static animation found', animation, displayType);
                                    directionExists = false;
                                }
                                module.save.transitionExists(animation, directionExists);
                            }
                            return (transitionExists !== undefined)
                                ? transitionExists
                                : directionExists
                                ;
                        },
                        animate: function() {
                            // can transition does not return a value if animation does not exist
                            return (module.can.transition() !== undefined);
                        }
                    },

                    is: {
                        animating: function() {
                            return $module.hasClass(className.animating);
                        },
                        inward: function() {
                            return $module.hasClass(className.inward);
                        },
                        outward: function() {
                            return $module.hasClass(className.outward);
                        },
                        looping: function() {
                            return $module.hasClass(className.looping);
                        },
                        occurring: function(animation) {
                            animation = animation || settings.animation;
                            animation = '.' + animation.replace(' ', '.');
                            return ( $module.filter(animation).length > 0 );
                        },
                        visible: function() {
                            return $module.is(':visible');
                        },
                        hidden: function() {
                            return $module.css('visibility') === 'hidden';
                        },
                        supported: function() {
                            return(animationEnd !== false);
                        }
                    },

                    hide: function() {
                        module.verbose('Hiding element');
                        if( module.is.animating() ) {
                            module.reset();
                        }
                        element.blur(); // IE will trigger focus change if element is not blurred before hiding
                        module.remove.display();
                        module.remove.visible();
                        module.set.hidden();
                        module.force.hidden();
                        settings.onHide.call(element);
                        settings.onComplete.call(element);
                        // module.repaint();
                    },

                    show: function(display) {
                        module.verbose('Showing element', display);
                        module.remove.hidden();
                        module.set.visible();
                        module.force.visible();
                        settings.onShow.call(element);
                        settings.onComplete.call(element);
                        // module.repaint();
                    },

                    toggle: function() {
                        if( module.is.visible() ) {
                            module.hide();
                        }
                        else {
                            module.show();
                        }
                    },

                    stop: function() {
                        module.debug('Stopping current animation');
                        $module.triggerHandler(animationEnd);
                    },

                    stopAll: function() {
                        module.debug('Stopping all animation');
                        module.remove.queueCallback();
                        $module.triggerHandler(animationEnd);
                    },

                    clear: {
                        queue: function() {
                            module.debug('Clearing animation queue');
                            module.remove.queueCallback();
                        }
                    },

                    enable: function() {
                        module.verbose('Starting animation');
                        $module.removeClass(className.disabled);
                    },

                    disable: function() {
                        module.debug('Stopping animation');
                        $module.addClass(className.disabled);
                    },

                    setting: function(name, value) {
                        module.debug('Changing setting', name, value);
                        if( $.isPlainObject(name) ) {
                            $.extend(true, settings, name);
                        }
                        else if(value !== undefined) {
                            settings[name] = value;
                        }
                        else {
                            return settings[name];
                        }
                    },
                    internal: function(name, value) {
                        if( $.isPlainObject(name) ) {
                            $.extend(true, module, name);
                        }
                        else if(value !== undefined) {
                            module[name] = value;
                        }
                        else {
                            return module[name];
                        }
                    },
                    debug: function() {
                        if(settings.debug) {
                            if(settings.performance) {
                                module.performance.log(arguments);
                            }
                            else {
                                module.debug = Function.prototype.bind.call(console.info, console, settings.name + ':');
                                module.debug.apply(console, arguments);
                            }
                        }
                    },
                    verbose: function() {
                        if(settings.verbose && settings.debug) {
                            if(settings.performance) {
                                module.performance.log(arguments);
                            }
                            else {
                                module.verbose = Function.prototype.bind.call(console.info, console, settings.name + ':');
                                module.verbose.apply(console, arguments);
                            }
                        }
                    },
                    error: function() {
                        module.error = Function.prototype.bind.call(console.error, console, settings.name + ':');
                        module.error.apply(console, arguments);
                    },
                    performance: {
                        log: function(message) {
                            var
                                currentTime,
                                executionTime,
                                previousTime
                                ;
                            if(settings.performance) {
                                currentTime   = new Date().getTime();
                                previousTime  = time || currentTime;
                                executionTime = currentTime - previousTime;
                                time          = currentTime;
                                performance.push({
                                    'Name'           : message[0],
                                    'Arguments'      : [].slice.call(message, 1) || '',
                                    'Element'        : element,
                                    'Execution Time' : executionTime
                                });
                            }
                            clearTimeout(module.performance.timer);
                            module.performance.timer = setTimeout(module.performance.display, 500);
                        },
                        display: function() {
                            var
                                title = settings.name + ':',
                                totalTime = 0
                                ;
                            time = false;
                            clearTimeout(module.performance.timer);
                            $.each(performance, function(index, data) {
                                totalTime += data['Execution Time'];
                            });
                            title += ' ' + totalTime + 'ms';
                            if(moduleSelector) {
                                title += ' \'' + moduleSelector + '\'';
                            }
                            if($allModules.length > 1) {
                                title += ' ' + '(' + $allModules.length + ')';
                            }
                            if( (console.group !== undefined || console.table !== undefined) && performance.length > 0) {
                                console.groupCollapsed(title);
                                if(console.table) {
                                    console.table(performance);
                                }
                                else {
                                    $.each(performance, function(index, data) {
                                        console.log(data['Name'] + ': ' + data['Execution Time']+'ms');
                                    });
                                }
                                console.groupEnd();
                            }
                            performance = [];
                        }
                    },
                    // modified for transition to return invoke success
                    invoke: function(query, passedArguments, context) {
                        var
                            object = instance,
                            maxDepth,
                            found,
                            response
                            ;
                        passedArguments = passedArguments || queryArguments;
                        context         = element         || context;
                        if(typeof query == 'string' && object !== undefined) {
                            query    = query.split(/[\. ]/);
                            maxDepth = query.length - 1;
                            $.each(query, function(depth, value) {
                                var camelCaseValue = (depth != maxDepth)
                                        ? value + query[depth + 1].charAt(0).toUpperCase() + query[depth + 1].slice(1)
                                        : query
                                    ;
                                if( $.isPlainObject( object[camelCaseValue] ) && (depth != maxDepth) ) {
                                    object = object[camelCaseValue];
                                }
                                else if( object[camelCaseValue] !== undefined ) {
                                    found = object[camelCaseValue];
                                    return false;
                                }
                                else if( $.isPlainObject( object[value] ) && (depth != maxDepth) ) {
                                    object = object[value];
                                }
                                else if( object[value] !== undefined ) {
                                    found = object[value];
                                    return false;
                                }
                                else {
                                    return false;
                                }
                            });
                        }
                        if ( $.isFunction( found ) ) {
                            response = found.apply(context, passedArguments);
                        }
                        else if(found !== undefined) {
                            response = found;
                        }

                        if($.isArray(returnedValue)) {
                            returnedValue.push(response);
                        }
                        else if(returnedValue !== undefined) {
                            returnedValue = [returnedValue, response];
                        }
                        else if(response !== undefined) {
                            returnedValue = response;
                        }
                        return (found !== undefined)
                            ? found
                            : false
                            ;
                    }
                };
                module.initialize();
            })
        ;
        return (returnedValue !== undefined)
            ? returnedValue
            : this
            ;
    };

// Records if CSS transition is available
    $.fn.transition.exists = {};

    $.fn.transition.settings = {

        // module info
        name          : 'Transition',

        // debug content outputted to console
        debug         : false,

        // verbose debug output
        verbose       : false,

        // performance data output
        performance   : true,

        // event namespace
        namespace     : 'transition',

        // delay between animations in group
        interval      : 0,

        // whether group animations should be reversed
        reverse       : 'auto',

        // animation callback event
        onStart       : function() {},
        onComplete    : function() {},
        onShow        : function() {},
        onHide        : function() {},

        // whether timeout should be used to ensure callback fires in cases animationend does not
        useFailSafe   : true,

        // delay in ms for fail safe
        failSafeDelay : 100,

        // whether EXACT animation can occur twice in a row
        allowRepeats  : false,

        // Override final display type on visible
        displayType   : false,

        // animation duration
        animation     : 'fade',
        duration      : false,

        // new animations will occur after previous ones
        queue         : true,

        metadata : {
            displayType: 'display'
        },

        className   : {
            animating  : 'animating',
            disabled   : 'disabled',
            hidden     : 'hidden',
            inward     : 'in',
            loading    : 'loading',
            looping    : 'looping',
            outward    : 'out',
            transition : 'transition',
            visible    : 'visible'
        },

        // possible errors
        error: {
            noAnimation : 'There is no css animation matching the one you specified. Please make sure your css is vendor prefixed, and you have included transition css.',
            repeated    : 'That animation is already occurring, cancelling repeated animation',
            method      : 'The method you called is not defined',
            support     : 'This browser does not support CSS animations'
        }

    };


})( jQuery, window, document );

/*!
 * # Semantic UI 2.1.6 - API
 * http://github.com/semantic-org/semantic-ui/
 *
 *
 * Copyright 2015 Contributors
 * Released under the MIT license
 * http://opensource.org/licenses/MIT
 *
 */

;(function ( $, window, document, undefined ) {

    "use strict";

    $.api = $.fn.api = function(parameters) {

        var
        // use window context if none specified
            $allModules     = $.isFunction(this)
                ? $(window)
                : $(this),
            moduleSelector = $allModules.selector || '',
            time           = new Date().getTime(),
            performance    = [],

            query          = arguments[0],
            methodInvoked  = (typeof query == 'string'),
            queryArguments = [].slice.call(arguments, 1),

            returnedValue
            ;

        $allModules
            .each(function() {
                var
                    settings          = ( $.isPlainObject(parameters) )
                        ? $.extend(true, {}, $.fn.api.settings, parameters)
                        : $.extend({}, $.fn.api.settings),

                // internal aliases
                    namespace       = settings.namespace,
                    metadata        = settings.metadata,
                    selector        = settings.selector,
                    error           = settings.error,
                    className       = settings.className,

                // define namespaces for modules
                    eventNamespace  = '.' + namespace,
                    moduleNamespace = 'module-' + namespace,

                // element that creates request
                    $module         = $(this),
                    $form           = $module.closest(selector.form),

                // context used for state
                    $context        = (settings.stateContext)
                        ? $(settings.stateContext)
                        : $module,

                // request details
                    ajaxSettings,
                    requestSettings,
                    url,
                    data,
                    requestStartTime,

                // standard module
                    element         = this,
                    context         = $context[0],
                    instance        = $module.data(moduleNamespace),
                    module
                    ;

                module = {

                    initialize: function() {
                        if(!methodInvoked) {
                            module.bind.events();
                        }
                        module.instantiate();
                    },

                    instantiate: function() {
                        module.verbose('Storing instance of module', module);
                        instance = module;
                        $module
                            .data(moduleNamespace, instance)
                        ;
                    },

                    destroy: function() {
                        module.verbose('Destroying previous module for', element);
                        $module
                            .removeData(moduleNamespace)
                            .off(eventNamespace)
                        ;
                    },

                    bind: {
                        events: function() {
                            var
                                triggerEvent = module.get.event()
                                ;
                            if( triggerEvent ) {
                                module.verbose('Attaching API events to element', triggerEvent);
                                $module
                                    .on(triggerEvent + eventNamespace, module.event.trigger)
                                ;
                            }
                            else if(settings.on == 'now') {
                                module.debug('Querying API endpoint immediately');
                                module.query();
                            }
                        }
                    },

                    decode: {
                        json: function(response) {
                            if(response !== undefined && typeof response == 'string') {
                                try {
                                    response = JSON.parse(response);
                                }
                                catch(e) {
                                    // isnt json string
                                }
                            }
                            return response;
                        }
                    },

                    read: {
                        cachedResponse: function(url) {
                            var
                                response
                                ;
                            if(window.Storage === undefined) {
                                module.error(error.noStorage);
                                return;
                            }
                            response = sessionStorage.getItem(url);
                            module.debug('Using cached response', url, response);
                            response = module.decode.json(response);
                            return false;
                        }
                    },
                    write: {
                        cachedResponse: function(url, response) {
                            if(response && response === '') {
                                module.debug('Response empty, not caching', response);
                                return;
                            }
                            if(window.Storage === undefined) {
                                module.error(error.noStorage);
                                return;
                            }
                            if( $.isPlainObject(response) ) {
                                response = JSON.stringify(response);
                            }
                            sessionStorage.setItem(url, response);
                            module.verbose('Storing cached response for url', url, response);
                        }
                    },

                    query: function() {

                        if(module.is.disabled()) {
                            module.debug('Element is disabled API request aborted');
                            return;
                        }

                        if(module.is.loading()) {
                            if(settings.interruptRequests) {
                                module.debug('Interrupting previous request');
                                module.abort();
                            }
                            else {
                                module.debug('Cancelling request, previous request is still pending');
                                return;
                            }
                        }

                        // pass element metadata to url (value, text)
                        if(settings.defaultData) {
                            $.extend(true, settings.urlData, module.get.defaultData());
                        }

                        // Add form content
                        if(settings.serializeForm) {
                            settings.data = module.add.formData(settings.data);
                        }

                        // call beforesend and get any settings changes
                        requestSettings = module.get.settings();

                        // check if before send cancelled request
                        if(requestSettings === false) {
                            module.cancelled = true;
                            module.error(error.beforeSend);
                            return;
                        }
                        else {
                            module.cancelled = false;
                        }

                        // get url
                        url = module.get.templatedURL();

                        if(!url && !module.is.mocked()) {
                            module.error(error.missingURL);
                            return;
                        }

                        // replace variables
                        url = module.add.urlData( url );

                        // missing url parameters
                        if( !url && !module.is.mocked()) {
                            return;
                        }


                        // look for jQuery ajax parameters in settings
                        ajaxSettings = $.extend(true, {}, settings, {
                            type       : settings.method || settings.type,
                            data       : data,
                            url        : settings.base + url,
                            beforeSend : settings.beforeXHR,
                            success    : function() {},
                            failure    : function() {},
                            complete   : function() {}
                        });

                        module.debug('Querying URL', ajaxSettings.url);
                        module.verbose('Using AJAX settings', ajaxSettings);

                        if(settings.cache === 'local' && module.read.cachedResponse(url)) {
                            module.debug('Response returned from local cache');
                            module.request = module.create.request();
                            module.request.resolveWith(context, [ module.read.cachedResponse(url) ]);
                            return;
                        }

                        if( !settings.throttle ) {
                            module.debug('Sending request', data, ajaxSettings.method);
                            module.send.request();
                        }
                        else {
                            if(!settings.throttleFirstRequest && !module.timer) {
                                module.debug('Sending request', data, ajaxSettings.method);
                                module.send.request();
                                module.timer = setTimeout(function(){}, settings.throttle);
                            }
                            else {
                                module.debug('Throttling request', settings.throttle);
                                clearTimeout(module.timer);
                                module.timer = setTimeout(function() {
                                    if(module.timer) {
                                        delete module.timer;
                                    }
                                    module.debug('Sending throttled request', data, ajaxSettings.method);
                                    module.send.request();
                                }, settings.throttle);
                            }
                        }

                    },

                    should: {
                        removeError: function() {
                            return ( settings.hideError === true || (settings.hideError === 'auto' && !module.is.form()) );
                        }
                    },

                    is: {
                        disabled: function() {
                            return ($module.filter(selector.disabled).length > 0);
                        },
                        form: function() {
                            return $module.is('form') || $context.is('form');
                        },
                        mocked: function() {
                            return (settings.mockResponse || settings.mockResponseAsync);
                        },
                        input: function() {
                            return $module.is('input');
                        },
                        loading: function() {
                            return (module.request && module.request.state() == 'pending');
                        },
                        abortedRequest: function(xhr) {
                            if(xhr && xhr.readyState !== undefined && xhr.readyState === 0) {
                                module.verbose('XHR request determined to be aborted');
                                return true;
                            }
                            else {
                                module.verbose('XHR request was not aborted');
                                return false;
                            }
                        },
                        validResponse: function(response) {
                            if( (settings.dataType !== 'json' && settings.dataType !== 'jsonp') || !$.isFunction(settings.successTest) ) {
                                module.verbose('Response is not JSON, skipping validation', settings.successTest, response);
                                return true;
                            }
                            module.debug('Checking JSON returned success', settings.successTest, response);
                            if( settings.successTest(response) ) {
                                module.debug('Response passed success test', response);
                                return true;
                            }
                            else {
                                module.debug('Response failed success test', response);
                                return false;
                            }
                        }
                    },

                    was: {
                        cancelled: function() {
                            return (module.cancelled || false);
                        },
                        succesful: function() {
                            return (module.request && module.request.state() == 'resolved');
                        },
                        failure: function() {
                            return (module.request && module.request.state() == 'rejected');
                        },
                        complete: function() {
                            return (module.request && (module.request.state() == 'resolved' || module.request.state() == 'rejected') );
                        }
                    },

                    add: {
                        urlData: function(url, urlData) {
                            var
                                requiredVariables,
                                optionalVariables
                                ;
                            if(url) {
                                requiredVariables = url.match(settings.regExp.required);
                                optionalVariables = url.match(settings.regExp.optional);
                                urlData           = urlData || settings.urlData;
                                if(requiredVariables) {
                                    module.debug('Looking for required URL variables', requiredVariables);
                                    $.each(requiredVariables, function(index, templatedString) {
                                        var
                                        // allow legacy {$var} style
                                            variable = (templatedString.indexOf('$') !== -1)
                                                ? templatedString.substr(2, templatedString.length - 3)
                                                : templatedString.substr(1, templatedString.length - 2),
                                            value   = ($.isPlainObject(urlData) && urlData[variable] !== undefined)
                                                ? urlData[variable]
                                                : ($module.data(variable) !== undefined)
                                                ? $module.data(variable)
                                                : ($context.data(variable) !== undefined)
                                                ? $context.data(variable)
                                                : urlData[variable]
                                            ;
                                        // remove value
                                        if(value === undefined) {
                                            module.error(error.requiredParameter, variable, url);
                                            url = false;
                                            return false;
                                        }
                                        else {
                                            module.verbose('Found required variable', variable, value);
                                            value = (settings.encodeParameters)
                                                ? module.get.urlEncodedValue(value)
                                                : value
                                            ;
                                            url = url.replace(templatedString, value);
                                        }
                                    });
                                }
                                if(optionalVariables) {
                                    module.debug('Looking for optional URL variables', requiredVariables);
                                    $.each(optionalVariables, function(index, templatedString) {
                                        var
                                        // allow legacy {/$var} style
                                            variable = (templatedString.indexOf('$') !== -1)
                                                ? templatedString.substr(3, templatedString.length - 4)
                                                : templatedString.substr(2, templatedString.length - 3),
                                            value   = ($.isPlainObject(urlData) && urlData[variable] !== undefined)
                                                ? urlData[variable]
                                                : ($module.data(variable) !== undefined)
                                                ? $module.data(variable)
                                                : ($context.data(variable) !== undefined)
                                                ? $context.data(variable)
                                                : urlData[variable]
                                            ;
                                        // optional replacement
                                        if(value !== undefined) {
                                            module.verbose('Optional variable Found', variable, value);
                                            url = url.replace(templatedString, value);
                                        }
                                        else {
                                            module.verbose('Optional variable not found', variable);
                                            // remove preceding slash if set
                                            if(url.indexOf('/' + templatedString) !== -1) {
                                                url = url.replace('/' + templatedString, '');
                                            }
                                            else {
                                                url = url.replace(templatedString, '');
                                            }
                                        }
                                    });
                                }
                            }
                            return url;
                        },
                        formData: function(data) {
                            var
                                canSerialize = ($.fn.serializeObject !== undefined),
                                formData     = (canSerialize)
                                    ? $form.serializeObject()
                                    : $form.serialize(),
                                hasOtherData
                                ;
                            data         = data || settings.data;
                            hasOtherData = $.isPlainObject(data);

                            if(hasOtherData) {
                                if(canSerialize) {
                                    module.debug('Extending existing data with form data', data, formData);
                                    data = $.extend(true, {}, data, formData);
                                }
                                else {
                                    module.error(error.missingSerialize);
                                    module.debug('Cant extend data. Replacing data with form data', data, formData);
                                    data = formData;
                                }
                            }
                            else {
                                module.debug('Adding form data', formData);
                                data = formData;
                            }
                            return data;
                        }
                    },

                    send: {
                        request: function() {
                            module.set.loading();
                            module.request = module.create.request();
                            if( module.is.mocked() ) {
                                module.mockedXHR = module.create.mockedXHR();
                            }
                            else {
                                module.xhr = module.create.xhr();
                            }
                            settings.onRequest.call(context, module.request, module.xhr);
                        }
                    },

                    event: {
                        trigger: function(event) {
                            module.query();
                            if(event.type == 'submit' || event.type == 'click') {
                                event.preventDefault();
                            }
                        },
                        xhr: {
                            always: function() {
                                // nothing special
                            },
                            done: function(response, textStatus, xhr) {
                                var
                                    context            = this,
                                    elapsedTime        = (new Date().getTime() - requestStartTime),
                                    timeLeft           = (settings.loadingDuration - elapsedTime),
                                    translatedResponse = ( $.isFunction(settings.onResponse) )
                                        ? settings.onResponse.call(context, $.extend(true, {}, response))
                                        : false
                                    ;
                                timeLeft = (timeLeft > 0)
                                    ? timeLeft
                                    : 0
                                ;
                                if(translatedResponse) {
                                    module.debug('Modified API response in onResponse callback', settings.onResponse, translatedResponse, response);
                                    response = translatedResponse;
                                }
                                if(timeLeft > 0) {
                                    module.debug('Response completed early delaying state change by', timeLeft);
                                }
                                setTimeout(function() {
                                    if( module.is.validResponse(response) ) {
                                        module.request.resolveWith(context, [response, xhr]);
                                    }
                                    else {
                                        module.request.rejectWith(context, [xhr, 'invalid']);
                                    }
                                }, timeLeft);
                            },
                            fail: function(xhr, status, httpMessage) {
                                var
                                    context     = this,
                                    elapsedTime = (new Date().getTime() - requestStartTime),
                                    timeLeft    = (settings.loadingDuration - elapsedTime)
                                    ;
                                timeLeft = (timeLeft > 0)
                                    ? timeLeft
                                    : 0
                                ;
                                if(timeLeft > 0) {
                                    module.debug('Response completed early delaying state change by', timeLeft);
                                }
                                setTimeout(function() {
                                    if( module.is.abortedRequest(xhr) ) {
                                        module.request.rejectWith(context, [xhr, 'aborted', httpMessage]);
                                    }
                                    else {
                                        module.request.rejectWith(context, [xhr, 'error', status, httpMessage]);
                                    }
                                }, timeLeft);
                            }
                        },
                        request: {
                            done: function(response, xhr) {
                                module.debug('Successful API Response', response);
                                if(settings.cache === 'local' && url) {
                                    module.write.cachedResponse(url, response);
                                    module.debug('Saving server response locally', module.cache);
                                }
                                settings.onSuccess.call(context, response, $module, xhr);
                            },
                            complete: function(firstParameter, secondParameter) {
                                var
                                    xhr,
                                    response
                                    ;
                                // have to guess callback parameters based on request success
                                if( module.was.succesful() ) {
                                    response = firstParameter;
                                    xhr      = secondParameter;
                                }
                                else {
                                    xhr      = firstParameter;
                                    response = module.get.responseFromXHR(xhr);
                                }
                                module.remove.loading();
                                settings.onComplete.call(context, response, $module, xhr);
                            },
                            fail: function(xhr, status, httpMessage) {
                                var
                                // pull response from xhr if available
                                    response     = module.get.responseFromXHR(xhr),
                                    errorMessage = module.get.errorFromRequest(response, status, httpMessage)
                                    ;
                                if(status == 'aborted') {
                                    module.debug('XHR Aborted (Most likely caused by page navigation or CORS Policy)', status, httpMessage);
                                    settings.onAbort.call(context, status, $module, xhr);
                                }
                                else if(status == 'invalid') {
                                    module.debug('JSON did not pass success test. A server-side error has most likely occurred', response);
                                }
                                else if(status == 'error')  {
                                    if(xhr !== undefined) {
                                        module.debug('XHR produced a server error', status, httpMessage);
                                        // make sure we have an error to display to console
                                        if( xhr.status != 200 && httpMessage !== undefined && httpMessage !== '') {
                                            module.error(error.statusMessage + httpMessage, ajaxSettings.url);
                                        }
                                        settings.onError.call(context, errorMessage, $module, xhr);
                                    }
                                }

                                if(settings.errorDuration && status !== 'aborted') {
                                    module.debug('Adding error state');
                                    module.set.error();
                                    if( module.should.removeError() ) {
                                        setTimeout(module.remove.error, settings.errorDuration);
                                    }
                                }
                                module.debug('API Request failed', errorMessage, xhr);
                                settings.onFailure.call(context, response, $module, xhr);
                            }
                        }
                    },

                    create: {

                        request: function() {
                            // api request promise
                            return $.Deferred()
                                .always(module.event.request.complete)
                                .done(module.event.request.done)
                                .fail(module.event.request.fail)
                                ;
                        },

                        mockedXHR: function () {
                            var
                            // xhr does not simulate these properties of xhr but must return them
                                textStatus  = false,
                                status      = false,
                                httpMessage = false,
                                asyncCallback,
                                response,
                                mockedXHR
                                ;

                            mockedXHR = $.Deferred()
                                .always(module.event.xhr.complete)
                                .done(module.event.xhr.done)
                                .fail(module.event.xhr.fail)
                            ;

                            if(settings.mockResponse) {
                                if( $.isFunction(settings.mockResponse) ) {
                                    module.debug('Using mocked callback returning response', settings.mockResponse);
                                    response = settings.mockResponse.call(context, settings);
                                }
                                else {
                                    module.debug('Using specified response', settings.mockResponse);
                                    response = settings.mockResponse;
                                }
                                // simulating response
                                mockedXHR.resolveWith(context, [ response, textStatus, { responseText: response }]);
                            }
                            else if( $.isFunction(settings.mockResponseAsync) ) {
                                asyncCallback = function(response) {
                                    module.debug('Async callback returned response', response);

                                    if(response) {
                                        mockedXHR.resolveWith(context, [ response, textStatus, { responseText: response }]);
                                    }
                                    else {
                                        mockedXHR.rejectWith(context, [{ responseText: response }, status, httpMessage]);
                                    }
                                };
                                module.debug('Using async mocked response', settings.mockResponseAsync);
                                settings.mockResponseAsync.call(context, settings, asyncCallback);
                            }
                            return mockedXHR;
                        },

                        xhr: function() {
                            var
                                xhr
                                ;
                            // ajax request promise
                            xhr = $.ajax(ajaxSettings)
                                .always(module.event.xhr.always)
                                .done(module.event.xhr.done)
                                .fail(module.event.xhr.fail)
                            ;
                            module.verbose('Created server request', xhr);
                            return xhr;
                        }
                    },

                    set: {
                        error: function() {
                            module.verbose('Adding error state to element', $context);
                            $context.addClass(className.error);
                        },
                        loading: function() {
                            module.verbose('Adding loading state to element', $context);
                            $context.addClass(className.loading);
                            requestStartTime = new Date().getTime();
                        }
                    },

                    remove: {
                        error: function() {
                            module.verbose('Removing error state from element', $context);
                            $context.removeClass(className.error);
                        },
                        loading: function() {
                            module.verbose('Removing loading state from element', $context);
                            $context.removeClass(className.loading);
                        }
                    },

                    get: {
                        responseFromXHR: function(xhr) {
                            return $.isPlainObject(xhr)
                                ? (settings.dataType == 'json' || settings.dataType == 'jsonp')
                                ? module.decode.json(xhr.responseText)
                                : xhr.responseText
                                : false
                                ;
                        },
                        errorFromRequest: function(response, status, httpMessage) {
                            return ($.isPlainObject(response) && response.error !== undefined)
                                ? response.error // use json error message
                                : (settings.error[status] !== undefined) // use server error message
                                ? settings.error[status]
                                : httpMessage
                                ;
                        },
                        request: function() {
                            return module.request || false;
                        },
                        xhr: function() {
                            return module.xhr || false;
                        },
                        settings: function() {
                            var
                                runSettings
                                ;
                            runSettings = settings.beforeSend.call(context, settings);
                            if(runSettings) {
                                if(runSettings.success !== undefined) {
                                    module.debug('Legacy success callback detected', runSettings);
                                    //module.error(error.legacyParameters, runSettings.success);
                                    runSettings.onSuccess = runSettings.success;
                                }
                                if(runSettings.failure !== undefined) {
                                    module.debug('Legacy failure callback detected', runSettings);
                                    module.error(error.legacyParameters, runSettings.failure);
                                    runSettings.onFailure = runSettings.failure;
                                }
                                if(runSettings.complete !== undefined) {
                                    module.debug('Legacy complete callback detected', runSettings);
                                    module.error(error.legacyParameters, runSettings.complete);
                                    runSettings.onComplete = runSettings.complete;
                                }
                            }
                            if(runSettings === undefined) {
                                module.error(error.noReturnedValue);
                            }
                            return (runSettings !== undefined)
                                ? runSettings
                                : settings
                                ;
                        },
                        urlEncodedValue: function(value) {
                            var
                                decodedValue   = window.decodeURIComponent(value),
                                encodedValue   = window.encodeURIComponent(value),
                                alreadyEncoded = (decodedValue !== value)
                                ;
                            if(alreadyEncoded) {
                                module.debug('URL value is already encoded, avoiding double encoding', value);
                                return value;
                            }
                            module.verbose('Encoding value using encodeURIComponent', value, encodedValue);
                            return encodedValue;
                        },
                        defaultData: function() {
                            var
                                data = {}
                                ;
                            if( !$.isWindow(element) ) {
                                if( module.is.input() ) {
                                    data.value = $module.val();
                                }
                                else if( !module.is.form() ) {

                                }
                                else {
                                    data.text = $module.text();
                                }
                            }
                            return data;
                        },
                        event: function() {
                            if( $.isWindow(element) || settings.on == 'now' ) {
                                module.debug('API called without element, no events attached');
                                return false;
                            }
                            else if(settings.on == 'auto') {
                                if( $module.is('input') ) {
                                    return (element.oninput !== undefined)
                                        ? 'input'
                                        : (element.onpropertychange !== undefined)
                                        ? 'propertychange'
                                        : 'keyup'
                                        ;
                                }
                                else if( $module.is('form') ) {
                                    return 'submit';
                                }
                                else {
                                    return 'click';
                                }
                            }
                            else {
                                return settings.on;
                            }
                        },
                        templatedURL: function(action) {
                            action = action || $module.data(metadata.action) || settings.action || false;
                            url    = $module.data(metadata.url) || settings.url || false;
                            if(url) {
                                module.debug('Using specified url', url);
                                return url;
                            }
                            if(action) {
                                module.debug('Looking up url for action', action, settings.api);
                                if(settings.api[action] === undefined && !module.is.mocked()) {
                                    module.error(error.missingAction, settings.action, settings.api);
                                    return;
                                }
                                url = settings.api[action];
                            }
                            else if( module.is.form() ) {
                                url = $module.attr('action') || $context.attr('action') || false;
                                module.debug('No url or action specified, defaulting to form action', url);
                            }
                            return url;
                        }
                    },

                    abort: function() {
                        var
                            xhr = module.get.xhr()
                            ;
                        if( xhr && xhr.state() !== 'resolved') {
                            module.debug('Cancelling API request');
                            xhr.abort();
                        }
                    },

                    // reset state
                    reset: function() {
                        module.remove.error();
                        module.remove.loading();
                    },

                    setting: function(name, value) {
                        module.debug('Changing setting', name, value);
                        if( $.isPlainObject(name) ) {
                            $.extend(true, settings, name);
                        }
                        else if(value !== undefined) {
                            settings[name] = value;
                        }
                        else {
                            return settings[name];
                        }
                    },
                    internal: function(name, value) {
                        if( $.isPlainObject(name) ) {
                            $.extend(true, module, name);
                        }
                        else if(value !== undefined) {
                            module[name] = value;
                        }
                        else {
                            return module[name];
                        }
                    },
                    debug: function() {
                        if(settings.debug) {
                            if(settings.performance) {
                                module.performance.log(arguments);
                            }
                            else {
                                module.debug = Function.prototype.bind.call(console.info, console, settings.name + ':');
                                module.debug.apply(console, arguments);
                            }
                        }
                    },
                    verbose: function() {
                        if(settings.verbose && settings.debug) {
                            if(settings.performance) {
                                module.performance.log(arguments);
                            }
                            else {
                                module.verbose = Function.prototype.bind.call(console.info, console, settings.name + ':');
                                module.verbose.apply(console, arguments);
                            }
                        }
                    },
                    error: function() {
                        module.error = Function.prototype.bind.call(console.error, console, settings.name + ':');
                        module.error.apply(console, arguments);
                    },
                    performance: {
                        log: function(message) {
                            var
                                currentTime,
                                executionTime,
                                previousTime
                                ;
                            if(settings.performance) {
                                currentTime   = new Date().getTime();
                                previousTime  = time || currentTime;
                                executionTime = currentTime - previousTime;
                                time          = currentTime;
                                performance.push({
                                    'Name'           : message[0],
                                    'Arguments'      : [].slice.call(message, 1) || '',
                                    //'Element'        : element,
                                    'Execution Time' : executionTime
                                });
                            }
                            clearTimeout(module.performance.timer);
                            module.performance.timer = setTimeout(module.performance.display, 500);
                        },
                        display: function() {
                            var
                                title = settings.name + ':',
                                totalTime = 0
                                ;
                            time = false;
                            clearTimeout(module.performance.timer);
                            $.each(performance, function(index, data) {
                                totalTime += data['Execution Time'];
                            });
                            title += ' ' + totalTime + 'ms';
                            if(moduleSelector) {
                                title += ' \'' + moduleSelector + '\'';
                            }
                            if( (console.group !== undefined || console.table !== undefined) && performance.length > 0) {
                                console.groupCollapsed(title);
                                if(console.table) {
                                    console.table(performance);
                                }
                                else {
                                    $.each(performance, function(index, data) {
                                        console.log(data['Name'] + ': ' + data['Execution Time']+'ms');
                                    });
                                }
                                console.groupEnd();
                            }
                            performance = [];
                        }
                    },
                    invoke: function(query, passedArguments, context) {
                        var
                            object = instance,
                            maxDepth,
                            found,
                            response
                            ;
                        passedArguments = passedArguments || queryArguments;
                        context         = element         || context;
                        if(typeof query == 'string' && object !== undefined) {
                            query    = query.split(/[\. ]/);
                            maxDepth = query.length - 1;
                            $.each(query, function(depth, value) {
                                var camelCaseValue = (depth != maxDepth)
                                        ? value + query[depth + 1].charAt(0).toUpperCase() + query[depth + 1].slice(1)
                                        : query
                                    ;
                                if( $.isPlainObject( object[camelCaseValue] ) && (depth != maxDepth) ) {
                                    object = object[camelCaseValue];
                                }
                                else if( object[camelCaseValue] !== undefined ) {
                                    found = object[camelCaseValue];
                                    return false;
                                }
                                else if( $.isPlainObject( object[value] ) && (depth != maxDepth) ) {
                                    object = object[value];
                                }
                                else if( object[value] !== undefined ) {
                                    found = object[value];
                                    return false;
                                }
                                else {
                                    module.error(error.method, query);
                                    return false;
                                }
                            });
                        }
                        if ( $.isFunction( found ) ) {
                            response = found.apply(context, passedArguments);
                        }
                        else if(found !== undefined) {
                            response = found;
                        }
                        if($.isArray(returnedValue)) {
                            returnedValue.push(response);
                        }
                        else if(returnedValue !== undefined) {
                            returnedValue = [returnedValue, response];
                        }
                        else if(response !== undefined) {
                            returnedValue = response;
                        }
                        return found;
                    }
                };

                if(methodInvoked) {
                    if(instance === undefined) {
                        module.initialize();
                    }
                    module.invoke(query);
                }
                else {
                    if(instance !== undefined) {
                        instance.invoke('destroy');
                    }
                    module.initialize();
                }
            })
        ;

        return (returnedValue !== undefined)
            ? returnedValue
            : this
            ;
    };

    $.api.settings = {

        name              : 'API',
        namespace         : 'api',

        debug             : false,
        verbose           : false,
        performance       : true,

        // object containing all templates endpoints
        api               : {},

        // whether to cache responses
        cache             : true,

        // whether new requests should abort previous requests
        interruptRequests : true,

        // event binding
        on                : 'auto',

        // context for applying state classes
        stateContext      : false,

        // duration for loading state
        loadingDuration   : 0,

        // whether to hide errors after a period of time
        hideError         : 'auto',

        // duration for error state
        errorDuration     : 2000,

        // whether parameters should be encoded with encodeURIComponent
        encodeParameters  : true,

        // API action to use
        action            : false,

        // templated URL to use
        url               : false,

        // base URL to apply to all endpoints
        base              : '',

        // data that will
        urlData           : {},

        // whether to add default data to url data
        defaultData          : true,

        // whether to serialize closest form
        serializeForm        : false,

        // how long to wait before request should occur
        throttle             : 0,

        // whether to throttle first request or only repeated
        throttleFirstRequest : true,

        // standard ajax settings
        method            : 'get',
        data              : {},
        dataType          : 'json',

        // mock response
        mockResponse      : false,
        mockResponseAsync : false,

        // callbacks before request
        beforeSend  : function(settings) { return settings; },
        beforeXHR   : function(xhr) {},
        onRequest   : function(promise, xhr) {},

        // after request
        onResponse  : false, // function(response) { },

        // response was successful, if JSON passed validation
        onSuccess   : function(response, $module) {},

        // request finished without aborting
        onComplete  : function(response, $module) {},

        // failed JSON success test
        onFailure   : function(response, $module) {},

        // server error
        onError     : function(errorMessage, $module) {},

        // request aborted
        onAbort     : function(errorMessage, $module) {},

        successTest : false,

        // errors
        error : {
            beforeSend        : 'The before send function has aborted the request',
            error             : 'There was an error with your request',
            exitConditions    : 'API Request Aborted. Exit conditions met',
            JSONParse         : 'JSON could not be parsed during error handling',
            legacyParameters  : 'You are using legacy API success callback names',
            method            : 'The method you called is not defined',
            missingAction     : 'API action used but no url was defined',
            missingSerialize  : 'jquery-serialize-object is required to add form data to an existing data object',
            missingURL        : 'No URL specified for api event',
            noReturnedValue   : 'The beforeSend callback must return a settings object, beforeSend ignored.',
            noStorage         : 'Caching responses locally requires session storage',
            parseError        : 'There was an error parsing your request',
            requiredParameter : 'Missing a required URL parameter: ',
            statusMessage     : 'Server gave an error: ',
            timeout           : 'Your request timed out'
        },

        regExp  : {
            required : /\{\$*[A-z0-9]+\}/g,
            optional : /\{\/\$*[A-z0-9]+\}/g,
        },

        className: {
            loading : 'loading',
            error   : 'error'
        },

        selector: {
            disabled : '.disabled',
            form      : 'form'
        },

        metadata: {
            action  : 'action',
            url     : 'url'
        }
    };



})( jQuery, window, document );

/*!
 * # Semantic UI 2.1.6 - State
 * http://github.com/semantic-org/semantic-ui/
 *
 *
 * Copyright 2015 Contributors
 * Released under the MIT license
 * http://opensource.org/licenses/MIT
 *
 */

;(function ( $, window, document, undefined ) {

    "use strict";

    $.fn.state = function(parameters) {
        var
            $allModules     = $(this),

            moduleSelector  = $allModules.selector || '',

            hasTouch        = ('ontouchstart' in document.documentElement),
            time            = new Date().getTime(),
            performance     = [],

            query           = arguments[0],
            methodInvoked   = (typeof query == 'string'),
            queryArguments  = [].slice.call(arguments, 1),

            returnedValue
            ;
        $allModules
            .each(function() {
                var
                    settings          = ( $.isPlainObject(parameters) )
                        ? $.extend(true, {}, $.fn.state.settings, parameters)
                        : $.extend({}, $.fn.state.settings),

                    error           = settings.error,
                    metadata        = settings.metadata,
                    className       = settings.className,
                    namespace       = settings.namespace,
                    states          = settings.states,
                    text            = settings.text,

                    eventNamespace  = '.' + namespace,
                    moduleNamespace = namespace + '-module',

                    $module         = $(this),

                    element         = this,
                    instance        = $module.data(moduleNamespace),

                    module
                    ;
                module = {

                    initialize: function() {
                        module.verbose('Initializing module');

                        // allow module to guess desired state based on element
                        if(settings.automatic) {
                            module.add.defaults();
                        }

                        // bind events with delegated events
                        if(settings.context && moduleSelector !== '') {
                            $(settings.context)
                                .on(moduleSelector, 'mouseenter' + eventNamespace, module.change.text)
                                .on(moduleSelector, 'mouseleave' + eventNamespace, module.reset.text)
                                .on(moduleSelector, 'click'      + eventNamespace, module.toggle.state)
                            ;
                        }
                        else {
                            $module
                                .on('mouseenter' + eventNamespace, module.change.text)
                                .on('mouseleave' + eventNamespace, module.reset.text)
                                .on('click'      + eventNamespace, module.toggle.state)
                            ;
                        }
                        module.instantiate();
                    },

                    instantiate: function() {
                        module.verbose('Storing instance of module', module);
                        instance = module;
                        $module
                            .data(moduleNamespace, module)
                        ;
                    },

                    destroy: function() {
                        module.verbose('Destroying previous module', instance);
                        $module
                            .off(eventNamespace)
                            .removeData(moduleNamespace)
                        ;
                    },

                    refresh: function() {
                        module.verbose('Refreshing selector cache');
                        $module = $(element);
                    },

                    add: {
                        defaults: function() {
                            var
                                userStates = parameters && $.isPlainObject(parameters.states)
                                    ? parameters.states
                                    : {}
                                ;
                            $.each(settings.defaults, function(type, typeStates) {
                                if( module.is[type] !== undefined && module.is[type]() ) {
                                    module.verbose('Adding default states', type, element);
                                    $.extend(settings.states, typeStates, userStates);
                                }
                            });
                        }
                    },

                    is: {

                        active: function() {
                            return $module.hasClass(className.active);
                        },
                        loading: function() {
                            return $module.hasClass(className.loading);
                        },
                        inactive: function() {
                            return !( $module.hasClass(className.active) );
                        },
                        state: function(state) {
                            if(className[state] === undefined) {
                                return false;
                            }
                            return $module.hasClass( className[state] );
                        },

                        enabled: function() {
                            return !( $module.is(settings.filter.active) );
                        },
                        disabled: function() {
                            return ( $module.is(settings.filter.active) );
                        },
                        textEnabled: function() {
                            return !( $module.is(settings.filter.text) );
                        },

                        // definitions for automatic type detection
                        button: function() {
                            return $module.is('.button:not(a, .submit)');
                        },
                        input: function() {
                            return $module.is('input');
                        },
                        progress: function() {
                            return $module.is('.ui.progress');
                        }
                    },

                    allow: function(state) {
                        module.debug('Now allowing state', state);
                        states[state] = true;
                    },
                    disallow: function(state) {
                        module.debug('No longer allowing', state);
                        states[state] = false;
                    },

                    allows: function(state) {
                        return states[state] || false;
                    },

                    enable: function() {
                        $module.removeClass(className.disabled);
                    },

                    disable: function() {
                        $module.addClass(className.disabled);
                    },

                    setState: function(state) {
                        if(module.allows(state)) {
                            $module.addClass( className[state] );
                        }
                    },

                    removeState: function(state) {
                        if(module.allows(state)) {
                            $module.removeClass( className[state] );
                        }
                    },

                    toggle: {
                        state: function() {
                            var
                                apiRequest,
                                requestCancelled
                                ;
                            if( module.allows('active') && module.is.enabled() ) {
                                module.refresh();
                                if($.fn.api !== undefined) {
                                    apiRequest       = $module.api('get request');
                                    requestCancelled = $module.api('was cancelled');
                                    if( requestCancelled ) {
                                        module.debug('API Request cancelled by beforesend');
                                        settings.activateTest   = function(){ return false; };
                                        settings.deactivateTest = function(){ return false; };
                                    }
                                    else if(apiRequest) {
                                        module.listenTo(apiRequest);
                                        return;
                                    }
                                }
                                module.change.state();
                            }
                        }
                    },

                    listenTo: function(apiRequest) {
                        module.debug('API request detected, waiting for state signal', apiRequest);
                        if(apiRequest) {
                            if(text.loading) {
                                module.update.text(text.loading);
                            }
                            $.when(apiRequest)
                                .then(function() {
                                    if(apiRequest.state() == 'resolved') {
                                        module.debug('API request succeeded');
                                        settings.activateTest   = function(){ return true; };
                                        settings.deactivateTest = function(){ return true; };
                                    }
                                    else {
                                        module.debug('API request failed');
                                        settings.activateTest   = function(){ return false; };
                                        settings.deactivateTest = function(){ return false; };
                                    }
                                    module.change.state();
                                })
                            ;
                        }
                    },

                    // checks whether active/inactive state can be given
                    change: {

                        state: function() {
                            module.debug('Determining state change direction');
                            // inactive to active change
                            if( module.is.inactive() ) {
                                module.activate();
                            }
                            else {
                                module.deactivate();
                            }
                            if(settings.sync) {
                                module.sync();
                            }
                            settings.onChange.call(element);
                        },

                        text: function() {
                            if( module.is.textEnabled() ) {
                                if(module.is.disabled() ) {
                                    module.verbose('Changing text to disabled text', text.hover);
                                    module.update.text(text.disabled);
                                }
                                else if( module.is.active() ) {
                                    if(text.hover) {
                                        module.verbose('Changing text to hover text', text.hover);
                                        module.update.text(text.hover);
                                    }
                                    else if(text.deactivate) {
                                        module.verbose('Changing text to deactivating text', text.deactivate);
                                        module.update.text(text.deactivate);
                                    }
                                }
                                else {
                                    if(text.hover) {
                                        module.verbose('Changing text to hover text', text.hover);
                                        module.update.text(text.hover);
                                    }
                                    else if(text.activate){
                                        module.verbose('Changing text to activating text', text.activate);
                                        module.update.text(text.activate);
                                    }
                                }
                            }
                        }

                    },

                    activate: function() {
                        if( settings.activateTest.call(element) ) {
                            module.debug('Setting state to active');
                            $module
                                .addClass(className.active)
                            ;
                            module.update.text(text.active);
                            settings.onActivate.call(element);
                        }
                    },

                    deactivate: function() {
                        if( settings.deactivateTest.call(element) ) {
                            module.debug('Setting state to inactive');
                            $module
                                .removeClass(className.active)
                            ;
                            module.update.text(text.inactive);
                            settings.onDeactivate.call(element);
                        }
                    },

                    sync: function() {
                        module.verbose('Syncing other buttons to current state');
                        if( module.is.active() ) {
                            $allModules
                                .not($module)
                                .state('activate');
                        }
                        else {
                            $allModules
                                .not($module)
                                .state('deactivate')
                            ;
                        }
                    },

                    get: {
                        text: function() {
                            return (settings.selector.text)
                                ? $module.find(settings.selector.text).text()
                                : $module.html()
                                ;
                        },
                        textFor: function(state) {
                            return text[state] || false;
                        }
                    },

                    flash: {
                        text: function(text, duration, callback) {
                            var
                                previousText = module.get.text()
                                ;
                            module.debug('Flashing text message', text, duration);
                            text     = text     || settings.text.flash;
                            duration = duration || settings.flashDuration;
                            callback = callback || function() {};
                            module.update.text(text);
                            setTimeout(function(){
                                module.update.text(previousText);
                                callback.call(element);
                            }, duration);
                        }
                    },

                    reset: {
                        // on mouseout sets text to previous value
                        text: function() {
                            var
                                activeText   = text.active   || $module.data(metadata.storedText),
                                inactiveText = text.inactive || $module.data(metadata.storedText)
                                ;
                            if( module.is.textEnabled() ) {
                                if( module.is.active() && activeText) {
                                    module.verbose('Resetting active text', activeText);
                                    module.update.text(activeText);
                                }
                                else if(inactiveText) {
                                    module.verbose('Resetting inactive text', activeText);
                                    module.update.text(inactiveText);
                                }
                            }
                        }
                    },

                    update: {
                        text: function(text) {
                            var
                                currentText = module.get.text()
                                ;
                            if(text && text !== currentText) {
                                module.debug('Updating text', text);
                                if(settings.selector.text) {
                                    $module
                                        .data(metadata.storedText, text)
                                        .find(settings.selector.text)
                                        .text(text)
                                    ;
                                }
                                else {
                                    $module
                                        .data(metadata.storedText, text)
                                        .html(text)
                                    ;
                                }
                            }
                            else {
                                module.debug('Text is already set, ignoring update', text);
                            }
                        }
                    },

                    setting: function(name, value) {
                        module.debug('Changing setting', name, value);
                        if( $.isPlainObject(name) ) {
                            $.extend(true, settings, name);
                        }
                        else if(value !== undefined) {
                            settings[name] = value;
                        }
                        else {
                            return settings[name];
                        }
                    },
                    internal: function(name, value) {
                        if( $.isPlainObject(name) ) {
                            $.extend(true, module, name);
                        }
                        else if(value !== undefined) {
                            module[name] = value;
                        }
                        else {
                            return module[name];
                        }
                    },
                    debug: function() {
                        if(settings.debug) {
                            if(settings.performance) {
                                module.performance.log(arguments);
                            }
                            else {
                                module.debug = Function.prototype.bind.call(console.info, console, settings.name + ':');
                                module.debug.apply(console, arguments);
                            }
                        }
                    },
                    verbose: function() {
                        if(settings.verbose && settings.debug) {
                            if(settings.performance) {
                                module.performance.log(arguments);
                            }
                            else {
                                module.verbose = Function.prototype.bind.call(console.info, console, settings.name + ':');
                                module.verbose.apply(console, arguments);
                            }
                        }
                    },
                    error: function() {
                        module.error = Function.prototype.bind.call(console.error, console, settings.name + ':');
                        module.error.apply(console, arguments);
                    },
                    performance: {
                        log: function(message) {
                            var
                                currentTime,
                                executionTime,
                                previousTime
                                ;
                            if(settings.performance) {
                                currentTime   = new Date().getTime();
                                previousTime  = time || currentTime;
                                executionTime = currentTime - previousTime;
                                time          = currentTime;
                                performance.push({
                                    'Name'           : message[0],
                                    'Arguments'      : [].slice.call(message, 1) || '',
                                    'Element'        : element,
                                    'Execution Time' : executionTime
                                });
                            }
                            clearTimeout(module.performance.timer);
                            module.performance.timer = setTimeout(module.performance.display, 500);
                        },
                        display: function() {
                            var
                                title = settings.name + ':',
                                totalTime = 0
                                ;
                            time = false;
                            clearTimeout(module.performance.timer);
                            $.each(performance, function(index, data) {
                                totalTime += data['Execution Time'];
                            });
                            title += ' ' + totalTime + 'ms';
                            if(moduleSelector) {
                                title += ' \'' + moduleSelector + '\'';
                            }
                            if( (console.group !== undefined || console.table !== undefined) && performance.length > 0) {
                                console.groupCollapsed(title);
                                if(console.table) {
                                    console.table(performance);
                                }
                                else {
                                    $.each(performance, function(index, data) {
                                        console.log(data['Name'] + ': ' + data['Execution Time']+'ms');
                                    });
                                }
                                console.groupEnd();
                            }
                            performance = [];
                        }
                    },
                    invoke: function(query, passedArguments, context) {
                        var
                            object = instance,
                            maxDepth,
                            found,
                            response
                            ;
                        passedArguments = passedArguments || queryArguments;
                        context         = element         || context;
                        if(typeof query == 'string' && object !== undefined) {
                            query    = query.split(/[\. ]/);
                            maxDepth = query.length - 1;
                            $.each(query, function(depth, value) {
                                var camelCaseValue = (depth != maxDepth)
                                        ? value + query[depth + 1].charAt(0).toUpperCase() + query[depth + 1].slice(1)
                                        : query
                                    ;
                                if( $.isPlainObject( object[camelCaseValue] ) && (depth != maxDepth) ) {
                                    object = object[camelCaseValue];
                                }
                                else if( object[camelCaseValue] !== undefined ) {
                                    found = object[camelCaseValue];
                                    return false;
                                }
                                else if( $.isPlainObject( object[value] ) && (depth != maxDepth) ) {
                                    object = object[value];
                                }
                                else if( object[value] !== undefined ) {
                                    found = object[value];
                                    return false;
                                }
                                else {
                                    module.error(error.method, query);
                                    return false;
                                }
                            });
                        }
                        if ( $.isFunction( found ) ) {
                            response = found.apply(context, passedArguments);
                        }
                        else if(found !== undefined) {
                            response = found;
                        }
                        if($.isArray(returnedValue)) {
                            returnedValue.push(response);
                        }
                        else if(returnedValue !== undefined) {
                            returnedValue = [returnedValue, response];
                        }
                        else if(response !== undefined) {
                            returnedValue = response;
                        }
                        return found;
                    }
                };

                if(methodInvoked) {
                    if(instance === undefined) {
                        module.initialize();
                    }
                    module.invoke(query);
                }
                else {
                    if(instance !== undefined) {
                        instance.invoke('destroy');
                    }
                    module.initialize();
                }
            })
        ;

        return (returnedValue !== undefined)
            ? returnedValue
            : this
            ;
    };

    $.fn.state.settings = {

        // module info
        name           : 'State',

        // debug output
        debug          : false,

        // verbose debug output
        verbose        : false,

        // namespace for events
        namespace      : 'state',

        // debug data includes performance
        performance    : true,

        // callback occurs on state change
        onActivate     : function() {},
        onDeactivate   : function() {},
        onChange       : function() {},

        // state test functions
        activateTest   : function() { return true; },
        deactivateTest : function() { return true; },

        // whether to automatically map default states
        automatic      : true,

        // activate / deactivate changes all elements instantiated at same time
        sync           : false,

        // default flash text duration, used for temporarily changing text of an element
        flashDuration  : 1000,

        // selector filter
        filter     : {
            text   : '.loading, .disabled',
            active : '.disabled'
        },

        context    : false,

        // error
        error: {
            beforeSend : 'The before send function has cancelled state change',
            method     : 'The method you called is not defined.'
        },

        // metadata
        metadata: {
            promise    : 'promise',
            storedText : 'stored-text'
        },

        // change class on state
        className: {
            active   : 'active',
            disabled : 'disabled',
            error    : 'error',
            loading  : 'loading',
            success  : 'success',
            warning  : 'warning'
        },

        selector: {
            // selector for text node
            text: false
        },

        defaults : {
            input: {
                disabled : true,
                loading  : true,
                active   : true
            },
            button: {
                disabled : true,
                loading  : true,
                active   : true,
            },
            progress: {
                active   : true,
                success  : true,
                warning  : true,
                error    : true
            }
        },

        states     : {
            active   : true,
            disabled : true,
            error    : true,
            loading  : true,
            success  : true,
            warning  : true
        },

        text     : {
            disabled   : false,
            flash      : false,
            hover      : false,
            active     : false,
            inactive   : false,
            activate   : false,
            deactivate : false
        }

    };



})( jQuery, window, document );

/*!
 * # Semantic UI 2.1.6 - Visibility
 * http://github.com/semantic-org/semantic-ui/
 *
 *
 * Copyright 2015 Contributors
 * Released under the MIT license
 * http://opensource.org/licenses/MIT
 *
 */

;(function ( $, window, document, undefined ) {

    "use strict";

    $.fn.visibility = function(parameters) {
        var
            $allModules    = $(this),
            moduleSelector = $allModules.selector || '',

            time           = new Date().getTime(),
            performance    = [],

            query          = arguments[0],
            methodInvoked  = (typeof query == 'string'),
            queryArguments = [].slice.call(arguments, 1),
            returnedValue
            ;

        $allModules
            .each(function() {
                var
                    settings        = ( $.isPlainObject(parameters) )
                        ? $.extend(true, {}, $.fn.visibility.settings, parameters)
                        : $.extend({}, $.fn.visibility.settings),

                    className       = settings.className,
                    namespace       = settings.namespace,
                    error           = settings.error,
                    metadata        = settings.metadata,

                    eventNamespace  = '.' + namespace,
                    moduleNamespace = 'module-' + namespace,

                    $window         = $(window),

                    $module         = $(this),
                    $context        = $(settings.context),

                    $placeholder,

                    selector        = $module.selector || '',
                    instance        = $module.data(moduleNamespace),

                    requestAnimationFrame = window.requestAnimationFrame
                        || window.mozRequestAnimationFrame
                        || window.webkitRequestAnimationFrame
                        || window.msRequestAnimationFrame
                        || function(callback) { setTimeout(callback, 0); },

                    element         = this,
                    disabled        = false,

                    observer,
                    module
                    ;

                module = {

                    initialize: function() {
                        module.debug('Initializing', settings);

                        module.setup.cache();

                        if( module.should.trackChanges() ) {

                            if(settings.type == 'image') {
                                module.setup.image();
                            }
                            if(settings.type == 'fixed') {
                                module.setup.fixed();
                            }

                            if(settings.observeChanges) {
                                module.observeChanges();
                            }
                            module.bind.events();
                        }

                        module.save.position();
                        if( !module.is.visible() ) {
                            module.error(error.visible, $module);
                        }

                        if(settings.initialCheck) {
                            module.checkVisibility();
                        }
                        module.instantiate();
                    },

                    instantiate: function() {
                        module.debug('Storing instance', module);
                        $module
                            .data(moduleNamespace, module)
                        ;
                        instance = module;
                    },

                    destroy: function() {
                        module.verbose('Destroying previous module');
                        if(observer) {
                            observer.disconnect();
                        }
                        $window
                            .off('load'   + eventNamespace, module.event.load)
                            .off('resize' + eventNamespace, module.event.resize)
                        ;
                        $context
                            .off('scrollchange' + eventNamespace, module.event.scrollchange)
                        ;
                        $module
                            .off(eventNamespace)
                            .removeData(moduleNamespace)
                        ;
                    },

                    observeChanges: function() {
                        if('MutationObserver' in window) {
                            observer = new MutationObserver(function(mutations) {
                                module.verbose('DOM tree modified, updating visibility calculations');
                                module.timer = setTimeout(function() {
                                    module.verbose('DOM tree modified, updating sticky menu');
                                    module.refresh();
                                }, 100);
                            });
                            observer.observe(element, {
                                childList : true,
                                subtree   : true
                            });
                            module.debug('Setting up mutation observer', observer);
                        }
                    },

                    bind: {
                        events: function() {
                            module.verbose('Binding visibility events to scroll and resize');
                            if(settings.refreshOnLoad) {
                                $window
                                    .on('load'   + eventNamespace, module.event.load)
                                ;
                            }
                            $window
                                .on('resize' + eventNamespace, module.event.resize)
                            ;
                            // pub/sub pattern
                            $context
                                .off('scroll'      + eventNamespace)
                                .on('scroll'       + eventNamespace, module.event.scroll)
                                .on('scrollchange' + eventNamespace, module.event.scrollchange)
                            ;
                        }
                    },

                    event: {
                        resize: function() {
                            module.debug('Window resized');
                            if(settings.refreshOnResize) {
                                requestAnimationFrame(module.refresh);
                            }
                        },
                        load: function() {
                            module.debug('Page finished loading');
                            requestAnimationFrame(module.refresh);
                        },
                        // publishes scrollchange event on one scroll
                        scroll: function() {
                            if(settings.throttle) {
                                clearTimeout(module.timer);
                                module.timer = setTimeout(function() {
                                    $context.triggerHandler('scrollchange' + eventNamespace, [ $context.scrollTop() ]);
                                }, settings.throttle);
                            }
                            else {
                                requestAnimationFrame(function() {
                                    $context.triggerHandler('scrollchange' + eventNamespace, [ $context.scrollTop() ]);
                                });
                            }
                        },
                        // subscribes to scrollchange
                        scrollchange: function(event, scrollPosition) {
                            module.checkVisibility(scrollPosition);
                        },
                    },

                    precache: function(images, callback) {
                        if (!(images instanceof Array)) {
                            images = [images];
                        }
                        var
                            imagesLength  = images.length,
                            loadedCounter = 0,
                            cache         = [],
                            cacheImage    = document.createElement('img'),
                            handleLoad    = function() {
                                loadedCounter++;
                                if (loadedCounter >= images.length) {
                                    if ($.isFunction(callback)) {
                                        callback();
                                    }
                                }
                            }
                            ;
                        while (imagesLength--) {
                            cacheImage         = document.createElement('img');
                            cacheImage.onload  = handleLoad;
                            cacheImage.onerror = handleLoad;
                            cacheImage.src     = images[imagesLength];
                            cache.push(cacheImage);
                        }
                    },

                    enableCallbacks: function() {
                        module.debug('Allowing callbacks to occur');
                        disabled = false;
                    },

                    disableCallbacks: function() {
                        module.debug('Disabling all callbacks temporarily');
                        disabled = true;
                    },

                    should: {
                        trackChanges: function() {
                            if(methodInvoked) {
                                module.debug('One time query, no need to bind events');
                                return false;
                            }
                            module.debug('Callbacks being attached');
                            return true;
                        }
                    },

                    setup: {
                        cache: function() {
                            module.cache = {
                                occurred : {},
                                screen   : {},
                                element  : {},
                            };
                        },
                        image: function() {
                            var
                                src = $module.data(metadata.src)
                                ;
                            if(src) {
                                module.verbose('Lazy loading image', src);
                                settings.once           = true;
                                settings.observeChanges = false;

                                // show when top visible
                                settings.onOnScreen = function() {
                                    module.debug('Image on screen', element);
                                    module.precache(src, function() {
                                        module.set.image(src);
                                    });
                                };
                            }
                        },
                        fixed: function() {
                            module.debug('Setting up fixed');
                            settings.once           = false;
                            settings.observeChanges = false;
                            settings.initialCheck   = true;
                            settings.refreshOnLoad  = true;
                            if(!parameters.transition) {
                                settings.transition = false;
                            }
                            module.create.placeholder();
                            module.debug('Added placeholder', $placeholder);
                            settings.onTopPassed = function() {
                                module.debug('Element passed, adding fixed position', $module);
                                module.show.placeholder();
                                module.set.fixed();
                                if(settings.transition) {
                                    if($.fn.transition !== undefined) {
                                        $module.transition(settings.transition, settings.duration);
                                    }
                                }
                            };
                            settings.onTopPassedReverse = function() {
                                module.debug('Element returned to position, removing fixed', $module);
                                module.hide.placeholder();
                                module.remove.fixed();
                            };
                        }
                    },

                    create: {
                        placeholder: function() {
                            module.verbose('Creating fixed position placeholder');
                            $placeholder = $module
                                .clone(false)
                                .css('display', 'none')
                                .addClass(className.placeholder)
                                .insertAfter($module)
                            ;
                        }
                    },

                    show: {
                        placeholder: function() {
                            module.verbose('Showing placeholder');
                            $placeholder
                                .css('display', 'block')
                                .css('visibility', 'hidden')
                            ;
                        }
                    },
                    hide: {
                        placeholder: function() {
                            module.verbose('Hiding placeholder');
                            $placeholder
                                .css('display', 'none')
                                .css('visibility', '')
                            ;
                        }
                    },

                    set: {
                        fixed: function() {
                            module.verbose('Setting element to fixed position');
                            $module
                                .addClass(className.fixed)
                                .css({
                                    position : 'fixed',
                                    top      : settings.offset + 'px',
                                    left     : 'auto',
                                    zIndex   : '1'
                                })
                            ;
                        },
                        image: function(src) {
                            $module
                                .attr('src', src)
                            ;
                            if(settings.transition) {
                                if( $.fn.transition !== undefined ) {
                                    $module.transition(settings.transition, settings.duration);
                                }
                                else {
                                    $module.fadeIn(settings.duration);
                                }
                            }
                            else {
                                $module.show();
                            }
                        }
                    },

                    is: {
                        onScreen: function() {
                            var
                                calculations   = module.get.elementCalculations()
                                ;
                            return calculations.onScreen;
                        },
                        offScreen: function() {
                            var
                                calculations   = module.get.elementCalculations()
                                ;
                            return calculations.offScreen;
                        },
                        visible: function() {
                            if(module.cache && module.cache.element) {
                                return !(module.cache.element.width === 0 && module.cache.element.offset.top === 0);
                            }
                            return false;
                        }
                    },

                    refresh: function() {
                        module.debug('Refreshing constants (width/height)');
                        if(settings.type == 'fixed') {
                            module.remove.fixed();
                            module.remove.occurred();
                        }
                        module.reset();
                        module.save.position();
                        if(settings.checkOnRefresh) {
                            module.checkVisibility();
                        }
                        settings.onRefresh.call(element);
                    },

                    reset: function() {
                        module.verbose('Reseting all cached values');
                        if( $.isPlainObject(module.cache) ) {
                            module.cache.screen = {};
                            module.cache.element = {};
                        }
                    },

                    checkVisibility: function(scroll) {
                        module.verbose('Checking visibility of element', module.cache.element);

                        if( !disabled && module.is.visible() ) {

                            // save scroll position
                            module.save.scroll(scroll);

                            // update calculations derived from scroll
                            module.save.calculations();

                            // percentage
                            module.passed();

                            // reverse (must be first)
                            module.passingReverse();
                            module.topVisibleReverse();
                            module.bottomVisibleReverse();
                            module.topPassedReverse();
                            module.bottomPassedReverse();

                            // one time
                            module.onScreen();
                            module.offScreen();
                            module.passing();
                            module.topVisible();
                            module.bottomVisible();
                            module.topPassed();
                            module.bottomPassed();

                            // on update callback
                            if(settings.onUpdate) {
                                settings.onUpdate.call(element, module.get.elementCalculations());
                            }
                        }
                    },

                    passed: function(amount, newCallback) {
                        var
                            calculations   = module.get.elementCalculations(),
                            amountInPixels
                            ;
                        // assign callback
                        if(amount && newCallback) {
                            settings.onPassed[amount] = newCallback;
                        }
                        else if(amount !== undefined) {
                            return (module.get.pixelsPassed(amount) > calculations.pixelsPassed);
                        }
                        else if(calculations.passing) {
                            $.each(settings.onPassed, function(amount, callback) {
                                if(calculations.bottomVisible || calculations.pixelsPassed > module.get.pixelsPassed(amount)) {
                                    module.execute(callback, amount);
                                }
                                else if(!settings.once) {
                                    module.remove.occurred(callback);
                                }
                            });
                        }
                    },

                    onScreen: function(newCallback) {
                        var
                            calculations = module.get.elementCalculations(),
                            callback     = newCallback || settings.onOnScreen,
                            callbackName = 'onScreen'
                            ;
                        if(newCallback) {
                            module.debug('Adding callback for onScreen', newCallback);
                            settings.onOnScreen = newCallback;
                        }
                        if(calculations.onScreen) {
                            module.execute(callback, callbackName);
                        }
                        else if(!settings.once) {
                            module.remove.occurred(callbackName);
                        }
                        if(newCallback !== undefined) {
                            return calculations.onOnScreen;
                        }
                    },

                    offScreen: function(newCallback) {
                        var
                            calculations = module.get.elementCalculations(),
                            callback     = newCallback || settings.onOffScreen,
                            callbackName = 'offScreen'
                            ;
                        if(newCallback) {
                            module.debug('Adding callback for offScreen', newCallback);
                            settings.onOffScreen = newCallback;
                        }
                        if(calculations.offScreen) {
                            module.execute(callback, callbackName);
                        }
                        else if(!settings.once) {
                            module.remove.occurred(callbackName);
                        }
                        if(newCallback !== undefined) {
                            return calculations.onOffScreen;
                        }
                    },

                    passing: function(newCallback) {
                        var
                            calculations = module.get.elementCalculations(),
                            callback     = newCallback || settings.onPassing,
                            callbackName = 'passing'
                            ;
                        if(newCallback) {
                            module.debug('Adding callback for passing', newCallback);
                            settings.onPassing = newCallback;
                        }
                        if(calculations.passing) {
                            module.execute(callback, callbackName);
                        }
                        else if(!settings.once) {
                            module.remove.occurred(callbackName);
                        }
                        if(newCallback !== undefined) {
                            return calculations.passing;
                        }
                    },


                    topVisible: function(newCallback) {
                        var
                            calculations = module.get.elementCalculations(),
                            callback     = newCallback || settings.onTopVisible,
                            callbackName = 'topVisible'
                            ;
                        if(newCallback) {
                            module.debug('Adding callback for top visible', newCallback);
                            settings.onTopVisible = newCallback;
                        }
                        if(calculations.topVisible) {
                            module.execute(callback, callbackName);
                        }
                        else if(!settings.once) {
                            module.remove.occurred(callbackName);
                        }
                        if(newCallback === undefined) {
                            return calculations.topVisible;
                        }
                    },

                    bottomVisible: function(newCallback) {
                        var
                            calculations = module.get.elementCalculations(),
                            callback     = newCallback || settings.onBottomVisible,
                            callbackName = 'bottomVisible'
                            ;
                        if(newCallback) {
                            module.debug('Adding callback for bottom visible', newCallback);
                            settings.onBottomVisible = newCallback;
                        }
                        if(calculations.bottomVisible) {
                            module.execute(callback, callbackName);
                        }
                        else if(!settings.once) {
                            module.remove.occurred(callbackName);
                        }
                        if(newCallback === undefined) {
                            return calculations.bottomVisible;
                        }
                    },

                    topPassed: function(newCallback) {
                        var
                            calculations = module.get.elementCalculations(),
                            callback     = newCallback || settings.onTopPassed,
                            callbackName = 'topPassed'
                            ;
                        if(newCallback) {
                            module.debug('Adding callback for top passed', newCallback);
                            settings.onTopPassed = newCallback;
                        }
                        if(calculations.topPassed) {
                            module.execute(callback, callbackName);
                        }
                        else if(!settings.once) {
                            module.remove.occurred(callbackName);
                        }
                        if(newCallback === undefined) {
                            return calculations.topPassed;
                        }
                    },

                    bottomPassed: function(newCallback) {
                        var
                            calculations = module.get.elementCalculations(),
                            callback     = newCallback || settings.onBottomPassed,
                            callbackName = 'bottomPassed'
                            ;
                        if(newCallback) {
                            module.debug('Adding callback for bottom passed', newCallback);
                            settings.onBottomPassed = newCallback;
                        }
                        if(calculations.bottomPassed) {
                            module.execute(callback, callbackName);
                        }
                        else if(!settings.once) {
                            module.remove.occurred(callbackName);
                        }
                        if(newCallback === undefined) {
                            return calculations.bottomPassed;
                        }
                    },

                    passingReverse: function(newCallback) {
                        var
                            calculations = module.get.elementCalculations(),
                            callback     = newCallback || settings.onPassingReverse,
                            callbackName = 'passingReverse'
                            ;
                        if(newCallback) {
                            module.debug('Adding callback for passing reverse', newCallback);
                            settings.onPassingReverse = newCallback;
                        }
                        if(!calculations.passing) {
                            if(module.get.occurred('passing')) {
                                module.execute(callback, callbackName);
                            }
                        }
                        else if(!settings.once) {
                            module.remove.occurred(callbackName);
                        }
                        if(newCallback !== undefined) {
                            return !calculations.passing;
                        }
                    },


                    topVisibleReverse: function(newCallback) {
                        var
                            calculations = module.get.elementCalculations(),
                            callback     = newCallback || settings.onTopVisibleReverse,
                            callbackName = 'topVisibleReverse'
                            ;
                        if(newCallback) {
                            module.debug('Adding callback for top visible reverse', newCallback);
                            settings.onTopVisibleReverse = newCallback;
                        }
                        if(!calculations.topVisible) {
                            if(module.get.occurred('topVisible')) {
                                module.execute(callback, callbackName);
                            }
                        }
                        else if(!settings.once) {
                            module.remove.occurred(callbackName);
                        }
                        if(newCallback === undefined) {
                            return !calculations.topVisible;
                        }
                    },

                    bottomVisibleReverse: function(newCallback) {
                        var
                            calculations = module.get.elementCalculations(),
                            callback     = newCallback || settings.onBottomVisibleReverse,
                            callbackName = 'bottomVisibleReverse'
                            ;
                        if(newCallback) {
                            module.debug('Adding callback for bottom visible reverse', newCallback);
                            settings.onBottomVisibleReverse = newCallback;
                        }
                        if(!calculations.bottomVisible) {
                            if(module.get.occurred('bottomVisible')) {
                                module.execute(callback, callbackName);
                            }
                        }
                        else if(!settings.once) {
                            module.remove.occurred(callbackName);
                        }
                        if(newCallback === undefined) {
                            return !calculations.bottomVisible;
                        }
                    },

                    topPassedReverse: function(newCallback) {
                        var
                            calculations = module.get.elementCalculations(),
                            callback     = newCallback || settings.onTopPassedReverse,
                            callbackName = 'topPassedReverse'
                            ;
                        if(newCallback) {
                            module.debug('Adding callback for top passed reverse', newCallback);
                            settings.onTopPassedReverse = newCallback;
                        }
                        if(!calculations.topPassed) {
                            if(module.get.occurred('topPassed')) {
                                module.execute(callback, callbackName);
                            }
                        }
                        else if(!settings.once) {
                            module.remove.occurred(callbackName);
                        }
                        if(newCallback === undefined) {
                            return !calculations.onTopPassed;
                        }
                    },

                    bottomPassedReverse: function(newCallback) {
                        var
                            calculations = module.get.elementCalculations(),
                            callback     = newCallback || settings.onBottomPassedReverse,
                            callbackName = 'bottomPassedReverse'
                            ;
                        if(newCallback) {
                            module.debug('Adding callback for bottom passed reverse', newCallback);
                            settings.onBottomPassedReverse = newCallback;
                        }
                        if(!calculations.bottomPassed) {
                            if(module.get.occurred('bottomPassed')) {
                                module.execute(callback, callbackName);
                            }
                        }
                        else if(!settings.once) {
                            module.remove.occurred(callbackName);
                        }
                        if(newCallback === undefined) {
                            return !calculations.bottomPassed;
                        }
                    },

                    execute: function(callback, callbackName) {
                        var
                            calculations = module.get.elementCalculations(),
                            screen       = module.get.screenCalculations()
                            ;
                        callback = callback || false;
                        if(callback) {
                            if(settings.continuous) {
                                module.debug('Callback being called continuously', callbackName, calculations);
                                callback.call(element, calculations, screen);
                            }
                            else if(!module.get.occurred(callbackName)) {
                                module.debug('Conditions met', callbackName, calculations);
                                callback.call(element, calculations, screen);
                            }
                        }
                        module.save.occurred(callbackName);
                    },

                    remove: {
                        fixed: function() {
                            module.debug('Removing fixed position');
                            $module
                                .removeClass(className.fixed)
                                .css({
                                    position : '',
                                    top      : '',
                                    left     : '',
                                    zIndex   : ''
                                })
                            ;
                        },
                        occurred: function(callback) {
                            if(callback) {
                                var
                                    occurred = module.cache.occurred
                                    ;
                                if(occurred[callback] !== undefined && occurred[callback] === true) {
                                    module.debug('Callback can now be called again', callback);
                                    module.cache.occurred[callback] = false;
                                }
                            }
                            else {
                                module.cache.occurred = {};
                            }
                        }
                    },

                    save: {
                        calculations: function() {
                            module.verbose('Saving all calculations necessary to determine positioning');
                            module.save.direction();
                            module.save.screenCalculations();
                            module.save.elementCalculations();
                        },
                        occurred: function(callback) {
                            if(callback) {
                                if(module.cache.occurred[callback] === undefined || (module.cache.occurred[callback] !== true)) {
                                    module.verbose('Saving callback occurred', callback);
                                    module.cache.occurred[callback] = true;
                                }
                            }
                        },
                        scroll: function(scrollPosition) {
                            scrollPosition      = scrollPosition + settings.offset || $context.scrollTop() + settings.offset;
                            module.cache.scroll = scrollPosition;
                        },
                        direction: function() {
                            var
                                scroll     = module.get.scroll(),
                                lastScroll = module.get.lastScroll(),
                                direction
                                ;
                            if(scroll > lastScroll && lastScroll) {
                                direction = 'down';
                            }
                            else if(scroll < lastScroll && lastScroll) {
                                direction = 'up';
                            }
                            else {
                                direction = 'static';
                            }
                            module.cache.direction = direction;
                            return module.cache.direction;
                        },
                        elementPosition: function() {
                            var
                                element = module.cache.element,
                                screen  = module.get.screenSize()
                                ;
                            module.verbose('Saving element position');
                            // (quicker than $.extend)
                            element.fits          = (element.height < screen.height);
                            element.offset        = $module.offset();
                            element.width         = $module.outerWidth();
                            element.height        = $module.outerHeight();
                            // store
                            module.cache.element = element;
                            return element;
                        },
                        elementCalculations: function() {
                            var
                                screen     = module.get.screenCalculations(),
                                element    = module.get.elementPosition()
                                ;
                            // offset
                            if(settings.includeMargin) {
                                element.margin        = {};
                                element.margin.top    = parseInt($module.css('margin-top'), 10);
                                element.margin.bottom = parseInt($module.css('margin-bottom'), 10);
                                element.top    = element.offset.top - element.margin.top;
                                element.bottom = element.offset.top + element.height + element.margin.bottom;
                            }
                            else {
                                element.top    = element.offset.top;
                                element.bottom = element.offset.top + element.height;
                            }

                            // visibility
                            element.topVisible       = (screen.bottom >= element.top);
                            element.topPassed        = (screen.top >= element.top);
                            element.bottomVisible    = (screen.bottom >= element.bottom);
                            element.bottomPassed     = (screen.top >= element.bottom);
                            element.pixelsPassed     = 0;
                            element.percentagePassed = 0;

                            // meta calculations
                            element.onScreen  = (element.topVisible && !element.bottomPassed);
                            element.passing   = (element.topPassed && !element.bottomPassed);
                            element.offScreen = (!element.onScreen);

                            // passing calculations
                            if(element.passing) {
                                element.pixelsPassed     = (screen.top - element.top);
                                element.percentagePassed = (screen.top - element.top) / element.height;
                            }
                            module.cache.element = element;
                            module.verbose('Updated element calculations', element);
                            return element;
                        },
                        screenCalculations: function() {
                            var
                                scroll = module.get.scroll()
                                ;
                            module.save.direction();
                            module.cache.screen.top    = scroll;
                            module.cache.screen.bottom = scroll + module.cache.screen.height;
                            return module.cache.screen;
                        },
                        screenSize: function() {
                            module.verbose('Saving window position');
                            module.cache.screen = {
                                height: $context.height()
                            };
                        },
                        position: function() {
                            module.save.screenSize();
                            module.save.elementPosition();
                        }
                    },

                    get: {
                        pixelsPassed: function(amount) {
                            var
                                element = module.get.elementCalculations()
                                ;
                            if(amount.search('%') > -1) {
                                return ( element.height * (parseInt(amount, 10) / 100) );
                            }
                            return parseInt(amount, 10);
                        },
                        occurred: function(callback) {
                            return (module.cache.occurred !== undefined)
                                ? module.cache.occurred[callback] || false
                                : false
                                ;
                        },
                        direction: function() {
                            if(module.cache.direction === undefined) {
                                module.save.direction();
                            }
                            return module.cache.direction;
                        },
                        elementPosition: function() {
                            if(module.cache.element === undefined) {
                                module.save.elementPosition();
                            }
                            return module.cache.element;
                        },
                        elementCalculations: function() {
                            if(module.cache.element === undefined) {
                                module.save.elementCalculations();
                            }
                            return module.cache.element;
                        },
                        screenCalculations: function() {
                            if(module.cache.screen === undefined) {
                                module.save.screenCalculations();
                            }
                            return module.cache.screen;
                        },
                        screenSize: function() {
                            if(module.cache.screen === undefined) {
                                module.save.screenSize();
                            }
                            return module.cache.screen;
                        },
                        scroll: function() {
                            if(module.cache.scroll === undefined) {
                                module.save.scroll();
                            }
                            return module.cache.scroll;
                        },
                        lastScroll: function() {
                            if(module.cache.screen === undefined) {
                                module.debug('First scroll event, no last scroll could be found');
                                return false;
                            }
                            return module.cache.screen.top;
                        }
                    },

                    setting: function(name, value) {
                        if( $.isPlainObject(name) ) {
                            $.extend(true, settings, name);
                        }
                        else if(value !== undefined) {
                            settings[name] = value;
                        }
                        else {
                            return settings[name];
                        }
                    },
                    internal: function(name, value) {
                        if( $.isPlainObject(name) ) {
                            $.extend(true, module, name);
                        }
                        else if(value !== undefined) {
                            module[name] = value;
                        }
                        else {
                            return module[name];
                        }
                    },
                    debug: function() {
                        if(settings.debug) {
                            if(settings.performance) {
                                module.performance.log(arguments);
                            }
                            else {
                                module.debug = Function.prototype.bind.call(console.info, console, settings.name + ':');
                                module.debug.apply(console, arguments);
                            }
                        }
                    },
                    verbose: function() {
                        if(settings.verbose && settings.debug) {
                            if(settings.performance) {
                                module.performance.log(arguments);
                            }
                            else {
                                module.verbose = Function.prototype.bind.call(console.info, console, settings.name + ':');
                                module.verbose.apply(console, arguments);
                            }
                        }
                    },
                    error: function() {
                        module.error = Function.prototype.bind.call(console.error, console, settings.name + ':');
                        module.error.apply(console, arguments);
                    },
                    performance: {
                        log: function(message) {
                            var
                                currentTime,
                                executionTime,
                                previousTime
                                ;
                            if(settings.performance) {
                                currentTime   = new Date().getTime();
                                previousTime  = time || currentTime;
                                executionTime = currentTime - previousTime;
                                time          = currentTime;
                                performance.push({
                                    'Name'           : message[0],
                                    'Arguments'      : [].slice.call(message, 1) || '',
                                    'Element'        : element,
                                    'Execution Time' : executionTime
                                });
                            }
                            clearTimeout(module.performance.timer);
                            module.performance.timer = setTimeout(module.performance.display, 500);
                        },
                        display: function() {
                            var
                                title = settings.name + ':',
                                totalTime = 0
                                ;
                            time = false;
                            clearTimeout(module.performance.timer);
                            $.each(performance, function(index, data) {
                                totalTime += data['Execution Time'];
                            });
                            title += ' ' + totalTime + 'ms';
                            if(moduleSelector) {
                                title += ' \'' + moduleSelector + '\'';
                            }
                            if( (console.group !== undefined || console.table !== undefined) && performance.length > 0) {
                                console.groupCollapsed(title);
                                if(console.table) {
                                    console.table(performance);
                                }
                                else {
                                    $.each(performance, function(index, data) {
                                        console.log(data['Name'] + ': ' + data['Execution Time']+'ms');
                                    });
                                }
                                console.groupEnd();
                            }
                            performance = [];
                        }
                    },
                    invoke: function(query, passedArguments, context) {
                        var
                            object = instance,
                            maxDepth,
                            found,
                            response
                            ;
                        passedArguments = passedArguments || queryArguments;
                        context         = element         || context;
                        if(typeof query == 'string' && object !== undefined) {
                            query    = query.split(/[\. ]/);
                            maxDepth = query.length - 1;
                            $.each(query, function(depth, value) {
                                var camelCaseValue = (depth != maxDepth)
                                        ? value + query[depth + 1].charAt(0).toUpperCase() + query[depth + 1].slice(1)
                                        : query
                                    ;
                                if( $.isPlainObject( object[camelCaseValue] ) && (depth != maxDepth) ) {
                                    object = object[camelCaseValue];
                                }
                                else if( object[camelCaseValue] !== undefined ) {
                                    found = object[camelCaseValue];
                                    return false;
                                }
                                else if( $.isPlainObject( object[value] ) && (depth != maxDepth) ) {
                                    object = object[value];
                                }
                                else if( object[value] !== undefined ) {
                                    found = object[value];
                                    return false;
                                }
                                else {
                                    module.error(error.method, query);
                                    return false;
                                }
                            });
                        }
                        if ( $.isFunction( found ) ) {
                            response = found.apply(context, passedArguments);
                        }
                        else if(found !== undefined) {
                            response = found;
                        }
                        if($.isArray(returnedValue)) {
                            returnedValue.push(response);
                        }
                        else if(returnedValue !== undefined) {
                            returnedValue = [returnedValue, response];
                        }
                        else if(response !== undefined) {
                            returnedValue = response;
                        }
                        return found;
                    }
                };

                if(methodInvoked) {
                    if(instance === undefined) {
                        module.initialize();
                    }
                    instance.save.scroll();
                    instance.save.calculations();
                    module.invoke(query);
                }
                else {
                    if(instance !== undefined) {
                        instance.invoke('destroy');
                    }
                    module.initialize();
                }
            })
        ;

        return (returnedValue !== undefined)
            ? returnedValue
            : this
            ;
    };

    $.fn.visibility.settings = {

        name                   : 'Visibility',
        namespace              : 'visibility',

        debug                  : false,
        verbose                : false,
        performance            : true,

        // whether to use mutation observers to follow changes
        observeChanges         : true,

        // check position immediately on init
        initialCheck           : true,

        // whether to refresh calculations after all page images load
        refreshOnLoad          : true,

        // whether to refresh calculations after page resize event
        refreshOnResize        : true,

        // should call callbacks on refresh event (resize, etc)
        checkOnRefresh         : true,

        // callback should only occur one time
        once                   : true,

        // callback should fire continuously whe evaluates to true
        continuous             : false,

        // offset to use with scroll top
        offset                 : 0,

        // whether to include margin in elements position
        includeMargin          : false,

        // scroll context for visibility checks
        context                : window,

        // visibility check delay in ms (defaults to animationFrame)
        throttle               : false,

        // special visibility type (image, fixed)
        type                   : false,

        // image only animation settings
        transition             : 'fade in',
        duration               : 1000,

        // array of callbacks for percentage
        onPassed               : {},

        // standard callbacks
        onOnScreen             : false,
        onOffScreen            : false,
        onPassing              : false,
        onTopVisible           : false,
        onBottomVisible        : false,
        onTopPassed            : false,
        onBottomPassed         : false,

        // reverse callbacks
        onPassingReverse       : false,
        onTopVisibleReverse    : false,
        onBottomVisibleReverse : false,
        onTopPassedReverse     : false,
        onBottomPassedReverse  : false,

        // utility callbacks
        onUpdate               : false, // disabled by default for performance
        onRefresh              : function(){},

        metadata : {
            src: 'src'
        },

        className: {
            fixed       : 'fixed',
            placeholder : 'placeholder'
        },

        error : {
            method  : 'The method you called is not defined.',
            visible : 'Element is hidden, you must call refresh after element becomes visible'
        }

    };
})( jQuery, window, document );
/*
 radialIndicator.js v 1.0.0
 Author: Sudhanshu Yadav
 Copyright (c) 2015 Sudhanshu Yadav - ignitersworld.com , released under the MIT license.
 Demo on: ignitersworld.com/lab/radialIndicator.html
 */

;(function ($, window, document) {
    "use strict";
    //circumfence and quart value to start bar from top
    var circ = Math.PI * 2,
        quart = Math.PI / 2;

    //function to convert hex to rgb

    function hexToRgb(hex) {
        // Expand shorthand form (e.g. "03F") to full form (e.g. "0033FF")
        var shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
        hex = hex.replace(shorthandRegex, function (m, r, g, b) {
            return r + r + g + g + b + b;
        });

        var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
        return result ? [parseInt(result[1], 16), parseInt(result[2], 16), parseInt(result[3], 16)] : null;
    }

    function getPropVal(curShift, perShift, bottomRange, topRange) {
        return Math.round(bottomRange + ((topRange - bottomRange) * curShift / perShift));
    }


    //function to get current color in case of
    function getCurrentColor(curPer, bottomVal, topVal, bottomColor, topColor) {
        var rgbAryTop = topColor.indexOf('#') != -1 ? hexToRgb(topColor) : topColor.match(/\d+/g),
            rgbAryBottom = bottomColor.indexOf('#') != -1 ? hexToRgb(bottomColor) : bottomColor.match(/\d+/g),
            perShift = topVal - bottomVal,
            curShift = curPer - bottomVal;

        if (!rgbAryTop || !rgbAryBottom) return null;

        return 'rgb(' + getPropVal(curShift, perShift, rgbAryBottom[0], rgbAryTop[0]) + ',' + getPropVal(curShift, perShift, rgbAryBottom[1], rgbAryTop[1]) + ',' + getPropVal(curShift, perShift, rgbAryBottom[2], rgbAryTop[2]) + ')';
    }

    //to merge object
    function merge() {
        var arg = arguments,
            target = arg[0];
        for (var i = 1, ln = arg.length; i < ln; i++) {
            var obj = arg[i];
            for (var k in obj) {
                if (obj.hasOwnProperty(k)) {
                    target[k] = obj[k];
                }
            }
        }
        return target;
    }

    //function to apply formatting on number depending on parameter
    function formatter(pattern) {
        return function (num) {
            if(!pattern) return num.toString();
            num = num || 0
            var numRev = num.toString().split('').reverse(),
                output = pattern.split("").reverse(),
                i = 0,
                lastHashReplaced = 0;

            //changes hash with numbers
            for (var ln = output.length; i < ln; i++) {
                if (!numRev.length) break;
                if (output[i] == "#") {
                    lastHashReplaced = i;
                    output[i] = numRev.shift();
                }
            }

            //add overflowing numbers before prefix
            output.splice(lastHashReplaced+1, output.lastIndexOf('#') - lastHashReplaced, numRev.reverse().join(""));

            return output.reverse().join('');
        }
    }


    //circle bar class
    function Indicator(container, indOption) {
        indOption = indOption || {};
        indOption = merge({}, radialIndicator.defaults, indOption);

        this.indOption = indOption;

        //create a queryselector if a selector string is passed in container
        if (typeof container == "string")
            container = document.querySelector(container);

        //get the first element if container is a node list
        if (container.length)
            container = container[0];

        this.container = container;

        //create a canvas element
        var canElm = document.createElement("canvas");
        container.appendChild(canElm);

        this.canElm = canElm; // dom object where drawing will happen

        this.ctx = canElm.getContext('2d'); //get 2d canvas context

        //add intial value
        this.current_value = indOption.initValue || indOption.minValue || 0;

    }


    Indicator.prototype = {
        constructor: radialIndicator,
        init: function () {
            var indOption = this.indOption,
                canElm = this.canElm,
                ctx = this.ctx,
                dim = (indOption.radius + indOption.barWidth) * 2, //elm width and height
                center = dim / 2; //center point in both x and y axis


            //create a formatter function
            this.formatter = typeof indOption.format == "function" ? indOption.format : formatter(indOption.format);

            //maximum text length;
            this.maxLength = indOption.percentage ? 4 : this.formatter(indOption.maxValue).length;

            canElm.width = dim;
            canElm.height = dim;

            //draw a grey circle
            ctx.strokeStyle = indOption.barBgColor; //background circle color
            ctx.lineWidth = indOption.barWidth;
            ctx.beginPath();
            ctx.arc(center, center, indOption.radius, 0, 2 * Math.PI);
            ctx.stroke();

            //store the image data after grey circle draw
            this.imgData = ctx.getImageData(0, 0, dim, dim);

            //put the initial value if defined
            this.value(this.current_value);

            return this;
        },
        //update the value of indicator without animation
        value: function (val) {
            //return the val if val is not provided
            if (val === undefined || isNaN(val)) {
                return this.current_value;
            }

            val = parseInt(val);

            var ctx = this.ctx,
                indOption = this.indOption,
                curColor = indOption.barColor,
                dim = (indOption.radius + indOption.barWidth) * 2,
                minVal = indOption.minValue,
                maxVal = indOption.maxValue,
                center = dim / 2;

            //limit the val in range of 0 to 100
            val = val < minVal ? minVal : val > maxVal ? maxVal : val;

            var perVal = Math.round(((val - minVal) * 100 / (maxVal - minVal)) * 100) / 100, //percentage value tp two decimal precision
                dispVal = indOption.percentage ? perVal + '%' : this.formatter(val); //formatted value

            //save val on object
            this.current_value = val;


            //draw the bg circle
            ctx.putImageData(this.imgData, 0, 0);

            //get current color if color range is set
            if (typeof curColor == "object") {
                var range = Object.keys(curColor);

                for (var i = 1, ln = range.length; i < ln; i++) {
                    var bottomVal = range[i - 1],
                        topVal = range[i],
                        bottomColor = curColor[bottomVal],
                        topColor = curColor[topVal],
                        newColor = val == bottomVal ? bottomColor : val == topVal ? topColor : val > bottomVal && val < topVal ? indOption.interpolate ? getCurrentColor(val, bottomVal, topVal, bottomColor, topColor) : topColor : false;

                    if (newColor != false) {
                        curColor = newColor;
                        break;
                    }
                }
            }

            //draw th circle value
            ctx.strokeStyle = curColor;

            //add linecap if value setted on options
            if (indOption.roundCorner) ctx.lineCap = "round";

            ctx.beginPath();
            ctx.arc(center, center, indOption.radius, -(quart), ((circ) * perVal / 100) - quart, false);
            ctx.stroke();

            //add percentage text
            if (indOption.displayNumber) {
                var cFont = ctx.font.split(' '),
                    weight = indOption.fontWeight,
                    fontSize = indOption.fontSize || (dim / (this.maxLength - (Math.floor(this.maxLength*1.4/4)-1)));

                cFont = indOption.fontFamily || cFont[cFont.length - 1];


                ctx.fillStyle = indOption.fontColor || curColor;
                ctx.font = weight +" "+ fontSize + "px " + cFont;
                ctx.textAlign = "center";
                ctx.textBaseline = 'middle';
                ctx.fillText(dispVal, center, center);
            }

            return this;
        },
        //animate progressbar to the value
        animate: function (val) {

            var indOption = this.indOption,
                counter = this.current_value || indOption.minValue,
                self = this,
                incBy = Math.ceil((indOption.maxValue - indOption.minValue) / (indOption.frameNum || (indOption.percentage ? 100 : 500))), //increment by .2% on every tick and 1% if showing as percentage
                back = val < counter;

            //clear interval function if already started
            if (this.intvFunc) clearInterval(this.intvFunc);

            this.intvFunc = setInterval(function () {

                if ((!back && counter >= val) || (back && counter <= val)) {
                    if (self.current_value == counter) {
                        clearInterval(self.intvFunc);
                        return;
                    } else {
                        counter = val;
                    }
                }

                self.value(counter); //dispaly the value

                if (counter != val) {
                    counter = counter + (back ? -incBy : incBy)
                }; //increment or decrement till counter does not reach  to value
            }, indOption.frameTime);

            return this;
        },
        //method to update options
        option: function (key, val) {
            if (val === undefined) return this.option[key];

            if (['radius', 'barWidth', 'barBgColor', 'format', 'maxValue', 'percentage'].indexOf(key) != -1) {
                this.indOption[key] = val;
                this.init().value(this.current_value);
            }
            this.indOption[key] = val;
        }

    };

    /** Initializer function **/
    function radialIndicator(container, options) {
        var progObj = new Indicator(container, options);
        progObj.init();
        return progObj;
    }

    //radial indicator defaults
    radialIndicator.defaults = {
        radius: 50, //inner radius of indicator
        barWidth: 5, //bar width
        barBgColor: '#eeeeee', //unfilled bar color
        barColor: '#99CC33', //filled bar color , can be a range also having different colors on different value like {0 : "#ccc", 50 : '#333', 100: '#000'}
        format: null, //format indicator numbers, can be a # formator ex (##,###.##) or a function
        frameTime: 10, //miliseconds to move from one frame to another
        frameNum: null, //Defines numbers of frame in indicator, defaults to 100 when showing percentage and 500 for other values
        fontColor: null, //font color
        fontFamily: null, //defines font family
        fontWeight: 'bold', //defines font weight
        fontSize : null, //define the font size of indicator number
        interpolate: true, //interpolate color between ranges
        percentage: false, //show percentage of value
        displayNumber: true, //display indicator number
        roundCorner: false, //have round corner in filled bar
        minValue: 0, //minimum value
        maxValue: 100, //maximum value
        initValue: 0 //define initial value of indicator
    };

    window.radialIndicator = radialIndicator;

    //add as a jquery plugin
    if ($) {
        $.fn.radialIndicator = function (options) {
            return this.each(function () {
                var newPCObj = radialIndicator(this, options);
                $.data(this, 'radialIndicator', newPCObj);
            });
        };
    }

}(window.jQuery, window, document, void 0));

/*
 == mresize jQuery plugin (event based element resize fn) ==
 Version: 1.0.1
 Plugin URI: http://manos.malihu.gr/event-based-jquery-element-resize/
 Author: malihu
 Author URI: http://manos.malihu.gr
 License: MIT License (MIT)
 */
;(function(factory){

    if(typeof define==="function" && define.amd){
        define(["jquery"],factory); //AMD
    }else if(typeof exports==="object"){
        module.exports=factory; //Browserify
    }else{
        factory(jQuery); //globals
    }

}(function($){

    $.event.special.mresize={
        add:function(){
            var el=$(this);
            if(el.data("mresize")) return;
            if(el.css("position")==="static") el.css("position","relative");
            el
                .append("<div class='resize' style='position:absolute; width:auto; height:auto; top:0; right:0; bottom:0; left:0; margin:0; padding:0; overflow:hidden; visibility:hidden; z-index:-1'><iframe style='width:100%; height:0; border:0; visibility:visible; margin:0' /><iframe style='width:0; height:100%; border:0; visibility:visible; margin:0' /></div>")
                .data("mresize",{"w":el.width(),"h":el.height(),t:null,throttle:100})
                .find(".resize iframe").each(function(){
                $(this.contentWindow || this).on("resize",function(){
                    var d=el.data("mresize");
                    if(d.w!==el.width() || d.h!==el.height()){
                        if(d.t) clearTimeout(d.t);
                        d.t=setTimeout(function(){
                            el.triggerHandler("mresize");
                            d.w=el.width();
                            d.h=el.height();
                        },d.throttle);
                    }
                });
            });
        },
        remove:function(){
            $(this).removeData("mresize").find(".resize").remove();
        }
    };

}));
/*
 UploadiFive 1.2.2
 Copyright (c) 2012 Reactive Apps, Ronnie Garcia
 Released under the UploadiFive Standard License <http://www.uploadify.com/uploadifive-standard-license>
 */
;(function($) {
    var methods = {

        init : function(options) {

            return this.each(function() {

                // Create a reference to the jQuery DOM object
                var $this = $(this);
                $this.data('uploadifive', {
                    inputs     : {}, // The object that contains all the file inputs
                    inputCount : 0,  // The total number of file inputs created
                    fileID     : 0,
                    queue      : {
                        count      : 0, // Total number of files in the queue
                        selected   : 0, // Number of files selected in the last select operation
                        replaced   : 0, // Number of files replaced in the last select operation
                        errors     : 0, // Number of files that returned an error in the last select operation
                        queued     : 0, // Number of files added to the queue in the last select operation
                        cancelled  : 0  // Total number of files that have been cancelled or removed from the queue
                    },
                    uploads    : {
                        current    : 0, // Number of files currently being uploaded
                        attempts   : 0, // Number of file uploads attempted in the last upload operation
                        successful : 0, // Number of files successfully uploaded in the last upload operation
                        errors     : 0, // Number of files returning errors in the last upload operation
                        count      : 0  // Total number of files uploaded successfully
                    }
                });
                var $data = $this.data('uploadifive');

                // Set the default options
                var settings = $data.settings = $.extend({
                    'auto'            : true,               // Automatically upload a file when it's added to the queue
                    'buttonClass'     : false,              // A class to add to the UploadiFive button
                    'buttonText'      : StrackLang['Select_Files'],     // The text that appears on the UploadiFive button
                    'checkScript'     : false,              // Path to the script that checks for existing file names
                    'dnd'             : true,               // Allow drag and drop into the queue
                    'dropTarget'      : false,              // Selector for the drop target
                    'fileObjName'     : 'Filedata',         // The name of the file object to use in your server-side script
                    'fileSizeLimit'   : 0,                  // Maximum allowed size of files to upload
                    'fileType'        : false,              // Type of files allowed (image, etc), separate with a pipe character |
                    'formData'        : {},                 // Additional data to send to the upload script
                    'height'          : 20,                 // The height of the button
                    'itemTemplate'    : false,              // The HTML markup for the item in the queue
                    'method'          : 'post',             // The method to use when submitting the upload
                    'multi'           : true,               // Set to true to allow multiple file selections
                    'overrideEvents'  : [],                 // An array of events to override
                    'queueID'         : false,              // The ID of the file queue
                    'queueSizeLimit'  : 0,                  // The maximum number of files that can be in the queue
                    'removeCompleted' : false,              // Set to true to remove files that have completed uploading
                    'simUploadLimit'  : 0,                  // The maximum number of files to upload at once
                    'truncateLength'  : 0,                  // The length to truncate the file names to
                    'uploadLimit'     : 0,                  // The maximum number of files you can upload
                    'uploadScript'    : 'uploadifive.php',  // The path to the upload script
                    'width'           : 100,                 // The width of the button
                    'token'           : '',                 // 验证令牌

                    /*
                     // Events
                     'onAddQueueItem'   : function(file) {},                        // Triggered for each file that is added to the queue
                     'onCancel'         : function(file) {},                        // Triggered when a file is cancelled or removed from the queue
                     'onCheck'          : function(file, exists) {},                // Triggered when the server is checked for an existing file
                     'onClearQueue'     : function(queue) {},                       // Triggered during the clearQueue function
                     'onDestroy'        : function() {}                             // Triggered during the destroy function
                     'onDrop'           : function(files, numberOfFilesDropped) {}, // Triggered when files are dropped into the file queue
                     'onError'          : function(file, fileType, data) {},        // Triggered when an error occurs
                     'onFallback'       : function() {},                            // Triggered if the HTML5 File API is not supported by the browser
                     'onInit'           : function() {},                            // Triggered when UploadiFive if initialized
                     'onQueueComplete'  : function() {},                            // Triggered once when an upload queue is done
                     'onProgress'       : function(file, event) {},                 // Triggered during each progress update of an upload
                     'onSelect'         : function() {},                            // Triggered once when files are selected from a dialog box
                     'onUpload'         : function(file) {},                        // Triggered when an upload queue is started
                     'onUploadComplete' : function(file, data) {},                  // Triggered when a file is successfully uploaded
                     'onUploadFile'     : function(file) {},                        // Triggered for each file being uploaded
                     */
                }, options);

                // Calculate the file size limit
                if (isNaN(settings.fileSizeLimit)) {
                    var fileSizeLimitBytes = parseInt(settings.fileSizeLimit) * 1.024
                    if (settings.fileSizeLimit.indexOf('KB') > -1) {
                        settings.fileSizeLimit = fileSizeLimitBytes * 1000;
                    } else if (settings.fileSizeLimit.indexOf('MB') > -1) {
                        settings.fileSizeLimit = fileSizeLimitBytes * 1000000;
                    } else if (settings.fileSizeLimit.indexOf('GB') > -1) {
                        settings.fileSizeLimit = fileSizeLimitBytes * 1000000000;
                    }
                } else {
                    settings.fileSizeLimit = settings.fileSizeLimit * 1024;
                }

                // Create a template for a file input
                $data.inputTemplate = $('<input type="file">')
                    .css({
                        'font-size' : settings.height + 'px',
                        'opacity'   : 0,
                        'position'  : 'absolute',
                        'right'     : '-3px',
                        'top'       : '-3px',
                        'z-index'   : 999
                    });

                // Create a new input
                $data.createInput = function() {

                    // Create a clone of the file input
                    var input     = $data.inputTemplate.clone();
                    // Create a unique name for the input item
                    var inputName = input.name = 'input' + $data.inputCount++;
                    // Set the multiple attribute
                    if (settings.multi) {
                        input.attr('multiple', true);
                    }
                    // Set the accept attribute on the input
                    if (settings.fileType) {
                        input.attr('accept', settings.fileType);
                    }
                    // Set the onchange event for the input
                    input.bind('change', function() {
                        $data.queue.selected = 0;
                        $data.queue.replaced = 0;
                        $data.queue.errors   = 0;
                        $data.queue.queued   = 0;
                        // Add a queue item to the queue for each file
                        var limit = this.files.length;
                        $data.queue.selected = limit;
                        if (($data.queue.count + limit) > settings.queueSizeLimit && settings.queueSizeLimit !== 0) {
                            if ($.inArray('onError', settings.overrideEvents) < 0) {
                                alert('The maximum number of queue items has been reached (' + settings.queueSizeLimit + ').  Please select fewer files.');
                            }
                            // Trigger the error event
                            if (typeof settings.onError === 'function') {
                                settings.onError.call($this, 'QUEUE_LIMIT_EXCEEDED');
                            }
                        } else {
                            for (var n = 0; n < limit; n++) {
                                file = this.files[n];
                                $data.addQueueItem(file);
                            }
                            $data.inputs[inputName] = this;
                            $data.createInput();
                        }
                        // Upload the file if auto-uploads are enabled
                        if (settings.auto) {
                            methods.upload.call($this);
                        }
                        // Trigger the select event
                        if (typeof settings.onSelect === 'function') {
                            settings.onSelect.call($this, $data.queue);
                        }
                    });
                    // Hide the existing current item and add the new one
                    if ($data.currentInput) {
                        $data.currentInput.hide();
                    }
                    $data.button.append(input);
                    $data.currentInput = input;
                }

                // Remove an input
                $data.destroyInput = function(key) {
                    $($data.inputs[key]).remove();
                    delete $data.inputs[key];
                    $data.inputCount--;
                }

                // Drop a file into the queue
                $data.drop = function(e) {
                    $data.queue.selected = 0;
                    $data.queue.replaced = 0;
                    $data.queue.errors   = 0;
                    $data.queue.queued   = 0;

                    var fileData = e.dataTransfer;

                    var inputName = fileData.name = 'input' + $data.inputCount++;
                    // Add a queue item to the queue for each file
                    var limit = fileData.files.length;
                    $data.queue.selected = limit;
                    if (($data.queue.count + limit) > settings.queueSizeLimit && settings.queueSizeLimit !== 0) {
                        // Check if the queueSizeLimit was reached
                        if ($.inArray('onError', settings.overrideEvents) < 0) {
                            alert('The maximum number of queue items has been reached (' + settings.queueSizeLimit + ').  Please select fewer files.');
                        }
                        // Trigger the onError event
                        if (typeof settings.onError === 'function') {
                            settings.onError.call($this, 'QUEUE_LIMIT_EXCEEDED');
                        }
                    } else {
                        // Add a queue item for each file
                        for (var n = 0; n < limit; n++) {
                            file = fileData.files[n];
                            $data.addQueueItem(file);
                        }
                        // Save the data to the inputs object
                        $data.inputs[inputName] = fileData;
                    }

                    // Upload the file if auto-uploads are enabled
                    if (settings.auto) {
                        methods.upload.call($this);
                    }

                    // Trigger the onDrop event
                    if (typeof settings.onDrop === 'function') {
                        settings.onDrop.call($this, fileData.files, fileData.files.length);
                    }

                    // Stop FireFox from opening the dropped file(s)
                    e.preventDefault();
                    e.stopPropagation();
                }

                // Check if a filename exists in the queue
                $data.fileExistsInQueue = function(file) {
                    for (var key in $data.inputs) {
                        input = $data.inputs[key];
                        limit = input.files.length;
                        for (var n = 0; n < limit; n++) {
                            existingFile = input.files[n];
                            // Check if the filename matches
                            if (existingFile.name == file.name && !existingFile.complete) {
                                return true;
                            }
                        }
                    }
                    return false;
                }

                // Remove an existing file in the queue
                $data.removeExistingFile = function(file) {
                    for (var key in $data.inputs) {
                        input = $data.inputs[key];
                        limit = input.files.length;
                        for (var n = 0; n < limit; n++) {
                            existingFile = input.files[n];
                            // Check if the filename matches
                            if (existingFile.name == file.name && !existingFile.complete) {
                                $data.queue.replaced++;
                                methods.cancel.call($this, existingFile, true);
                            }
                        }
                    }
                }

                // Create the file item template
                if (settings.itemTemplate == false) {
                    $data.queueItem = $('<div class="uploadifive-queue-item">\
                        <a class="close" href="#">X</a>\
                        <div><span class="filename"></span><span class="fileinfo"></span></div>\
                        <div class="progress">\
                            <div class="progress-bar"></div>\
                        </div>\
                    </div>');
                } else {
                    $data.queueItem = $(settings.itemTemplate);
                }

                // Add an item to the queue
                $data.addQueueItem = function(file) {
                    if ($.inArray('onAddQueueItem', settings.overrideEvents) < 0) {
                        // Check if the filename already exists in the queue
                        $data.removeExistingFile(file);
                        // Create a clone of the queue item template
                        file.queueItem = $data.queueItem.clone();
                        // Add an ID to the queue item
                        file.queueItem.attr('id', settings.id + '-file-' + $data.fileID++);
                        // Bind the close event to the close button
                        file.queueItem.find('.close').bind('click', function() {
                            methods.cancel.call($this, file);
                            return false;
                        });
                        var fileName = file.name;
                        if (fileName.length > settings.truncateLength && settings.truncateLength != 0) {
                            fileName = fileName.substring(0, settings.truncateLength) + '...';
                        }
                        file.queueItem.find('.filename').html(fileName);
                        // Add a reference to the file
                        file.queueItem.data('file', file);
                        $data.queueEl.append(file.queueItem);
                    }
                    // Trigger the addQueueItem event
                    if (typeof settings.onAddQueueItem === 'function') {
                        settings.onAddQueueItem.call($this, file);
                    }
                    // Check the filesize
                    if (file.size > settings.fileSizeLimit && settings.fileSizeLimit != 0) {
                        $data.error('FILE_SIZE_LIMIT_EXCEEDED', file);
                    } else {
                        $data.queue.queued++;
                        $data.queue.count++;
                    }
                }

                // Remove an item from the queue
                $data.removeQueueItem = function(file, instant, delay) {
                    // Set the default delay
                    if (!delay) delay = 0;
                    var fadeTime = instant ? 0 : 500;
                    if (file.queueItem) {
                        if (file.queueItem.find('.fileinfo').html() != ' - Completed') {
                            file.queueItem.find('.fileinfo').html(' - Cancelled');
                        }
                        file.queueItem.find('.progress-bar').width(0);
                        file.queueItem.delay(delay).fadeOut(fadeTime, function() {
                            $(this).remove();
                        });
                        delete file.queueItem;
                        $data.queue.count--;
                    }
                }

                // Count the number of files that need to be uploaded
                $data.filesToUpload = function() {
                    var filesToUpload = 0;
                    for (var key in $data.inputs) {
                        input = $data.inputs[key];
                        limit = input.files.length;
                        for (var n = 0; n < limit; n++) {
                            file = input.files[n];
                            if (!file.skip && !file.complete) {
                                filesToUpload++;
                            }
                        }
                    }
                    return filesToUpload;
                }

                // Check if a file exists
                $data.checkExists = function(file) {
                    if ($.inArray('onCheck', settings.overrideEvents) < 0) {
                        // This request needs to be synchronous
                        $.ajaxSetup({
                            'async' : false
                        });
                        // Send the filename to the check script
                        var checkData = $.extend(settings.formData, {filename: file.name});
                        $.post(settings.checkScript, checkData, function(fileExists) {
                            file.exists = parseInt(fileExists);
                        });
                        if (file.exists) {
                            if (!confirm('A file named ' + file.name + ' already exists in the upload folder.\nWould you like to replace it?')) {
                                // If not replacing the file, cancel the upload
                                methods.cancel.call($this, file);
                                return true;
                            }
                        }
                    }
                    // Trigger the check event
                    if (typeof settings.onCheck === 'function') {
                        settings.onCheck.call($this, file, file.exists);
                    }
                    return false;
                }

                // Upload a single file
                $data.uploadFile = function(file, uploadAll) {
                    if (!file.skip && !file.complete && !file.uploading) {

                        file.uploading = true;
                        $data.uploads.current++;
                        $data.uploads.attempted++;

                        // Create a new AJAX request
                        xhr = file.xhr = new XMLHttpRequest();

                        // Start the upload
                        // Use the faster FormData if it exists
                        if (typeof FormData === 'function' || typeof FormData === 'object') {

                            // Create a new FormData object
                            var formData = new FormData();

                            // Add the form data
                            formData.append(settings.fileObjName, file);

                            // Add the rest of the formData
                            for (i in settings.formData) {
                                formData.append(i, settings.formData[i]);
                            }

                            // Open the AJAX call
                            xhr.open(settings.method, settings.uploadScript, true);

                            // On progress function
                            xhr.upload.addEventListener('progress', function(e) {
                                if (e.lengthComputable) {
                                    $data.progress(e, file);
                                }
                            }, false);

                            xhr.setRequestHeader('token', settings.token);

                            // On complete function
                            xhr.addEventListener('load', function(e) {
                                if (this.readyState == 4) {
                                    file.uploading = false;
                                    if (this.status == 200) {
                                        if (file.xhr.responseText !== 'Invalid file type.') {
                                            $data.uploadComplete(e, file, uploadAll);
                                        } else {
                                            $data.error(file.xhr.responseText, file, uploadAll);
                                        }
                                    } else if (this.status == 404) {
                                        $data.error('404_FILE_NOT_FOUND', file, uploadAll);
                                    } else if (this.status == 403) {
                                        $data.error('403_FORBIDDEN', file, uploadAll);
                                    } else {
                                        $data.error('Unknown Error', file, uploadAll);
                                    }
                                }
                            });

                            // Send the form data (multipart/form-data)
                            xhr.send(formData);

                        } else {

                            // Send as binary
                            var reader = new FileReader();
                            reader.onload = function(e) {

                                // Set some file builder variables
                                var boundary = '-------------------------' + (new Date).getTime(),
                                    dashes   = '--',
                                    eol      = '\r\n',
                                    binFile  = '';

                                // Build an RFC2388 String
                                binFile += dashes + boundary + eol;
                                // Generate the headers
                                binFile += 'Content-Disposition: form-data; name="' + settings.fileObjName + '"';
                                if (file.name) {
                                    binFile += '; filename="' + file.name + '"';
                                }
                                binFile += eol;
                                binFile += 'Content-Type: application/octet-stream' + eol + eol;
                                binFile += e.target.result + eol;

                                for (key in settings.formData) {
                                    binFile += dashes + boundary + eol;
                                    binFile += 'Content-Disposition: form-data; name="' + key + '"' + eol + eol;
                                    binFile += settings.formData[key] + eol;
                                }

                                binFile += dashes + boundary + dashes + eol;

                                // On progress function
                                xhr.upload.addEventListener('progress', function(e) {
                                    $data.progress(e, file);
                                }, false);

                                // On complete function
                                xhr.addEventListener('load', function(e) {
                                    file.uploading = false;
                                    var status = this.status;
                                    if (status == 404) {
                                        $data.error('404_FILE_NOT_FOUND', file, uploadAll);
                                    } else {
                                        if (file.xhr.responseText != 'Invalid file type.') {
                                            $data.uploadComplete(e, file, uploadAll);
                                        } else {
                                            $data.error(file.xhr.responseText, file, uploadAll);
                                        }
                                    }
                                }, false);

                                // Open the ajax request
                                var url = settings.uploadScript;
                                if (settings.method == 'get') {
                                    var params = $(settings.formData).param();
                                    url += params;
                                }
                                xhr.open(settings.method, settings.uploadScript, true);
                                xhr.setRequestHeader("Content-Type", "multipart/form-data; boundary=" + boundary);
                                xhr.setRequestHeader('token', settings.token);

                                // Trigger the uploadFile event
                                if (typeof settings.onUploadFile === 'function') {
                                    settings.onUploadFile.call($this, file);
                                }

                                // Send the file for upload
                                xhr.sendAsBinary(binFile);
                            }
                            reader.readAsBinaryString(file);

                        }
                    }
                }

                // Update a file upload's progress
                $data.progress = function(e, file) {
                    if ($.inArray('onProgress', settings.overrideEvents) < 0) {
                        if (e.lengthComputable) {
                            var percent = Math.round((e.loaded / e.total) * 100);
                        }
                        file.queueItem.find('.fileinfo').html(' - ' + percent + '%');
                        file.queueItem.find('.progress-bar').css('width', percent + '%');
                    }
                    // Trigger the progress event
                    if (typeof settings.onProgress === 'function') {
                        settings.onProgress.call($this, file, e);
                    }
                }

                // Trigger an error
                $data.error = function(errorType, file, uploadAll) {
                    if ($.inArray('onError', settings.overrideEvents) < 0) {
                        // Get the error message
                        switch(errorType) {
                            case '404_FILE_NOT_FOUND':
                                errorMsg = '404 Error';
                                break;
                            case '403_FORBIDDEN':
                                errorMsg = '403 Forbidden';
                                break;
                            case 'FORBIDDEN_FILE_TYPE':
                                errorMsg = 'Forbidden File Type';
                                break;
                            case 'FILE_SIZE_LIMIT_EXCEEDED':
                                errorMsg = 'File Too Large';
                                break;
                            default:
                                errorMsg = 'Unknown Error';
                                break;
                        }

                        // Add the error class to the queue item
                        file.queueItem.addClass('error')
                            // Output the error in the queue item
                            .find('.fileinfo').html(' - ' + errorMsg);
                        // Hide the
                        file.queueItem.find('.progress').remove();
                    }
                    // Trigger the error event
                    if (typeof settings.onError === 'function') {
                        settings.onError.call($this, errorType, file);
                    }
                    file.skip = true;
                    if (errorType == '404_FILE_NOT_FOUND') {
                        $data.uploads.errors++;
                    } else {
                        $data.queue.errors++;
                    }
                    if (uploadAll) {
                        methods.upload.call($this, null, true);
                    }
                }

                // Trigger when a single file upload is complete
                $data.uploadComplete = function(e, file, uploadAll) {
                    if ($.inArray('onUploadComplete', settings.overrideEvents) < 0) {
                        file.queueItem.find('.progress-bar').css('width', '100%');
                        file.queueItem.find('.fileinfo').html(' - Completed');
                        file.queueItem.find('.progress').slideUp(250);
                        file.queueItem.addClass('complete');
                    }
                    // Trigger the complete event
                    if (typeof settings.onUploadComplete === 'function') {
                        settings.onUploadComplete.call($this, file, file.xhr.responseText);
                    }
                    if (settings.removeCompleted) {
                        setTimeout(function() { methods.cancel.call($this, file); }, 300);
                    }
                    file.complete = true;
                    $data.uploads.successful++;
                    $data.uploads.count++;
                    $data.uploads.current--;
                    delete file.xhr;
                    if (uploadAll) {
                        methods.upload.call($this, null, true);
                    }
                }

                // Trigger when all the files are done uploading
                $data.queueComplete = function() {
                    // Trigger the queueComplete event
                    if (typeof settings.onQueueComplete === 'function') {
                        settings.onQueueComplete.call($this, $data.uploads);
                    }
                }

                // ----------------------
                // Initialize UploadiFive
                // ----------------------

                // Check if HTML5 is available
                if (window.File && window.FileList && window.Blob && (window.FileReader || window.FormData)) {
                    // Assign an ID to the object
                    settings.id = 'uploadifive-' + $this.attr('id');

                    // Wrap the file input in a div with overflow set to hidden
                    $data.button = $('<div id="' + settings.id + '" class="uploadifive-button">' + settings.buttonText + '</div>');
                    if (settings.buttonClass) $data.button.addClass(settings.buttonClass);

                    // Style the button wrapper
                    $data.button.css({
                        'height'      : settings.height,
                        'line-height' : settings.height + 'px',
                        'overflow'    : 'hidden',
                        'position'    : 'relative',
                        'text-align'  : 'center',
                        'width'       : settings.width
                    });

                    // Insert the button above the file input
                    $this.before($data.button)
                        // Add the file input to the button
                        .appendTo($data.button)
                        // Modify the styles of the file input
                        .hide();

                    // Create a new input
                    $data.createInput.call($this);

                    // Create the queue container
                    if (!settings.queueID) {
                        settings.queueID = settings.id + '-queue';
                        $data.queueEl = $('<div id="' + settings.queueID + '" class="uploadifive-queue" />');
                        $data.button.after($data.queueEl);
                    } else {
                        $data.queueEl = $('#' + settings.queueID);
                    }

                    // Add drag and drop functionality
                    if (settings.dnd) {
                        var $dropTarget = settings.dropTarget ? $(settings.dropTarget) : $data.queueEl.get(0);
                        $dropTarget.addEventListener('dragleave', function(e) {
                            // Stop FireFox from opening the dropped file(s)
                            e.preventDefault();
                            e.stopPropagation();
                        }, false);
                        $dropTarget.addEventListener('dragenter', function(e) {
                            // Stop FireFox from opening the dropped file(s)
                            e.preventDefault();
                            e.stopPropagation();
                        }, false);
                        $dropTarget.addEventListener('dragover', function(e) {
                            // Stop FireFox from opening the dropped file(s)
                            e.preventDefault();
                            e.stopPropagation();
                        }, false);
                        $dropTarget.addEventListener('drop', $data.drop, false);
                    }

                    // Send as binary workaround for Chrome
                    if (!XMLHttpRequest.prototype.sendAsBinary) {
                        XMLHttpRequest.prototype.sendAsBinary = function(datastr) {
                            function byteValue(x) {
                                return x.charCodeAt(0) & 0xff;
                            }
                            var ords = Array.prototype.map.call(datastr, byteValue);
                            var ui8a = new Uint8Array(ords);
                            this.send(ui8a.buffer);
                        }
                    }

                    // Trigger the oninit event
                    if (typeof settings.onInit === 'function') {
                        settings.onInit.call($this);
                    }

                } else {

                    // Trigger the fallback event
                    if (typeof settings.onFallback === 'function') {
                        settings.onFallback.call($this);
                    }
                    return false;

                }

            });

        },


        // Write some data to the console
        debug : function() {

            return this.each(function() {

                console.log($(this).data('uploadifive'));

            });

        },

        // Clear all the items from the queue
        clearQueue : function() {

            this.each(function() {

                var $this    = $(this),
                    $data    = $this.data('uploadifive'),
                    settings = $data.settings;

                for (var key in $data.inputs) {
                    input = $data.inputs[key];
                    limit = input.files.length;
                    for (i = 0; i < limit; i++) {
                        file = input.files[i];
                        methods.cancel.call($this, file);
                    }
                }
                // Trigger the onClearQueue event
                if (typeof settings.onClearQueue === 'function') {
                    settings.onClearQueue.call($this, $('#' + $data.settings.queueID));
                }

            });

        },

		addQueueItem: function(file) {
			this.each(function() {
				 var $this    = $(this),
                    $data    = $this.data('uploadifive');
					$data.addQueueItem(file);
			});
		},

        // Cancel a file upload in progress or remove a file from the queue
        cancel : function(file, fast) {

            this.each(function() {

                var $this    = $(this),
                    $data    = $this.data('uploadifive'),
                    settings = $data.settings;

                // If user passed a queue item ID instead of file...
                if (typeof file === 'string') {
                    if (!isNaN(file)) {
                        fileID = 'uploadifive-' + $(this).attr('id') + '-file-' + file;
                    }
                    file = $('#' + fileID).data('file');
                }

                file.skip = true;
                $data.filesCancelled++;
                if (file.uploading) {
                    $data.uploads.current--;
                    file.uploading = false;
                    file.xhr.abort();
                    delete file.xhr;
                    methods.upload.call($this);
                }
                if ($.inArray('onCancel', settings.overrideEvents) < 0) {
                    $data.removeQueueItem(file, fast);
                }

                // Trigger the cancel event
                if (typeof settings.onCancel === 'function') {
                    settings.onCancel.call($this, file);
                }

            });

        },

        // Upload the files in the queue
        upload : function(file, keepVars) {

            this.each(function() {

                var $this    = $(this),
                    $data    = $this.data('uploadifive'),
                    settings = $data.settings;

                if (file) {
                    $data.uploadFile.call($this, file);
                } else {

                    // Check if the upload limit was reached
                    if (($data.uploads.count + $data.uploads.current) < settings.uploadLimit || settings.uploadLimit == 0) {
                        if (!keepVars) {
                            $data.uploads.attempted   = 0;
                            $data.uploads.successsful = 0;
                            $data.uploads.errors      = 0;
                            var filesToUpload = $data.filesToUpload();
                            // Trigger the onUpload event
                            if (typeof settings.onUpload === 'function') {
                                settings.onUpload.call($this, filesToUpload);
                            }
                        }

                        // Loop through the files
                        $('#' + settings.queueID).find('.uploadifive-queue-item').not('.error, .complete').each(function() {
                            _file = $(this).data('file');
                            // Check if the simUpload limit was reached
                            if (($data.uploads.current >= settings.simUploadLimit && settings.simUploadLimit !== 0) || ($data.uploads.current >= settings.uploadLimit && settings.uploadLimit !== 0) || ($data.uploads.count >= settings.uploadLimit && settings.uploadLimit !== 0)) {
                                return false;
                            }
                            if (settings.checkScript) {
                                // Let the loop know that we're already processing this file
                                _file.checking = true;
                                skipFile = $data.checkExists(_file);
                                _file.checking = false;
                                if (!skipFile) {
                                    $data.uploadFile(_file, true);
                                }
                            } else {
                                $data.uploadFile(_file, true);
                            }
                        });
                        if ($('#' + settings.queueID).find('.uploadifive-queue-item').not('.error, .complete').size() == 0) {
                            $data.queueComplete();
                        }
                    } else {
                        if ($data.uploads.current == 0) {
                            if ($.inArray('onError', settings.overrideEvents) < 0) {
                                if ($data.filesToUpload() > 0 && settings.uploadLimit != 0) {
                                    alert('The maximum upload limit has been reached.');
                                }
                            }
                            // Trigger the onError event
                            if (typeof settings.onError === 'function') {
                                settings.onError.call($this, 'UPLOAD_LIMIT_EXCEEDED', $data.filesToUpload());
                            }
                        }
                    }

                }

            });

        },

        // Destroy an instance of UploadiFive
        destroy : function() {

            this.each(function() {

                var $this    = $(this),
                    $data    = $this.data('uploadifive'),
                    settings = $data.settings;

                // Clear the queue
                methods.clearQueue.call($this);
                // Destroy the queue if it was created
                if (!settings.queueID) $('#' + settings.queueID).remove();
                // Remove extra inputs
                $this.siblings('input').remove();
                // Show the original file input
                $this.show()
                    // Move the file input out of the button
                    .insertBefore($data.button);
                // Delete the button
                $data.button.remove();
                // Trigger the destroy event
                if (typeof settings.onDestroy === 'function') {
                    settings.onDestroy.call($this);
                }

            });

        },
        // Get or set the settings data
        settings : function(name, value, resetObjects) {

            var args        = arguments;
            var returnValue = value;

            this.each(function() {
                // Create a reference to the jQuery DOM object
                var $this        = $(this),
                    uploadifive = $this.data('uploadifive'),
                    settings     = uploadifive.settings;

                if (name&&value) {
                    settings[name][value]=resetObjects
                }

            });
        },
    }

    $.fn.uploadifive = function(method) {

        if (methods[method]) {
            return methods[method].apply(this, Array.prototype.slice.call(arguments, 1));
        } else if (typeof method === 'object' || !method) {
            return methods.init.apply(this, arguments);
        } else {
            $.error('The method ' + method + ' does not exist in $.uploadify');
        }

    }

})(jQuery);
//CSV
(function(root, factory) {
    if (typeof define === "function" && define.amd) {
        define([], factory);
    } else if (typeof module === "object" && module.exports) {
        module.exports = factory();
    } else {
        root.CSV = factory();
    }
}(this, function() {
    'use strict';

    var ESCAPE_DELIMITERS = ['|', '^'],
        CELL_DELIMITERS = [',', ';', '\t', '|', '^'],
        LINE_DELIMITERS = ['\r\n', '\r', '\n'];

    function isObject(object) {
        var type = typeof object;
        return type === 'function' || type === 'object' && !!object;
    }
    var isArray = Array.isArray || function(object) {
            return toString.call(object) === '[object Array]';
        }
    function isString(object) {
        return typeof object === 'string';
    }
    function isNumber(object) {
        return !isNaN(Number(object));
    }
    function isBoolean(value) {
        return value == false || value == true;
    }
    function isNull(value) {
        return value == null;
    }
    function isPresent(value) {
        return value != null;
    }

    function fallback(value, fallback) {
        return isPresent(value) ? value : fallback;
    }

    function forEach(collection, iterator) {
        for (var _i = 0, _len = collection.length; _i < _len; _i += 1) {
            if (iterator(collection[_i], _i) === false) break;
        }
    }

    function sanitizeString(string) {
        return string.replace(/"/g,'\\"');
    }

    function buildCell(index) {
        return 'attrs[' + index + ']';
    }

    function castCell(value, index) {
        if (isNumber(value)) {
            return 'Number(' + buildCell(index) + ')';
        } else if (isBoolean(value)) {
            return 'Boolean(' + buildCell(index) + ' == true)';
        } else {
            return 'String(' + buildCell(index) + ')';
        }
    }

    function buildConstructor(deserialize, cast, values, attrs) {
        var definition = [];
        if (arguments.length == 3) {
            if (cast) {
                if (isArray(cast)) {
                    forEach(values, function(value, index) {
                        if (isString(cast[index])) {
                            cast[index] = cast[index].toLowerCase();
                        } else {
                            deserialize[cast[index]] = cast[index];
                        }
                        definition.push('deserialize[cast[' + index + ']](' + buildCell(index) + ')');
                    });
                } else {
                    forEach(values, function(value, index) {
                        definition.push(castCell(value, index));
                    });
                }
            } else {
                forEach(values, function(value, index) {
                    definition.push(buildCell(index));
                });
            }
            definition = 'return [' + definition.join(',') + ']';
        } else {
            if (cast) {
                if (isArray(cast)) {
                    forEach(values, function(value, index) {
                        if (isString(cast[index])) {
                            cast[index] = cast[index].toLowerCase();
                        } else {
                            deserialize[cast[index]] = cast[index];
                        }
                        definition.push('"' + sanitizeString(attrs[index]) + '": deserialize[cast[' + index + ']](' + buildCell(index) + ')');
                    });
                } else {
                    forEach(values, function(value, index) {
                        definition.push('"' + sanitizeString(attrs[index]) + '": ' + castCell(value, index));
                    });
                }
            } else {
                forEach(values, function(value, index) {
                    definition.push('"' + sanitizeString(attrs[index]) + '": ' + buildCell(index));
                });
            }
            definition = 'return {' + definition.join(',') + '}';
        }
        return new Function('attrs', 'deserialize', 'cast', definition);
    }

    function detectDelimiter(string, delimiters) {
        var count = 0,
            detected;

        forEach(delimiters, function(delimiter) {
            var needle = delimiter,
                matches;
            if (ESCAPE_DELIMITERS.indexOf(delimiter) != -1) {
                needle = '\\' + needle;
            }
            matches = string.match(new RegExp(needle, 'g'));
            if (matches && matches.length > count) {
                count = matches.length;
                detected = delimiter;
            }
        });
        return (detected || delimiters[0]);
    }

    var CSV = (function() {
        function CSV(data, options) {
            if (!options) options = {};

            if (isArray(data)) {
                this.mode = 'encode';
            } else if (isString(data)) {
                this.mode = 'parse';
            } else {
                throw new Error("Incompatible format!");
            }

            this.data = data;

            this.options = {
                header: fallback(options.header, false),
                cast: fallback(options.cast, true)
            }

            var lineDelimiter = options.lineDelimiter || options.line,
                cellDelimiter = options.cellDelimiter || options.delimiter;

            if (this.isParser()) {
                this.options.lineDelimiter = lineDelimiter || detectDelimiter(this.data, LINE_DELIMITERS);
                this.options.cellDelimiter = cellDelimiter || detectDelimiter(this.data, CELL_DELIMITERS);
                this.data = normalizeCSV(this.data, this.options.lineDelimiter);
            } else if (this.isEncoder()) {
                this.options.lineDelimiter = lineDelimiter || '\r\n';
                this.options.cellDelimiter = cellDelimiter || ',';
            }
        }

        function invoke(method, constructor, attributes, deserialize, cast) {
            method(new constructor(attributes, deserialize, cast));
        }

        function normalizeCSV(text, lineDelimiter) {
            if (text.slice(-lineDelimiter.length) != lineDelimiter) text += lineDelimiter;
            return text;
        }

        CSV.prototype.set = function(setting, value) {
            return this.options[setting] = value;
        }

        CSV.prototype.isParser = function() {
            return this.mode == 'parse';
        }

        CSV.prototype.isEncoder = function() {
            return this.mode == 'encode';
        }

        CSV.prototype.parse = function(callback) {
            if (this.mode != 'parse') return;
            if (this.data.trim().length === 0) return [];

            var data = this.data,
                options = this.options,
                header = options.header,
                current = { cell: '', line: [] },
                deserialize = this.deserialize,
                flag, record, response;

            if (!callback) {
                response = [];
                callback = function(record) {
                    response.push(record);
                }
            }

            function resetFlags() {
                flag = { escaped: false, quote: false, cell: true };
            }
            function resetCell() {
                current.cell = '';
            }
            function resetLine() {
                current.line = [];
            }

            function saveCell(cell) {
                current.line.push(flag.escaped ? cell.slice(1, -1).replace(/""/g, '"') : cell);
                resetCell();
                resetFlags();
            }
            function saveLastCell(cell) {
                saveCell(cell.slice(0, 1 - options.lineDelimiter.length));
            }
            function saveLine() {
                if (header) {
                    if (isArray(header)) {
                        record = buildConstructor(deserialize, options.cast, current.line, header);
                        saveLine = function() {
                            invoke(callback, record, current.line, deserialize, options.cast);
                        };
                        saveLine();
                    } else {
                        header = current.line;
                    }
                } else {
                    if (!record) {
                        record = buildConstructor(deserialize, options.cast, current.line);
                    }
                    saveLine = function() {
                        invoke(callback, record, current.line, deserialize, options.cast);
                    };
                    saveLine();
                }
            }

            if (options.lineDelimiter.length == 1) saveLastCell = saveCell;

            var dataLength = data.length,
                cellDelimiter = options.cellDelimiter.charCodeAt(0),
                lineDelimiter = options.lineDelimiter.charCodeAt(options.lineDelimiter.length - 1),
                _i, _c, _ch;

            resetFlags();

            for (_i = 0, _c = 0; _i < dataLength; _i++) {
                _ch = data.charCodeAt(_i);

                if (flag.cell) {
                    flag.cell = false;
                    if (_ch == 34) {
                        flag.escaped = true;
                        continue;
                    }
                }

                if (flag.escaped && _ch == 34) {
                    flag.quote = !flag.quote;
                    continue;
                }

                if ((flag.escaped && flag.quote) || !flag.escaped) {
                    if (_ch == cellDelimiter) {
                        saveCell(current.cell + data.slice(_c, _i));
                        _c = _i + 1;
                    } else if (_ch == lineDelimiter) {
                        saveLastCell(current.cell + data.slice(_c, _i));
                        _c = _i + 1;
                        if (current.line.length > 1 || current.line[0] !== "") {
                            saveLine();
                        }
                        resetLine();
                    }
                }
            }

            if (response) {
                return response;
            } else {
                return this;
            }
        }

        function serializeType(object) {
            if (isArray(object)) {
                return 'array';
            } else if (isObject(object)) {
                return 'object';
            } else if (isString(object)) {
                return 'string';
            } else if (isNull(object)) {
                return 'null';
            } else {
                return 'primitive';
            }
        }

        CSV.prototype.deserialize = {
            "string": function(string) {
                return String(string);
            },
            "number": function(number) {
                return Number(number);
            },
            "boolean": function(b) {
                return Boolean(b);
            }
        }

        CSV.prototype.serialize = {
            "object": function(object) {
                var that = this,
                    attributes = Object.keys(object),
                    serialized = Array(attributes.length);
                forEach(attributes, function(attr, index) {
                    serialized[index] = that[serializeType(object[attr])](object[attr]);
                });
                return serialized;
            },
            "array": function(array) {
                var that = this,
                    serialized = Array(array.length);
                forEach(array, function(value, index) {
                    serialized[index] = that[serializeType(value)](value);
                });
                return serialized;
            },
            "string": function(string) {
                return '"' + String(string).replace(/"/g, '""') + '"';
            },
            "null": function(value) {
                return '';
            },
            "primitive": function(value) {
                return value;
            }
        }

        CSV.prototype.encode = function(callback) {
            if (this.mode != 'encode') return;

            if (this.data.length == 0) return '';

            var data = this.data,
                options = this.options,
                header = options.header,
                sample = data[0],
                serialize = this.serialize,
                offset = 0,
                attributes, response;

            if (!callback) {
                response = Array(data.length);
                callback = function(record, index) {
                    response[index + offset] = record;
                }
            }

            function serializeLine(record) {
                return record.join(options.cellDelimiter);
            }

            if (header) {
                if (!isArray(header)) {
                    attributes = Object.keys(sample);
                    header = attributes;
                }
                callback(serializeLine(serialize.array(header)), 0);
                offset = 1;
            }

            var recordType = serializeType(sample),
                map;

            if (recordType == 'array') {
                if (isArray(options.cast)) {
                    map = Array(options.cast.length);
                    forEach(options.cast, function(type, index) {
                        if (isString(type)) {
                            map[index] = type.toLowerCase();
                        } else {
                            map[index] = type;
                            serialize[type] = type;
                        }
                    });
                } else {
                    map = Array(sample.length);
                    forEach(sample, function(value, index) {
                        map[index] = serializeType(value);
                    });
                }
                forEach(data, function(record, recordIndex) {
                    var serializedRecord = Array(map.length);
                    forEach(record, function(value, valueIndex) {
                        serializedRecord[valueIndex] = serialize[map[valueIndex]](value);
                    });
                    callback(serializeLine(serializedRecord), recordIndex);
                });
            } else if (recordType == 'object') {
                attributes = Object.keys(sample);
                if (isArray(options.cast)) {
                    map = Array(options.cast.length);
                    forEach(options.cast, function(type, index) {
                        if (isString(type)) {
                            map[index] = type.toLowerCase();
                        } else {
                            map[index] = type;
                            serialize[type] = type;
                        }
                    });
                } else {
                    map = Array(attributes.length);
                    forEach(attributes, function(attr, index) {
                        map[index] = serializeType(sample[attr]);
                    });
                }
                forEach(data, function(record, recordIndex) {
                    var serializedRecord = Array(attributes.length);
                    forEach(attributes, function(attr, attrIndex) {
                        serializedRecord[attrIndex] = serialize[map[attrIndex]](record[attr]);
                    });
                    callback(serializeLine(serializedRecord), recordIndex);
                });
            }

            if (response) {
                return response.join(options.lineDelimiter);
            } else {
                return this;
            }
        }

        CSV.prototype.forEach = function(callback) {
            return this[this.mode](callback);
        }

        return CSV;
    })();

    CSV.parse = function(data, options) {
        return new CSV(data, options).parse();
    }

    CSV.encode = function(data, options) {
        return new CSV(data, options).encode();
    }

    CSV.forEach = function(data, options, callback) {
        if (arguments.length == 2) {
            callback = options;
        }
        return new CSV(data, options).forEach(callback);
    }

    return CSV;
}));
/*!
 * jquery.inputmask.bundle.js
 * https://github.com/RobinHerbots/jquery.inputmask
 * Copyright (c) 2010 - 2016 Robin Herbots
 * Licensed under the MIT license (http://www.opensource.org/licenses/mit-license.php)
 * Version: 3.3.1
 */

/*!
 * jquery.inputmask.bundle.js
 * https://github.com/RobinHerbots/jquery.inputmask
 * Copyright (c) 2010 - 2016 Robin Herbots
 * Licensed under the MIT license (http://www.opensource.org/licenses/mit-license.php)
 * Version: 3.3.1
 */



! function ($) {
    function Inputmask(alias, options) {
        return this instanceof Inputmask ? ($.isPlainObject(alias) ? options = alias : (options = options || {},
            options.alias = alias), this.el = void 0, this.opts = $.extend(!0, {}, this.defaults, options),
            this.noMasksCache = options && void 0 !== options.definitions, this.userOptions = options || {},
            this.events = {}, void resolveAlias(this.opts.alias, options, this.opts)) : new Inputmask(alias, options);
    }

    function isInputEventSupported(eventName) {
        var el = document.createElement("input"),
            evName = "on" + eventName,
            isSupported = evName in el;
        return isSupported || (el.setAttribute(evName, "return;"), isSupported = "function" == typeof el[evName]),
            el = null, isSupported;
    }

    function isElementTypeSupported(input, opts) {
        var elementType = input.getAttribute("type"),
            isSupported = "INPUT" === input.tagName && -1 !== $.inArray(elementType, opts.supportsInputType) || input.isContentEditable || "TEXTAREA" === input.tagName;
        if (!isSupported && "INPUT" === input.tagName) {
            var el = document.createElement("input");
            el.setAttribute("type", elementType), isSupported = "text" === el.type, el = null;
        }
        return isSupported;
    }

    function resolveAlias(aliasStr, options, opts) {
        var aliasDefinition = opts.aliases[aliasStr];
        return aliasDefinition ? (aliasDefinition.alias && resolveAlias(aliasDefinition.alias, void 0, opts),
            $.extend(!0, opts, aliasDefinition), $.extend(!0, opts, options), !0) : (null === opts.mask && (opts.mask = aliasStr),
            !1);
    }

    function importAttributeOptions(npt, opts, userOptions) {
        function importOption(option, optionData) {
            optionData = void 0 !== optionData ? optionData : npt.getAttribute("data-inputmask-" + option),
            null !== optionData && ("string" == typeof optionData && (0 === option.indexOf("on") ? optionData = window[optionData] : "false" === optionData ? optionData = !1 : "true" === optionData && (optionData = !0)),
                userOptions[option] = optionData);
        }
        var option, dataoptions, optionData, p, attrOptions = npt.getAttribute("data-inputmask");
        if (attrOptions && "" !== attrOptions && (attrOptions = attrOptions.replace(new RegExp("'", "g"), '"'),
            dataoptions = JSON.parse("{" + attrOptions + "}")), dataoptions) {
            optionData = void 0;
            for (p in dataoptions)
                if ("alias" === p.toLowerCase()) {
                    optionData = dataoptions[p];
                    break;
                }
        }
        importOption("alias", optionData), userOptions.alias && resolveAlias(userOptions.alias, userOptions, opts);
        for (option in opts) {
            if (dataoptions) {
                optionData = void 0;
                for (p in dataoptions)
                    if (p.toLowerCase() === option.toLowerCase()) {
                        optionData = dataoptions[p];
                        break;
                    }
            }
            importOption(option, optionData);
        }
        return $.extend(!0, opts, userOptions), opts;
    }

    function generateMaskSet(opts, nocache) {
        function analyseMask(mask) {
            function MaskToken(isGroup, isOptional, isQuantifier, isAlternator) {
                this.matches = [], this.isGroup = isGroup || !1, this.isOptional = isOptional || !1,
                    this.isQuantifier = isQuantifier || !1, this.isAlternator = isAlternator || !1,
                    this.quantifier = {
                        min: 1,
                        max: 1
                    };
            }

            function insertTestDefinition(mtoken, element, position) {
                var maskdef = opts.definitions[element];
                position = void 0 !== position ? position : mtoken.matches.length;
                var prevMatch = mtoken.matches[position - 1];
                if (maskdef && !escaped) {
                    maskdef.placeholder = $.isFunction(maskdef.placeholder) ? maskdef.placeholder(opts) : maskdef.placeholder;
                    for (var prevalidators = maskdef.prevalidator, prevalidatorsL = prevalidators ? prevalidators.length : 0, i = 1; i < maskdef.cardinality; i++) {
                        var prevalidator = prevalidatorsL >= i ? prevalidators[i - 1] : [],
                            validator = prevalidator.validator,
                            cardinality = prevalidator.cardinality;
                        mtoken.matches.splice(position++, 0, {
                            fn: validator ? "string" == typeof validator ? new RegExp(validator) : new function () {
                                this.test = validator;
                            }() : new RegExp("."),
                            cardinality: cardinality ? cardinality : 1,
                            optionality: mtoken.isOptional,
                            newBlockMarker: void 0 === prevMatch || prevMatch.def !== (maskdef.definitionSymbol || element),
                            casing: maskdef.casing,
                            def: maskdef.definitionSymbol || element,
                            placeholder: maskdef.placeholder,
                            mask: element
                        }), prevMatch = mtoken.matches[position - 1];
                    }
                    mtoken.matches.splice(position++, 0, {
                        fn: maskdef.validator ? "string" == typeof maskdef.validator ? new RegExp(maskdef.validator) : new function () {
                            this.test = maskdef.validator;
                        }() : new RegExp("."),
                        cardinality: maskdef.cardinality,
                        optionality: mtoken.isOptional,
                        newBlockMarker: void 0 === prevMatch || prevMatch.def !== (maskdef.definitionSymbol || element),
                        casing: maskdef.casing,
                        def: maskdef.definitionSymbol || element,
                        placeholder: maskdef.placeholder,
                        mask: element
                    });
                } else mtoken.matches.splice(position++, 0, {
                    fn: null,
                    cardinality: 0,
                    optionality: mtoken.isOptional,
                    newBlockMarker: void 0 === prevMatch || prevMatch.def !== element,
                    casing: null,
                    def: opts.staticDefinitionSymbol || element,
                    placeholder: void 0 !== opts.staticDefinitionSymbol ? element : void 0,
                    mask: element
                }), escaped = !1;
            }

            function verifyGroupMarker(lastMatch, isOpenGroup) {
                lastMatch.isGroup && (lastMatch.isGroup = !1, insertTestDefinition(lastMatch, opts.groupmarker.start, 0),
                isOpenGroup !== !0 && insertTestDefinition(lastMatch, opts.groupmarker.end));
            }

            function maskCurrentToken(m, currentToken, lastMatch, extraCondition) {
                currentToken.matches.length > 0 && (void 0 === extraCondition || extraCondition) && (lastMatch = currentToken.matches[currentToken.matches.length - 1],
                    verifyGroupMarker(lastMatch)), insertTestDefinition(currentToken, m);
            }

            function defaultCase() {
                if (openenings.length > 0) {
                    if (currentOpeningToken = openenings[openenings.length - 1], maskCurrentToken(m, currentOpeningToken, lastMatch, !currentOpeningToken.isAlternator),
                        currentOpeningToken.isAlternator) {
                        alternator = openenings.pop();
                        for (var mndx = 0; mndx < alternator.matches.length; mndx++) alternator.matches[mndx].isGroup = !1;
                        openenings.length > 0 ? (currentOpeningToken = openenings[openenings.length - 1],
                            currentOpeningToken.matches.push(alternator)) : currentToken.matches.push(alternator);
                    }
                } else maskCurrentToken(m, currentToken, lastMatch);
            }

            function reverseTokens(maskToken) {
                function reverseStatic(st) {
                    return st === opts.optionalmarker.start ? st = opts.optionalmarker.end : st === opts.optionalmarker.end ? st = opts.optionalmarker.start : st === opts.groupmarker.start ? st = opts.groupmarker.end : st === opts.groupmarker.end && (st = opts.groupmarker.start),
                        st;
                }
                maskToken.matches = maskToken.matches.reverse();
                for (var match in maskToken.matches) {
                    var intMatch = parseInt(match);
                    if (maskToken.matches[match].isQuantifier && maskToken.matches[intMatch + 1] && maskToken.matches[intMatch + 1].isGroup) {
                        var qt = maskToken.matches[match];
                        maskToken.matches.splice(match, 1), maskToken.matches.splice(intMatch + 1, 0, qt);
                    }
                    void 0 !== maskToken.matches[match].matches ? maskToken.matches[match] = reverseTokens(maskToken.matches[match]) : maskToken.matches[match] = reverseStatic(maskToken.matches[match]);
                }
                return maskToken;
            }
            for (var match, m, openingToken, currentOpeningToken, alternator, lastMatch, groupToken, tokenizer = /(?:[?*+]|\{[0-9\+\*]+(?:,[0-9\+\*]*)?\})|[^.?*+^${[]()|\\]+|./g, escaped = !1, currentToken = new MaskToken(), openenings = [], maskTokens = []; match = tokenizer.exec(mask);)
                if (m = match[0],
                    escaped) defaultCase();
                else switch (m.charAt(0)) {
                    case opts.escapeChar:
                        escaped = !0;
                        break;

                    case opts.optionalmarker.end:
                    case opts.groupmarker.end:
                        if (openingToken = openenings.pop(), void 0 !== openingToken)
                            if (openenings.length > 0) {
                                if (currentOpeningToken = openenings[openenings.length - 1], currentOpeningToken.matches.push(openingToken),
                                    currentOpeningToken.isAlternator) {
                                    alternator = openenings.pop();
                                    for (var mndx = 0; mndx < alternator.matches.length; mndx++) alternator.matches[mndx].isGroup = !1;
                                    openenings.length > 0 ? (currentOpeningToken = openenings[openenings.length - 1],
                                        currentOpeningToken.matches.push(alternator)) : currentToken.matches.push(alternator);
                                }
                            } else currentToken.matches.push(openingToken);
                        else defaultCase();
                        break;

                    case opts.optionalmarker.start:
                        openenings.push(new MaskToken(!1, !0));
                        break;

                    case opts.groupmarker.start:
                        openenings.push(new MaskToken(!0));
                        break;

                    case opts.quantifiermarker.start:
                        var quantifier = new MaskToken(!1, !1, !0);
                        m = m.replace(/[{}]/g, "");
                        var mq = m.split(","),
                            mq0 = isNaN(mq[0]) ? mq[0] : parseInt(mq[0]),
                            mq1 = 1 === mq.length ? mq0 : isNaN(mq[1]) ? mq[1] : parseInt(mq[1]);
                        if (("*" === mq1 || "+" === mq1) && (mq0 = "*" === mq1 ? 0 : 1), quantifier.quantifier = {
                            min: mq0,
                            max: mq1
                        }, openenings.length > 0) {
                            var matches = openenings[openenings.length - 1].matches;
                            match = matches.pop(), match.isGroup || (groupToken = new MaskToken(!0), groupToken.matches.push(match),
                                match = groupToken), matches.push(match), matches.push(quantifier);
                        } else match = currentToken.matches.pop(), match.isGroup || (groupToken = new MaskToken(!0),
                            groupToken.matches.push(match), match = groupToken), currentToken.matches.push(match),
                            currentToken.matches.push(quantifier);
                        break;

                    case opts.alternatormarker:
                        openenings.length > 0 ? (currentOpeningToken = openenings[openenings.length - 1],
                            lastMatch = currentOpeningToken.matches.pop()) : lastMatch = currentToken.matches.pop(),
                            lastMatch.isAlternator ? openenings.push(lastMatch) : (alternator = new MaskToken(!1, !1, !1, !0),
                                alternator.matches.push(lastMatch), openenings.push(alternator));
                        break;

                    default:
                        defaultCase();
                }
            for (; openenings.length > 0;) openingToken = openenings.pop(), verifyGroupMarker(openingToken, !0),
                currentToken.matches.push(openingToken);
            return currentToken.matches.length > 0 && (lastMatch = currentToken.matches[currentToken.matches.length - 1],
                verifyGroupMarker(lastMatch), maskTokens.push(currentToken)), opts.numericInput && reverseTokens(maskTokens[0]),
                maskTokens;
        }

        function generateMask(mask, metadata) {
            if (null === mask || "" === mask) return void 0;
            if (1 === mask.length && opts.greedy === !1 && 0 !== opts.repeat && (opts.placeholder = ""),
            opts.repeat > 0 || "*" === opts.repeat || "+" === opts.repeat) {
                var repeatStart = "*" === opts.repeat ? 0 : "+" === opts.repeat ? 1 : opts.repeat;
                mask = opts.groupmarker.start + mask + opts.groupmarker.end + opts.quantifiermarker.start + repeatStart + "," + opts.repeat + opts.quantifiermarker.end;
            }
            var masksetDefinition;
            return void 0 === Inputmask.prototype.masksCache[mask] || nocache === !0 ? (masksetDefinition = {
                mask: mask,
                maskToken: analyseMask(mask),
                validPositions: {},
                _buffer: void 0,
                buffer: void 0,
                tests: {},
                metadata: metadata
            }, nocache !== !0 && (Inputmask.prototype.masksCache[opts.numericInput ? mask.split("").reverse().join("") : mask] = masksetDefinition,
                masksetDefinition = $.extend(!0, {}, Inputmask.prototype.masksCache[opts.numericInput ? mask.split("").reverse().join("") : mask]))) : masksetDefinition = $.extend(!0, {}, Inputmask.prototype.masksCache[opts.numericInput ? mask.split("").reverse().join("") : mask]),
                masksetDefinition;
        }

        function preProcessMask(mask) {
            return mask = mask.toString();
        }
        var ms;
        if ($.isFunction(opts.mask) && (opts.mask = opts.mask(opts)), $.isArray(opts.mask)) {
            if (opts.mask.length > 1) {
                opts.keepStatic = null === opts.keepStatic ? !0 : opts.keepStatic;
                var altMask = "(";
                return $.each(opts.numericInput ? opts.mask.reverse() : opts.mask, function (ndx, msk) {
                    altMask.length > 1 && (altMask += ")|("), altMask += preProcessMask(void 0 === msk.mask || $.isFunction(msk.mask) ? msk : msk.mask);
                }), altMask += ")", generateMask(altMask, opts.mask);
            }
            opts.mask = opts.mask.pop();
        }
        return opts.mask && (ms = void 0 === opts.mask.mask || $.isFunction(opts.mask.mask) ? generateMask(preProcessMask(opts.mask), opts.mask) : generateMask(preProcessMask(opts.mask.mask), opts.mask)),
            ms;
    }

    function maskScope(actionObj, maskset, opts) {
        function getMaskTemplate(baseOnInput, minimalPos, includeInput) {
            minimalPos = minimalPos || 0;
            var ndxIntlzr, test, testPos, maskTemplate = [],
                pos = 0,
                lvp = getLastValidPosition();
            do {
                if (baseOnInput === !0 && getMaskSet().validPositions[pos]) {
                    var validPos = getMaskSet().validPositions[pos];
                    test = validPos.match, ndxIntlzr = validPos.locator.slice(), maskTemplate.push(includeInput === !0 ? validPos.input : getPlaceholder(pos, test));
                } else testPos = getTestTemplate(pos, ndxIntlzr, pos - 1), test = testPos.match,
                    ndxIntlzr = testPos.locator.slice(), (opts.jitMasking === !1 || lvp > pos || isFinite(opts.jitMasking) && opts.jitMasking > pos) && maskTemplate.push(getPlaceholder(pos, test));
                pos++;
            } while ((void 0 === maxLength || maxLength > pos - 1) && null !== test.fn || null === test.fn && "" !== test.def || minimalPos >= pos);
            return "" === maskTemplate[maskTemplate.length - 1] && maskTemplate.pop(), maskTemplate;
        }

        function getMaskSet() {
            return maskset;
        }

        function resetMaskSet(soft) {
            var maskset = getMaskSet();
            maskset.buffer = void 0, soft !== !0 && (maskset.tests = {}, maskset._buffer = void 0,
                maskset.validPositions = {}, maskset.p = 0);
        }

        function getLastValidPosition(closestTo, strict, validPositions) {
            var before = -1,
                after = -1,
                valids = validPositions || getMaskSet().validPositions;
            void 0 === closestTo && (closestTo = -1);
            for (var posNdx in valids) {
                var psNdx = parseInt(posNdx);
                valids[psNdx] && (strict || null !== valids[psNdx].match.fn) && (closestTo >= psNdx && (before = psNdx),
                psNdx >= closestTo && (after = psNdx));
            }
            return -1 !== before && closestTo - before > 1 || closestTo > after ? before : after;
        }

        function setValidPosition(pos, validTest, fromSetValid, isSelection) {
            if (isSelection || opts.insertMode && void 0 !== getMaskSet().validPositions[pos] && void 0 === fromSetValid) {
                var i, positionsClone = $.extend(!0, {}, getMaskSet().validPositions),
                    lvp = getLastValidPosition();
                for (i = pos; lvp >= i; i++) delete getMaskSet().validPositions[i];
                getMaskSet().validPositions[pos] = validTest;
                var j, valid = !0,
                    vps = getMaskSet().validPositions,
                    needsValidation = !1;
                for (i = j = pos; lvp >= i; i++) {
                    var t = positionsClone[i];
                    if (void 0 !== t)
                        for (var posMatch = j, prevPosMatch = -1; posMatch < getMaskLength() && (null == t.match.fn && vps[i] && (vps[i].match.optionalQuantifier === !0 || vps[i].match.optionality === !0) || null != t.match.fn);) {
                            if (null === t.match.fn || !opts.keepStatic && vps[i] && (void 0 !== vps[i + 1] && getTests(i + 1, vps[i].locator.slice(), i).length > 1 || void 0 !== vps[i].alternation) ? posMatch++ : posMatch = seekNext(j),
                            needsValidation === !1 && positionsClone[posMatch] && positionsClone[posMatch].match.def === t.match.def) {
                                getMaskSet().validPositions[posMatch] = $.extend(!0, {}, positionsClone[posMatch]),
                                    getMaskSet().validPositions[posMatch].input = t.input, j = posMatch, valid = !0;
                                break;
                            }
                            if (positionCanMatchDefinition(posMatch, t.match.def)) {
                                var result = isValid(posMatch, t.input, !0, !0);
                                if (valid = result !== !1, j = result.caret || result.insert ? getLastValidPosition() : posMatch,
                                    needsValidation = !0, valid) break;
                            } else {
                                if (valid = null == t.match.fn, prevPosMatch === posMatch) break;
                                prevPosMatch = posMatch;
                            }
                        }
                    if (!valid) break;
                }
                if (!valid) return getMaskSet().validPositions = $.extend(!0, {}, positionsClone),
                    resetMaskSet(!0), !1;
            } else getMaskSet().validPositions[pos] = validTest;
            return resetMaskSet(!0), !0;
        }

        function stripValidPositions(start, end, nocheck, strict) {
            function IsEnclosedStatic(pos) {
                var posMatch = getMaskSet().validPositions[pos];
                if (void 0 !== posMatch && null === posMatch.match.fn) {
                    var prevMatch = getMaskSet().validPositions[pos - 1],
                        nextMatch = getMaskSet().validPositions[pos + 1];
                    return void 0 !== prevMatch && void 0 !== nextMatch;
                }
                return !1;
            }
            var i, startPos = start,
                positionsClone = $.extend(!0, {}, getMaskSet().validPositions),
                needsValidation = !1;
            for (getMaskSet().p = start, i = end - 1; i >= startPos; i--) void 0 !== getMaskSet().validPositions[i] && (nocheck === !0 || !IsEnclosedStatic(i) && opts.canClearPosition(getMaskSet(), i, getLastValidPosition(), strict, opts) !== !1) && delete getMaskSet().validPositions[i];
            for (resetMaskSet(!0), i = startPos + 1; i <= getLastValidPosition();) {
                for (; void 0 !== getMaskSet().validPositions[startPos];) startPos++;
                var s = getMaskSet().validPositions[startPos];
                if (startPos > i && (i = startPos + 1), void 0 === getMaskSet().validPositions[i] && isMask(i) || void 0 !== s) i++;
                else {
                    var t = getTestTemplate(i);
                    needsValidation === !1 && positionsClone[startPos] && positionsClone[startPos].match.def === t.match.def ? (getMaskSet().validPositions[startPos] = $.extend(!0, {}, positionsClone[startPos]),
                        getMaskSet().validPositions[startPos].input = t.input, delete getMaskSet().validPositions[i],
                        i++) : positionCanMatchDefinition(startPos, t.match.def) ? isValid(startPos, t.input || getPlaceholder(i), !0) !== !1 && (delete getMaskSet().validPositions[i],
                        i++, needsValidation = !0) : isMask(i) || (i++, startPos--), startPos++;
                }
            }
            resetMaskSet(!0);
        }

        function getTestTemplate(pos, ndxIntlzr, tstPs) {
            var testPos = getMaskSet().validPositions[pos];
            if (void 0 === testPos)
                for (var testPositions = getTests(pos, ndxIntlzr, tstPs), lvp = getLastValidPosition(), lvTest = getMaskSet().validPositions[lvp] || getTests(0)[0], lvTestAltArr = void 0 !== lvTest.alternation ? lvTest.locator[lvTest.alternation].toString().split(",") : [], ndx = 0; ndx < testPositions.length && (testPos = testPositions[ndx],
                    !(testPos.match && (opts.greedy && testPos.match.optionalQuantifier !== !0 || (testPos.match.optionality === !1 || testPos.match.newBlockMarker === !1) && testPos.match.optionalQuantifier !== !0) && (void 0 === lvTest.alternation || lvTest.alternation !== testPos.alternation || void 0 !== testPos.locator[lvTest.alternation] && checkAlternationMatch(testPos.locator[lvTest.alternation].toString().split(","), lvTestAltArr)))); ndx++);
            return testPos;
        }

        function getTest(pos) {
            return getMaskSet().validPositions[pos] ? getMaskSet().validPositions[pos].match : getTests(pos)[0].match;
        }

        function positionCanMatchDefinition(pos, def) {
            for (var valid = !1, tests = getTests(pos), tndx = 0; tndx < tests.length; tndx++)
                if (tests[tndx].match && tests[tndx].match.def === def) {
                    valid = !0;
                    break;
                }
            return valid;
        }

        function selectBestMatch(pos, alternateNdx) {
            var bestMatch, indexPos;
            return (getMaskSet().tests[pos] || getMaskSet().validPositions[pos]) && $.each(getMaskSet().tests[pos] || [getMaskSet().validPositions[pos]], function (ndx, lmnt) {
                var ndxPos = lmnt.alternation ? lmnt.locator[lmnt.alternation].toString().indexOf(alternateNdx) : -1;
                (void 0 === indexPos || indexPos > ndxPos) && -1 !== ndxPos && (bestMatch = lmnt,
                    indexPos = ndxPos);
            }), bestMatch;
        }

        function getTests(pos, ndxIntlzr, tstPs) {
            function resolveTestFromToken(maskToken, ndxInitializer, loopNdx, quantifierRecurse) {
                function handleMatch(match, loopNdx, quantifierRecurse) {
                    function isFirstMatch(latestMatch, tokenGroup) {
                        var firstMatch = 0 === $.inArray(latestMatch, tokenGroup.matches);
                        return firstMatch || $.each(tokenGroup.matches, function (ndx, match) {
                            return match.isQuantifier === !0 && (firstMatch = isFirstMatch(latestMatch, tokenGroup.matches[ndx - 1])) ? !1 : void 0;
                        }), firstMatch;
                    }

                    function resolveNdxInitializer(pos, alternateNdx) {
                        var bestMatch = selectBestMatch(pos, alternateNdx);
                        return bestMatch ? bestMatch.locator.slice(bestMatch.alternation + 1) : [];
                    }
                    if (testPos > 1e4) throw "Inputmask: There is probably an error in your mask definition or in the code. Create an issue on github with an example of the mask you are using. " + getMaskSet().mask;
                    if (testPos === pos && void 0 === match.matches) return matches.push({
                        match: match,
                        locator: loopNdx.reverse(),
                        cd: cacheDependency
                    }), !0;
                    if (void 0 !== match.matches) {
                        if (match.isGroup && quantifierRecurse !== match) {
                            if (match = handleMatch(maskToken.matches[$.inArray(match, maskToken.matches) + 1], loopNdx)) return !0;
                        } else if (match.isOptional) {
                            var optionalToken = match;
                            if (match = resolveTestFromToken(match, ndxInitializer, loopNdx, quantifierRecurse)) {
                                if (latestMatch = matches[matches.length - 1].match, !isFirstMatch(latestMatch, optionalToken)) return !0;
                                insertStop = !0, testPos = pos;
                            }
                        } else if (match.isAlternator) {
                            var maltMatches, alternateToken = match,
                                malternateMatches = [],
                                currentMatches = matches.slice(),
                                loopNdxCnt = loopNdx.length,
                                altIndex = ndxInitializer.length > 0 ? ndxInitializer.shift() : -1;
                            if (-1 === altIndex || "string" == typeof altIndex) {
                                var amndx, currentPos = testPos,
                                    ndxInitializerClone = ndxInitializer.slice(),
                                    altIndexArr = [];
                                if ("string" == typeof altIndex) altIndexArr = altIndex.split(",");
                                else
                                    for (amndx = 0; amndx < alternateToken.matches.length; amndx++) altIndexArr.push(amndx);
                                for (var ndx = 0; ndx < altIndexArr.length; ndx++) {
                                    if (amndx = parseInt(altIndexArr[ndx]), matches = [], ndxInitializer = resolveNdxInitializer(testPos, amndx),
                                        match = handleMatch(alternateToken.matches[amndx] || maskToken.matches[amndx], [amndx].concat(loopNdx), quantifierRecurse) || match,
                                    match !== !0 && void 0 !== match && altIndexArr[altIndexArr.length - 1] < alternateToken.matches.length) {
                                        var ntndx = $.inArray(match, maskToken.matches) + 1;
                                        maskToken.matches.length > ntndx && (match = handleMatch(maskToken.matches[ntndx], [ntndx].concat(loopNdx.slice(1, loopNdx.length)), quantifierRecurse),
                                        match && (altIndexArr.push(ntndx.toString()), $.each(matches, function (ndx, lmnt) {
                                            lmnt.alternation = loopNdx.length - 1;
                                        })));
                                    }
                                    maltMatches = matches.slice(), testPos = currentPos, matches = [];
                                    for (var i = 0; i < ndxInitializerClone.length; i++) ndxInitializer[i] = ndxInitializerClone[i];
                                    for (var ndx1 = 0; ndx1 < maltMatches.length; ndx1++) {
                                        var altMatch = maltMatches[ndx1];
                                        altMatch.alternation = altMatch.alternation || loopNdxCnt;
                                        for (var ndx2 = 0; ndx2 < malternateMatches.length; ndx2++) {
                                            var altMatch2 = malternateMatches[ndx2];
                                            if (altMatch.match.def === altMatch2.match.def && ("string" != typeof altIndex || -1 !== $.inArray(altMatch.locator[altMatch.alternation].toString(), altIndexArr))) {
                                                altMatch.match.mask === altMatch2.match.mask && (maltMatches.splice(ndx1, 1), ndx1--),
                                                -1 === altMatch2.locator[altMatch.alternation].toString().indexOf(altMatch.locator[altMatch.alternation]) && (altMatch2.locator[altMatch.alternation] = altMatch2.locator[altMatch.alternation] + "," + altMatch.locator[altMatch.alternation],
                                                    altMatch2.alternation = altMatch.alternation);
                                                break;
                                            }
                                        }
                                    }
                                    malternateMatches = malternateMatches.concat(maltMatches);
                                }
                                "string" == typeof altIndex && (malternateMatches = $.map(malternateMatches, function (lmnt, ndx) {
                                    if (isFinite(ndx)) {
                                        var mamatch, alternation = lmnt.alternation,
                                            altLocArr = lmnt.locator[alternation].toString().split(",");
                                        lmnt.locator[alternation] = void 0, lmnt.alternation = void 0;
                                        for (var alndx = 0; alndx < altLocArr.length; alndx++) mamatch = -1 !== $.inArray(altLocArr[alndx], altIndexArr),
                                        mamatch && (void 0 !== lmnt.locator[alternation] ? (lmnt.locator[alternation] += ",",
                                            lmnt.locator[alternation] += altLocArr[alndx]) : lmnt.locator[alternation] = parseInt(altLocArr[alndx]),
                                            lmnt.alternation = alternation);
                                        if (void 0 !== lmnt.locator[alternation]) return lmnt;
                                    }
                                })), matches = currentMatches.concat(malternateMatches), testPos = pos, insertStop = matches.length > 0;
                            } else match = handleMatch(alternateToken.matches[altIndex] || maskToken.matches[altIndex], [altIndex].concat(loopNdx), quantifierRecurse);
                            if (match) return !0;
                        } else if (match.isQuantifier && quantifierRecurse !== maskToken.matches[$.inArray(match, maskToken.matches) - 1])
                            for (var qt = match, qndx = ndxInitializer.length > 0 ? ndxInitializer.shift() : 0; qndx < (isNaN(qt.quantifier.max) ? qndx + 1 : qt.quantifier.max) && pos >= testPos; qndx++) {
                                var tokenGroup = maskToken.matches[$.inArray(qt, maskToken.matches) - 1];
                                if (match = handleMatch(tokenGroup, [qndx].concat(loopNdx), tokenGroup)) {
                                    if (latestMatch = matches[matches.length - 1].match, latestMatch.optionalQuantifier = qndx > qt.quantifier.min - 1,
                                        isFirstMatch(latestMatch, tokenGroup)) {
                                        if (qndx > qt.quantifier.min - 1) {
                                            insertStop = !0, testPos = pos;
                                            break;
                                        }
                                        return !0;
                                    }
                                    return !0;
                                }
                            } else if (match = resolveTestFromToken(match, ndxInitializer, loopNdx, quantifierRecurse)) return !0;
                    } else testPos++;
                }
                for (var tndx = ndxInitializer.length > 0 ? ndxInitializer.shift() : 0; tndx < maskToken.matches.length; tndx++)
                    if (maskToken.matches[tndx].isQuantifier !== !0) {
                        var match = handleMatch(maskToken.matches[tndx], [tndx].concat(loopNdx), quantifierRecurse);
                        if (match && testPos === pos) return match;
                        if (testPos > pos) break;
                    }
            }

            function mergeLocators(tests) {
                var locator = [];
                return $.isArray(tests) || (tests = [tests]), void 0 === tests[0].alternation ? locator = tests[0].locator.slice() : $.each(tests, function (ndx, tst) {
                    if ("" !== tst.def)
                        if (0 === locator.length) locator = tst.locator.slice();
                        else
                            for (var i = 0; i < locator.length; i++) tst.locator[i] && -1 === locator[i].toString().indexOf(tst.locator[i]) && (locator[i] += "," + tst.locator[i]);
                }), locator;
            }
            var latestMatch, maskTokens = getMaskSet().maskToken,
                testPos = ndxIntlzr ? tstPs : 0,
                ndxInitializer = ndxIntlzr || [0],
                matches = [],
                insertStop = !1,
                cacheDependency = ndxIntlzr ? ndxIntlzr.join("") : "";
            if (pos > -1) {
                if (void 0 === ndxIntlzr) {
                    for (var test, previousPos = pos - 1; void 0 === (test = getMaskSet().validPositions[previousPos] || getMaskSet().tests[previousPos]) && previousPos > -1;) previousPos--;
                    void 0 !== test && previousPos > -1 && (ndxInitializer = mergeLocators(test), cacheDependency = ndxInitializer.join(""),
                        testPos = previousPos);
                }
                if (getMaskSet().tests[pos] && getMaskSet().tests[pos][0].cd === cacheDependency) return getMaskSet().tests[pos];
                for (var mtndx = ndxInitializer.shift(); mtndx < maskTokens.length; mtndx++) {
                    var match = resolveTestFromToken(maskTokens[mtndx], ndxInitializer, [mtndx]);
                    if (match && testPos === pos || testPos > pos) break;
                }
            }
            return (0 === matches.length || insertStop) && matches.push({
                match: {
                    fn: null,
                    cardinality: 0,
                    optionality: !0,
                    casing: null,
                    def: ""
                },
                locator: []
            }), getMaskSet().tests[pos] = $.extend(!0, [], matches), getMaskSet().tests[pos];
        }

        function getBufferTemplate() {
            return void 0 === getMaskSet()._buffer && (getMaskSet()._buffer = getMaskTemplate(!1, 1)),
                getMaskSet()._buffer;
        }

        function getBuffer(noCache) {
            if (void 0 === getMaskSet().buffer || noCache === !0) {
                if (noCache === !0)
                    for (var testNdx in getMaskSet().tests) void 0 === getMaskSet().validPositions[testNdx] && delete getMaskSet().tests[testNdx];
                getMaskSet().buffer = getMaskTemplate(!0, getLastValidPosition(), !0);
            }
            return getMaskSet().buffer;
        }

        function refreshFromBuffer(start, end, buffer) {
            var i;
            if (buffer = buffer, start === !0) resetMaskSet(), start = 0, end = buffer.length;
            else
                for (i = start; end > i; i++) delete getMaskSet().validPositions[i],
                    delete getMaskSet().tests[i];
            for (i = start; end > i; i++) resetMaskSet(!0), buffer[i] !== opts.skipOptionalPartCharacter && isValid(i, buffer[i], !0, !0);
        }

        function casing(elem, test) {
            switch (test.casing) {
                case "upper":
                    elem = elem.toUpperCase();
                    break;

                case "lower":
                    elem = elem.toLowerCase();
            }
            return elem;
        }

        function checkAlternationMatch(altArr1, altArr2) {
            for (var altArrC = opts.greedy ? altArr2 : altArr2.slice(0, 1), isMatch = !1, alndx = 0; alndx < altArr1.length; alndx++)
                if (-1 !== $.inArray(altArr1[alndx], altArrC)) {
                    isMatch = !0;
                    break;
                }
            return isMatch;
        }

        function isValid(pos, c, strict, fromSetValid) {
            function isSelection(posObj) {
                return isRTL ? posObj.begin - posObj.end > 1 || posObj.begin - posObj.end === 1 && opts.insertMode : posObj.end - posObj.begin > 1 || posObj.end - posObj.begin === 1 && opts.insertMode;
            }

            function _isValid(position, c, strict, fromSetValid) {
                var rslt = !1;
                return $.each(getTests(position), function (ndx, tst) {
                    for (var test = tst.match, loopend = c ? 1 : 0, chrs = "", i = test.cardinality; i > loopend; i--) chrs += getBufferElement(position - (i - 1));
                    if (c && (chrs += c), getBuffer(!0), rslt = null != test.fn ? test.fn.test(chrs, getMaskSet(), position, strict, opts, isSelection(pos)) : c !== test.def && c !== opts.skipOptionalPartCharacter || "" === test.def ? !1 : {
                        c: test.placeholder || test.def,
                        pos: position
                    }, rslt !== !1) {
                        var elem = void 0 !== rslt.c ? rslt.c : c;
                        elem = elem === opts.skipOptionalPartCharacter && null === test.fn ? test.placeholder || test.def : elem;
                        var validatedPos = position,
                            possibleModifiedBuffer = getBuffer();
                        if (void 0 !== rslt.remove && ($.isArray(rslt.remove) || (rslt.remove = [rslt.remove]),
                            $.each(rslt.remove.sort(function (a, b) {
                                return b - a;
                            }), function (ndx, lmnt) {
                                stripValidPositions(lmnt, lmnt + 1, !0);
                            })), void 0 !== rslt.insert && ($.isArray(rslt.insert) || (rslt.insert = [rslt.insert]),
                            $.each(rslt.insert.sort(function (a, b) {
                                return a - b;
                            }), function (ndx, lmnt) {
                                isValid(lmnt.pos, lmnt.c, !1, fromSetValid);
                            })), rslt.refreshFromBuffer) {
                            var refresh = rslt.refreshFromBuffer;
                            if (strict = !0, refreshFromBuffer(refresh === !0 ? refresh : refresh.start, refresh.end, possibleModifiedBuffer),
                            void 0 === rslt.pos && void 0 === rslt.c) return rslt.pos = getLastValidPosition(),
                                !1;
                            if (validatedPos = void 0 !== rslt.pos ? rslt.pos : position, validatedPos !== position) return rslt = $.extend(rslt, isValid(validatedPos, elem, !0, fromSetValid)),
                                !1;
                        } else if (rslt !== !0 && void 0 !== rslt.pos && rslt.pos !== position && (validatedPos = rslt.pos,
                            refreshFromBuffer(position, validatedPos, getBuffer().slice()), validatedPos !== position)) return rslt = $.extend(rslt, isValid(validatedPos, elem, !0)),
                            !1;
                        return rslt !== !0 && void 0 === rslt.pos && void 0 === rslt.c ? !1 : (ndx > 0 && resetMaskSet(!0),
                        setValidPosition(validatedPos, $.extend({}, tst, {
                            input: casing(elem, test)
                        }), fromSetValid, isSelection(pos)) || (rslt = !1), !1);
                    }
                }), rslt;
            }

            function alternate(pos, c, strict, fromSetValid) {
                for (var lastAlt, alternation, isValidRslt, altPos, i, validPos, validPsClone = $.extend(!0, {}, getMaskSet().validPositions), testsClone = $.extend(!0, {}, getMaskSet().tests), lAlt = getLastValidPosition(); lAlt >= 0 && (altPos = getMaskSet().validPositions[lAlt],
                !altPos || void 0 === altPos.alternation || (lastAlt = lAlt, alternation = getMaskSet().validPositions[lastAlt].alternation,
                getTestTemplate(lastAlt).locator[altPos.alternation] === altPos.locator[altPos.alternation])); lAlt--);
                if (void 0 !== alternation) {
                    lastAlt = parseInt(lastAlt);
                    for (var decisionPos in getMaskSet().validPositions)
                        if (decisionPos = parseInt(decisionPos),
                            altPos = getMaskSet().validPositions[decisionPos], decisionPos >= lastAlt && void 0 !== altPos.alternation) {
                            var altNdxs;
                            0 === lastAlt ? (altNdxs = [], $.each(getMaskSet().tests[lastAlt], function (ndx, test) {
                                void 0 !== test.locator[alternation] && (altNdxs = altNdxs.concat(test.locator[alternation].toString().split(",")));
                            })) : altNdxs = getMaskSet().validPositions[lastAlt].locator[alternation].toString().split(",");
                            var decisionTaker = void 0 !== altPos.locator[alternation] ? altPos.locator[alternation] : altNdxs[0];
                            decisionTaker.length > 0 && (decisionTaker = decisionTaker.split(",")[0]);
                            for (var mndx = 0; mndx < altNdxs.length; mndx++) {
                                var validInputs = [],
                                    staticInputsBeforePos = 0,
                                    staticInputsBeforePosAlternate = 0;
                                if (decisionTaker < altNdxs[mndx]) {
                                    for (var possibilityPos, possibilities, dp = decisionPos; dp >= 0; dp--)
                                        if (possibilityPos = getMaskSet().validPositions[dp],
                                        void 0 !== possibilityPos) {
                                            var bestMatch = selectBestMatch(dp, altNdxs[mndx]);
                                            getMaskSet().validPositions[dp].match.def !== bestMatch.match.def && (validInputs.push(getMaskSet().validPositions[dp].input),
                                                getMaskSet().validPositions[dp] = bestMatch, getMaskSet().validPositions[dp].input = getPlaceholder(dp),
                                            null === getMaskSet().validPositions[dp].match.fn && staticInputsBeforePosAlternate++,
                                                possibilityPos = bestMatch), possibilities = possibilityPos.locator[alternation],
                                                possibilityPos.locator[alternation] = parseInt(altNdxs[mndx]);
                                            break;
                                        }
                                    if (decisionTaker !== possibilityPos.locator[alternation]) {
                                        for (i = decisionPos + 1; i < getLastValidPosition(void 0, !0) + 1; i++) validPos = getMaskSet().validPositions[i],
                                            validPos && null != validPos.match.fn ? validInputs.push(validPos.input) : pos > i && staticInputsBeforePos++,
                                            delete getMaskSet().validPositions[i], delete getMaskSet().tests[i];
                                        for (resetMaskSet(!0), opts.keepStatic = !opts.keepStatic, isValidRslt = !0; validInputs.length > 0;) {
                                            var input = validInputs.shift();
                                            if (input !== opts.skipOptionalPartCharacter && !(isValidRslt = isValid(getLastValidPosition(void 0, !0) + 1, input, !1, fromSetValid))) break;
                                        }
                                        if (possibilityPos.alternation = alternation, possibilityPos.locator[alternation] = possibilities,
                                            isValidRslt) {
                                            var targetLvp = getLastValidPosition(pos) + 1;
                                            for (i = decisionPos + 1; i < getLastValidPosition() + 1; i++) validPos = getMaskSet().validPositions[i],
                                            (void 0 === validPos || null == validPos.match.fn) && pos > i && staticInputsBeforePosAlternate++;
                                            pos += staticInputsBeforePosAlternate - staticInputsBeforePos, isValidRslt = isValid(pos > targetLvp ? targetLvp : pos, c, strict, fromSetValid);
                                        }
                                        if (opts.keepStatic = !opts.keepStatic, isValidRslt) return isValidRslt;
                                        resetMaskSet(), getMaskSet().validPositions = $.extend(!0, {}, validPsClone), getMaskSet().tests = $.extend(!0, {}, testsClone);
                                    }
                                }
                            }
                            break;
                        }
                }
                return !1;
            }

            function trackbackAlternations(originalPos, newPos) {
                for (var vp = getMaskSet().validPositions[newPos], targetLocator = vp.locator, tll = targetLocator.length, ps = originalPos; newPos > ps; ps++)
                    if (void 0 === getMaskSet().validPositions[ps] && !isMask(ps, !0)) {
                        var tests = getTests(ps),
                            bestMatch = tests[0],
                            equality = -1;
                        $.each(tests, function (ndx, tst) {
                            for (var i = 0; tll > i && (void 0 !== tst.locator[i] && checkAlternationMatch(tst.locator[i].toString().split(","), targetLocator[i].toString().split(","))); i++) i > equality && (equality = i,
                                bestMatch = tst);
                        }), setValidPosition(ps, $.extend({}, bestMatch, {
                            input: bestMatch.match.placeholder || bestMatch.match.def
                        }), !0);
                    }
            }
            strict = strict === !0;
            var maskPos = pos;
            void 0 !== pos.begin && (maskPos = isRTL && !isSelection(pos) ? pos.end : pos.begin);
            for (var result = !1, positionsClone = $.extend(!0, {}, getMaskSet().validPositions), pndx = maskPos - 1; pndx > -1 && !getMaskSet().validPositions[pndx]; pndx--);
            var testTemplate;
            for (pndx++; maskPos > pndx; pndx++) void 0 === getMaskSet().validPositions[pndx] && (opts.jitMasking === !1 || opts.jitMasking > pndx) && ((testTemplate = getTestTemplate(pndx)).match.def === opts.radixPointDefinitionSymbol || !isMask(pndx, !0) || $.inArray(opts.radixPoint, getBuffer()) < pndx && testTemplate.match.fn && testTemplate.match.fn.test(getPlaceholder(pndx), getMaskSet(), pndx, !1, opts)) && _isValid(getLastValidPosition(pndx, !0) + 1, testTemplate.match.placeholder || (null == testTemplate.match.fn ? testTemplate.match.def : "" !== getPlaceholder(pndx) ? getPlaceholder(pndx) : getBuffer()[pndx]), !0, fromSetValid);
            if (isSelection(pos) && (handleRemove(void 0, Inputmask.keyCode.DELETE, pos), maskPos = getMaskSet().p),
            maskPos < getMaskLength() && (result = _isValid(maskPos, c, strict, fromSetValid),
            (!strict || fromSetValid === !0) && result === !1)) {
                var currentPosValid = getMaskSet().validPositions[maskPos];
                if (!currentPosValid || null !== currentPosValid.match.fn || currentPosValid.match.def !== c && c !== opts.skipOptionalPartCharacter) {
                    if ((opts.insertMode || void 0 === getMaskSet().validPositions[seekNext(maskPos)]) && !isMask(maskPos, !0)) {
                        var staticChar = getTestTemplate(maskPos).match;
                        staticChar = staticChar.placeholder || staticChar.def, _isValid(maskPos, staticChar, strict, fromSetValid);
                        for (var nPos = maskPos + 1, snPos = seekNext(maskPos); snPos >= nPos; nPos++)
                            if (result = _isValid(nPos, c, strict, fromSetValid),
                            result !== !1) {
                                trackbackAlternations(maskPos, nPos), maskPos = nPos;
                                break;
                            }
                    }
                } else result = {
                    caret: seekNext(maskPos)
                };
            }
            return result === !1 && opts.keepStatic && (result = alternate(maskPos, c, strict, fromSetValid)),
            result === !0 && (result = {
                pos: maskPos
            }), $.isFunction(opts.postValidation) && result !== !1 && !strict && fromSetValid !== !0 && (result = opts.postValidation(getBuffer(!0), result, opts) ? result : !1),
            void 0 === result.pos && (result.pos = maskPos), result === !1 && (resetMaskSet(!0),
                getMaskSet().validPositions = $.extend(!0, {}, positionsClone)), result;
        }

        function isMask(pos, strict) {
            var test;
            if (strict ? (test = getTestTemplate(pos).match, "" === test.def && (test = getTest(pos))) : test = getTest(pos),
            null != test.fn) return test.fn;
            if (strict !== !0 && pos > -1 && !opts.keepStatic && void 0 === getMaskSet().validPositions[pos]) {
                var tests = getTests(pos);
                return tests.length > 2;
            }
            return !1;
        }

        function getMaskLength() {
            var maskLength;
            maxLength = void 0 !== el ? el.maxLength : void 0, -1 === maxLength && (maxLength = void 0);
            var pos, lvp = getLastValidPosition(),
                testPos = getMaskSet().validPositions[lvp],
                ndxIntlzr = void 0 !== testPos ? testPos.locator.slice() : void 0;
            for (pos = lvp + 1; void 0 === testPos || null !== testPos.match.fn || null === testPos.match.fn && "" !== testPos.match.def; pos++) testPos = getTestTemplate(pos, ndxIntlzr, pos - 1),
                ndxIntlzr = testPos.locator.slice();
            var lastTest = getTest(pos - 1);
            return maskLength = "" !== lastTest.def ? pos : pos - 1, void 0 === maxLength || maxLength > maskLength ? maskLength : maxLength;
        }

        function seekNext(pos, newBlock) {
            var maskL = getMaskLength();
            if (pos >= maskL) return maskL;
            for (var position = pos; ++position < maskL && (newBlock === !0 && (getTest(position).newBlockMarker !== !0 || !isMask(position)) || newBlock !== !0 && !isMask(position) && (opts.nojumps !== !0 || opts.nojumpsThreshold > position)););
            return position;
        }

        function seekPrevious(pos, newBlock) {
            var position = pos;
            if (0 >= position) return 0;
            for (; --position > 0 && (newBlock === !0 && getTest(position).newBlockMarker !== !0 || newBlock !== !0 && !isMask(position)););
            return position;
        }

        function getBufferElement(position) {
            return void 0 === getMaskSet().validPositions[position] ? getPlaceholder(position) : getMaskSet().validPositions[position].input;
        }

        function writeBuffer(input, buffer, caretPos, event, triggerInputEvent) {
            if (event && $.isFunction(opts.onBeforeWrite)) {
                var result = opts.onBeforeWrite(event, buffer, caretPos, opts);
                if (result) {
                    if (result.refreshFromBuffer) {
                        var refresh = result.refreshFromBuffer;
                        refreshFromBuffer(refresh === !0 ? refresh : refresh.start, refresh.end, result.buffer || buffer),
                            buffer = getBuffer(!0);
                    }
                    void 0 !== caretPos && (caretPos = void 0 !== result.caret ? result.caret : caretPos);
                }
            }
            input.inputmask._valueSet(buffer.join("")), void 0 === caretPos || void 0 !== event && "blur" === event.type || caret(input, caretPos),
            triggerInputEvent === !0 && (skipInputEvent = !0, $(input).trigger("input"));
        }

        function getPlaceholder(pos, test) {
            if (test = test || getTest(pos), void 0 !== test.placeholder) return test.placeholder;
            if (null === test.fn) {
                if (pos > -1 && !opts.keepStatic && void 0 === getMaskSet().validPositions[pos]) {
                    var prevTest, tests = getTests(pos),
                        staticAlternations = [];
                    if (tests.length > 2)
                        for (var i = 0; i < tests.length; i++)
                            if (tests[i].match.optionality !== !0 && tests[i].match.optionalQuantifier !== !0 && (null === tests[i].match.fn || void 0 === prevTest || tests[i].match.fn.test(prevTest.match.def, getMaskSet(), pos, !0, opts) !== !1) && (staticAlternations.push(tests[i]),
                            null === tests[i].match.fn && (prevTest = tests[i]), staticAlternations.length > 1)) return opts.placeholder.charAt(pos % opts.placeholder.length);
                }
                return test.def;
            }
            return opts.placeholder.charAt(pos % opts.placeholder.length);
        }

        function checkVal(input, writeOut, strict, nptvl) {
            function isTemplateMatch() {
                var isMatch = !1,
                    charCodeNdx = getBufferTemplate().slice(initialNdx, seekNext(initialNdx)).join("").indexOf(charCodes);
                if (-1 !== charCodeNdx && !isMask(initialNdx)) {
                    isMatch = !0;
                    for (var bufferTemplateArr = getBufferTemplate().slice(initialNdx, initialNdx + charCodeNdx), i = 0; i < bufferTemplateArr.length; i++)
                        if (" " !== bufferTemplateArr[i]) {
                            isMatch = !1;
                            break;
                        }
                }
                return isMatch;
            }
            var result, inputValue = nptvl.slice(),
                charCodes = "",
                initialNdx = 0;
            if (resetMaskSet(), getMaskSet().p = seekNext(-1), !strict)
                if (opts.autoUnmask !== !0) {
                    var staticInput = getBufferTemplate().slice(0, seekNext(-1)).join(""),
                        matches = inputValue.join("").match(new RegExp("^" + Inputmask.escapeRegex(staticInput), "g"));
                    matches && matches.length > 0 && (inputValue.splice(0, matches.length * staticInput.length),
                        initialNdx = seekNext(initialNdx));
                } else initialNdx = seekNext(initialNdx);
            $.each(inputValue, function (ndx, charCode) {
                if (void 0 !== charCode) {
                    var keypress = new $.Event("keypress");
                    keypress.which = charCode.charCodeAt(0), charCodes += charCode;
                    var lvp = getLastValidPosition(void 0, !0),
                        lvTest = getMaskSet().validPositions[lvp],
                        nextTest = getTestTemplate(lvp + 1, lvTest ? lvTest.locator.slice() : void 0, lvp);
                    if (!isTemplateMatch() || strict || opts.autoUnmask) {
                        var pos = strict ? ndx : null == nextTest.match.fn && nextTest.match.optionality && lvp + 1 < getMaskSet().p ? lvp + 1 : getMaskSet().p;
                        result = keypressEvent.call(input, keypress, !0, !1, strict, pos), initialNdx = pos + 1,
                            charCodes = "";
                    } else result = keypressEvent.call(input, keypress, !0, !1, !0, lvp + 1);
                    if (!strict && $.isFunction(opts.onBeforeWrite) && (result = opts.onBeforeWrite(keypress, getBuffer(), result.forwardPosition, opts),
                    result && result.refreshFromBuffer)) {
                        var refresh = result.refreshFromBuffer;
                        refreshFromBuffer(refresh === !0 ? refresh : refresh.start, refresh.end, result.buffer),
                            resetMaskSet(!0), result.caret && (getMaskSet().p = result.caret);
                    }
                }
            }), writeOut && writeBuffer(input, getBuffer(), document.activeElement === input ? seekNext(getLastValidPosition(0)) : void 0, new $.Event("checkval"));
        }

        function unmaskedvalue(input) {
            if (input && void 0 === input.inputmask) return input.value;
            var umValue = [],
                vps = getMaskSet().validPositions;
            for (var pndx in vps) vps[pndx].match && null != vps[pndx].match.fn && umValue.push(vps[pndx].input);
            var unmaskedValue = 0 === umValue.length ? null : (isRTL ? umValue.reverse() : umValue).join("");
            if (null !== unmaskedValue) {
                var bufferValue = (isRTL ? getBuffer().slice().reverse() : getBuffer()).join("");
                $.isFunction(opts.onUnMask) && (unmaskedValue = opts.onUnMask(bufferValue, unmaskedValue, opts) || unmaskedValue);
            }
            return unmaskedValue;
        }

        function caret(input, begin, end, notranslate) {
            function translatePosition(pos) {
                if (notranslate !== !0 && isRTL && "number" == typeof pos && (!opts.greedy || "" !== opts.placeholder)) {
                    var bffrLght = getBuffer().join("").length;
                    pos = bffrLght - pos;
                }
                return pos;
            }
            var range;
            if ("number" != typeof begin) return input.setSelectionRange ? (begin = input.selectionStart,
                end = input.selectionEnd) : window.getSelection ? (range = window.getSelection().getRangeAt(0),
            (range.commonAncestorContainer.parentNode === input || range.commonAncestorContainer === input) && (begin = range.startOffset,
                end = range.endOffset)) : document.selection && document.selection.createRange && (range = document.selection.createRange(),
                begin = 0 - range.duplicate().moveStart("character", -input.inputmask._valueGet().length),
                end = begin + range.text.length), {
                begin: translatePosition(begin),
                end: translatePosition(end)
            };
            begin = translatePosition(begin), end = translatePosition(end), end = "number" == typeof end ? end : begin;
            var scrollCalc = parseInt(((input.ownerDocument.defaultView || window).getComputedStyle ? (input.ownerDocument.defaultView || window).getComputedStyle(input, null) : input.currentStyle).fontSize) * end;
            if (input.scrollLeft = scrollCalc > input.scrollWidth ? scrollCalc : 0, mobile || opts.insertMode !== !1 || begin !== end || end++,
                input.setSelectionRange) input.selectionStart = begin, input.selectionEnd = end;
            else if (window.getSelection) {
                if (range = document.createRange(), void 0 === input.firstChild || null === input.firstChild) {
                    var textNode = document.createTextNode("");
                    input.appendChild(textNode);
                }
                range.setStart(input.firstChild, begin < input.inputmask._valueGet().length ? begin : input.inputmask._valueGet().length),
                    range.setEnd(input.firstChild, end < input.inputmask._valueGet().length ? end : input.inputmask._valueGet().length),
                    range.collapse(!0);
                var sel = window.getSelection();
                sel.removeAllRanges(), sel.addRange(range);
            } else input.createTextRange && (range = input.createTextRange(), range.collapse(!0),
                range.moveEnd("character", end), range.moveStart("character", begin), range.select());
        }

        function determineLastRequiredPosition(returnDefinition) {
            var pos, testPos, buffer = getBuffer(),
                bl = buffer.length,
                lvp = getLastValidPosition(),
                positions = {},
                lvTest = getMaskSet().validPositions[lvp],
                ndxIntlzr = void 0 !== lvTest ? lvTest.locator.slice() : void 0;
            for (pos = lvp + 1; pos < buffer.length; pos++) testPos = getTestTemplate(pos, ndxIntlzr, pos - 1),
                ndxIntlzr = testPos.locator.slice(), positions[pos] = $.extend(!0, {}, testPos);
            var lvTestAlt = lvTest && void 0 !== lvTest.alternation ? lvTest.locator[lvTest.alternation] : void 0;
            for (pos = bl - 1; pos > lvp && (testPos = positions[pos], (testPos.match.optionality || testPos.match.optionalQuantifier || lvTestAlt && (lvTestAlt !== positions[pos].locator[lvTest.alternation] && null != testPos.match.fn || null === testPos.match.fn && testPos.locator[lvTest.alternation] && checkAlternationMatch(testPos.locator[lvTest.alternation].toString().split(","), lvTestAlt.toString().split(",")) && "" !== getTests(pos)[0].def)) && buffer[pos] === getPlaceholder(pos, testPos.match)); pos--) bl--;
            return returnDefinition ? {
                l: bl,
                def: positions[bl] ? positions[bl].match : void 0
            } : bl;
        }

        function clearOptionalTail(buffer) {
            for (var rl = determineLastRequiredPosition(), lmib = buffer.length - 1; lmib > rl && !isMask(lmib); lmib--);
            return buffer.splice(rl, lmib + 1 - rl), buffer;
        }

        function isComplete(buffer) {
            if ($.isFunction(opts.isComplete)) return opts.isComplete(buffer, opts);
            if ("*" === opts.repeat) return void 0;
            var complete = !1,
                lrp = determineLastRequiredPosition(!0),
                aml = seekPrevious(lrp.l);
            if (void 0 === lrp.def || lrp.def.newBlockMarker || lrp.def.optionality || lrp.def.optionalQuantifier) {
                complete = !0;
                for (var i = 0; aml >= i; i++) {
                    var test = getTestTemplate(i).match;
                    if (null !== test.fn && void 0 === getMaskSet().validPositions[i] && test.optionality !== !0 && test.optionalQuantifier !== !0 || null === test.fn && buffer[i] !== getPlaceholder(i, test)) {
                        complete = !1;
                        break;
                    }
                }
            }
            return complete;
        }

        function patchValueProperty(npt) {
            function patchValhook(type) {
                if ($.valHooks && (void 0 === $.valHooks[type] || $.valHooks[type].inputmaskpatch !== !0)) {
                    var valhookGet = $.valHooks[type] && $.valHooks[type].get ? $.valHooks[type].get : function (elem) {
                            return elem.value;
                        },
                        valhookSet = $.valHooks[type] && $.valHooks[type].set ? $.valHooks[type].set : function (elem, value) {
                            return elem.value = value, elem;
                        };
                    $.valHooks[type] = {
                        get: function (elem) {
                            if (elem.inputmask) {
                                if (elem.inputmask.opts.autoUnmask) return elem.inputmask.unmaskedvalue();
                                var result = valhookGet(elem);
                                return -1 !== getLastValidPosition(void 0, void 0, elem.inputmask.maskset.validPositions) || opts.nullable !== !0 ? result : "";
                            }
                            return valhookGet(elem);
                        },
                        set: function (elem, value) {
                            var result, $elem = $(elem);
                            return result = valhookSet(elem, value), elem.inputmask && $elem.trigger("setvalue"),
                                result;
                        },
                        inputmaskpatch: !0
                    };
                }
            }

            function getter() {
                return this.inputmask ? this.inputmask.opts.autoUnmask ? this.inputmask.unmaskedvalue() : -1 !== getLastValidPosition() || opts.nullable !== !0 ? document.activeElement === this && opts.clearMaskOnLostFocus ? (isRTL ? clearOptionalTail(getBuffer().slice()).reverse() : clearOptionalTail(getBuffer().slice())).join("") : valueGet.call(this) : "" : valueGet.call(this);
            }

            function setter(value) {
                valueSet.call(this, value), this.inputmask && $(this).trigger("setvalue");
            }

            function installNativeValueSetFallback(npt) {
                EventRuler.on(npt, "mouseenter", function (event) {
                    var $input = $(this),
                        input = this,
                        value = input.inputmask._valueGet();
                    value !== getBuffer().join("") && $input.trigger("setvalue");
                });
            }
            var valueGet, valueSet;
            if (!npt.inputmask.__valueGet) {
                if (Object.getOwnPropertyDescriptor) {
                    "function" != typeof Object.getPrototypeOf && (Object.getPrototypeOf = "object" == typeof "test".__proto__ ? function (object) {
                        return object.__proto__;
                    } : function (object) {
                        return object.constructor.prototype;
                    });
                    var valueProperty = Object.getPrototypeOf ? Object.getOwnPropertyDescriptor(Object.getPrototypeOf(npt), "value") : void 0;
                    valueProperty && valueProperty.get && valueProperty.set ? (valueGet = valueProperty.get,
                        valueSet = valueProperty.set, Object.defineProperty(npt, "value", {
                        get: getter,
                        set: setter,
                        configurable: !0
                    })) : "INPUT" !== npt.tagName && (valueGet = function () {
                        return this.textContent;
                    }, valueSet = function (value) {
                        this.textContent = value;
                    }, Object.defineProperty(npt, "value", {
                        get: getter,
                        set: setter,
                        configurable: !0
                    }));
                } else document.__lookupGetter__ && npt.__lookupGetter__("value") && (valueGet = npt.__lookupGetter__("value"),
                    valueSet = npt.__lookupSetter__("value"), npt.__defineGetter__("value", getter),
                    npt.__defineSetter__("value", setter));
                npt.inputmask.__valueGet = valueGet, npt.inputmask._valueGet = function (overruleRTL) {
                    return isRTL && overruleRTL !== !0 ? valueGet.call(this.el).split("").reverse().join("") : valueGet.call(this.el);
                }, npt.inputmask.__valueSet = valueSet, npt.inputmask._valueSet = function (value, overruleRTL) {
                    valueSet.call(this.el, null === value || void 0 === value ? "" : overruleRTL !== !0 && isRTL ? value.split("").reverse().join("") : value);
                }, void 0 === valueGet && (valueGet = function () {
                    return this.value;
                }, valueSet = function (value) {
                    this.value = value;
                }, patchValhook(npt.type), installNativeValueSetFallback(npt));
            }
        }

        function handleRemove(input, k, pos, strict) {
            function generalize() {
                if (opts.keepStatic) {
                    resetMaskSet(!0);
                    var lastAlt, validInputs = [],
                        positionsClone = $.extend(!0, {}, getMaskSet().validPositions);
                    for (lastAlt = getLastValidPosition(); lastAlt >= 0; lastAlt--) {
                        var validPos = getMaskSet().validPositions[lastAlt];
                        if (validPos && (null != validPos.match.fn && validInputs.push(validPos.input),
                            delete getMaskSet().validPositions[lastAlt], void 0 !== validPos.alternation && validPos.locator[validPos.alternation] === getTestTemplate(lastAlt).locator[validPos.alternation])) break;
                    }
                    if (lastAlt > -1)
                        for (; validInputs.length > 0;) {
                            getMaskSet().p = seekNext(getLastValidPosition());
                            var keypress = new $.Event("keypress");
                            keypress.which = validInputs.pop().charCodeAt(0), keypressEvent.call(input, keypress, !0, !1, !1, getMaskSet().p);
                        } else getMaskSet().validPositions = $.extend(!0, {}, positionsClone);
                }
            }
            if ((opts.numericInput || isRTL) && (k === Inputmask.keyCode.BACKSPACE ? k = Inputmask.keyCode.DELETE : k === Inputmask.keyCode.DELETE && (k = Inputmask.keyCode.BACKSPACE),
                isRTL)) {
                var pend = pos.end;
                pos.end = pos.begin, pos.begin = pend;
            }
            k === Inputmask.keyCode.BACKSPACE && (pos.end - pos.begin < 1 || opts.insertMode === !1) ? (pos.begin = seekPrevious(pos.begin),
            void 0 === getMaskSet().validPositions[pos.begin] || getMaskSet().validPositions[pos.begin].input !== opts.groupSeparator && getMaskSet().validPositions[pos.begin].input !== opts.radixPoint || pos.begin--) : k === Inputmask.keyCode.DELETE && pos.begin === pos.end && (pos.end = isMask(pos.end) ? pos.end + 1 : seekNext(pos.end) + 1,
            void 0 === getMaskSet().validPositions[pos.begin] || getMaskSet().validPositions[pos.begin].input !== opts.groupSeparator && getMaskSet().validPositions[pos.begin].input !== opts.radixPoint || pos.end++),
                stripValidPositions(pos.begin, pos.end, !1, strict), strict !== !0 && generalize();
            var lvp = getLastValidPosition(pos.begin);
            lvp < pos.begin ? (-1 === lvp && resetMaskSet(), getMaskSet().p = seekNext(lvp)) : strict !== !0 && (getMaskSet().p = pos.begin);
        }

        function keydownEvent(ev) {
            var e = ev;
            var input = this,
                $input = $(input),
                k = e.keyCode,
                pos = caret(input);
            if (k === Inputmask.keyCode.BACKSPACE || k === Inputmask.keyCode.DELETE || iphone && k === Inputmask.keyCode.BACKSPACE_SAFARI || e.ctrlKey && k === Inputmask.keyCode.X && !isInputEventSupported("cut")) e.preventDefault(),
                handleRemove(input, k, pos), writeBuffer(input, getBuffer(), getMaskSet().p, e, undoValue !== getBuffer().join("")),
                input.inputmask._valueGet() === getBufferTemplate().join("") ? $input.trigger("cleared") : isComplete(getBuffer()) === !0 && $input.trigger("complete"),
            opts.showTooltip && (input.title = opts.tooltip || getMaskSet().mask);
            else if (k === Inputmask.keyCode.END || k === Inputmask.keyCode.PAGE_DOWN) {
                e.preventDefault();
                var caretPos = seekNext(getLastValidPosition());
                opts.insertMode || caretPos !== getMaskLength() || e.shiftKey || caretPos--, caret(input, e.shiftKey ? pos.begin : caretPos, caretPos, !0);
            } else k === Inputmask.keyCode.HOME && !e.shiftKey || k === Inputmask.keyCode.PAGE_UP ? (e.preventDefault(),
                caret(input, 0, e.shiftKey ? pos.begin : 0, !0)) : (opts.undoOnEscape && k === Inputmask.keyCode.ESCAPE || 90 === k && e.ctrlKey) && e.altKey !== !0 ? (checkVal(input, !0, !1, undoValue.split("")),
                $input.trigger("click")) : k !== Inputmask.keyCode.INSERT || e.shiftKey || e.ctrlKey ? opts.tabThrough === !0 && k === Inputmask.keyCode.TAB ? (e.shiftKey === !0 ? (null === getTest(pos.begin).fn && (pos.begin = seekNext(pos.begin)),
                pos.end = seekPrevious(pos.begin, !0), pos.begin = seekPrevious(pos.end, !0)) : (pos.begin = seekNext(pos.begin, !0),
                pos.end = seekNext(pos.begin, !0), pos.end < getMaskLength() && pos.end--), pos.begin < getMaskLength() && (e.preventDefault(),
                caret(input, pos.begin, pos.end))) : opts.insertMode !== !1 || e.shiftKey || (k === Inputmask.keyCode.RIGHT ? setTimeout(function () {
                var caretPos = caret(input);
                caret(input, caretPos.begin);
            }, 0) : k === Inputmask.keyCode.LEFT && setTimeout(function () {
                var caretPos = caret(input);
                caret(input, isRTL ? caretPos.begin + 1 : caretPos.begin - 1);
            }, 0)) : (opts.insertMode = !opts.insertMode, caret(input, opts.insertMode || pos.begin !== getMaskLength() ? pos.begin : pos.begin - 1));
            opts.onKeyDown.call(this, e, getBuffer(), caret(input).begin, opts), ignorable = -1 !== $.inArray(k, opts.ignorables);
        }

        function keypressEvent(ev, checkval, writeOut, strict, ndx) {
            var e = ev;
            var input = this,
                $input = $(input),
                k = e.which || e.charCode || e.keyCode;
            if (!(checkval === !0 || e.ctrlKey && e.altKey) && (e.ctrlKey || e.metaKey || ignorable)) return k === Inputmask.keyCode.ENTER && undoValue !== getBuffer().join("") && (undoValue = getBuffer().join(""),
                setTimeout(function () {
                    $input.trigger("change");
                }, 0)), !0;
            if (k) {
                46 === k && e.shiftKey === !1 && "," === opts.radixPoint && (k = 44);
                var forwardPosition, pos = checkval ? {
                        begin: ndx,
                        end: ndx
                    } : caret(input),
                    c = String.fromCharCode(k);
                getMaskSet().writeOutBuffer = !0;
                var valResult = isValid(pos, c, strict);
                if (valResult !== !1) {
                    var p = valResult.pos;
                    if (resetMaskSet(!0), void 0 !== valResult.caret) forwardPosition = valResult.caret;
                    else {
                        var vps = getMaskSet().validPositions;
                        forwardPosition = !opts.keepStatic && (void 0 !== vps[p + 1] && getTests(p + 1, vps[p].locator.slice(), p).length > 1 || void 0 !== vps[p].alternation) ? p + 1 : seekNext(p);
                    }
                    getMaskSet().p = forwardPosition;
                }
                if (writeOut !== !1) {
                    var self = this;
                    if (setTimeout(function () {
                        opts.onKeyValidation.call(self, k, valResult, opts);
                    }, 0), getMaskSet().writeOutBuffer && valResult !== !1) {
                        var buffer = getBuffer();
                        writeBuffer(input, buffer, opts.numericInput && void 0 === valResult.caret ? seekPrevious(forwardPosition) : forwardPosition, e, checkval !== !0),
                        checkval !== !0 && setTimeout(function () {
                            isComplete(buffer) === !0 && $input.trigger("complete");
                        }, 0);
                    }
                }
                if (opts.showTooltip && (input.title = opts.tooltip || getMaskSet().mask), e.preventDefault(),
                    checkval) return valResult.forwardPosition = forwardPosition, valResult;
            }
        }

        function pasteEvent(ev) {
            var e = ev;
            var tempValue, input = this,
                ev = e.originalEvent || e,
                $input = $(input),
                inputValue = input.inputmask._valueGet(!0),
                caretPos = caret(input);
            isRTL && (tempValue = caretPos.end, caretPos.end = caretPos.begin, caretPos.begin = tempValue);
            var valueBeforeCaret = inputValue.substr(0, caretPos.begin),
                valueAfterCaret = inputValue.substr(caretPos.end, inputValue.length);
            valueBeforeCaret === (isRTL ? getBufferTemplate().reverse() : getBufferTemplate()).slice(0, caretPos.begin).join("") && (valueBeforeCaret = ""),
            valueAfterCaret === (isRTL ? getBufferTemplate().reverse() : getBufferTemplate()).slice(caretPos.end).join("") && (valueAfterCaret = ""),
            isRTL && (tempValue = valueBeforeCaret, valueBeforeCaret = valueAfterCaret, valueAfterCaret = tempValue),
                window.clipboardData && window.clipboardData.getData ? inputValue = valueBeforeCaret + window.clipboardData.getData("Text") + valueAfterCaret : ev.clipboardData && ev.clipboardData.getData && (inputValue = valueBeforeCaret + ev.clipboardData.getData("text/plain") + valueAfterCaret);
            var pasteValue = inputValue;
            if ($.isFunction(opts.onBeforePaste)) {
                if (pasteValue = opts.onBeforePaste(inputValue, opts), pasteValue === !1) return e.preventDefault();
                pasteValue || (pasteValue = inputValue);
            }
            return checkVal(input, !1, !1, isRTL ? pasteValue.split("").reverse() : pasteValue.toString().split("")),
                writeBuffer(input, getBuffer(), seekNext(getLastValidPosition()), e, !0), isComplete(getBuffer()) === !0 && $input.trigger("complete"),
                e.preventDefault();
        }

        function inputFallBackEvent(ev) {
            var e = ev;
            var input = this,
                inputValue = input.inputmask._valueGet();
            if (getBuffer().join("") !== inputValue) {
                var caretPos = caret(input);
                if (inputValue = inputValue.replace(new RegExp("(" + Inputmask.escapeRegex(getBufferTemplate().join("")) + ")*"), ""),
                    iemobile) {
                    var inputChar = inputValue.replace(getBuffer().join(""), "");
                    if (1 === inputChar.length) {
                        var keypress = new $.Event("keypress");
                        return keypress.which = inputChar.charCodeAt(0), keypressEvent.call(input, keypress, !0, !0, !1, getMaskSet().validPositions[caretPos.begin - 1] ? caretPos.begin : caretPos.begin - 1),
                            !1;
                    }
                }
                if (caretPos.begin > inputValue.length && (caret(input, inputValue.length), caretPos = caret(input)),
                getBuffer().length - inputValue.length !== 1 || inputValue.charAt(caretPos.begin) === getBuffer()[caretPos.begin] || inputValue.charAt(caretPos.begin + 1) === getBuffer()[caretPos.begin] || isMask(caretPos.begin)) {
                    for (var lvp = getLastValidPosition() + 1, bufferTemplate = getBuffer().slice(lvp).join(""); null === inputValue.match(Inputmask.escapeRegex(bufferTemplate) + "$");) bufferTemplate = bufferTemplate.slice(1);
                    inputValue = inputValue.replace(bufferTemplate, ""), inputValue = inputValue.split(""),
                        checkVal(input, !0, !1, inputValue), isComplete(getBuffer()) === !0 && $(input).trigger("complete");
                } else e.keyCode = Inputmask.keyCode.BACKSPACE, keydownEvent.call(input, e);
                e.preventDefault();
            }
        }

        function setValueEvent(ev) {
            var e = ev;
            var input = this,
                value = input.inputmask._valueGet();
            checkVal(input, !0, !1, ($.isFunction(opts.onBeforeMask) ? opts.onBeforeMask(value, opts) || value : value).split("")),
                undoValue = getBuffer().join(""), (opts.clearMaskOnLostFocus || opts.clearIncomplete) && input.inputmask._valueGet() === getBufferTemplate().join("") && input.inputmask._valueSet("");
        }

        function focusEvent(ev) {
            var e = ev;
            var input = this,
                nptValue = input.inputmask._valueGet();
            opts.showMaskOnFocus && (!opts.showMaskOnHover || opts.showMaskOnHover && "" === nptValue) ? input.inputmask._valueGet() !== getBuffer().join("") && writeBuffer(input, getBuffer(), seekNext(getLastValidPosition())) : mouseEnter === !1 && caret(input, seekNext(getLastValidPosition())),
            opts.positionCaretOnTab === !0 && setTimeout(function () {
                caret(input, seekNext(getLastValidPosition()));
            }, 0), undoValue = getBuffer().join("");
        }

        function mouseleaveEvent(ev) {
            var e = ev;
            var input = this;
            if (mouseEnter = !1, opts.clearMaskOnLostFocus && document.activeElement !== input) {
                var buffer = getBuffer().slice(),
                    nptValue = input.inputmask._valueGet();
                nptValue !== input.getAttribute("placeholder") && "" !== nptValue && (-1 === getLastValidPosition() && nptValue === getBufferTemplate().join("") ? buffer = [] : clearOptionalTail(buffer),
                    writeBuffer(input, buffer));
            }
        }

        function clickEvent(ev) {
            var e = ev;

            function doRadixFocus(clickPos) {
                if (opts.radixFocus && "" !== opts.radixPoint) {
                    var vps = getMaskSet().validPositions;
                    if (void 0 === vps[clickPos] || vps[clickPos].input === getPlaceholder(clickPos)) {
                        if (clickPos < seekNext(-1)) return !0;
                        var radixPos = $.inArray(opts.radixPoint, getBuffer());
                        if (-1 !== radixPos) {
                            for (var vp in vps)
                                if (vp > radixPos && vps[vp].input !== getPlaceholder(vp)) return !1;
                            return !0;
                        }
                    }
                }
                return !1;
            }
            var input = this;
            setTimeout(function () {
                if (document.activeElement === input) {
                    var selectedCaret = caret(input);
                    if (selectedCaret.begin === selectedCaret.end)
                        if (doRadixFocus(selectedCaret.begin)) caret(input, opts.numericInput ? seekNext($.inArray(opts.radixPoint, getBuffer())) : $.inArray(opts.radixPoint, getBuffer()));
                        else {
                            var clickPosition = selectedCaret.begin,
                                lvclickPosition = getLastValidPosition(clickPosition, !0),
                                lastPosition = seekNext(lvclickPosition);
                            if (lastPosition > clickPosition) caret(input, isMask(clickPosition) || isMask(clickPosition - 1) ? clickPosition : seekNext(clickPosition));
                            else {
                                var placeholder = getPlaceholder(lastPosition);
                                ("" !== placeholder && getBuffer()[lastPosition] !== placeholder || !isMask(lastPosition, !0) && getTest(lastPosition).def === placeholder) && (lastPosition = seekNext(lastPosition)),
                                    caret(input, lastPosition);
                            }
                        }
                }
            }, 0);
        }

        function dblclickEvent(ev) {
            var e = ev;
            var input = this;
            setTimeout(function () {
                caret(input, 0, seekNext(getLastValidPosition()));
            }, 0);
        }

        function cutEvent(ev) {
            var e = ev;
            var input = this,
                $input = $(input),
                pos = caret(input),
                ev = e.originalEvent || e,
                clipboardData = window.clipboardData || ev.clipboardData,
                clipData = isRTL ? getBuffer().slice(pos.end, pos.begin) : getBuffer().slice(pos.begin, pos.end);
            clipboardData.setData("text", isRTL ? clipData.reverse().join("") : clipData.join("")),
            document.execCommand && document.execCommand("copy"), handleRemove(input, Inputmask.keyCode.DELETE, pos),
                writeBuffer(input, getBuffer(), getMaskSet().p, e, undoValue !== getBuffer().join("")),
            input.inputmask._valueGet() === getBufferTemplate().join("") && $input.trigger("cleared"),
            opts.showTooltip && (input.title = opts.tooltip || getMaskSet().mask);
        }

        function blurEvent(ev) {
            var e = ev;
            var $input = $(this),
                input = this;
            if (input.inputmask) {
                var nptValue = input.inputmask._valueGet(),
                    buffer = getBuffer().slice();
                undoValue !== buffer.join("") && setTimeout(function () {
                    $input.trigger("change"), undoValue = buffer.join("");
                }, 0), "" !== nptValue && (opts.clearMaskOnLostFocus && (-1 === getLastValidPosition() && nptValue === getBufferTemplate().join("") ? buffer = [] : clearOptionalTail(buffer)),
                isComplete(buffer) === !1 && (setTimeout(function () {
                    $input.trigger("incomplete");
                }, 0), opts.clearIncomplete && (resetMaskSet(), buffer = opts.clearMaskOnLostFocus ? [] : getBufferTemplate().slice())),
                    writeBuffer(input, buffer, void 0, e));
            }
        }

        function mouseenterEvent(ev) {
            var e = ev;
            var input = this;
            mouseEnter = !0, document.activeElement !== input && opts.showMaskOnHover && input.inputmask._valueGet() !== getBuffer().join("") && writeBuffer(input, getBuffer());
        }

        function submitEvent(ev) {
            var e = ev;
            undoValue !== getBuffer().join("") && $el.trigger("change"), opts.clearMaskOnLostFocus && -1 === getLastValidPosition() && el.inputmask._valueGet && el.inputmask._valueGet() === getBufferTemplate().join("") && el.inputmask._valueSet(""),
            opts.removeMaskOnSubmit && (el.inputmask._valueSet(el.inputmask.unmaskedvalue(), !0),
                setTimeout(function () {
                    writeBuffer(el, getBuffer());
                }, 0));
        }

        function resetEvent(ev) {
            var e = ev;
            setTimeout(function () {
                $el.trigger("setvalue");
            }, 0);
        }

        function compositionstartEvent(ev) {
            //中文输入开始
            opts.lock_input = true;
        }

        function compositionendEvent(ev) {
            //中文输入结束
            opts.lock_input = false;
            var e = ev;
            var that = this;
            if(!opts.lock_input){
                inputFallBackEvent.apply(that, arguments);
            }
        }

        function inputHelper(ev) {
            var e = ev;
            var that = this;
            if(!opts.lock_input){
                inputFallBackEvent.apply(that, arguments);
            }
        }


        function mask(elem) {
            if (el = elem, $el = $(el), opts.showTooltip && (el.title = opts.tooltip || getMaskSet().mask),
            ("rtl" === el.dir || opts.rightAlign) && (el.style.textAlign = "right"), ("rtl" === el.dir || opts.numericInput) && (el.dir = "ltr",
                el.removeAttribute("dir"), el.inputmask.isRTL = !0, isRTL = !0), EventRuler.off(el),
                patchValueProperty(el), isElementTypeSupported(el, opts) && (EventRuler.on(el, "submit", submitEvent),
                EventRuler.on(el, "reset", resetEvent), EventRuler.on(el, "mouseenter", mouseenterEvent),
                EventRuler.on(el, "blur", blurEvent), EventRuler.on(el, "focus", focusEvent), EventRuler.on(el, "mouseleave", mouseleaveEvent),
                EventRuler.on(el, "click", clickEvent), EventRuler.on(el, "dblclick", dblclickEvent),
                EventRuler.on(el, "paste", pasteEvent), EventRuler.on(el, "dragdrop", pasteEvent),
                EventRuler.on(el, "drop", pasteEvent), EventRuler.on(el, "cut", cutEvent), EventRuler.on(el, "complete", opts.oncomplete),
                EventRuler.on(el, "incomplete", opts.onincomplete),
                EventRuler.on(el, "cleared", opts.oncleared),
                EventRuler.on(el, "compositionstart", compositionstartEvent),
                EventRuler.on(el, "compositionend", compositionendEvent),
                EventRuler.on(el, "keydown", keydownEvent),
                EventRuler.on(el, "keypress", keypressEvent),
                EventRuler.on(el, "input", inputHelper),
                EventRuler.on(el, "setvalue", setValueEvent)),
            "" !== el.inputmask._valueGet() || opts.clearMaskOnLostFocus === !1 || document.activeElement === el) {
                var initialValue = $.isFunction(opts.onBeforeMask) ? opts.onBeforeMask(el.inputmask._valueGet(), opts) || el.inputmask._valueGet() : el.inputmask._valueGet();
                checkVal(el, !0, !1, initialValue.split(""));
                var buffer = getBuffer().slice();
                undoValue = buffer.join(""), isComplete(buffer) === !1 && opts.clearIncomplete && resetMaskSet(),
                opts.clearMaskOnLostFocus && document.activeElement !== el && (-1 === getLastValidPosition() ? buffer = [] : clearOptionalTail(buffer)),
                    writeBuffer(el, buffer), document.activeElement === el && caret(el, seekNext(getLastValidPosition()));
            }
        }
        var undoValue, el, $el, maxLength, valueBuffer, isRTL = !1,
            skipKeyPressEvent = !1,
            skipInputEvent = !1,
            ignorable = !1,
            mouseEnter = !0,
            EventRuler = {
                on: function (input, eventName, eventHandler) {
                    var ev = function (el) {
                        e = el;
                        if (void 0 === this.inputmask && "FORM" !== this.nodeName) {
                            var imOpts = $.data(this, "_inputmask_opts");
                            imOpts ? new Inputmask(imOpts).mask(this) : EventRuler.off(this);
                        } else {
                            if ("setvalue" === e.type || !(this.disabled || this.readOnly && !("keydown" === e.type && e.ctrlKey && 67 === e.keyCode || opts.tabThrough === !1 && e.keyCode === Inputmask.keyCode.TAB))) {
                                switch (e.type) {
                                    case "input":
                                        if (skipInputEvent === !0) return skipInputEvent = !1, e.preventDefault();
                                        break;

                                    case "keydown":
                                        skipKeyPressEvent = !1, skipInputEvent = !1;

                                        break;

                                    case "keypress":
                                        if (skipKeyPressEvent === !0) return e.preventDefault();
                                        skipKeyPressEvent = !0;
                                        break;

                                    case "click":
                                        // if (iemobile) {
                                        var that = this;
                                        return setTimeout(function () {
                                            eventHandler.apply(that, arguments);
                                        }, 0), !1;
                                    // }
                                }
                                var returnVal = eventHandler.apply(this, arguments);
                                return returnVal === !1 && (e.preventDefault(), e.stopPropagation()), returnVal;
                            }
                            e.preventDefault();
                        }
                    };
                    input.inputmask.events[eventName] = input.inputmask.events[eventName] || [], input.inputmask.events[eventName].push(ev),
                        -1 !== $.inArray(eventName, ["submit", "reset"]) ? null != input.form && $(input.form).on(eventName, ev) : $(input).on(eventName, ev);
                },
                off: function (input, event) {
                    if (input.inputmask && input.inputmask.events) {
                        var events;
                        event ? (events = [], events[event] = input.inputmask.events[event]) : events = input.inputmask.events,
                            $.each(events, function (eventName, evArr) {
                                for (; evArr.length > 0;) {
                                    var ev = evArr.pop(); -
                                        1 !== $.inArray(eventName, ["submit", "reset"]) ? null != input.form && $(input.form).off(eventName, ev) : $(input).off(eventName, ev);
                                }
                                delete input.inputmask.events[eventName];
                            });
                    }
                }
            };
        if (void 0 !== actionObj) switch (actionObj.action) {
            case "isComplete":
                return el = actionObj.el, isComplete(getBuffer());

            case "unmaskedvalue":
                return el = actionObj.el, void 0 !== el && void 0 !== el.inputmask ? (maskset = el.inputmask.maskset,
                    opts = el.inputmask.opts, isRTL = el.inputmask.isRTL) : (valueBuffer = actionObj.value,
                opts.numericInput && (isRTL = !0), valueBuffer = ($.isFunction(opts.onBeforeMask) ? opts.onBeforeMask(valueBuffer, opts) || valueBuffer : valueBuffer).split(""),
                    checkVal(void 0, !1, !1, isRTL ? valueBuffer.reverse() : valueBuffer), $.isFunction(opts.onBeforeWrite) && opts.onBeforeWrite(void 0, getBuffer(), 0, opts)),
                    unmaskedvalue(el);

            case "mask":
                el = actionObj.el, maskset = el.inputmask.maskset, opts = el.inputmask.opts, isRTL = el.inputmask.isRTL,
                    undoValue = getBuffer().join(""), mask(el);
                break;

            case "format":
                return opts.numericInput && (isRTL = !0), valueBuffer = ($.isFunction(opts.onBeforeMask) ? opts.onBeforeMask(actionObj.value, opts) || actionObj.value : actionObj.value).split(""),
                    checkVal(void 0, !1, !1, isRTL ? valueBuffer.reverse() : valueBuffer), $.isFunction(opts.onBeforeWrite) && opts.onBeforeWrite(void 0, getBuffer(), 0, opts),
                    actionObj.metadata ? {
                        value: isRTL ? getBuffer().slice().reverse().join("") : getBuffer().join(""),
                        metadata: maskScope({
                            action: "getmetadata"
                        }, maskset, opts)
                    } : isRTL ? getBuffer().slice().reverse().join("") : getBuffer().join("");

            case "isValid":
                opts.numericInput && (isRTL = !0), actionObj.value ? (valueBuffer = actionObj.value.split(""),
                    checkVal(void 0, !1, !0, isRTL ? valueBuffer.reverse() : valueBuffer)) : actionObj.value = getBuffer().join("");
                for (var buffer = getBuffer(), rl = determineLastRequiredPosition(), lmib = buffer.length - 1; lmib > rl && !isMask(lmib); lmib--);
                return buffer.splice(rl, lmib + 1 - rl), isComplete(buffer) && actionObj.value === getBuffer().join("");

            case "getemptymask":
                return getBufferTemplate().join("");

            case "remove":
                el = actionObj.el, $el = $(el), maskset = el.inputmask.maskset, opts = el.inputmask.opts,
                    el.inputmask._valueSet(unmaskedvalue(el)), EventRuler.off(el);
                var valueProperty;
                Object.getOwnPropertyDescriptor && Object.getPrototypeOf ? (valueProperty = Object.getOwnPropertyDescriptor(Object.getPrototypeOf(el), "value"),
                valueProperty && el.inputmask.__valueGet && Object.defineProperty(el, "value", {
                    get: el.inputmask.__valueGet,
                    set: el.inputmask.__valueSet,
                    configurable: !0
                })) : document.__lookupGetter__ && el.__lookupGetter__("value") && el.inputmask.__valueGet && (el.__defineGetter__("value", el.inputmask.__valueGet),
                    el.__defineSetter__("value", el.inputmask.__valueSet)), el.inputmask = void 0;
                break;

            case "getmetadata":
                if ($.isArray(maskset.metadata)) {
                    for (var alternation, lvp = getLastValidPosition(void 0, !0), firstAlt = lvp; firstAlt >= 0; firstAlt--)
                        if (getMaskSet().validPositions[firstAlt] && void 0 !== getMaskSet().validPositions[firstAlt].alternation) {
                            alternation = getMaskSet().validPositions[firstAlt].alternation;
                            break;
                        }
                    return void 0 !== alternation ? maskset.metadata[getMaskSet().validPositions[firstAlt].locator[alternation]] : [];
                }
                return maskset.metadata;
        }
    }
    Inputmask.prototype = {
        defaults: {
            lock_input: false,
            placeholder: "_",
            optionalmarker: {
                start: "[",
                end: "]"
            },
            quantifiermarker: {
                start: "{",
                end: "}"
            },
            groupmarker: {
                start: "(",
                end: ")"
            },
            alternatormarker: "|",
            escapeChar: "\\",
            mask: null,
            oncomplete: $.noop,
            onincomplete: $.noop,
            oncleared: $.noop,
            repeat: 0,
            greedy: !0,
            autoUnmask: !1,
            removeMaskOnSubmit: !1,
            clearMaskOnLostFocus: !0,
            insertMode: !0,
            clearIncomplete: !1,
            aliases: {},
            alias: null,
            onKeyDown: $.noop,
            onBeforeMask: null,
            onBeforePaste: function (pastedValue, opts) {
                return $.isFunction(opts.onBeforeMask) ? opts.onBeforeMask(pastedValue, opts) : pastedValue;
            },
            onBeforeWrite: null,
            onUnMask: null,
            showMaskOnFocus: !0,
            showMaskOnHover: !0,
            onKeyValidation: $.noop,
            skipOptionalPartCharacter: " ",
            showTooltip: !1,
            tooltip: void 0,
            numericInput: !1,
            rightAlign: !1,
            undoOnEscape: !0,
            radixPoint: "",
            radixPointDefinitionSymbol: void 0,
            groupSeparator: "",
            radixFocus: !1,
            nojumps: !1,
            nojumpsThreshold: 0,
            keepStatic: null,
            positionCaretOnTab: !1,
            tabThrough: !1,
            supportsInputType: ["text", "tel", "password"],
            definitions: {
                "9": {
                    validator: "[0-9]",
                    cardinality: 1,
                    definitionSymbol: "*"
                },
                "a": {
                    validator: "[A-Za-z]",
                    cardinality: 1,
                    definitionSymbol: "*"
                },
                "*": {
                    validator: "[0-9A-Za-z\-\_\u4e00-\u9fa5]",
                    cardinality: 1
                }
            },
            ignorables: [8, 9, 13, 19, 27, 33, 34, 35, 36, 37, 38, 39, 40, 45, 46, 93, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123],
            isComplete: null,
            canClearPosition: $.noop,
            postValidation: null,
            staticDefinitionSymbol: void 0,
            jitMasking: !1,
            nullable: !0
        },
        masksCache: {},
        mask: function (elems) {
            var that = this;
            return "string" == typeof elems && (elems = document.getElementById(elems) || document.querySelectorAll(elems)),
                elems = elems.nodeName ? [elems] : elems, $.each(elems, function (ndx, el) {
                var scopedOpts = $.extend(!0, {}, that.opts);
                importAttributeOptions(el, scopedOpts, $.extend(!0, {}, that.userOptions));
                var maskset = generateMaskSet(scopedOpts, that.noMasksCache);
                void 0 !== maskset && (void 0 !== el.inputmask && el.inputmask.remove(), el.inputmask = new Inputmask(),
                    el.inputmask.opts = scopedOpts, el.inputmask.noMasksCache = that.noMasksCache, el.inputmask.userOptions = $.extend(!0, {}, that.userOptions),
                    el.inputmask.el = el, el.inputmask.maskset = maskset, el.inputmask.isRTL = !1, $.data(el, "_inputmask_opts", scopedOpts),
                    maskScope({
                        action: "mask",
                        el: el
                    }));
            }), elems && elems[0] ? elems[0].inputmask || this : this;
        },
        option: function (options, noremask) {
            return "string" == typeof options ? this.opts[options] : "object" == typeof options ? ($.extend(this.userOptions, options),
            this.el && noremask !== !0 && this.mask(this.el), this) : void 0;
        },
        unmaskedvalue: function (value) {
            return maskScope({
                action: "unmaskedvalue",
                el: this.el,
                value: value
            }, this.el && this.el.inputmask ? this.el.inputmask.maskset : generateMaskSet(this.opts, this.noMasksCache), this.opts);
        },
        remove: function () {
            return this.el ? (maskScope({
                action: "remove",
                el: this.el
            }), this.el.inputmask = void 0, this.el) : void 0;
        },
        getemptymask: function () {
            return maskScope({
                action: "getemptymask"
            }, this.maskset || generateMaskSet(this.opts, this.noMasksCache), this.opts);
        },
        hasMaskedValue: function () {
            return !this.opts.autoUnmask;
        },
        isComplete: function () {
            return maskScope({
                action: "isComplete",
                el: this.el
            }, this.maskset || generateMaskSet(this.opts, this.noMasksCache), this.opts);
        },
        getmetadata: function () {
            return maskScope({
                action: "getmetadata"
            }, this.maskset || generateMaskSet(this.opts, this.noMasksCache), this.opts);
        },
        isValid: function (value) {
            return maskScope({
                action: "isValid",
                value: value
            }, this.maskset || generateMaskSet(this.opts, this.noMasksCache), this.opts);
        },
        format: function (value, metadata) {
            return maskScope({
                action: "format",
                value: value,
                metadata: metadata
            }, this.maskset || generateMaskSet(this.opts, this.noMasksCache), this.opts);
        }
    }, Inputmask.extendDefaults = function (options) {
        $.extend(!0, Inputmask.prototype.defaults, options);
    }, Inputmask.extendDefinitions = function (definition) {
        $.extend(!0, Inputmask.prototype.defaults.definitions, definition);
    }, Inputmask.extendAliases = function (alias) {
        $.extend(!0, Inputmask.prototype.defaults.aliases, alias);
    }, Inputmask.format = function (value, options, metadata) {
        return Inputmask(options).format(value, metadata);
    }, Inputmask.unmask = function (value, options) {
        return Inputmask(options).unmaskedvalue(value);
    }, Inputmask.isValid = function (value, options) {
        return Inputmask(options).isValid(value);
    }, Inputmask.remove = function (elems) {
        $.each(elems, function (ndx, el) {
            el.inputmask && el.inputmask.remove();
        });
    }, Inputmask.escapeRegex = function (str) {
        var specials = ["/", ".", "*", "+", "?", "|", "(", ")", "[", "]", "{", "}", "\\", "$", "^"];
        return str.replace(new RegExp("(\\" + specials.join("|\\") + ")", "gim"), "\\$1");
    }, Inputmask.keyCode = {
        ALT: 18,
        BACKSPACE: 8,
        BACKSPACE_SAFARI: 127,
        CAPS_LOCK: 20,
        COMMA: 188,
        COMMAND: 91,
        COMMAND_LEFT: 91,
        COMMAND_RIGHT: 93,
        CONTROL: 17,
        DELETE: 46,
        DOWN: 40,
        END: 35,
        ENTER: 13,
        ESCAPE: 27,
        HOME: 36,
        INSERT: 45,
        LEFT: 37,
        MENU: 93,
        NUMPAD_ADD: 107,
        NUMPAD_DECIMAL: 110,
        NUMPAD_DIVIDE: 111,
        NUMPAD_ENTER: 108,
        NUMPAD_MULTIPLY: 106,
        NUMPAD_SUBTRACT: 109,
        PAGE_DOWN: 34,
        PAGE_UP: 33,
        PERIOD: 190,
        RIGHT: 39,
        SHIFT: 16,
        SPACE: 32,
        TAB: 9,
        UP: 38,
        WINDOWS: 91,
        X: 88
    };
    var ua = navigator.userAgent,
        mobile = /mobile/i.test(ua),
        iemobile = /iemobile/i.test(ua),
        iphone = /iphone/i.test(ua) && !iemobile;
    /android.*safari.*/i.test(ua) && !iemobile;
    return window.Inputmask = Inputmask, Inputmask;
}(jQuery),
    function ($, Inputmask) {
        return void 0 === $.fn.inputmask && ($.fn.inputmask = function (fn, options) {
            var nptmask, input = this[0];
            if (void 0 === options && (options = {}), "string" == typeof fn) switch (fn) {
                case "unmaskedvalue":
                    return input && input.inputmask ? input.inputmask.unmaskedvalue() : $(input).val();

                case "remove":
                    return this.each(function () {
                        this.inputmask && this.inputmask.remove();
                    });

                case "getemptymask":
                    return input && input.inputmask ? input.inputmask.getemptymask() : "";

                case "hasMaskedValue":
                    return input && input.inputmask ? input.inputmask.hasMaskedValue() : !1;

                case "isComplete":
                    return input && input.inputmask ? input.inputmask.isComplete() : !0;

                case "getmetadata":
                    return input && input.inputmask ? input.inputmask.getmetadata() : void 0;

                case "setvalue":
                    $(input).val(options), input && void 0 !== input.inputmask && $(input).triggerHandler("setvalue");
                    break;

                case "option":
                    if ("string" != typeof options) return this.each(function () {
                        return void 0 !== this.inputmask ? this.inputmask.option(options) : void 0;
                    });
                    if (input && void 0 !== input.inputmask) return input.inputmask.option(options);
                    break;

                default:
                    return options.alias = fn, nptmask = new Inputmask(options), this.each(function () {
                        nptmask.mask(this);
                    });
            } else {
                if ("object" == typeof fn) return nptmask = new Inputmask(fn), void 0 === fn.mask && void 0 === fn.alias ? this.each(function () {
                    return void 0 !== this.inputmask ? this.inputmask.option(fn) : void nptmask.mask(this);
                }) : this.each(function () {
                    nptmask.mask(this);
                });
                if (void 0 === fn) return this.each(function () {
                    nptmask = new Inputmask(options), nptmask.mask(this);
                });
            }
        }), $.fn.inputmask;
    }(jQuery, Inputmask),
    function ($, Inputmask) {
        return Inputmask.extendDefinitions({
            h: {
                validator: "[01][0-9]|2[0-3]",
                cardinality: 2,
                prevalidator: [{
                    validator: "[0-2]",
                    cardinality: 1
                }]
            },
            s: {
                validator: "[0-5][0-9]",
                cardinality: 2,
                prevalidator: [{
                    validator: "[0-5]",
                    cardinality: 1
                }]
            },
            d: {
                validator: "0[1-9]|[12][0-9]|3[01]",
                cardinality: 2,
                prevalidator: [{
                    validator: "[0-3]",
                    cardinality: 1
                }]
            },
            m: {
                validator: "0[1-9]|1[012]",
                cardinality: 2,
                prevalidator: [{
                    validator: "[01]",
                    cardinality: 1
                }]
            },
            y: {
                validator: "(19|20)\\d{2}",
                cardinality: 4,
                prevalidator: [{
                    validator: "[12]",
                    cardinality: 1
                }, {
                    validator: "(19|20)",
                    cardinality: 2
                }, {
                    validator: "(19|20)\\d",
                    cardinality: 3
                }]
            }
        }), Inputmask.extendAliases({
            "dd/mm/yyyy": {
                mask: "1/2/y",
                placeholder: "dd/mm/yyyy",
                regex: {
                    val1pre: new RegExp("[0-3]"),
                    val1: new RegExp("0[1-9]|[12][0-9]|3[01]"),
                    val2pre: function (separator) {
                        var escapedSeparator = Inputmask.escapeRegex.call(this, separator);
                        return new RegExp("((0[1-9]|[12][0-9]|3[01])" + escapedSeparator + "[01])");
                    },
                    val2: function (separator) {
                        var escapedSeparator = Inputmask.escapeRegex.call(this, separator);
                        return new RegExp("((0[1-9]|[12][0-9])" + escapedSeparator + "(0[1-9]|1[012]))|(30" + escapedSeparator + "(0[13-9]|1[012]))|(31" + escapedSeparator + "(0[13578]|1[02]))");
                    }
                },
                leapday: "29/02/",
                separator: "/",
                yearrange: {
                    minyear: 1900,
                    maxyear: 2099
                },
                isInYearRange: function (chrs, minyear, maxyear) {
                    if (isNaN(chrs)) return !1;
                    var enteredyear = parseInt(chrs.concat(minyear.toString().slice(chrs.length))),
                        enteredyear2 = parseInt(chrs.concat(maxyear.toString().slice(chrs.length)));
                    return (isNaN(enteredyear) ? !1 : enteredyear >= minyear && maxyear >= enteredyear) || (isNaN(enteredyear2) ? !1 : enteredyear2 >= minyear && maxyear >= enteredyear2);
                },
                determinebaseyear: function (minyear, maxyear, hint) {
                    var currentyear = new Date().getFullYear();
                    if (minyear > currentyear) return minyear;
                    if (currentyear > maxyear) {
                        for (var maxYearPrefix = maxyear.toString().slice(0, 2), maxYearPostfix = maxyear.toString().slice(2, 4); maxYearPrefix + hint > maxyear;) maxYearPrefix--;
                        var maxxYear = maxYearPrefix + maxYearPostfix;
                        return minyear > maxxYear ? minyear : maxxYear;
                    }
                    if (currentyear >= minyear && maxyear >= currentyear) {
                        for (var currentYearPrefix = currentyear.toString().slice(0, 2); currentYearPrefix + hint > maxyear;) currentYearPrefix--;
                        var currentYearAndHint = currentYearPrefix + hint;
                        return minyear > currentYearAndHint ? minyear : currentYearAndHint;
                    }
                    return currentyear;
                },
                onKeyDown: function (e, buffer, caretPos, opts) {
                    var $input = $(this);
                    if (e.ctrlKey && e.keyCode === Inputmask.keyCode.RIGHT) {
                        var today = new Date();
                        $input.val(today.getDate().toString() + (today.getMonth() + 1).toString() + today.getFullYear().toString()),
                            $input.trigger("setvalue");
                    }
                },
                getFrontValue: function (mask, buffer, opts) {
                    for (var start = 0, length = 0, i = 0; i < mask.length && "2" !== mask.charAt(i); i++) {
                        var definition = opts.definitions[mask.charAt(i)];
                        definition ? (start += length, length = definition.cardinality) : length++;
                    }
                    return buffer.join("").substr(start, length);
                },
                definitions: {
                    "1": {
                        validator: function (chrs, maskset, pos, strict, opts) {
                            var isValid = opts.regex.val1.test(chrs);
                            return strict || isValid || chrs.charAt(1) !== opts.separator && -1 === "-./".indexOf(chrs.charAt(1)) || !(isValid = opts.regex.val1.test("0" + chrs.charAt(0))) ? isValid : (maskset.buffer[pos - 1] = "0", {
                                refreshFromBuffer: {
                                    start: pos - 1,
                                    end: pos
                                },
                                pos: pos,
                                c: chrs.charAt(0)
                            });
                        },
                        cardinality: 2,
                        prevalidator: [{
                            validator: function (chrs, maskset, pos, strict, opts) {
                                var pchrs = chrs;
                                isNaN(maskset.buffer[pos + 1]) || (pchrs += maskset.buffer[pos + 1]);
                                var isValid = 1 === pchrs.length ? opts.regex.val1pre.test(pchrs) : opts.regex.val1.test(pchrs);
                                if (!strict && !isValid) {
                                    if (isValid = opts.regex.val1.test(chrs + "0")) return maskset.buffer[pos] = chrs,
                                        maskset.buffer[++pos] = "0", {
                                        pos: pos,
                                        c: "0"
                                    };
                                    if (isValid = opts.regex.val1.test("0" + chrs)) return maskset.buffer[pos] = "0",
                                        pos++, {
                                        pos: pos
                                    };
                                }
                                return isValid;
                            },
                            cardinality: 1
                        }]
                    },
                    "2": {
                        validator: function (chrs, maskset, pos, strict, opts) {
                            var frontValue = opts.getFrontValue(maskset.mask, maskset.buffer, opts); -
                                1 !== frontValue.indexOf(opts.placeholder[0]) && (frontValue = "01" + opts.separator);
                            var isValid = opts.regex.val2(opts.separator).test(frontValue + chrs);
                            if (!strict && !isValid && (chrs.charAt(1) === opts.separator || -1 !== "-./".indexOf(chrs.charAt(1))) && (isValid = opts.regex.val2(opts.separator).test(frontValue + "0" + chrs.charAt(0)))) return maskset.buffer[pos - 1] = "0", {
                                refreshFromBuffer: {
                                    start: pos - 1,
                                    end: pos
                                },
                                pos: pos,
                                c: chrs.charAt(0)
                            };
                            if (opts.mask.indexOf("2") === opts.mask.length - 1 && isValid) {
                                var dayMonthValue = maskset.buffer.join("").substr(4, 4) + chrs;
                                if (dayMonthValue !== opts.leapday) return !0;
                                var year = parseInt(maskset.buffer.join("").substr(0, 4), 10);
                                return year % 4 === 0 ? year % 100 === 0 ? year % 400 === 0 ? !0 : !1 : !0 : !1;
                            }
                            return isValid;
                        },
                        cardinality: 2,
                        prevalidator: [{
                            validator: function (chrs, maskset, pos, strict, opts) {
                                isNaN(maskset.buffer[pos + 1]) || (chrs += maskset.buffer[pos + 1]);
                                var frontValue = opts.getFrontValue(maskset.mask, maskset.buffer, opts); -
                                    1 !== frontValue.indexOf(opts.placeholder[0]) && (frontValue = "01" + opts.separator);
                                var isValid = 1 === chrs.length ? opts.regex.val2pre(opts.separator).test(frontValue + chrs) : opts.regex.val2(opts.separator).test(frontValue + chrs);
                                return strict || isValid || !(isValid = opts.regex.val2(opts.separator).test(frontValue + "0" + chrs)) ? isValid : (maskset.buffer[pos] = "0",
                                    pos++, {
                                    pos: pos
                                });
                            },
                            cardinality: 1
                        }]
                    },
                    y: {
                        validator: function (chrs, maskset, pos, strict, opts) {
                            if (opts.isInYearRange(chrs, opts.yearrange.minyear, opts.yearrange.maxyear)) {
                                var dayMonthValue = maskset.buffer.join("").substr(0, 6);
                                if (dayMonthValue !== opts.leapday) return !0;
                                var year = parseInt(chrs, 10);
                                return year % 4 === 0 ? year % 100 === 0 ? year % 400 === 0 ? !0 : !1 : !0 : !1;
                            }
                            return !1;
                        },
                        cardinality: 4,
                        prevalidator: [{
                            validator: function (chrs, maskset, pos, strict, opts) {
                                var isValid = opts.isInYearRange(chrs, opts.yearrange.minyear, opts.yearrange.maxyear);
                                if (!strict && !isValid) {
                                    var yearPrefix = opts.determinebaseyear(opts.yearrange.minyear, opts.yearrange.maxyear, chrs + "0").toString().slice(0, 1);
                                    if (isValid = opts.isInYearRange(yearPrefix + chrs, opts.yearrange.minyear, opts.yearrange.maxyear)) return maskset.buffer[pos++] = yearPrefix.charAt(0), {
                                        pos: pos
                                    };
                                    if (yearPrefix = opts.determinebaseyear(opts.yearrange.minyear, opts.yearrange.maxyear, chrs + "0").toString().slice(0, 2),
                                        isValid = opts.isInYearRange(yearPrefix + chrs, opts.yearrange.minyear, opts.yearrange.maxyear)) return maskset.buffer[pos++] = yearPrefix.charAt(0),
                                        maskset.buffer[pos++] = yearPrefix.charAt(1), {
                                        pos: pos
                                    };
                                }
                                return isValid;
                            },
                            cardinality: 1
                        }, {
                            validator: function (chrs, maskset, pos, strict, opts) {
                                var isValid = opts.isInYearRange(chrs, opts.yearrange.minyear, opts.yearrange.maxyear);
                                if (!strict && !isValid) {
                                    var yearPrefix = opts.determinebaseyear(opts.yearrange.minyear, opts.yearrange.maxyear, chrs).toString().slice(0, 2);
                                    if (isValid = opts.isInYearRange(chrs[0] + yearPrefix[1] + chrs[1], opts.yearrange.minyear, opts.yearrange.maxyear)) return maskset.buffer[pos++] = yearPrefix.charAt(1), {
                                        pos: pos
                                    };
                                    if (yearPrefix = opts.determinebaseyear(opts.yearrange.minyear, opts.yearrange.maxyear, chrs).toString().slice(0, 2),
                                        opts.isInYearRange(yearPrefix + chrs, opts.yearrange.minyear, opts.yearrange.maxyear)) {
                                        var dayMonthValue = maskset.buffer.join("").substr(0, 6);
                                        if (dayMonthValue !== opts.leapday) isValid = !0;
                                        else {
                                            var year = parseInt(chrs, 10);
                                            isValid = year % 4 === 0 ? year % 100 === 0 ? year % 400 === 0 ? !0 : !1 : !0 : !1;
                                        }
                                    } else isValid = !1;
                                    if (isValid) return maskset.buffer[pos - 1] = yearPrefix.charAt(0), maskset.buffer[pos++] = yearPrefix.charAt(1),
                                        maskset.buffer[pos++] = chrs.charAt(0), {
                                        refreshFromBuffer: {
                                            start: pos - 3,
                                            end: pos
                                        },
                                        pos: pos
                                    };
                                }
                                return isValid;
                            },
                            cardinality: 2
                        }, {
                            validator: function (chrs, maskset, pos, strict, opts) {
                                return opts.isInYearRange(chrs, opts.yearrange.minyear, opts.yearrange.maxyear);
                            },
                            cardinality: 3
                        }]
                    }
                },
                insertMode: !1,
                autoUnmask: !1
            },
            "mm/dd/yyyy": {
                placeholder: "mm/dd/yyyy",
                alias: "dd/mm/yyyy",
                regex: {
                    val2pre: function (separator) {
                        var escapedSeparator = Inputmask.escapeRegex.call(this, separator);
                        return new RegExp("((0[13-9]|1[012])" + escapedSeparator + "[0-3])|(02" + escapedSeparator + "[0-2])");
                    },
                    val2: function (separator) {
                        var escapedSeparator = Inputmask.escapeRegex.call(this, separator);
                        return new RegExp("((0[1-9]|1[012])" + escapedSeparator + "(0[1-9]|[12][0-9]))|((0[13-9]|1[012])" + escapedSeparator + "30)|((0[13578]|1[02])" + escapedSeparator + "31)");
                    },
                    val1pre: new RegExp("[01]"),
                    val1: new RegExp("0[1-9]|1[012]")
                },
                leapday: "02/29/",
                onKeyDown: function (e, buffer, caretPos, opts) {
                    var $input = $(this);
                    if (e.ctrlKey && e.keyCode === Inputmask.keyCode.RIGHT) {
                        var today = new Date();
                        $input.val((today.getMonth() + 1).toString() + today.getDate().toString() + today.getFullYear().toString()),
                            $input.trigger("setvalue");
                    }
                }
            },
            "yyyy/mm/dd": {
                mask: "y/1/2",
                placeholder: "yyyy/mm/dd",
                alias: "mm/dd/yyyy",
                leapday: "/02/29",
                onKeyDown: function (e, buffer, caretPos, opts) {
                    var $input = $(this);
                    if (e.ctrlKey && e.keyCode === Inputmask.keyCode.RIGHT) {
                        var today = new Date();
                        $input.val(today.getFullYear().toString() + (today.getMonth() + 1).toString() + today.getDate().toString()),
                            $input.trigger("setvalue");
                    }
                }
            },
            "dd.mm.yyyy": {
                mask: "1.2.y",
                placeholder: "dd.mm.yyyy",
                leapday: "29.02.",
                separator: ".",
                alias: "dd/mm/yyyy"
            },
            "dd-mm-yyyy": {
                mask: "1-2-y",
                placeholder: "dd-mm-yyyy",
                leapday: "29-02-",
                separator: "-",
                alias: "dd/mm/yyyy"
            },
            "mm.dd.yyyy": {
                mask: "1.2.y",
                placeholder: "mm.dd.yyyy",
                leapday: "02.29.",
                separator: ".",
                alias: "mm/dd/yyyy"
            },
            "mm-dd-yyyy": {
                mask: "1-2-y",
                placeholder: "mm-dd-yyyy",
                leapday: "02-29-",
                separator: "-",
                alias: "mm/dd/yyyy"
            },
            "yyyy.mm.dd": {
                mask: "y.1.2",
                placeholder: "yyyy.mm.dd",
                leapday: ".02.29",
                separator: ".",
                alias: "yyyy/mm/dd"
            },
            "yyyy-mm-dd": {
                mask: "y-1-2",
                placeholder: "yyyy-mm-dd",
                leapday: "-02-29",
                separator: "-",
                alias: "yyyy/mm/dd"
            },
            datetime: {
                mask: "1/2/y h:s",
                placeholder: "mm/dd/yyyy hh:mm",
                alias: "mm/dd/yyyy",
                regex: {
                    hrspre: new RegExp("[012]"),
                    hrs24: new RegExp("2[0-4]|1[3-9]"),
                    hrs: new RegExp("[01][0-9]|2[0-4]"),
                    ampm: new RegExp("^[a|p|A|P][m|M]"),
                    mspre: new RegExp("[0-5]"),
                    ms: new RegExp("[0-5][0-9]")
                },
                timeseparator: ":",
                hourFormat: "24",
                definitions: {
                    h: {
                        validator: function (chrs, maskset, pos, strict, opts) {
                            if ("24" === opts.hourFormat && 24 === parseInt(chrs, 10)) return maskset.buffer[pos - 1] = "0",
                                maskset.buffer[pos] = "0", {
                                refreshFromBuffer: {
                                    start: pos - 1,
                                    end: pos
                                },
                                c: "0"
                            };
                            var isValid = opts.regex.hrs.test(chrs);
                            if (!strict && !isValid && (chrs.charAt(1) === opts.timeseparator || -1 !== "-.:".indexOf(chrs.charAt(1))) && (isValid = opts.regex.hrs.test("0" + chrs.charAt(0)))) return maskset.buffer[pos - 1] = "0",
                                maskset.buffer[pos] = chrs.charAt(0), pos++, {
                                refreshFromBuffer: {
                                    start: pos - 2,
                                    end: pos
                                },
                                pos: pos,
                                c: opts.timeseparator
                            };
                            if (isValid && "24" !== opts.hourFormat && opts.regex.hrs24.test(chrs)) {
                                var tmp = parseInt(chrs, 10);
                                return 24 === tmp ? (maskset.buffer[pos + 5] = "a", maskset.buffer[pos + 6] = "m") : (maskset.buffer[pos + 5] = "p",
                                    maskset.buffer[pos + 6] = "m"), tmp -= 12, 10 > tmp ? (maskset.buffer[pos] = tmp.toString(),
                                    maskset.buffer[pos - 1] = "0") : (maskset.buffer[pos] = tmp.toString().charAt(1),
                                    maskset.buffer[pos - 1] = tmp.toString().charAt(0)), {
                                    refreshFromBuffer: {
                                        start: pos - 1,
                                        end: pos + 6
                                    },
                                    c: maskset.buffer[pos]
                                };
                            }
                            return isValid;
                        },
                        cardinality: 2,
                        prevalidator: [{
                            validator: function (chrs, maskset, pos, strict, opts) {
                                var isValid = opts.regex.hrspre.test(chrs);
                                return strict || isValid || !(isValid = opts.regex.hrs.test("0" + chrs)) ? isValid : (maskset.buffer[pos] = "0",
                                    pos++, {
                                    pos: pos
                                });
                            },
                            cardinality: 1
                        }]
                    },
                    s: {
                        validator: "[0-5][0-9]",
                        cardinality: 2,
                        prevalidator: [{
                            validator: function (chrs, maskset, pos, strict, opts) {
                                var isValid = opts.regex.mspre.test(chrs);
                                return strict || isValid || !(isValid = opts.regex.ms.test("0" + chrs)) ? isValid : (maskset.buffer[pos] = "0",
                                    pos++, {
                                    pos: pos
                                });
                            },
                            cardinality: 1
                        }]
                    },
                    t: {
                        validator: function (chrs, maskset, pos, strict, opts) {
                            return opts.regex.ampm.test(chrs + "m");
                        },
                        casing: "lower",
                        cardinality: 1
                    }
                },
                insertMode: !1,
                autoUnmask: !1
            },
            datebox: {
                mask: "y-1-2 h:s",
                placeholder: "yyyy-mm-dd hh:mm",
                leapday: "-02-29",
                separator: "-",
                alias: "datetime"
            },
            datetime12: {
                mask: "1/2/y h:s t\\m",
                placeholder: "dd/mm/yyyy hh:mm xm",
                alias: "datetime",
                hourFormat: "12"
            },
            "mm/dd/yyyy hh:mm xm": {
                mask: "1/2/y h:s t\\m",
                placeholder: "mm/dd/yyyy hh:mm xm",
                alias: "datetime12",
                regex: {
                    val2pre: function (separator) {
                        var escapedSeparator = Inputmask.escapeRegex.call(this, separator);
                        return new RegExp("((0[13-9]|1[012])" + escapedSeparator + "[0-3])|(02" + escapedSeparator + "[0-2])");
                    },
                    val2: function (separator) {
                        var escapedSeparator = Inputmask.escapeRegex.call(this, separator);
                        return new RegExp("((0[1-9]|1[012])" + escapedSeparator + "(0[1-9]|[12][0-9]))|((0[13-9]|1[012])" + escapedSeparator + "30)|((0[13578]|1[02])" + escapedSeparator + "31)");
                    },
                    val1pre: new RegExp("[01]"),
                    val1: new RegExp("0[1-9]|1[012]")
                },
                leapday: "02/29/",
                onKeyDown: function (e, buffer, caretPos, opts) {
                    var $input = $(this);
                    if (e.ctrlKey && e.keyCode === Inputmask.keyCode.RIGHT) {
                        var today = new Date();
                        $input.val((today.getMonth() + 1).toString() + today.getDate().toString() + today.getFullYear().toString()),
                            $input.trigger("setvalue");
                    }
                }
            },
            "hh:mm t": {
                mask: "h:s t\\m",
                placeholder: "hh:mm xm",
                alias: "datetime",
                hourFormat: "12"
            },
            "h:s t": {
                mask: "h:s t\\m",
                placeholder: "hh:mm xm",
                alias: "datetime",
                hourFormat: "12"
            },
            "hh:mm:ss": {
                mask: "h:s:s",
                placeholder: "hh:mm:ss",
                alias: "datetime",
                autoUnmask: !1
            },
            "hh:mm": {
                mask: "h:s",
                placeholder: "hh:mm",
                alias: "datetime",
                autoUnmask: !1
            },
            date: {
                alias: "dd/mm/yyyy"
            },
            "mm/yyyy": {
                mask: "1/y",
                placeholder: "mm/yyyy",
                leapday: "donotuse",
                separator: "/",
                alias: "mm/dd/yyyy"
            },
            shamsi: {
                regex: {
                    val2pre: function (separator) {
                        var escapedSeparator = Inputmask.escapeRegex.call(this, separator);
                        return new RegExp("((0[1-9]|1[012])" + escapedSeparator + "[0-3])");
                    },
                    val2: function (separator) {
                        var escapedSeparator = Inputmask.escapeRegex.call(this, separator);
                        return new RegExp("((0[1-9]|1[012])" + escapedSeparator + "(0[1-9]|[12][0-9]))|((0[1-9]|1[012])" + escapedSeparator + "30)|((0[1-6])" + escapedSeparator + "31)");
                    },
                    val1pre: new RegExp("[01]"),
                    val1: new RegExp("0[1-9]|1[012]")
                },
                yearrange: {
                    minyear: 1300,
                    maxyear: 1499
                },
                mask: "y/1/2",
                leapday: "/12/30",
                placeholder: "yyyy/mm/dd",
                alias: "mm/dd/yyyy",
                clearIncomplete: !0
            }
        }), Inputmask;
    }(jQuery, Inputmask),
    function ($, Inputmask) {
        return Inputmask.extendDefinitions({
            A: {
                validator: "[A-Za-z\u0410-\u044f\u0401\u0451\xc0-\xff\xb5]",
                cardinality: 1,
                casing: "upper"
            },
            "&": {
                validator: "[0-9A-Za-z\u0410-\u044f\u0401\u0451\xc0-\xff\xb5]",
                cardinality: 1,
                casing: "upper"
            },
            "#": {
                validator: "[0-9A-Fa-f]",
                cardinality: 1,
                casing: "upper"
            }
        }), Inputmask.extendAliases({
            url: {
                definitions: {
                    i: {
                        validator: ".",
                        cardinality: 1
                    }
                },
                mask: "(\\http://)|(\\http\\s://)|(ftp://)|(ftp\\s://)i{+}",
                insertMode: !1,
                autoUnmask: !1
            },
            ip: {
                mask: "i[i[i]].i[i[i]].i[i[i]].i[i[i]]",
                definitions: {
                    i: {
                        validator: function (chrs, maskset, pos, strict, opts) {
                            return pos - 1 > -1 && "." !== maskset.buffer[pos - 1] ? (chrs = maskset.buffer[pos - 1] + chrs,
                                chrs = pos - 2 > -1 && "." !== maskset.buffer[pos - 2] ? maskset.buffer[pos - 2] + chrs : "0" + chrs) : chrs = "00" + chrs,
                                new RegExp("25[0-5]|2[0-4][0-9]|[01][0-9][0-9]").test(chrs);
                        },
                        cardinality: 1
                    }
                },
                onUnMask: function (maskedValue, unmaskedValue, opts) {
                    return maskedValue;
                }
            },
            email: {
                mask: "*{1,64}[.*{1,64}][.*{1,64}][.*{1,63}]@-{1,63}.-{1,63}[.-{1,63}][.-{1,63}]",
                greedy: !1,
                onBeforePaste: function (pastedValue, opts) {
                    return pastedValue = pastedValue.toLowerCase(), pastedValue.replace("mailto:", "");
                },
                definitions: {
                    "*": {
                        validator: "[0-9A-Za-z!#$%&'*+/=?^_`{|}~-]",
                        cardinality: 1,
                        casing: "lower"
                    },
                    "-": {
                        validator: "[0-9A-Za-z-]",
                        cardinality: 1,
                        casing: "lower"
                    }
                },
                onUnMask: function (maskedValue, unmaskedValue, opts) {
                    return maskedValue;
                }
            },
            mac: {
                mask: "##:##:##:##:##:##"
            },
            range: {
                mask: "*{1,30}~*{1,30}",
                greedy: !1,
                definitions: {
                    "*": {
                        validator: "[0-9\-]",
                        cardinality: 1,
                        casing: "lower"
                    }
                }
            },
            alphaDash: {
                mask: "*{1,64}",
                greedy: !1,
                definitions: {
                    "*": {
                        validator: "[a-z\_A-Z0-9]",
                        cardinality: 1,
                        casing: "lower"
                    }
                }
            },
            resolution: {
                mask: "9{1,8}×9{1,8}"
            },
            phone: {
                mask: "+86-9{11}"
            },
            timecode: {
                mask: "##:##:##:##"
            },
            timecode_range: {
                mask: "##:##:##:##-##:##:##:##"
            },
            cropping: {
                mask: "*{1,6}[.*{1,6}]:*{1,6}[.*{1,6}]",
                greedy: !1,
                definitions: {
                    "*": {
                        validator: "[0-9]",
                        cardinality: 1,
                        casing: "lower"
                    }
                }
            },
            vin: {
                mask: "V{13}9{4}",
                definitions: {
                    V: {
                        validator: "[A-HJ-NPR-Za-hj-npr-z\\d]",
                        cardinality: 1,
                        casing: "upper"
                    }
                },
                clearIncomplete: !0,
                autoUnmask: !0
            }
        }), Inputmask;
    }(jQuery, Inputmask),
    function ($, Inputmask) {
        return Inputmask.extendAliases({
            numeric: {
                mask: function (opts) {
                    function autoEscape(txt) {
                        for (var escapedTxt = "", i = 0; i < txt.length; i++) escapedTxt += opts.definitions[txt.charAt(i)] || opts.optionalmarker.start === txt.charAt(i) || opts.optionalmarker.end === txt.charAt(i) || opts.quantifiermarker.start === txt.charAt(i) || opts.quantifiermarker.end === txt.charAt(i) || opts.groupmarker.start === txt.charAt(i) || opts.groupmarker.end === txt.charAt(i) || opts.alternatormarker === txt.charAt(i) ? "\\" + txt.charAt(i) : txt.charAt(i);
                        return escapedTxt;
                    }
                    if (0 !== opts.repeat && isNaN(opts.integerDigits) && (opts.integerDigits = opts.repeat),
                        opts.repeat = 0, opts.groupSeparator === opts.radixPoint && ("." === opts.radixPoint ? opts.groupSeparator = "," : "," === opts.radixPoint ? opts.groupSeparator = "." : opts.groupSeparator = ""),
                    " " === opts.groupSeparator && (opts.skipOptionalPartCharacter = void 0), opts.autoGroup = opts.autoGroup && "" !== opts.groupSeparator,
                    opts.autoGroup && ("string" == typeof opts.groupSize && isFinite(opts.groupSize) && (opts.groupSize = parseInt(opts.groupSize)),
                        isFinite(opts.integerDigits))) {
                        var seps = Math.floor(opts.integerDigits / opts.groupSize),
                            mod = opts.integerDigits % opts.groupSize;
                        opts.integerDigits = parseInt(opts.integerDigits) + (0 === mod ? seps - 1 : seps),
                        opts.integerDigits < 1 && (opts.integerDigits = "*");
                    }
                    opts.placeholder.length > 1 && (opts.placeholder = opts.placeholder.charAt(0)),
                        opts.radixFocus = opts.radixFocus && "" !== opts.placeholder && opts.integerOptional === !0,
                        opts.definitions[";"] = opts.definitions["~"], opts.definitions[";"].definitionSymbol = "~",
                    opts.numericInput === !0 && (opts.radixFocus = !1, opts.digitsOptional = !1, isNaN(opts.digits) && (opts.digits = 2),
                        opts.decimalProtect = !1);
                    var mask = autoEscape(opts.prefix);
                    return mask += "[+]", mask += opts.integerOptional === !0 ? "~{1," + opts.integerDigits + "}" : "~{" + opts.integerDigits + "}",
                    void 0 !== opts.digits && (isNaN(opts.digits) || parseInt(opts.digits) > 0) && (opts.decimalProtect && (opts.radixPointDefinitionSymbol = ":"),
                        mask += opts.digitsOptional ? "[" + (opts.decimalProtect ? ":" : opts.radixPoint) + ";{1," + opts.digits + "}]" : (opts.decimalProtect ? ":" : opts.radixPoint) + ";{" + opts.digits + "}"),
                        mask += "[-]", mask += autoEscape(opts.suffix), opts.greedy = !1, null !== opts.min && (opts.min = opts.min.toString().replace(new RegExp(Inputmask.escapeRegex(opts.groupSeparator), "g"), ""),
                    "," === opts.radixPoint && (opts.min = opts.min.replace(opts.radixPoint, "."))),
                    null !== opts.max && (opts.max = opts.max.toString().replace(new RegExp(Inputmask.escapeRegex(opts.groupSeparator), "g"), ""),
                    "," === opts.radixPoint && (opts.max = opts.max.replace(opts.radixPoint, "."))),
                        mask;
                },
                placeholder: "",
                greedy: !1,
                digits: "*",
                digitsOptional: !0,
                radixPoint: ".",
                radixFocus: !0,
                groupSize: 3,
                groupSeparator: "",
                autoGroup: !1,
                allowPlus: !0,
                allowMinus: !0,
                negationSymbol: {
                    front: "-",
                    back: ""
                },
                integerDigits: "+",
                integerOptional: !0,
                prefix: "",
                suffix: "",
                rightAlign: !0,
                decimalProtect: !0,
                min: null,
                max: null,
                step: 1,
                insertMode: !0,
                autoUnmask: !1,
                unmaskAsNumber: !1,
                postFormat: function (buffer, pos, opts) {
                    opts.numericInput === !0 && (buffer = buffer.reverse(), isFinite(pos) && (pos = buffer.join("").length - pos - 1));
                    var i, l, suffixStripped = !1;
                    buffer.length >= opts.suffix.length && buffer.join("").indexOf(opts.suffix) === buffer.length - opts.suffix.length && (buffer.length = buffer.length - opts.suffix.length,
                        suffixStripped = !0), pos = pos >= buffer.length ? buffer.length - 1 : pos < opts.prefix.length ? opts.prefix.length : pos;
                    var needsRefresh = !1,
                        charAtPos = buffer[pos],
                        cbuf = buffer.slice();
                    charAtPos === opts.groupSeparator && (cbuf.splice(pos--, 1), charAtPos = cbuf[pos]),
                    charAtPos !== opts.radixPoint && charAtPos !== opts.negationSymbol.front && charAtPos !== opts.negationSymbol.back && (cbuf[pos] = "?");
                    var bufVal = cbuf.join(""),
                        bufValOrigin = bufVal;
                    if (bufVal.length > 0 && opts.autoGroup || -1 !== bufVal.indexOf(opts.groupSeparator)) {
                        var escapedGroupSeparator = Inputmask.escapeRegex(opts.groupSeparator);
                        needsRefresh = 0 === bufVal.indexOf(opts.groupSeparator), bufVal = bufVal.replace(new RegExp(escapedGroupSeparator, "g"), "");
                        var radixSplit = bufVal.split(opts.radixPoint);
                        if (bufVal = "" === opts.radixPoint ? bufVal : radixSplit[0], bufVal !== opts.prefix + "?0" && bufVal.length >= opts.groupSize + opts.prefix.length)
                            for (var reg = new RegExp("([-+]?[\\d?]+)([\\d?]{" + opts.groupSize + "})"); reg.test(bufVal) && "" !== opts.groupSeparator;) bufVal = bufVal.replace(reg, "$1" + opts.groupSeparator + "$2"),
                                bufVal = bufVal.replace(opts.groupSeparator + opts.groupSeparator, opts.groupSeparator);
                        "" !== opts.radixPoint && radixSplit.length > 1 && (bufVal += opts.radixPoint + radixSplit[1]);
                    }
                    for (needsRefresh = bufValOrigin !== bufVal, buffer.length = bufVal.length, i = 0,
                             l = bufVal.length; l > i; i++) buffer[i] = bufVal.charAt(i);
                    var newPos = $.inArray("?", buffer);
                    if (-1 === newPos && (newPos = $.inArray(charAtPos, buffer)), buffer[newPos] = charAtPos,
                    !needsRefresh && suffixStripped)
                        for (i = 0, l = opts.suffix.length; l > i; i++) buffer.push(opts.suffix.charAt(i));
                    return newPos = opts.numericInput && isFinite(pos) ? buffer.join("").length - newPos - 1 : newPos,
                    opts.numericInput && (buffer = buffer.reverse(), $.inArray(opts.radixPoint, buffer) < newPos && buffer.join("").length - opts.suffix.length !== newPos && (newPos -= 1)), {
                        pos: newPos,
                        refreshFromBuffer: needsRefresh,
                        buffer: buffer
                    };
                },
                onBeforeWrite: function (e, buffer, caretPos, opts) {
                    var rslt;
                    if (e && ("blur" === e.type || "checkval" === e.type || "keydown" === e.type)) {
                        var maskedValue = opts.numericInput ? buffer.slice().reverse().join("") : buffer.join(""),
                            processValue = maskedValue.replace(opts.prefix, "");
                        processValue = processValue.replace(opts.suffix, ""), processValue = processValue.replace(new RegExp(Inputmask.escapeRegex(opts.groupSeparator), "g"), ""),
                        "," === opts.radixPoint && (processValue = processValue.replace(opts.radixPoint, "."));
                        var isNegative = processValue.match(new RegExp("[-" + Inputmask.escapeRegex(opts.negationSymbol.front) + "]", "g"));
                        if (isNegative = null !== isNegative && 1 === isNegative.length, processValue = processValue.replace(new RegExp("[-" + Inputmask.escapeRegex(opts.negationSymbol.front) + "]", "g"), ""),
                            processValue = processValue.replace(new RegExp(Inputmask.escapeRegex(opts.negationSymbol.back) + "$"), ""),
                        isNaN(opts.placeholder) && (processValue = processValue.replace(new RegExp(Inputmask.escapeRegex(opts.placeholder), "g"), "")),
                            processValue = processValue === opts.negationSymbol.front ? processValue + "0" : processValue,
                        "" !== processValue && isFinite(processValue)) {
                            var floatValue = parseFloat(processValue),
                                signedFloatValue = isNegative ? -1 * floatValue : floatValue;
                            if (null !== opts.min && isFinite(opts.min) && signedFloatValue < parseFloat(opts.min) ? (floatValue = Math.abs(opts.min),
                                isNegative = opts.min < 0, maskedValue = void 0) : null !== opts.max && isFinite(opts.max) && signedFloatValue > parseFloat(opts.max) && (floatValue = Math.abs(opts.max),
                                isNegative = opts.max < 0, maskedValue = void 0), processValue = floatValue.toString().replace(".", opts.radixPoint).split(""),
                                isFinite(opts.digits)) {
                                var radixPosition = $.inArray(opts.radixPoint, processValue),
                                    rpb = $.inArray(opts.radixPoint, maskedValue); -
                                    1 === radixPosition && (processValue.push(opts.radixPoint), radixPosition = processValue.length - 1);
                                for (var i = 1; i <= opts.digits; i++) opts.digitsOptional || void 0 !== processValue[radixPosition + i] && processValue[radixPosition + i] !== opts.placeholder.charAt(0) ? -1 !== rpb && void 0 !== maskedValue[rpb + i] && (processValue[radixPosition + i] = processValue[radixPosition + i] || maskedValue[rpb + i]) : processValue[radixPosition + i] = "0";
                                processValue[processValue.length - 1] === opts.radixPoint && delete processValue[processValue.length - 1];
                            }
                            if (floatValue.toString() !== processValue && floatValue.toString() + "." !== processValue || isNegative) return !isNegative || 0 === floatValue && "blur" === e.type || (processValue.unshift(opts.negationSymbol.front),
                                processValue.push(opts.negationSymbol.back)), processValue = (opts.prefix + processValue.join("")).split(""),
                            opts.numericInput && (processValue = processValue.reverse()), rslt = opts.postFormat(processValue, opts.numericInput ? caretPos : caretPos - 1, opts),
                            rslt.buffer && (rslt.refreshFromBuffer = rslt.buffer.join("") !== buffer.join("")),
                                rslt;
                        }
                    }
                    return opts.autoGroup ? (rslt = opts.postFormat(buffer, opts.numericInput ? caretPos : caretPos - 1, opts),
                        rslt.caret = caretPos <= opts.prefix.length ? rslt.pos : rslt.pos + 1, rslt) : void 0;
                },
                regex: {
                    integerPart: function (opts) {
                        return new RegExp("[" + Inputmask.escapeRegex(opts.negationSymbol.front) + "+]?\\d+");
                    },
                    integerNPart: function (opts) {
                        return new RegExp("[\\d" + Inputmask.escapeRegex(opts.groupSeparator) + Inputmask.escapeRegex(opts.placeholder.charAt(0)) + "]+");
                    }
                },
                signHandler: function (chrs, maskset, pos, strict, opts) {
                    if (!strict && opts.allowMinus && "-" === chrs || opts.allowPlus && "+" === chrs) {
                        var matchRslt = maskset.buffer.join("").match(opts.regex.integerPart(opts));
                        if (matchRslt && matchRslt[0].length > 0) return maskset.buffer[matchRslt.index] === ("-" === chrs ? "+" : opts.negationSymbol.front) ? "-" === chrs ? "" !== opts.negationSymbol.back ? {
                            pos: matchRslt.index,
                            c: opts.negationSymbol.front,
                            remove: matchRslt.index,
                            caret: pos,
                            insert: {
                                pos: maskset.buffer.length - opts.suffix.length - 1,
                                c: opts.negationSymbol.back
                            }
                        } : {
                            pos: matchRslt.index,
                            c: opts.negationSymbol.front,
                            remove: matchRslt.index,
                            caret: pos
                        } : "" !== opts.negationSymbol.back ? {
                            pos: matchRslt.index,
                            c: "+",
                            remove: [matchRslt.index, maskset.buffer.length - opts.suffix.length - 1],
                            caret: pos
                        } : {
                            pos: matchRslt.index,
                            c: "+",
                            remove: matchRslt.index,
                            caret: pos
                        } : maskset.buffer[matchRslt.index] === ("-" === chrs ? opts.negationSymbol.front : "+") ? "-" === chrs && "" !== opts.negationSymbol.back ? {
                            remove: [matchRslt.index, maskset.buffer.length - opts.suffix.length - 1],
                            caret: pos - 1
                        } : {
                            remove: matchRslt.index,
                            caret: pos - 1
                        } : "-" === chrs ? "" !== opts.negationSymbol.back ? {
                            pos: matchRslt.index,
                            c: opts.negationSymbol.front,
                            caret: pos + 1,
                            insert: {
                                pos: maskset.buffer.length - opts.suffix.length,
                                c: opts.negationSymbol.back
                            }
                        } : {
                            pos: matchRslt.index,
                            c: opts.negationSymbol.front,
                            caret: pos + 1
                        } : {
                            pos: matchRslt.index,
                            c: chrs,
                            caret: pos + 1
                        };
                    }
                    return !1;
                },
                radixHandler: function (chrs, maskset, pos, strict, opts) {
                    if (!strict && opts.numericInput !== !0 && chrs === opts.radixPoint && void 0 !== opts.digits && (isNaN(opts.digits) || parseInt(opts.digits) > 0)) {
                        var radixPos = $.inArray(opts.radixPoint, maskset.buffer),
                            integerValue = maskset.buffer.join("").match(opts.regex.integerPart(opts));
                        if (-1 !== radixPos && maskset.validPositions[radixPos]) return maskset.validPositions[radixPos - 1] ? {
                            caret: radixPos + 1
                        } : {
                            pos: integerValue.index,
                            c: integerValue[0],
                            caret: radixPos + 1
                        };
                        if (!integerValue || "0" === integerValue[0] && integerValue.index + 1 !== pos) return maskset.buffer[integerValue ? integerValue.index : pos] = "0", {
                            pos: (integerValue ? integerValue.index : pos) + 1,
                            c: opts.radixPoint
                        };
                    }
                    return !1;
                },
                leadingZeroHandler: function (chrs, maskset, pos, strict, opts, isSelection) {
                    if (!strict)
                        if (opts.numericInput === !0) {
                            var buffer = maskset.buffer.slice("").reverse(),
                                char = buffer[opts.prefix.length];
                            if ("0" === char && void 0 === maskset.validPositions[pos - 1]) return {
                                pos: pos,
                                remove: buffer.length - opts.prefix.length - 1
                            };
                        } else {
                            var radixPosition = $.inArray(opts.radixPoint, maskset.buffer),
                                matchRslt = maskset.buffer.slice(0, -1 !== radixPosition ? radixPosition : void 0).join("").match(opts.regex.integerNPart(opts));
                            if (matchRslt && (-1 === radixPosition || radixPosition >= pos)) {
                                var decimalPart = -1 === radixPosition ? 0 : parseInt(maskset.buffer.slice(radixPosition + 1).join(""));
                                if (0 === matchRslt[0].indexOf("" !== opts.placeholder ? opts.placeholder.charAt(0) : "0") && (matchRslt.index + 1 === pos || isSelection !== !0 && 0 === decimalPart)) return maskset.buffer.splice(matchRslt.index, 1), {
                                    pos: matchRslt.index,
                                    remove: matchRslt.index
                                };
                                if ("0" === chrs && pos <= matchRslt.index && matchRslt[0] !== opts.groupSeparator) return !1;
                            }
                        }
                    return !0;
                },
                definitions: {
                    "~": {
                        validator: function (chrs, maskset, pos, strict, opts, isSelection) {
                            var isValid = opts.signHandler(chrs, maskset, pos, strict, opts);
                            if (!isValid && (isValid = opts.radixHandler(chrs, maskset, pos, strict, opts),
                            !isValid && (isValid = strict ? new RegExp("[0-9" + Inputmask.escapeRegex(opts.groupSeparator) + "]").test(chrs) : new RegExp("[0-9]").test(chrs),
                            isValid === !0 && (isValid = opts.leadingZeroHandler(chrs, maskset, pos, strict, opts, isSelection),
                            isValid === !0)))) {
                                var radixPosition = $.inArray(opts.radixPoint, maskset.buffer);
                                isValid = -1 !== radixPosition && (opts.digitsOptional === !1 || maskset.validPositions[pos]) && opts.numericInput !== !0 && pos > radixPosition && !strict ? {
                                    pos: pos,
                                    remove: pos
                                } : {
                                    pos: pos
                                };
                            }
                            return isValid;
                        },
                        cardinality: 1
                    },
                    "+": {
                        validator: function (chrs, maskset, pos, strict, opts) {
                            var isValid = opts.signHandler(chrs, maskset, pos, strict, opts);
                            return !isValid && (strict && opts.allowMinus && chrs === opts.negationSymbol.front || opts.allowMinus && "-" === chrs || opts.allowPlus && "+" === chrs) && (isValid = strict || "-" !== chrs ? !0 : "" !== opts.negationSymbol.back ? {
                                pos: pos,
                                c: "-" === chrs ? opts.negationSymbol.front : "+",
                                caret: pos + 1,
                                insert: {
                                    pos: maskset.buffer.length,
                                    c: opts.negationSymbol.back
                                }
                            } : {
                                pos: pos,
                                c: "-" === chrs ? opts.negationSymbol.front : "+",
                                caret: pos + 1
                            }), isValid;
                        },
                        cardinality: 1,
                        placeholder: ""
                    },
                    "-": {
                        validator: function (chrs, maskset, pos, strict, opts) {
                            var isValid = opts.signHandler(chrs, maskset, pos, strict, opts);
                            return !isValid && strict && opts.allowMinus && chrs === opts.negationSymbol.back && (isValid = !0),
                                isValid;
                        },
                        cardinality: 1,
                        placeholder: ""
                    },
                    ":": {
                        validator: function (chrs, maskset, pos, strict, opts) {
                            var isValid = opts.signHandler(chrs, maskset, pos, strict, opts);
                            if (!isValid) {
                                var radix = "[" + Inputmask.escapeRegex(opts.radixPoint) + "]";
                                isValid = new RegExp(radix).test(chrs), isValid && maskset.validPositions[pos] && maskset.validPositions[pos].match.placeholder === opts.radixPoint && (isValid = {
                                    caret: pos + 1
                                });
                            }
                            return isValid ? {
                                c: opts.radixPoint
                            } : isValid;
                        },
                        cardinality: 1,
                        placeholder: function (opts) {
                            return opts.radixPoint;
                        }
                    }
                },
                onUnMask: function (maskedValue, unmaskedValue, opts) {
                    var processValue = maskedValue.replace(opts.prefix, "");
                    return processValue = processValue.replace(opts.suffix, ""), processValue = processValue.replace(new RegExp(Inputmask.escapeRegex(opts.groupSeparator), "g"), ""),
                        opts.unmaskAsNumber ? ("" !== opts.radixPoint && -1 !== processValue.indexOf(opts.radixPoint) && (processValue = processValue.replace(Inputmask.escapeRegex.call(this, opts.radixPoint), ".")),
                            Number(processValue)) : processValue;
                },
                isComplete: function (buffer, opts) {
                    var maskedValue = buffer.join(""),
                        bufClone = buffer.slice();
                    if (opts.postFormat(bufClone, 0, opts), bufClone.join("") !== maskedValue) return !1;
                    var processValue = maskedValue.replace(opts.prefix, "");
                    return processValue = processValue.replace(opts.suffix, ""), processValue = processValue.replace(new RegExp(Inputmask.escapeRegex(opts.groupSeparator), "g"), ""),
                    "," === opts.radixPoint && (processValue = processValue.replace(Inputmask.escapeRegex(opts.radixPoint), ".")),
                        isFinite(processValue);
                },
                onBeforeMask: function (initialValue, opts) {
                    if ("" !== opts.radixPoint && isFinite(initialValue)) initialValue = initialValue.toString().replace(".", opts.radixPoint);
                    else {
                        var kommaMatches = initialValue.match(/,/g),
                            dotMatches = initialValue.match(/\./g);
                        dotMatches && kommaMatches ? dotMatches.length > kommaMatches.length ? (initialValue = initialValue.replace(/\./g, ""),
                            initialValue = initialValue.replace(",", opts.radixPoint)) : kommaMatches.length > dotMatches.length ? (initialValue = initialValue.replace(/,/g, ""),
                            initialValue = initialValue.replace(".", opts.radixPoint)) : initialValue = initialValue.indexOf(".") < initialValue.indexOf(",") ? initialValue.replace(/\./g, "") : initialValue = initialValue.replace(/,/g, "") : initialValue = initialValue.replace(new RegExp(Inputmask.escapeRegex(opts.groupSeparator), "g"), "");
                    }
                    if (0 === opts.digits && (-1 !== initialValue.indexOf(".") ? initialValue = initialValue.substring(0, initialValue.indexOf(".")) : -1 !== initialValue.indexOf(",") && (initialValue = initialValue.substring(0, initialValue.indexOf(",")))),
                    "" !== opts.radixPoint && isFinite(opts.digits) && -1 !== initialValue.indexOf(opts.radixPoint)) {
                        var valueParts = initialValue.split(opts.radixPoint),
                            decPart = valueParts[1].match(new RegExp("\\d*"))[0];
                        if (parseInt(opts.digits) < decPart.toString().length) {
                            var digitsFactor = Math.pow(10, parseInt(opts.digits));
                            initialValue = initialValue.replace(Inputmask.escapeRegex(opts.radixPoint), "."),
                                initialValue = Math.round(parseFloat(initialValue) * digitsFactor) / digitsFactor,
                                initialValue = initialValue.toString().replace(".", opts.radixPoint);
                        }
                    }
                    return initialValue.toString();
                },
                canClearPosition: function (maskset, position, lvp, strict, opts) {
                    var positionInput = maskset.validPositions[position].input,
                        canClear = positionInput !== opts.radixPoint || null !== maskset.validPositions[position].match.fn && opts.decimalProtect === !1 || isFinite(positionInput) || position === lvp || positionInput === opts.groupSeparator || positionInput === opts.negationSymbol.front || positionInput === opts.negationSymbol.back;
                    return canClear;
                },
                onKeyDown: function (e, buffer, caretPos, opts) {
                    var $input = $(this);
                    if (e.ctrlKey) switch (e.keyCode) {
                        case Inputmask.keyCode.UP:
                            $input.val(parseFloat(this.inputmask.unmaskedvalue()) + parseInt(opts.step)), $input.trigger("setvalue");
                            break;

                        case Inputmask.keyCode.DOWN:
                            $input.val(parseFloat(this.inputmask.unmaskedvalue()) - parseInt(opts.step)), $input.trigger("setvalue");
                    }
                }
            },
            currency: { //美元
                prefix: "$ ",
                groupSeparator: ",",
                alias: "numeric",
                placeholder: "0",
                autoGroup: !0,
                digits: 2,
                digitsOptional: !1,
                clearMaskOnLostFocus: !1
            },
            decimal: {
                alias: "numeric"
            },
            integer: {
                alias: "numeric",
                digits: 0,
                radixPoint: ""
            },
            percentage: {
                alias: "numeric",
                digits: 2,
                radixPoint: ".",
                placeholder: "0",
                autoGroup: !1,
                min: 0,
                max: 10000,
                suffix: " %",
                allowPlus: !1,
                allowMinus: !1
            }
        }), Inputmask;
    }(jQuery, Inputmask),
    function ($, Inputmask) {
        return Inputmask.extendAliases({
            phoneNums: {
                url: "./phone-codes/phone-codes.js",
                countrycode: "",
                phoneCodeCache: {},
                mask: function (opts) {
                    if (void 0 === opts.phoneCodeCache[opts.url]) {
                        var maskList = [];
                        opts.definitions["#"] = opts.definitions[9], $.ajax({
                            url: opts.url,
                            async: !1,
                            type: "get",
                            dataType: "json",
                            success: function (response) {
                                maskList = response;
                            },
                            error: function (xhr, ajaxOptions, thrownError) {
                                alert(thrownError + " - " + opts.url);
                            }
                        }), opts.phoneCodeCache[opts.url] = maskList.sort(function (a, b) {
                            return (a.mask || a) < (b.mask || b) ? -1 : 1;
                        });
                    }
                    return opts.phoneCodeCache[opts.url];
                },
                keepStatic: !1,
                nojumps: !0,
                nojumpsThreshold: 1,
                onBeforeMask: function (value, opts) {
                    var processedValue = value.replace(/^0{1,2}/, "").replace(/[\s]/g, "");
                    return (processedValue.indexOf(opts.countrycode) > 1 || -1 === processedValue.indexOf(opts.countrycode)) && (processedValue = "+" + opts.countrycode + processedValue),
                        processedValue;
                }
            },
            phonebe: {
                alias: "phone",
                url: "phone-codes/phone-be.js",
                countrycode: "32",
                nojumpsThreshold: 4
            }
        }), Inputmask;
    }(jQuery, Inputmask),
    function ($, Inputmask) {
        return Inputmask.extendAliases({
            Regex: {
                mask: "r",
                greedy: !1,
                repeat: "*",
                regex: null,
                regexTokens: null,
                tokenizer: /\[\^?]?(?:[^\\\]]+|\\[\S\s]?)*]?|\\(?:0(?:[0-3][0-7]{0,2}|[4-7][0-7]?)?|[1-9][0-9]*|x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4}|c[A-Za-z]|[\S\s]?)|\((?:\?[:=!]?)?|(?:[?*+]|\{[0-9]+(?:,[0-9]*)?\})\??|[^.?*+^${[()|\\]+|./g,
                quantifierFilter: /[0-9]+[^,]/,
                isComplete: function (buffer, opts) {
                    return new RegExp(opts.regex).test(buffer.join(""));
                },
                definitions: {
                    r: {
                        validator: function (chrs, maskset, pos, strict, opts) {
                            function RegexToken(isGroup, isQuantifier) {
                                this.matches = [], this.isGroup = isGroup || !1, this.isQuantifier = isQuantifier || !1,
                                    this.quantifier = {
                                        min: 1,
                                        max: 1
                                    }, this.repeaterPart = void 0;
                            }

                            function analyseRegex() {
                                var match, m, currentToken = new RegexToken(),
                                    opengroups = [];
                                for (opts.regexTokens = []; match = opts.tokenizer.exec(opts.regex);) switch (m = match[0],
                                    m.charAt(0)) {
                                    case "(":
                                        opengroups.push(new RegexToken(!0));
                                        break;

                                    case ")":
                                        groupToken = opengroups.pop(), opengroups.length > 0 ? opengroups[opengroups.length - 1].matches.push(groupToken) : currentToken.matches.push(groupToken);
                                        break;

                                    case "{":
                                    case "+":
                                    case "*":
                                        var quantifierToken = new RegexToken(!1, !0);
                                        m = m.replace(/[{}]/g, "");
                                        var mq = m.split(","),
                                            mq0 = isNaN(mq[0]) ? mq[0] : parseInt(mq[0]),
                                            mq1 = 1 === mq.length ? mq0 : isNaN(mq[1]) ? mq[1] : parseInt(mq[1]);
                                        if (quantifierToken.quantifier = {
                                            min: mq0,
                                            max: mq1
                                        }, opengroups.length > 0) {
                                            var matches = opengroups[opengroups.length - 1].matches;
                                            match = matches.pop(), match.isGroup || (groupToken = new RegexToken(!0), groupToken.matches.push(match),
                                                match = groupToken), matches.push(match), matches.push(quantifierToken);
                                        } else match = currentToken.matches.pop(), match.isGroup || (groupToken = new RegexToken(!0),
                                            groupToken.matches.push(match), match = groupToken), currentToken.matches.push(match),
                                            currentToken.matches.push(quantifierToken);
                                        break;

                                    default:
                                        opengroups.length > 0 ? opengroups[opengroups.length - 1].matches.push(m) : currentToken.matches.push(m);
                                }
                                currentToken.matches.length > 0 && opts.regexTokens.push(currentToken);
                            }

                            function validateRegexToken(token, fromGroup) {
                                var isvalid = !1;
                                fromGroup && (regexPart += "(", openGroupCount++);
                                for (var mndx = 0; mndx < token.matches.length; mndx++) {
                                    var matchToken = token.matches[mndx];
                                    if (matchToken.isGroup === !0) isvalid = validateRegexToken(matchToken, !0);
                                    else if (matchToken.isQuantifier === !0) {
                                        var crrntndx = $.inArray(matchToken, token.matches),
                                            matchGroup = token.matches[crrntndx - 1],
                                            regexPartBak = regexPart;
                                        if (isNaN(matchToken.quantifier.max)) {
                                            for (; matchToken.repeaterPart && matchToken.repeaterPart !== regexPart && matchToken.repeaterPart.length > regexPart.length && !(isvalid = validateRegexToken(matchGroup, !0)););
                                            isvalid = isvalid || validateRegexToken(matchGroup, !0), isvalid && (matchToken.repeaterPart = regexPart),
                                                regexPart = regexPartBak + matchToken.quantifier.max;
                                        } else {
                                            for (var i = 0, qm = matchToken.quantifier.max - 1; qm > i && !(isvalid = validateRegexToken(matchGroup, !0)); i++);
                                            regexPart = regexPartBak + "{" + matchToken.quantifier.min + "," + matchToken.quantifier.max + "}";
                                        }
                                    } else if (void 0 !== matchToken.matches)
                                        for (var k = 0; k < matchToken.length && !(isvalid = validateRegexToken(matchToken[k], fromGroup)); k++);
                                    else {
                                        var testExp;
                                        if ("[" == matchToken.charAt(0)) {
                                            testExp = regexPart, testExp += matchToken;
                                            for (var j = 0; openGroupCount > j; j++) testExp += ")";
                                            var exp = new RegExp("^(" + testExp + ")$");
                                            isvalid = exp.test(bufferStr);
                                        } else
                                            for (var l = 0, tl = matchToken.length; tl > l; l++)
                                                if ("\\" !== matchToken.charAt(l)) {
                                                    testExp = regexPart, testExp += matchToken.substr(0, l + 1), testExp = testExp.replace(/\|$/, "");
                                                    for (var j = 0; openGroupCount > j; j++) testExp += ")";
                                                    var exp = new RegExp("^(" + testExp + ")$");
                                                    if (isvalid = exp.test(bufferStr)) break;
                                                }
                                        regexPart += matchToken;
                                    }
                                    if (isvalid) break;
                                }
                                return fromGroup && (regexPart += ")", openGroupCount--), isvalid;
                            }
                            var bufferStr, groupToken, cbuffer = maskset.buffer.slice(),
                                regexPart = "",
                                isValid = !1,
                                openGroupCount = 0;
                            null === opts.regexTokens && analyseRegex(), cbuffer.splice(pos, 0, chrs), bufferStr = cbuffer.join("");
                            for (var i = 0; i < opts.regexTokens.length; i++) {
                                var regexToken = opts.regexTokens[i];
                                if (isValid = validateRegexToken(regexToken, regexToken.isGroup)) break;
                            }
                            return isValid;
                        },
                        cardinality: 1
                    }
                }
            }
        }), Inputmask;
    }(jQuery, Inputmask);


// Picturefill 灯箱插件
window.matchMedia || (window.matchMedia = function() {
    "use strict";
    var a = window.styleMedia || window.media;
    if (!a) {
        var b = document.createElement("style"), c = document.getElementsByTagName("script")[0], d = null;
        b.type = "text/css", b.id = "matchmediajs-test", c.parentNode.insertBefore(b, c),
            d = "getComputedStyle" in window && window.getComputedStyle(b, null) || b.currentStyle,
            a = {
                matchMedium:function(a) {
                    var c = "@media " + a + "{ #matchmediajs-test { width: 1px; } }";
                    return b.styleSheet ? b.styleSheet.cssText = c :b.textContent = c, "1px" === d.width;
                }
            };
    }
    return function(b) {
        return {
            matches:a.matchMedium(b || "all"),
            media:b || "all"
        };
    };
}()), function(a, b, c) {
    "use strict";
    function d(b) {
        "object" == typeof module && "object" == typeof module.exports ? module.exports = b :"function" == typeof define && define.amd && define("picturefill", function() {
            return b;
        }), "object" == typeof a && (a.picturefill = b);
    }
    function e(a) {
        var b, c, d, e, f, i = a || {};
        b = i.elements || g.getAllElements();
        for (var j = 0, k = b.length; k > j; j++) if (c = b[j], d = c.parentNode, e = void 0,
                f = void 0, "IMG" === c.nodeName.toUpperCase() && (c[g.ns] || (c[g.ns] = {}), i.reevaluate || !c[g.ns].evaluated)) {
            if (d && "PICTURE" === d.nodeName.toUpperCase()) {
                if (g.removeVideoShim(d), e = g.getMatch(c, d), e === !1) continue;
            } else e = void 0;
            (d && "PICTURE" === d.nodeName.toUpperCase() || !g.sizesSupported && c.srcset && h.test(c.srcset)) && g.dodgeSrcset(c),
                e ? (f = g.processSourceSet(e), g.applyBestCandidate(f, c)) :(f = g.processSourceSet(c),
                (void 0 === c.srcset || c[g.ns].srcset) && g.applyBestCandidate(f, c)), c[g.ns].evaluated = !0;
        }
    }
    function f() {
        function c() {
            clearTimeout(d), d = setTimeout(h, 60);
        }
        g.initTypeDetects(), e();
        var d, f = setInterval(function() {
            return e(), /^loaded|^i|^c/.test(b.readyState) ? void clearInterval(f) :void 0;
        }, 250), h = function() {
            e({
                reevaluate:!0
            });
        };
        a.addEventListener ? a.addEventListener("resize", c, !1) :a.attachEvent && a.attachEvent("onresize", c);
    }
    if (a.HTMLPictureElement) return void d(function() {});
    b.createElement("picture");
    var g = a.picturefill || {}, h = /\s+\+?\d+(e\d+)?w/;
    g.ns = "picturefill", function() {
        g.srcsetSupported = "srcset" in c, g.sizesSupported = "sizes" in c, g.curSrcSupported = "currentSrc" in c;
    }(), g.trim = function(a) {
        return a.trim ? a.trim() :a.replace(/^\s+|\s+$/g, "");
    }, g.makeUrl = function() {
        var a = b.createElement("a");
        return function(b) {
            return a.href = b, a.href;
        };
    }(), g.restrictsMixedContent = function() {
        return "https:" === a.location.protocol;
    }, g.matchesMedia = function(b) {
        return a.matchMedia && a.matchMedia(b).matches;
    }, g.getDpr = function() {
        return a.devicePixelRatio || 1;
    }, g.getWidthFromLength = function(a) {
        var c;
        if (!a || a.indexOf("%") > -1 != !1 || !(parseFloat(a) > 0 || a.indexOf("calc(") > -1)) return !1;
        a = a.replace("vw", "%"), g.lengthEl || (g.lengthEl = b.createElement("div"), g.lengthEl.style.cssText = "border:0;display:block;font-size:1em;left:0;margin:0;padding:0;position:absolute;visibility:hidden",
            g.lengthEl.className = "helper-from-picturefill-js"), g.lengthEl.style.width = "0px";
        try {
            g.lengthEl.style.width = a;
        } catch (d) {}
        return b.body.appendChild(g.lengthEl), c = g.lengthEl.offsetWidth, 0 >= c && (c = !1),
            b.body.removeChild(g.lengthEl), c;
    }, g.detectTypeSupport = function(b, c) {
        var d = new a.Image();
        return d.onerror = function() {
            g.types[b] = !1, e();
        }, d.onload = function() {
            g.types[b] = 1 === d.width, e();
        }, d.src = c, "pending";
    }, g.types = g.types || {}, g.initTypeDetects = function() {
        g.types["image/jpeg"] = !0, g.types["image/gif"] = !0, g.types["image/png"] = !0,
            g.types["image/svg+xml"] = b.implementation.hasFeature("http://www.w3.org/TR/SVG11/feature#Image", "1.1"),
            g.types["image/webp"] = g.detectTypeSupport("image/webp", "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAAAAAAfQ//73v/+BiOh/AAA=");
    }, g.verifyTypeSupport = function(a) {
        var b = a.getAttribute("type");
        if (null === b || "" === b) return !0;
        var c = g.types[b];
        return "string" == typeof c && "pending" !== c ? (g.types[b] = g.detectTypeSupport(b, c),
            "pending") :"function" == typeof c ? (c(), "pending") :c;
    }, g.parseSize = function(a) {
        var b = /(\([^)]+\))?\s*(.+)/g.exec(a);
        return {
            media:b && b[1],
            length:b && b[2]
        };
    }, g.findWidthFromSourceSize = function(c) {
        for (var d, e = g.trim(c).split(/\s*,\s*/), f = 0, h = e.length; h > f; f++) {
            var i = e[f], j = g.parseSize(i), k = j.length, l = j.media;
            if (k && (!l || g.matchesMedia(l)) && (d = g.getWidthFromLength(k))) break;
        }
        return d || Math.max(a.innerWidth || 0, b.documentElement.clientWidth);
    }, g.parseSrcset = function(a) {
        for (var b = []; "" !== a; ) {
            a = a.replace(/^\s+/g, "");
            var c, d = a.search(/\s/g), e = null;
            if (-1 !== d) {
                c = a.slice(0, d);
                var f = c.slice(-1);
                if (("," === f || "" === c) && (c = c.replace(/,+$/, ""), e = ""), a = a.slice(d + 1),
                    null === e) {
                    var g = a.indexOf(",");
                    -1 !== g ? (e = a.slice(0, g), a = a.slice(g + 1)) :(e = a, a = "");
                }
            } else c = a, a = "";
            (c || e) && b.push({
                url:c,
                descriptor:e
            });
        }
        return b;
    }, g.parseDescriptor = function(a, b) {
        var c, d = b || "100vw", e = a && a.replace(/(^\s+|\s+$)/g, ""), f = g.findWidthFromSourceSize(d);
        if (e) for (var h = e.split(" "), i = h.length - 1; i >= 0; i--) {
            var j = h[i], k = j && j.slice(j.length - 1);
            if ("h" !== k && "w" !== k || g.sizesSupported) {
                if ("x" === k) {
                    var l = j && parseFloat(j, 10);
                    c = l && !isNaN(l) ? l :1;
                }
            } else c = parseFloat(parseInt(j, 10) / f);
        }
        return c || 1;
    }, g.getCandidatesFromSourceSet = function(a, b) {
        for (var c = g.parseSrcset(a), d = [], e = 0, f = c.length; f > e; e++) {
            var h = c[e];
            d.push({
                url:h.url,
                resolution:g.parseDescriptor(h.descriptor, b)
            });
        }
        return d;
    }, g.dodgeSrcset = function(a) {
        a.srcset && (a[g.ns].srcset = a.srcset, a.srcset = "", a.setAttribute("data-pfsrcset", a[g.ns].srcset));
    }, g.processSourceSet = function(a) {
        var b = a.getAttribute("srcset"), c = a.getAttribute("sizes"), d = [];
        return "IMG" === a.nodeName.toUpperCase() && a[g.ns] && a[g.ns].srcset && (b = a[g.ns].srcset),
        b && (d = g.getCandidatesFromSourceSet(b, c)), d;
    }, g.backfaceVisibilityFix = function(a) {
        var b = a.style || {}, c = "webkitBackfaceVisibility" in b, d = b.zoom;
        c && (b.zoom = ".999", c = a.offsetWidth, b.zoom = d);
    }, g.setIntrinsicSize = function() {
        var c = {}, d = function(a, b, c) {
            b && a.setAttribute("width", parseInt(b / c, 10));
        };
        return function(e, f) {
            var h;
            e[g.ns] && !a.pfStopIntrinsicSize && (void 0 === e[g.ns].dims && (e[g.ns].dims = e.getAttribute("width") || e.getAttribute("height")),
            e[g.ns].dims || (f.url in c ? d(e, c[f.url], f.resolution) :(h = b.createElement("img"),
                h.onload = function() {
                    if (c[f.url] = h.width, !c[f.url]) try {
                        b.body.appendChild(h), c[f.url] = h.width || h.offsetWidth, b.body.removeChild(h);
                    } catch (a) {}
                    e.src === f.url && d(e, c[f.url], f.resolution), e = null, h.onload = null, h = null;
                }, h.src = f.url)));
        };
    }(), g.applyBestCandidate = function(a, b) {
        var c, d, e;
        a.sort(g.ascendingSort), d = a.length, e = a[d - 1];
        for (var f = 0; d > f; f++) if (c = a[f], c.resolution >= g.getDpr()) {
            e = c;
            break;
        }
        e && (e.url = g.makeUrl(e.url), b.src !== e.url && (g.restrictsMixedContent() && "http:" === e.url.substr(0, "http:".length).toLowerCase() ? void 0 !== window.console && console.warn("Blocked mixed content image " + e.url) :(b.src = e.url,
        g.curSrcSupported || (b.currentSrc = b.src), g.backfaceVisibilityFix(b))), g.setIntrinsicSize(b, e));
    }, g.ascendingSort = function(a, b) {
        return a.resolution - b.resolution;
    }, g.removeVideoShim = function(a) {
        var b = a.getElementsByTagName("video");
        if (b.length) {
            for (var c = b[0], d = c.getElementsByTagName("source"); d.length; ) a.insertBefore(d[0], c);
            c.parentNode.removeChild(c);
        }
    }, g.getAllElements = function() {
        for (var a = [], c = b.getElementsByTagName("img"), d = 0, e = c.length; e > d; d++) {
            var f = c[d];
            ("PICTURE" === f.parentNode.nodeName.toUpperCase() || null !== f.getAttribute("srcset") || f[g.ns] && null !== f[g.ns].srcset) && a.push(f);
        }
        return a;
    }, g.getMatch = function(a, b) {
        for (var c, d = b.childNodes, e = 0, f = d.length; f > e; e++) {
            var h = d[e];
            if (1 === h.nodeType) {
                if (h === a) return c;
                if ("SOURCE" === h.nodeName.toUpperCase()) {
                    null !== h.getAttribute("src") && void 0 !== typeof console && console.warn("The `src` attribute is invalid on `picture` `source` element; instead, use `srcset`.");
                    var i = h.getAttribute("media");
                    if (h.getAttribute("srcset") && (!i || g.matchesMedia(i))) {
                        var j = g.verifyTypeSupport(h);
                        if (j === !0) {
                            c = h;
                            break;
                        }
                        if ("pending" === j) return !1;
                    }
                }
            }
        }
        return c;
    }, f(), e._ = g, d(e);
}(window, window.document, new window.Image());
/**!
 * lightgallery.js | 1.1.3 | February 11th 2019
 * http://sachinchoolur.github.io/lightgallery.js/
 * Copyright (c) 2016 Sachin N;
 * @license GPLv3
 */(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.Lightgallery = f()}})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
        (function (global, factory) {
            if (typeof define === "function" && define.amd) {
                define(['exports'], factory);
            } else if (typeof exports !== "undefined") {
                factory(exports);
            } else {
                var mod = {
                    exports: {}
                };
                factory(mod.exports);
                global.lgUtils = mod.exports;
            }
        })(this, function (exports) {
            'use strict';

            Object.defineProperty(exports, "__esModule", {
                value: true
            });

            var utils = {
                getAttribute: function getAttribute(el, label) {
                    return el[label];
                },

                setAttribute: function setAttribute(el, label, value) {
                    el[label] = value;
                },
                wrap: function wrap(el, className) {
                    if (!el) {
                        return;
                    }

                    var wrapper = document.createElement('div');
                    wrapper.className = className;
                    el.parentNode.insertBefore(wrapper, el);
                    el.parentNode.removeChild(el);
                    wrapper.appendChild(el);
                },

                addClass: function addClass(el, className) {
                    if (!el) {
                        return;
                    }

                    if (el.classList) {
                        el.classList.add(className);
                    } else {
                        el.className += ' ' + className;
                    }
                },

                removeClass: function removeClass(el, className) {
                    if (!el) {
                        return;
                    }

                    if (el.classList) {
                        el.classList.remove(className);
                    } else {
                        el.className = el.className.replace(new RegExp('(^|\\b)' + className.split(' ').join('|') + '(\\b|$)', 'gi'), ' ');
                    }
                },

                hasClass: function hasClass(el, className) {
                    if (el.classList) {
                        return el.classList.contains(className);
                    } else {
                        return new RegExp('(^| )' + className + '( |$)', 'gi').test(el.className);
                    }
                },

                // ex Transform
                // ex TransitionTimingFunction
                setVendor: function setVendor(el, property, value) {
                    if (!el) {
                        return;
                    }

                    el.style[property.charAt(0).toLowerCase() + property.slice(1)] = value;
                    el.style['webkit' + property] = value;
                    el.style['moz' + property] = value;
                    el.style['ms' + property] = value;
                    el.style['o' + property] = value;
                },

                trigger: function trigger(el, event) {
                    var detail = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

                    if (!el) {
                        return;
                    }

                    var customEvent = new CustomEvent(event, {
                        detail: detail
                    });
                    el.dispatchEvent(customEvent);
                },

                Listener: {
                    uid: 0
                },
                on: function on(el, events, fn) {
                    var _this = this;

                    if (!el) {
                        return;
                    }

                    events.split(' ').forEach(function (event) {
                        var _id = _this.getAttribute(el, 'lg-event-uid') || '';
                        utils.Listener.uid++;
                        _id += '&' + utils.Listener.uid;
                        _this.setAttribute(el, 'lg-event-uid', _id);
                        utils.Listener[event + utils.Listener.uid] = fn;
                        el.addEventListener(event.split('.')[0], fn, false);
                    });
                },

                off: function off(el, event) {
                    if (!el) {
                        return;
                    }

                    var _id = this.getAttribute(el, 'lg-event-uid');
                    if (_id) {
                        _id = _id.split('&');
                        for (var i = 0; i < _id.length; i++) {
                            if (_id[i]) {
                                var _event = event + _id[i];
                                if (_event.substring(0, 1) === '.') {
                                    for (var key in utils.Listener) {
                                        if (utils.Listener.hasOwnProperty(key)) {
                                            if (key.split('.').indexOf(_event.split('.')[1]) > -1) {
                                                el.removeEventListener(key.split('.')[0], utils.Listener[key]);
                                                this.setAttribute(el, 'lg-event-uid', this.getAttribute(el, 'lg-event-uid').replace('&' + _id[i], ''));
                                                delete utils.Listener[key];
                                            }
                                        }
                                    }
                                } else {
                                    el.removeEventListener(_event.split('.')[0], utils.Listener[_event]);
                                    this.setAttribute(el, 'lg-event-uid', this.getAttribute(el, 'lg-event-uid').replace('&' + _id[i], ''));
                                    delete utils.Listener[_event];
                                }
                            }
                        }
                    }
                },

                param: function param(obj) {
                    return Object.keys(obj).map(function (k) {
                        return encodeURIComponent(k) + '=' + encodeURIComponent(obj[k]);
                    }).join('&');
                }
            };

            exports.default = utils;
        });

    },{}],2:[function(require,module,exports){
        (function (global, factory) {
            if (typeof define === "function" && define.amd) {
                define(['./lg-utils'], factory);
            } else if (typeof exports !== "undefined") {
                factory(require('./lg-utils'));
            } else {
                var mod = {
                    exports: {}
                };
                factory(global.lgUtils);
                global.lightgallery = mod.exports;
            }
        })(this, function (_lgUtils) {
            'use strict';

            var _lgUtils2 = _interopRequireDefault(_lgUtils);

            function _interopRequireDefault(obj) {
                return obj && obj.__esModule ? obj : {
                    default: obj
                };
            }

            var _extends = Object.assign || function (target) {
                for (var i = 1; i < arguments.length; i++) {
                    var source = arguments[i];

                    for (var key in source) {
                        if (Object.prototype.hasOwnProperty.call(source, key)) {
                            target[key] = source[key];
                        }
                    }
                }

                return target;
            };

            /** Polyfill the CustomEvent() constructor functionality in Internet Explorer 9 and higher */
            (function () {

                if (typeof window.CustomEvent === 'function') {
                    return false;
                }

                function CustomEvent(event, params) {
                    params = params || {
                        bubbles: false,
                        cancelable: false,
                        detail: undefined
                    };
                    var evt = document.createEvent('CustomEvent');
                    evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);
                    return evt;
                }

                CustomEvent.prototype = window.Event.prototype;

                window.CustomEvent = CustomEvent;
            })();

            window.utils = _lgUtils2.default;
            window.lgData = {
                uid: 0
            };

            window.lgModules = {};
            var defaults = {

                mode: 'lg-slide',

                // Ex : 'ease'
                cssEasing: 'ease',

                //'for jquery animation'
                easing: 'linear',
                speed: 600,
                height: '100%',
                width: '100%',
                addClass: '',
                startClass: 'lg-start-zoom',
                backdropDuration: 150,
                hideBarsDelay: 6000,

                useLeft: false,

                closable: true,
                loop: true,
                escKey: true,
                keyPress: true,
                controls: true,
                slideEndAnimatoin: true,
                hideControlOnEnd: false,
                mousewheel: false,

                getCaptionFromTitleOrAlt: true,

                // .lg-item || '.lg-sub-html'
                appendSubHtmlTo: '.lg-sub-html',

                subHtmlSelectorRelative: false,

                /**
                 * @desc number of preload slides
                 * will exicute only after the current slide is fully loaded.
                 *
                 * @ex you clicked on 4th image and if preload = 1 then 3rd slide and 5th
                 * slide will be loaded in the background after the 4th slide is fully loaded..
                 * if preload is 2 then 2nd 3rd 5th 6th slides will be preloaded.. ... ...
                 *
                 */
                preload: 1,
                showAfterLoad: true,
                selector: '',
                selectWithin: '',
                nextHtml: '',
                prevHtml: '',

                // 0, 1
                index: false,

                iframeMaxWidth: '100%',

                download: true,
                counter: true,
                appendCounterTo: '.lg-toolbar',

                swipeThreshold: 50,
                enableSwipe: true,
                enableDrag: true,

                dynamic: false,
                dynamicEl: [],
                galleryId: 1
            };

            function Plugin(element, options) {

                // Current lightGallery element
                this.el = element;

                // lightGallery settings
                this.s = _extends({}, defaults, options);

                // When using dynamic mode, ensure dynamicEl is an array
                if (this.s.dynamic && this.s.dynamicEl !== 'undefined' && this.s.dynamicEl.constructor === Array && !this.s.dynamicEl.length) {
                    throw 'When using dynamic mode, you must also define dynamicEl as an Array.';
                }

                // lightGallery modules
                this.modules = {};

                // false when lightgallery complete first slide;
                this.lGalleryOn = false;

                this.lgBusy = false;

                // Timeout function for hiding controls;
                this.hideBartimeout = false;

                // To determine browser supports for touch events;
                this.isTouch = 'ontouchstart' in document.documentElement;

                // Disable hideControlOnEnd if sildeEndAnimation is true
                if (this.s.slideEndAnimatoin) {
                    this.s.hideControlOnEnd = false;
                }

                this.items = [];

                // Gallery items
                if (this.s.dynamic) {
                    this.items = this.s.dynamicEl;
                } else {
                    if (this.s.selector === 'this') {
                        this.items.push(this.el);
                    } else if (this.s.selector !== '') {
                        if (this.s.selectWithin) {
                            this.items = document.querySelector(this.s.selectWithin).querySelectorAll(this.s.selector);
                        } else {
                            this.items = this.el.querySelectorAll(this.s.selector);
                        }
                    } else {
                        this.items = this.el.children;
                    }
                }

                // .lg-item

                this.___slide = '';

                // .lg-outer
                this.outer = '';

                this.init();

                return this;
            }

            Plugin.prototype.init = function () {

                var _this = this;

                // s.preload should not be more than $item.length
                if (_this.s.preload > _this.items.length) {
                    _this.s.preload = _this.items.length;
                }

                // if dynamic option is enabled execute immediately
                var _hash = window.location.hash;
                if (_hash.indexOf('lg=' + this.s.galleryId) > 0) {

                    _this.index = parseInt(_hash.split('&slide=')[1], 10);

                    _lgUtils2.default.addClass(document.body, 'lg-from-hash');
                    if (!_lgUtils2.default.hasClass(document.body, 'lg-on')) {
                        _lgUtils2.default.addClass(document.body, 'lg-on');
                        setTimeout(function () {
                            _this.build(_this.index);
                        });
                    }
                }

                if (_this.s.dynamic) {

                    _lgUtils2.default.trigger(this.el, 'onBeforeOpen');

                    _this.index = _this.s.index || 0;

                    // prevent accidental double execution
                    if (!_lgUtils2.default.hasClass(document.body, 'lg-on')) {
                        _lgUtils2.default.addClass(document.body, 'lg-on');
                        setTimeout(function () {
                            _this.build(_this.index);
                        });
                    }
                } else {

                    for (var i = 0; i < _this.items.length; i++) {

                        /*jshint loopfunc: true */
                        (function (index) {

                            // Using different namespace for click because click event should not unbind if selector is same object('this')
                            _lgUtils2.default.on(_this.items[index], 'click.lgcustom', function (e) {

                                e.preventDefault();

                                _lgUtils2.default.trigger(_this.el, 'onBeforeOpen');

                                _this.index = _this.s.index || index;

                                if (!_lgUtils2.default.hasClass(document.body, 'lg-on')) {
                                    _this.build(_this.index);
                                    _lgUtils2.default.addClass(document.body, 'lg-on');
                                }
                            });
                        })(i);
                    }
                }
            };

            Plugin.prototype.build = function (index) {

                var _this = this;

                _this.structure();

                for (var key in window.lgModules) {
                    _this.modules[key] = new window.lgModules[key](_this.el);
                }

                // initiate slide function
                _this.slide(index, false, false);

                if (_this.s.keyPress) {
                    _this.keyPress();
                }

                if (_this.items.length > 1) {

                    _this.arrow();

                    setTimeout(function () {
                        _this.enableDrag();
                        _this.enableSwipe();
                    }, 50);

                    if (_this.s.mousewheel) {
                        _this.mousewheel();
                    }
                }

                _this.counter();

                _this.closeGallery();

                _lgUtils2.default.trigger(_this.el, 'onAfterOpen');

                // Hide controllers if mouse doesn't move for some period
                _lgUtils2.default.on(_this.outer, 'mousemove.lg click.lg touchstart.lg', function () {

                    _lgUtils2.default.removeClass(_this.outer, 'lg-hide-items');

                    clearTimeout(_this.hideBartimeout);

                    // Timeout will be cleared on each slide movement also
                    _this.hideBartimeout = setTimeout(function () {
                        _lgUtils2.default.addClass(_this.outer, 'lg-hide-items');
                    }, _this.s.hideBarsDelay);
                });
            };

            Plugin.prototype.structure = function () {
                var list = '';
                var controls = '';
                var i = 0;
                var subHtmlCont = '';
                var template;
                var _this = this;

                document.body.insertAdjacentHTML('beforeend', '<div class="lg-backdrop"></div>');
                _lgUtils2.default.setVendor(document.querySelector('.lg-backdrop'), 'TransitionDuration', this.s.backdropDuration + 'ms');

                // Create gallery items
                for (i = 0; i < this.items.length; i++) {
                    list += '<div class="lg-item"></div>';
                }

                // Create controlls
                if (this.s.controls && this.items.length > 1) {
                    controls = '<div class="lg-actions">' + '<div class="lg-prev lg-icon">' + this.s.prevHtml + '</div>' + '<div class="lg-next lg-icon">' + this.s.nextHtml + '</div>' + '</div>';
                }

                if (this.s.appendSubHtmlTo === '.lg-sub-html') {
                    subHtmlCont = '<div class="lg-sub-html"></div>';
                }

                template = '<div class="lg-outer ' + this.s.addClass + ' ' + this.s.startClass + '">' + '<div class="lg" style="width:' + this.s.width + '; height:' + this.s.height + '">' + '<div class="lg-inner">' + list + '</div>' + '<div class="lg-toolbar group">' + '<span class="lg-close lg-icon"></span>' + '</div>' + controls + subHtmlCont + '</div>' + '</div>';

                document.body.insertAdjacentHTML('beforeend', template);
                this.outer = document.querySelector('.lg-outer');
                this.___slide = this.outer.querySelectorAll('.lg-item');

                if (this.s.useLeft) {
                    _lgUtils2.default.addClass(this.outer, 'lg-use-left');

                    // Set mode lg-slide if use left is true;
                    this.s.mode = 'lg-slide';
                } else {
                    _lgUtils2.default.addClass(this.outer, 'lg-use-css3');
                }

                // For fixed height gallery
                _this.setTop();
                _lgUtils2.default.on(window, 'resize.lg orientationchange.lg', function () {
                    setTimeout(function () {
                        _this.setTop();
                    }, 100);
                });

                // add class lg-current to remove initial transition
                _lgUtils2.default.addClass(this.___slide[this.index], 'lg-current');

                // add Class for css support and transition mode
                if (this.doCss()) {
                    _lgUtils2.default.addClass(this.outer, 'lg-css3');
                } else {
                    _lgUtils2.default.addClass(this.outer, 'lg-css');

                    // Set speed 0 because no animation will happen if browser doesn't support css3
                    this.s.speed = 0;
                }

                _lgUtils2.default.addClass(this.outer, this.s.mode);

                if (this.s.enableDrag && this.items.length > 1) {
                    _lgUtils2.default.addClass(this.outer, 'lg-grab');
                }

                if (this.s.showAfterLoad) {
                    _lgUtils2.default.addClass(this.outer, 'lg-show-after-load');
                }

                if (this.doCss()) {
                    var inner = this.outer.querySelector('.lg-inner');
                    _lgUtils2.default.setVendor(inner, 'TransitionTimingFunction', this.s.cssEasing);
                    _lgUtils2.default.setVendor(inner, 'TransitionDuration', this.s.speed + 'ms');
                }

                setTimeout(function () {
                    _lgUtils2.default.addClass(document.querySelector('.lg-backdrop'), 'in');
                });

                setTimeout(function () {
                    _lgUtils2.default.addClass(_this.outer, 'lg-visible');
                }, this.s.backdropDuration);

                if (this.s.download) {
                    this.outer.querySelector('.lg-toolbar').insertAdjacentHTML('beforeend', '<a id="lg-download" target="_blank" download class="lg-download lg-icon"></a>');
                }

                // Store the current scroll top value to scroll back after closing the gallery..
                this.prevScrollTop = document.documentElement.scrollTop || document.body.scrollTop;
            };

            // For fixed height gallery
            Plugin.prototype.setTop = function () {
                if (this.s.height !== '100%') {
                    var wH = window.innerHeight;
                    var top = (wH - parseInt(this.s.height, 10)) / 2;
                    var lGallery = this.outer.querySelector('.lg');
                    if (wH >= parseInt(this.s.height, 10)) {
                        lGallery.style.top = top + 'px';
                    } else {
                        lGallery.style.top = '0px';
                    }
                }
            };

            // Find css3 support
            Plugin.prototype.doCss = function () {
                // check for css animation support
                var support = function support() {
                    var transition = ['transition', 'MozTransition', 'WebkitTransition', 'OTransition', 'msTransition', 'KhtmlTransition'];
                    var root = document.documentElement;
                    var i = 0;
                    for (i = 0; i < transition.length; i++) {
                        if (transition[i] in root.style) {
                            return true;
                        }
                    }
                };

                if (support()) {
                    return true;
                }

                return false;
            };

            /**
             *  @desc Check the given src is video
             *  @param {String} src
             *  @return {Object} video type
             *  Ex:{ youtube  :  ["//www.youtube.com/watch?v=c0asJgSyxcY", "c0asJgSyxcY"] }
             */
            Plugin.prototype.isVideo = function (src, index) {

                var html;
                if (this.s.dynamic) {
                    html = this.s.dynamicEl[index].html;
                } else {
                    html = this.items[index].getAttribute('data-html');
                }

                if (!src && html) {
                    return {
                        html5: true
                    };
                }

                var youtube = src.match(/\/\/(?:www\.)?youtu(?:\.be|be\.com|be-nocookie\.com)\/(?:watch\?v=|embed\/)?([a-z0-9\-\_\%]+)/i);
                var vimeo = src.match(/\/\/(?:www\.)?vimeo.com\/([0-9a-z\-_]+)/i);
                var dailymotion = src.match(/\/\/(?:www\.)?dai.ly\/([0-9a-z\-_]+)/i);
                var vk = src.match(/\/\/(?:www\.)?(?:vk\.com|vkontakte\.ru)\/(?:video_ext\.php\?)(.*)/i);

                if (youtube) {
                    return {
                        youtube: youtube
                    };
                } else if (vimeo) {
                    return {
                        vimeo: vimeo
                    };
                } else if (dailymotion) {
                    return {
                        dailymotion: dailymotion
                    };
                } else if (vk) {
                    return {
                        vk: vk
                    };
                }
            };

            /**
             *  @desc Create image counter
             *  Ex: 1/10
             */
            Plugin.prototype.counter = function () {
                if (this.s.counter) {
                    this.outer.querySelector(this.s.appendCounterTo).insertAdjacentHTML('beforeend', '<div id="lg-counter"><span id="lg-counter-current">' + (parseInt(this.index, 10) + 1) + '</span> / <span id="lg-counter-all">' + this.items.length + '</span></div>');
                }
            };

            /**
             *  @desc add sub-html into the slide
             *  @param {Number} index - index of the slide
             */
            Plugin.prototype.addHtml = function (index) {
                var subHtml = null;
                var currentEle;
                if (this.s.dynamic) {
                    subHtml = this.s.dynamicEl[index].subHtml;
                } else {
                    currentEle = this.items[index];
                    subHtml = currentEle.getAttribute('data-sub-html');
                    if (this.s.getCaptionFromTitleOrAlt && !subHtml) {
                        subHtml = currentEle.getAttribute('title');
                        if (subHtml && currentEle.querySelector('img')) {
                            subHtml = currentEle.querySelector('img').getAttribute('alt');
                        }
                    }
                }

                if (typeof subHtml !== 'undefined' && subHtml !== null) {

                    // get first letter of subhtml
                    // if first letter starts with . or # get the html form the jQuery object
                    var fL = subHtml.substring(0, 1);
                    if (fL === '.' || fL === '#') {
                        if (this.s.subHtmlSelectorRelative && !this.s.dynamic) {
                            subHtml = currentEle.querySelector(subHtml).innerHTML;
                        } else {
                            subHtml = document.querySelector(subHtml).innerHTML;
                        }
                    }
                } else {
                    subHtml = '';
                }

                if (this.s.appendSubHtmlTo === '.lg-sub-html') {
                    this.outer.querySelector(this.s.appendSubHtmlTo).innerHTML = subHtml;
                } else {
                    this.___slide[index].insertAdjacentHTML('beforeend', subHtml);
                }

                // Add lg-empty-html class if title doesn't exist
                if (typeof subHtml !== 'undefined' && subHtml !== null) {
                    if (subHtml === '') {
                        _lgUtils2.default.addClass(this.outer.querySelector(this.s.appendSubHtmlTo), 'lg-empty-html');
                    } else {
                        _lgUtils2.default.removeClass(this.outer.querySelector(this.s.appendSubHtmlTo), 'lg-empty-html');
                    }
                }

                _lgUtils2.default.trigger(this.el, 'onAfterAppendSubHtml', {
                    index: index
                });
            };

            /**
             *  @desc Preload slides
             *  @param {Number} index - index of the slide
             */
            Plugin.prototype.preload = function (index) {
                var i = 1;
                var j = 1;
                for (i = 1; i <= this.s.preload; i++) {
                    if (i >= this.items.length - index) {
                        break;
                    }

                    this.loadContent(index + i, false, 0);
                }

                for (j = 1; j <= this.s.preload; j++) {
                    if (index - j < 0) {
                        break;
                    }

                    this.loadContent(index - j, false, 0);
                }
            };

            /**
             *  @desc Load slide content into slide.
             *  @param {Number} index - index of the slide.
             *  @param {Boolean} rec - if true call loadcontent() function again.
             *  @param {Boolean} delay - delay for adding complete class. it is 0 except first time.
             */
            Plugin.prototype.loadContent = function (index, rec, delay) {

                var _this = this;
                var _hasPoster = false;
                var _img;
                var _src;
                var _poster;
                var _srcset;
                var _sizes;
                var _html;
                var getResponsiveSrc = function getResponsiveSrc(srcItms) {
                    var rsWidth = [];
                    var rsSrc = [];
                    for (var i = 0; i < srcItms.length; i++) {
                        var __src = srcItms[i].split(' ');

                        // Manage empty space
                        if (__src[0] === '') {
                            __src.splice(0, 1);
                        }

                        rsSrc.push(__src[0]);
                        rsWidth.push(__src[1]);
                    }

                    var wWidth = window.innerWidth;
                    for (var j = 0; j < rsWidth.length; j++) {
                        if (parseInt(rsWidth[j], 10) > wWidth) {
                            _src = rsSrc[j];
                            break;
                        }
                    }
                };

                if (_this.s.dynamic) {

                    if (_this.s.dynamicEl[index].poster) {
                        _hasPoster = true;
                        _poster = _this.s.dynamicEl[index].poster;
                    }

                    _html = _this.s.dynamicEl[index].html;
                    _src = _this.s.dynamicEl[index].src;

                    if (_this.s.dynamicEl[index].responsive) {
                        var srcDyItms = _this.s.dynamicEl[index].responsive.split(',');
                        getResponsiveSrc(srcDyItms);
                    }

                    _srcset = _this.s.dynamicEl[index].srcset;
                    _sizes = _this.s.dynamicEl[index].sizes;
                } else {

                    if (_this.items[index].getAttribute('data-poster')) {
                        _hasPoster = true;
                        _poster = _this.items[index].getAttribute('data-poster');
                    }

                    _html = _this.items[index].getAttribute('data-html');
                    _src = _this.items[index].getAttribute('href') || _this.items[index].getAttribute('data-src');

                    if (_this.items[index].getAttribute('data-responsive')) {
                        var srcItms = _this.items[index].getAttribute('data-responsive').split(',');
                        getResponsiveSrc(srcItms);
                    }

                    _srcset = _this.items[index].getAttribute('data-srcset');
                    _sizes = _this.items[index].getAttribute('data-sizes');
                }


                //if (_src || _srcset || _sizes || _poster) {

                var iframe = false;
                if (_this.s.dynamic) {
                    if (_this.s.dynamicEl[index].iframe) {
                        iframe = true;
                    }
                } else {
                    if (_this.items[index].getAttribute('data-iframe') === 'true') {
                        iframe = true;
                    }
                }

                var _isVideo = _this.isVideo(_src, index);
                if (!_lgUtils2.default.hasClass(_this.___slide[index], 'lg-loaded')) {
                    if (iframe) {
                        _this.___slide[index].insertAdjacentHTML('afterbegin', '<div class="lg-video-cont" style="max-width:' + _this.s.iframeMaxWidth + '"><div class="lg-video"><iframe class="lg-object" frameborder="0" src="' + _src + '"  allowfullscreen="true"></iframe></div></div>');
                    } else if (_hasPoster) {
                        var videoClass = '';
                        if (_isVideo && _isVideo.youtube) {
                            videoClass = 'lg-has-youtube';
                        } else if (_isVideo && _isVideo.vimeo) {
                            videoClass = 'lg-has-vimeo';
                        } else {
                            videoClass = 'lg-has-html5';
                        }

                        _this.___slide[index].insertAdjacentHTML('beforeend', '<div class="lg-video-cont ' + videoClass + ' "><div class="lg-video"><span class="lg-video-play"></span><img class="lg-object lg-has-poster" src="' + _poster + '" /></div></div>');
                    } else if (_isVideo) {
                        _this.___slide[index].insertAdjacentHTML('beforeend', '<div class="lg-video-cont "><div class="lg-video"></div></div>');
                        _lgUtils2.default.trigger(_this.el, 'hasVideo', {
                            index: index,
                            src: _src,
                            html: _html
                        });
                    } else {
                        _this.___slide[index].insertAdjacentHTML('beforeend', '<div class="lg-img-wrap"><img class="lg-object lg-image" src="' + _src + '" /></div>');
                    }

                    _lgUtils2.default.trigger(_this.el, 'onAferAppendSlide', {
                        index: index
                    });

                    _img = _this.___slide[index].querySelector('.lg-object');
                    if (_sizes) {
                        _img.setAttribute('sizes', _sizes);
                    }

                    if (_srcset) {
                        _img.setAttribute('srcset', _srcset);
                        try {
                            picturefill({
                                elements: [_img[0]]
                            });
                        } catch (e) {
                            console.error('Make sure you have included Picturefill version 2');
                        }
                    }

                    if (this.s.appendSubHtmlTo !== '.lg-sub-html') {
                        _this.addHtml(index);
                    }

                    _lgUtils2.default.addClass(_this.___slide[index], 'lg-loaded');
                }

                _lgUtils2.default.on(_this.___slide[index].querySelector('.lg-object'), 'load.lg error.lg', function () {

                    // For first time add some delay for displaying the start animation.
                    var _speed = 0;

                    // Do not change the delay value because it is required for zoom plugin.
                    // If gallery opened from direct url (hash) speed value should be 0
                    if (delay && !_lgUtils2.default.hasClass(document.body, 'lg-from-hash')) {
                        _speed = delay;
                    }

                    setTimeout(function () {
                        _lgUtils2.default.addClass(_this.___slide[index], 'lg-complete');

                        _lgUtils2.default.trigger(_this.el, 'onSlideItemLoad', {
                            index: index,
                            delay: delay || 0
                        });
                    }, _speed);
                });

                // @todo check load state for html5 videos
                if (_isVideo && _isVideo.html5 && !_hasPoster) {
                    _lgUtils2.default.addClass(_this.___slide[index], 'lg-complete');
                }

                if (rec === true) {
                    if (!_lgUtils2.default.hasClass(_this.___slide[index], 'lg-complete')) {
                        _lgUtils2.default.on(_this.___slide[index].querySelector('.lg-object'), 'load.lg error.lg', function () {
                            _this.preload(index);
                        });
                    } else {
                        _this.preload(index);
                    }
                }

                //}
            };

            /**
             *   @desc slide function for lightgallery
             ** Slide() gets call on start
             ** ** Set lg.on true once slide() function gets called.
             ** Call loadContent() on slide() function inside setTimeout
             ** ** On first slide we do not want any animation like slide of fade
             ** ** So on first slide( if lg.on if false that is first slide) loadContent() should start loading immediately
             ** ** Else loadContent() should wait for the transition to complete.
             ** ** So set timeout s.speed + 50
             <=> ** loadContent() will load slide content in to the particular slide
             ** ** It has recursion (rec) parameter. if rec === true loadContent() will call preload() function.
             ** ** preload will execute only when the previous slide is fully loaded (images iframe)
             ** ** avoid simultaneous image load
             <=> ** Preload() will check for s.preload value and call loadContent() again accoring to preload value
             ** loadContent()  <====> Preload();

             *   @param {Number} index - index of the slide
             *   @param {Boolean} fromTouch - true if slide function called via touch event or mouse drag
             *   @param {Boolean} fromThumb - true if slide function called via thumbnail click
             */
            Plugin.prototype.slide = function (index, fromTouch, fromThumb) {

                var _prevIndex = 0;
                for (var i = 0; i < this.___slide.length; i++) {
                    if (_lgUtils2.default.hasClass(this.___slide[i], 'lg-current')) {
                        _prevIndex = i;
                        break;
                    }
                }

                var _this = this;

                // Prevent if multiple call
                // Required for hsh plugin
                if (_this.lGalleryOn && _prevIndex === index) {
                    return;
                }

                var _length = this.___slide.length;
                var _time = _this.lGalleryOn ? this.s.speed : 0;
                var _next = false;
                var _prev = false;

                if (!_this.lgBusy) {

                    if (this.s.download) {
                        var _src;
                        if (_this.s.dynamic) {
                            _src = _this.s.dynamicEl[index].downloadUrl !== false && (_this.s.dynamicEl[index].downloadUrl || _this.s.dynamicEl[index].src);
                        } else {
                            _src = _this.items[index].getAttribute('data-download-url') !== 'false' && (_this.items[index].getAttribute('data-download-url') || _this.items[index].getAttribute('href') || _this.items[index].getAttribute('data-src'));
                        }

                        if (_src) {
                            document.getElementById('lg-download').setAttribute('href', _src);
                            _lgUtils2.default.removeClass(_this.outer, 'lg-hide-download');
                        } else {
                            _lgUtils2.default.addClass(_this.outer, 'lg-hide-download');
                        }
                    }

                    _lgUtils2.default.trigger(_this.el, 'onBeforeSlide', {
                        prevIndex: _prevIndex,
                        index: index,
                        fromTouch: fromTouch,
                        fromThumb: fromThumb
                    });

                    _this.lgBusy = true;

                    clearTimeout(_this.hideBartimeout);

                    // Add title if this.s.appendSubHtmlTo === lg-sub-html
                    if (this.s.appendSubHtmlTo === '.lg-sub-html') {

                        // wait for slide animation to complete
                        setTimeout(function () {
                            _this.addHtml(index);
                        }, _time);
                    }

                    this.arrowDisable(index);

                    if (!fromTouch) {

                        // remove all transitions
                        _lgUtils2.default.addClass(_this.outer, 'lg-no-trans');

                        for (var j = 0; j < this.___slide.length; j++) {
                            _lgUtils2.default.removeClass(this.___slide[j], 'lg-prev-slide');
                            _lgUtils2.default.removeClass(this.___slide[j], 'lg-next-slide');
                        }

                        if (index < _prevIndex) {
                            _prev = true;
                            if (index === 0 && _prevIndex === _length - 1 && !fromThumb) {
                                _prev = false;
                                _next = true;
                            }
                        } else if (index > _prevIndex) {
                            _next = true;
                            if (index === _length - 1 && _prevIndex === 0 && !fromThumb) {
                                _prev = true;
                                _next = false;
                            }
                        }

                        if (_prev) {

                            //prevslide
                            _lgUtils2.default.addClass(this.___slide[index], 'lg-prev-slide');
                            _lgUtils2.default.addClass(this.___slide[_prevIndex], 'lg-next-slide');
                        } else if (_next) {

                            // next slide
                            _lgUtils2.default.addClass(this.___slide[index], 'lg-next-slide');
                            _lgUtils2.default.addClass(this.___slide[_prevIndex], 'lg-prev-slide');
                        }

                        // give 50 ms for browser to add/remove class
                        setTimeout(function () {
                            _lgUtils2.default.removeClass(_this.outer.querySelector('.lg-current'), 'lg-current');

                            //_this.$slide.eq(_prevIndex).removeClass('lg-current');
                            _lgUtils2.default.addClass(_this.___slide[index], 'lg-current');

                            // reset all transitions
                            _lgUtils2.default.removeClass(_this.outer, 'lg-no-trans');
                        }, 50);
                    } else {

                        var touchPrev = index - 1;
                        var touchNext = index + 1;

                        if (index === 0 && _prevIndex === _length - 1) {

                            // next slide
                            touchNext = 0;
                            touchPrev = _length - 1;
                        } else if (index === _length - 1 && _prevIndex === 0) {

                            // prev slide
                            touchNext = 0;
                            touchPrev = _length - 1;
                        }

                        _lgUtils2.default.removeClass(_this.outer.querySelector('.lg-prev-slide'), 'lg-prev-slide');
                        _lgUtils2.default.removeClass(_this.outer.querySelector('.lg-current'), 'lg-current');
                        _lgUtils2.default.removeClass(_this.outer.querySelector('.lg-next-slide'), 'lg-next-slide');
                        _lgUtils2.default.addClass(_this.___slide[touchPrev], 'lg-prev-slide');
                        _lgUtils2.default.addClass(_this.___slide[touchNext], 'lg-next-slide');
                        _lgUtils2.default.addClass(_this.___slide[index], 'lg-current');
                    }

                    if (_this.lGalleryOn) {
                        setTimeout(function () {
                            _this.loadContent(index, true, 0);
                        }, this.s.speed + 50);

                        setTimeout(function () {
                            _this.lgBusy = false;
                            _lgUtils2.default.trigger(_this.el, 'onAfterSlide', {
                                prevIndex: _prevIndex,
                                index: index,
                                fromTouch: fromTouch,
                                fromThumb: fromThumb
                            });
                        }, this.s.speed);
                    } else {
                        _this.loadContent(index, true, _this.s.backdropDuration);

                        _this.lgBusy = false;
                        _lgUtils2.default.trigger(_this.el, 'onAfterSlide', {
                            prevIndex: _prevIndex,
                            index: index,
                            fromTouch: fromTouch,
                            fromThumb: fromThumb
                        });
                    }

                    _this.lGalleryOn = true;

                    if (this.s.counter) {
                        if (document.getElementById('lg-counter-current')) {
                            document.getElementById('lg-counter-current').innerHTML = index + 1;
                        }
                    }
                }
            };

            /**
             *  @desc Go to next slide
             *  @param {Boolean} fromTouch - true if slide function called via touch event
             */
            Plugin.prototype.goToNextSlide = function (fromTouch) {
                var _this = this;
                if (!_this.lgBusy) {
                    if (_this.index + 1 < _this.___slide.length) {
                        _this.index++;
                        _lgUtils2.default.trigger(_this.el, 'onBeforeNextSlide', {
                            index: _this.index
                        });
                        _this.slide(_this.index, fromTouch, false);
                    } else {
                        if (_this.s.loop) {
                            _this.index = 0;
                            _lgUtils2.default.trigger(_this.el, 'onBeforeNextSlide', {
                                index: _this.index
                            });
                            _this.slide(_this.index, fromTouch, false);
                        } else if (_this.s.slideEndAnimatoin) {
                            _lgUtils2.default.addClass(_this.outer, 'lg-right-end');
                            setTimeout(function () {
                                _lgUtils2.default.removeClass(_this.outer, 'lg-right-end');
                            }, 400);
                        }
                    }
                }
            };

            /**
             *  @desc Go to previous slide
             *  @param {Boolean} fromTouch - true if slide function called via touch event
             */
            Plugin.prototype.goToPrevSlide = function (fromTouch) {
                var _this = this;
                if (!_this.lgBusy) {
                    if (_this.index > 0) {
                        _this.index--;
                        _lgUtils2.default.trigger(_this.el, 'onBeforePrevSlide', {
                            index: _this.index,
                            fromTouch: fromTouch
                        });
                        _this.slide(_this.index, fromTouch, false);
                    } else {
                        if (_this.s.loop) {
                            _this.index = _this.items.length - 1;
                            _lgUtils2.default.trigger(_this.el, 'onBeforePrevSlide', {
                                index: _this.index,
                                fromTouch: fromTouch
                            });
                            _this.slide(_this.index, fromTouch, false);
                        } else if (_this.s.slideEndAnimatoin) {
                            _lgUtils2.default.addClass(_this.outer, 'lg-left-end');
                            setTimeout(function () {
                                _lgUtils2.default.removeClass(_this.outer, 'lg-left-end');
                            }, 400);
                        }
                    }
                }
            };

            Plugin.prototype.keyPress = function () {
                var _this = this;
                if (this.items.length > 1) {
                    _lgUtils2.default.on(window, 'keyup.lg', function (e) {
                        if (_this.items.length > 1) {
                            if (e.keyCode === 37) {
                                e.preventDefault();
                                _this.goToPrevSlide();
                            }

                            if (e.keyCode === 39) {
                                e.preventDefault();
                                _this.goToNextSlide();
                            }
                        }
                    });
                }

                _lgUtils2.default.on(window, 'keydown.lg', function (e) {
                    if (_this.s.escKey === true && e.keyCode === 27) {
                        e.preventDefault();
                        if (!_lgUtils2.default.hasClass(_this.outer, 'lg-thumb-open')) {
                            _this.destroy();
                        } else {
                            _lgUtils2.default.removeClass(_this.outer, 'lg-thumb-open');
                        }
                    }
                });
            };

            Plugin.prototype.arrow = function () {
                var _this = this;
                _lgUtils2.default.on(this.outer.querySelector('.lg-prev'), 'click.lg', function () {
                    _this.goToPrevSlide();
                });

                _lgUtils2.default.on(this.outer.querySelector('.lg-next'), 'click.lg', function () {
                    _this.goToNextSlide();
                });
            };

            Plugin.prototype.arrowDisable = function (index) {

                // Disable arrows if s.hideControlOnEnd is true
                if (!this.s.loop && this.s.hideControlOnEnd) {
                    var next = this.outer.querySelector('.lg-next');
                    var prev = this.outer.querySelector('.lg-prev');
                    if (index + 1 < this.___slide.length) {
                        next.removeAttribute('disabled');
                        _lgUtils2.default.removeClass(next, 'disabled');
                    } else {
                        next.setAttribute('disabled', 'disabled');
                        _lgUtils2.default.addClass(next, 'disabled');
                    }

                    if (index > 0) {
                        prev.removeAttribute('disabled');
                        _lgUtils2.default.removeClass(prev, 'disabled');
                    } else {
                        prev.setAttribute('disabled', 'disabled');
                        _lgUtils2.default.addClass(prev, 'disabled');
                    }
                }
            };

            Plugin.prototype.setTranslate = function (el, xValue, yValue) {
                // jQuery supports Automatic CSS prefixing since jQuery 1.8.0
                if (this.s.useLeft) {
                    el.style.left = xValue;
                } else {
                    _lgUtils2.default.setVendor(el, 'Transform', 'translate3d(' + xValue + 'px, ' + yValue + 'px, 0px)');
                }
            };

            Plugin.prototype.touchMove = function (startCoords, endCoords) {

                var distance = endCoords - startCoords;

                if (Math.abs(distance) > 15) {
                    // reset opacity and transition duration
                    _lgUtils2.default.addClass(this.outer, 'lg-dragging');

                    // move current slide
                    this.setTranslate(this.___slide[this.index], distance, 0);

                    // move next and prev slide with current slide
                    this.setTranslate(document.querySelector('.lg-prev-slide'), -this.___slide[this.index].clientWidth + distance, 0);
                    this.setTranslate(document.querySelector('.lg-next-slide'), this.___slide[this.index].clientWidth + distance, 0);
                }
            };

            Plugin.prototype.touchEnd = function (distance) {
                var _this = this;

                // keep slide animation for any mode while dragg/swipe
                if (_this.s.mode !== 'lg-slide') {
                    _lgUtils2.default.addClass(_this.outer, 'lg-slide');
                }

                for (var i = 0; i < this.___slide.length; i++) {
                    if (!_lgUtils2.default.hasClass(this.___slide[i], 'lg-current') && !_lgUtils2.default.hasClass(this.___slide[i], 'lg-prev-slide') && !_lgUtils2.default.hasClass(this.___slide[i], 'lg-next-slide')) {
                        this.___slide[i].style.opacity = '0';
                    }
                }

                // set transition duration
                setTimeout(function () {
                    _lgUtils2.default.removeClass(_this.outer, 'lg-dragging');
                    if (distance < 0 && Math.abs(distance) > _this.s.swipeThreshold) {
                        _this.goToNextSlide(true);
                    } else if (distance > 0 && Math.abs(distance) > _this.s.swipeThreshold) {
                        _this.goToPrevSlide(true);
                    } else if (Math.abs(distance) < 5) {

                        // Trigger click if distance is less than 5 pix
                        _lgUtils2.default.trigger(_this.el, 'onSlideClick');
                    }

                    for (var i = 0; i < _this.___slide.length; i++) {
                        _this.___slide[i].removeAttribute('style');
                    }
                });

                // remove slide class once drag/swipe is completed if mode is not slide
                setTimeout(function () {
                    if (!_lgUtils2.default.hasClass(_this.outer, 'lg-dragging') && _this.s.mode !== 'lg-slide') {
                        _lgUtils2.default.removeClass(_this.outer, 'lg-slide');
                    }
                }, _this.s.speed + 100);
            };

            Plugin.prototype.enableSwipe = function () {
                var _this = this;
                var startCoords = 0;
                var endCoords = 0;
                var isMoved = false;

                if (_this.s.enableSwipe && _this.isTouch && _this.doCss()) {

                    for (var i = 0; i < _this.___slide.length; i++) {
                        /*jshint loopfunc: true */
                        _lgUtils2.default.on(_this.___slide[i], 'touchstart.lg', function (e) {
                            if (!_lgUtils2.default.hasClass(_this.outer, 'lg-zoomed') && !_this.lgBusy) {
                                e.preventDefault();
                                _this.manageSwipeClass();
                                startCoords = e.targetTouches[0].pageX;
                            }
                        });
                    }

                    for (var j = 0; j < _this.___slide.length; j++) {
                        /*jshint loopfunc: true */
                        _lgUtils2.default.on(_this.___slide[j], 'touchmove.lg', function (e) {
                            if (!_lgUtils2.default.hasClass(_this.outer, 'lg-zoomed')) {
                                e.preventDefault();
                                endCoords = e.targetTouches[0].pageX;
                                _this.touchMove(startCoords, endCoords);
                                isMoved = true;
                            }
                        });
                    }

                    for (var k = 0; k < _this.___slide.length; k++) {
                        /*jshint loopfunc: true */
                        _lgUtils2.default.on(_this.___slide[k], 'touchend.lg', function () {
                            if (!_lgUtils2.default.hasClass(_this.outer, 'lg-zoomed')) {
                                if (isMoved) {
                                    isMoved = false;
                                    _this.touchEnd(endCoords - startCoords);
                                } else {
                                    _lgUtils2.default.trigger(_this.el, 'onSlideClick');
                                }
                            }
                        });
                    }
                }
            };

            Plugin.prototype.enableDrag = function () {
                var _this = this;
                var startCoords = 0;
                var endCoords = 0;
                var isDraging = false;
                var isMoved = false;
                if (_this.s.enableDrag && !_this.isTouch && _this.doCss()) {
                    for (var i = 0; i < _this.___slide.length; i++) {
                        /*jshint loopfunc: true */
                        _lgUtils2.default.on(_this.___slide[i], 'mousedown.lg', function (e) {
                            // execute only on .lg-object
                            if (!_lgUtils2.default.hasClass(_this.outer, 'lg-zoomed')) {
                                if (_lgUtils2.default.hasClass(e.target, 'lg-object') || _lgUtils2.default.hasClass(e.target, 'lg-video-play')) {
                                    e.preventDefault();

                                    if (!_this.lgBusy) {
                                        _this.manageSwipeClass();
                                        startCoords = e.pageX;
                                        isDraging = true;

                                        // ** Fix for webkit cursor issue https://code.google.com/p/chromium/issues/detail?id=26723
                                        _this.outer.scrollLeft += 1;
                                        _this.outer.scrollLeft -= 1;

                                        // *

                                        _lgUtils2.default.removeClass(_this.outer, 'lg-grab');
                                        _lgUtils2.default.addClass(_this.outer, 'lg-grabbing');

                                        _lgUtils2.default.trigger(_this.el, 'onDragstart');
                                    }
                                }
                            }
                        });
                    }

                    _lgUtils2.default.on(window, 'mousemove.lg', function (e) {
                        if (isDraging) {
                            isMoved = true;
                            endCoords = e.pageX;
                            _this.touchMove(startCoords, endCoords);
                            _lgUtils2.default.trigger(_this.el, 'onDragmove');
                        }
                    });

                    _lgUtils2.default.on(window, 'mouseup.lg', function (e) {
                        if (isMoved) {
                            isMoved = false;
                            _this.touchEnd(endCoords - startCoords);
                            _lgUtils2.default.trigger(_this.el, 'onDragend');
                        } else if (_lgUtils2.default.hasClass(e.target, 'lg-object') || _lgUtils2.default.hasClass(e.target, 'lg-video-play')) {
                            _lgUtils2.default.trigger(_this.el, 'onSlideClick');
                        }

                        // Prevent execution on click
                        if (isDraging) {
                            isDraging = false;
                            _lgUtils2.default.removeClass(_this.outer, 'lg-grabbing');
                            _lgUtils2.default.addClass(_this.outer, 'lg-grab');
                        }
                    });
                }
            };

            Plugin.prototype.manageSwipeClass = function () {
                var touchNext = this.index + 1;
                var touchPrev = this.index - 1;
                var length = this.___slide.length;
                if (this.s.loop) {
                    if (this.index === 0) {
                        touchPrev = length - 1;
                    } else if (this.index === length - 1) {
                        touchNext = 0;
                    }
                }

                for (var i = 0; i < this.___slide.length; i++) {
                    _lgUtils2.default.removeClass(this.___slide[i], 'lg-next-slide');
                    _lgUtils2.default.removeClass(this.___slide[i], 'lg-prev-slide');
                }

                if (touchPrev > -1) {
                    _lgUtils2.default.addClass(this.___slide[touchPrev], 'lg-prev-slide');
                }

                _lgUtils2.default.addClass(this.___slide[touchNext], 'lg-next-slide');
            };

            Plugin.prototype.mousewheel = function () {
                var _this = this;
                _lgUtils2.default.on(_this.outer, 'mousewheel.lg', function (e) {

                    if (!e.deltaY) {
                        return;
                    }

                    if (e.deltaY > 0) {
                        _this.goToPrevSlide();
                    } else {
                        _this.goToNextSlide();
                    }

                    e.preventDefault();
                });
            };

            Plugin.prototype.closeGallery = function () {

                var _this = this;
                var mousedown = false;
                _lgUtils2.default.on(this.outer.querySelector('.lg-close'), 'click.lg', function () {
                    _this.destroy();
                });

                if (_this.s.closable) {

                    // If you drag the slide and release outside gallery gets close on chrome
                    // for preventing this check mousedown and mouseup happened on .lg-item or lg-outer
                    _lgUtils2.default.on(_this.outer, 'mousedown.lg', function (e) {

                        if (_lgUtils2.default.hasClass(e.target, 'lg-outer') || _lgUtils2.default.hasClass(e.target, 'lg-item') || _lgUtils2.default.hasClass(e.target, 'lg-img-wrap')) {
                            mousedown = true;
                        } else {
                            mousedown = false;
                        }
                    });

                    _lgUtils2.default.on(_this.outer, 'mouseup.lg', function (e) {

                        if (_lgUtils2.default.hasClass(e.target, 'lg-outer') || _lgUtils2.default.hasClass(e.target, 'lg-item') || _lgUtils2.default.hasClass(e.target, 'lg-img-wrap') && mousedown) {
                            if (!_lgUtils2.default.hasClass(_this.outer, 'lg-dragging')) {
                                _this.destroy();
                            }
                        }
                    });
                }
            };

            Plugin.prototype.destroy = function (d) {

                var _this = this;

                if (!d) {
                    _lgUtils2.default.trigger(_this.el, 'onBeforeClose');
                }

                document.body.scrollTop = _this.prevScrollTop;
                document.documentElement.scrollTop = _this.prevScrollTop;

                /**
                 * if d is false or undefined destroy will only close the gallery
                 * plugins instance remains with the element
                 *
                 * if d is true destroy will completely remove the plugin
                 */

                if (d) {
                    if (!_this.s.dynamic) {
                        // only when not using dynamic mode is $items a jquery collection

                        for (var i = 0; i < this.items.length; i++) {
                            _lgUtils2.default.off(this.items[i], '.lg');
                            _lgUtils2.default.off(this.items[i], '.lgcustom');
                        }
                    }

                    var lguid = _this.el.getAttribute('lg-uid');
                    delete window.lgData[lguid];
                    _this.el.removeAttribute('lg-uid');
                }

                // Unbind all events added by lightGallery
                _lgUtils2.default.off(this.el, '.lgtm');

                // Distroy all lightGallery modules
                for (var key in window.lgModules) {
                    if (_this.modules[key]) {
                        _this.modules[key].destroy(d);
                    }
                }

                this.lGalleryOn = false;

                clearTimeout(_this.hideBartimeout);
                this.hideBartimeout = false;
                _lgUtils2.default.off(window, '.lg');
                _lgUtils2.default.removeClass(document.body, 'lg-on');
                _lgUtils2.default.removeClass(document.body, 'lg-from-hash');

                if (_this.outer) {
                    _lgUtils2.default.removeClass(_this.outer, 'lg-visible');
                }

                _lgUtils2.default.removeClass(document.querySelector('.lg-backdrop'), 'in');
                setTimeout(function () {
                    try {
                        if (_this.outer) {
                            _this.outer.parentNode.removeChild(_this.outer);
                        }

                        if (document.querySelector('.lg-backdrop')) {
                            document.querySelector('.lg-backdrop').parentNode.removeChild(document.querySelector('.lg-backdrop'));
                        }

                        if (!d) {
                            _lgUtils2.default.trigger(_this.el, 'onCloseAfter');
                        }
                    } catch (err) {}
                }, _this.s.backdropDuration + 50);
            };

            window.lightGallery = function (el, options) {
                if (!el) {
                    return;
                }

                try {
                    if (!el.getAttribute('lg-uid')) {
                        var uid = 'lg' + window.lgData.uid++;
                        window.lgData[uid] = new Plugin(el, options);
                        el.setAttribute('lg-uid', uid);
                    } else {
                        try {
                            window.lgData[el.getAttribute('lg-uid')].init();
                        } catch (err) {
                            console.error('lightGallery has not initiated properly');
                        }
                    }
                } catch (err) {
                    console.error('lightGallery has not initiated properly');
                }
            };
        });

    },{"./lg-utils":1}]},{},[2])(2)
});
//lg-autoplay.js
(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.LgAutoplay = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
        (function (global, factory) {
            if (typeof define === "function" && define.amd) {
                define([], factory);
            } else if (typeof exports !== "undefined") {
                factory();
            } else {
                var mod = {
                    exports: {}
                };
                factory();
                global.lgAutoplay = mod.exports;
            }
        })(this, function () {
            'use strict';

            var _extends = Object.assign || function (target) {
                for (var i = 1; i < arguments.length; i++) {
                    var source = arguments[i];

                    for (var key in source) {
                        if (Object.prototype.hasOwnProperty.call(source, key)) {
                            target[key] = source[key];
                        }
                    }
                }

                return target;
            };

            var autoplayDefaults = {
                autoplay: false,
                pause: 5000,
                progressBar: true,
                fourceAutoplay: false,
                autoplayControls: true,
                appendAutoplayControlsTo: '.lg-toolbar'
            };

            /**
             * Creates the autoplay plugin.
             * @param {object} element - lightGallery element
             */
            var Autoplay = function Autoplay(element) {

                this.el = element;

                this.core = window.lgData[this.el.getAttribute('lg-uid')];

                // Execute only if items are above 1
                if (this.core.items.length < 2) {
                    return false;
                }

                this.core.s = _extends({}, autoplayDefaults, this.core.s);
                this.interval = false;

                // Identify if slide happened from autoplay
                this.fromAuto = true;

                // Identify if autoplay canceled from touch/drag
                this.canceledOnTouch = false;

                // save fourceautoplay value
                this.fourceAutoplayTemp = this.core.s.fourceAutoplay;

                // do not allow progress bar if browser does not support css3 transitions
                if (!this.core.doCss()) {
                    this.core.s.progressBar = false;
                }

                this.init();

                return this;
            };

            Autoplay.prototype.init = function () {
                var _this = this;

                // append autoplay controls
                if (_this.core.s.autoplayControls) {
                    _this.controls();
                }

                // Create progress bar
                if (_this.core.s.progressBar) {
                    _this.core.outer.querySelector('.lg').insertAdjacentHTML('beforeend', '<div class="lg-progress-bar"><div class="lg-progress"></div></div>');
                }

                // set progress
                _this.progress();

                // Start autoplay
                if (_this.core.s.autoplay) {
                    _this.startlAuto();
                }

                // cancel interval on touchstart and dragstart
                utils.on(_this.el, 'onDragstart.lgtm touchstart.lgtm', function () {
                    if (_this.interval) {
                        _this.cancelAuto();
                        _this.canceledOnTouch = true;
                    }
                });

                // restore autoplay if autoplay canceled from touchstart / dragstart
                utils.on(_this.el, 'onDragend.lgtm touchend.lgtm onSlideClick.lgtm', function () {
                    if (!_this.interval && _this.canceledOnTouch) {
                        _this.startlAuto();
                        _this.canceledOnTouch = false;
                    }
                });
            };

            Autoplay.prototype.progress = function () {

                var _this = this;
                var _progressBar;
                var _progress;

                utils.on(_this.el, 'onBeforeSlide.lgtm', function () {

                    // start progress bar animation
                    if (_this.core.s.progressBar && _this.fromAuto) {
                        _progressBar = _this.core.outer.querySelector('.lg-progress-bar');
                        _progress = _this.core.outer.querySelector('.lg-progress');
                        if (_this.interval) {
                            _progress.removeAttribute('style');
                            utils.removeClass(_progressBar, 'lg-start');
                            setTimeout(function () {
                                utils.setVendor(_progress, 'Transition', 'width ' + (_this.core.s.speed + _this.core.s.pause) + 'ms ease 0s');
                                utils.addClass(_progressBar, 'lg-start');
                            }, 20);
                        }
                    }

                    // Remove setinterval if slide is triggered manually and fourceautoplay is false
                    if (!_this.fromAuto && !_this.core.s.fourceAutoplay) {
                        _this.cancelAuto();
                    }

                    _this.fromAuto = false;
                });
            };

            // Manage autoplay via play/stop buttons
            Autoplay.prototype.controls = function () {
                var _this = this;
                var _html = '<span class="lg-autoplay-button lg-icon"></span>';

                // Append autoplay controls
                _this.core.outer.querySelector(this.core.s.appendAutoplayControlsTo).insertAdjacentHTML('beforeend', _html);

                utils.on(_this.core.outer.querySelector('.lg-autoplay-button'), 'click.lg', function () {
                    if (utils.hasClass(_this.core.outer, 'lg-show-autoplay')) {
                        _this.cancelAuto();
                        _this.core.s.fourceAutoplay = false;
                    } else {
                        if (!_this.interval) {
                            _this.startlAuto();
                            _this.core.s.fourceAutoplay = _this.fourceAutoplayTemp;
                        }
                    }
                });
            };

            // Autostart gallery
            Autoplay.prototype.startlAuto = function () {
                var _this = this;

                utils.setVendor(_this.core.outer.querySelector('.lg-progress'), 'Transition', 'width ' + (_this.core.s.speed + _this.core.s.pause) + 'ms ease 0s');
                utils.addClass(_this.core.outer, 'lg-show-autoplay');
                utils.addClass(_this.core.outer.querySelector('.lg-progress-bar'), 'lg-start');

                _this.interval = setInterval(function () {
                    if (_this.core.index + 1 < _this.core.items.length) {
                        _this.core.index++;
                    } else {
                        _this.core.index = 0;
                    }

                    _this.fromAuto = true;
                    _this.core.slide(_this.core.index, false, false);
                }, _this.core.s.speed + _this.core.s.pause);
            };

            // cancel Autostart
            Autoplay.prototype.cancelAuto = function () {
                clearInterval(this.interval);
                this.interval = false;
                if (this.core.outer.querySelector('.lg-progress')) {
                    this.core.outer.querySelector('.lg-progress').removeAttribute('style');
                }

                utils.removeClass(this.core.outer, 'lg-show-autoplay');
                utils.removeClass(this.core.outer.querySelector('.lg-progress-bar'), 'lg-start');
            };

            Autoplay.prototype.destroy = function () {

                this.cancelAuto();
                if (this.core.outer.querySelector('.lg-progress-bar')) {
                    this.core.outer.querySelector('.lg-progress-bar').parentNode.removeChild(this.core.outer.querySelector('.lg-progress-bar'));
                }
            };

            window.lgModules.autoplay = Autoplay;
        });

    },{}]},{},[1])(1)
});
// lg-fullscreen.js
(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.LgFullscreen = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
        (function (global, factory) {
            if (typeof define === "function" && define.amd) {
                define([], factory);
            } else if (typeof exports !== "undefined") {
                factory();
            } else {
                var mod = {
                    exports: {}
                };
                factory();
                global.lgFullscreen = mod.exports;
            }
        })(this, function () {
            'use strict';

            var _extends = Object.assign || function (target) {
                for (var i = 1; i < arguments.length; i++) {
                    var source = arguments[i];

                    for (var key in source) {
                        if (Object.prototype.hasOwnProperty.call(source, key)) {
                            target[key] = source[key];
                        }
                    }
                }

                return target;
            };

            var fullscreenDefaults = {
                fullScreen: true
            };

            var Fullscreen = function Fullscreen(element) {

                this.el = element;

                this.core = window.lgData[this.el.getAttribute('lg-uid')];
                this.core.s = _extends({}, fullscreenDefaults, this.core.s);

                this.init();

                return this;
            };

            Fullscreen.prototype.init = function () {
                var fullScreen = '';
                if (this.core.s.fullScreen) {

                    // check for fullscreen browser support
                    if (!document.fullscreenEnabled && !document.webkitFullscreenEnabled && !document.mozFullScreenEnabled && !document.msFullscreenEnabled) {
                        return;
                    } else {
                        fullScreen = '<span class="lg-fullscreen lg-icon"></span>';
                        this.core.outer.querySelector('.lg-toolbar').insertAdjacentHTML('beforeend', fullScreen);
                        this.fullScreen();
                    }
                }
            };

            Fullscreen.prototype.requestFullscreen = function () {
                var el = document.documentElement;
                if (el.requestFullscreen) {
                    el.requestFullscreen();
                } else if (el.msRequestFullscreen) {
                    el.msRequestFullscreen();
                } else if (el.mozRequestFullScreen) {
                    el.mozRequestFullScreen();
                } else if (el.webkitRequestFullscreen) {
                    el.webkitRequestFullscreen();
                }
            };

            Fullscreen.prototype.exitFullscreen = function () {
                if(document.fullscreenElement && document.fullscreenElement.nodeName == 'VIDEO') {
                    if (document.exitFullscreen) {
                        document.exitFullscreen();
                    } else if (document.msExitFullscreen) {
                        document.msExitFullscreen();
                    } else if (document.mozCancelFullScreen) {
                        document.mozCancelFullScreen();
                    } else if (document.webkitExitFullscreen) {
                        document.webkitExitFullscreen();
                    }
                }
            };

            // https://developer.mozilla.org/en-US/docs/Web/Guide/API/DOM/Using_full_screen_mode
            Fullscreen.prototype.fullScreen = function () {
                var _this = this;

                utils.on(document, 'fullscreenchange.lgfullscreen webkitfullscreenchange.lgfullscreen mozfullscreenchange.lgfullscreen MSFullscreenChange.lgfullscreen', function () {
                    if (utils.hasClass(_this.core.outer, 'lg-fullscreen-on')) {
                        utils.removeClass(_this.core.outer, 'lg-fullscreen-on');
                    } else {
                        utils.addClass(_this.core.outer, 'lg-fullscreen-on');
                    }
                });

                utils.on(this.core.outer.querySelector('.lg-fullscreen'), 'click.lg', function () {
                    if (!document.fullscreenElement && !document.mozFullScreenElement && !document.webkitFullscreenElement && !document.msFullscreenElement) {
                        _this.requestFullscreen();
                    } else {
                        _this.exitFullscreen();
                    }
                });
            };

            Fullscreen.prototype.destroy = function () {

                // exit from fullscreen if activated
                this.exitFullscreen();

                utils.off(document, '.lgfullscreen');
            };

            window.lgModules.fullscreen = Fullscreen;
        });

    },{}]},{},[1])(1)
});
//lg-zoom.js
(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.LgZoom = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
        (function (global, factory) {
            if (typeof define === "function" && define.amd) {
                define([], factory);
            } else if (typeof exports !== "undefined") {
                factory();
            } else {
                var mod = {
                    exports: {}
                };
                factory();
                global.lgZoom = mod.exports;
            }
        })(this, function () {
            'use strict';

            var _extends = Object.assign || function (target) {
                for (var i = 1; i < arguments.length; i++) {
                    var source = arguments[i];

                    for (var key in source) {
                        if (Object.prototype.hasOwnProperty.call(source, key)) {
                            target[key] = source[key];
                        }
                    }
                }

                return target;
            };

            var getUseLeft = function getUseLeft() {
                var useLeft = false;
                var isChrome = navigator.userAgent.match(/Chrom(e|ium)\/([0-9]+)\./);
                if (isChrome && parseInt(isChrome[2], 10) < 54) {
                    useLeft = true;
                }

                return useLeft;
            };

            var zoomDefaults = {
                scale: 1,
                zoom: true,
                actualSize: true,
                enableZoomAfter: 300,
                useLeftForZoom: getUseLeft()
            };

            var Zoom = function Zoom(element) {

                this.el = element;

                this.core = window.lgData[this.el.getAttribute('lg-uid')];
                this.core.s = _extends({}, zoomDefaults, this.core.s);

                if (this.core.s.zoom && this.core.doCss()) {
                    this.init();

                    // Store the zoomable timeout value just to clear it while closing
                    this.zoomabletimeout = false;

                    // Set the initial value center
                    this.pageX = window.innerWidth / 2;
                    this.pageY = window.innerHeight / 2 + (document.documentElement.scrollTop || document.body.scrollTop);
                }

                return this;
            };

            Zoom.prototype.init = function () {

                var _this = this;
                var zoomIcons = '<span id="lg-zoom-in" class="lg-icon"></span><span id="lg-zoom-out" class="lg-icon"></span>';

                if (_this.core.s.actualSize) {
                    zoomIcons += '<span id="lg-actual-size" class="lg-icon"></span>';
                }

                if (_this.core.s.useLeftForZoom) {
                    utils.addClass(_this.core.outer, 'lg-use-left-for-zoom');
                } else {
                    utils.addClass(_this.core.outer, 'lg-use-transition-for-zoom');
                }

                this.core.outer.querySelector('.lg-toolbar').insertAdjacentHTML('beforeend', zoomIcons);

                // Add zoomable class
                utils.on(_this.core.el, 'onSlideItemLoad.lgtmzoom', function (event) {

                    // delay will be 0 except first time
                    var _speed = _this.core.s.enableZoomAfter + event.detail.delay;

                    // set _speed value 0 if gallery opened from direct url and if it is first slide
                    if (utils.hasClass(document.body, 'lg-from-hash') && event.detail.delay) {

                        // will execute only once
                        _speed = 0;
                    } else {

                        // Remove lg-from-hash to enable starting animation.
                        utils.removeClass(document.body, 'lg-from-hash');
                    }

                    _this.zoomabletimeout = setTimeout(function () {
                        utils.addClass(_this.core.___slide[event.detail.index], 'lg-zoomable');
                    }, _speed + 30);
                });

                var scale = 1;
                /**
                 * @desc Image zoom
                 * Translate the wrap and scale the image to get better user experience
                 *
                 * @param {String} scaleVal - Zoom decrement/increment value
                 */
                var zoom = function zoom(scaleVal) {

                    var image = _this.core.outer.querySelector('.lg-current .lg-image');
                    if(!image){
                        return false;
                    }
                    var _x;
                    var _y;

                    // Find offset manually to avoid issue after zoom
                    var offsetX = (window.innerWidth - image.clientWidth) / 2;
                    var offsetY = (window.innerHeight - image.clientHeight) / 2 + (document.documentElement.scrollTop || document.body.scrollTop);

                    _x = _this.pageX - offsetX;
                    _y = _this.pageY - offsetY;

                    var x = (scaleVal - 1) * _x;
                    var y = (scaleVal - 1) * _y;

                    utils.setVendor(image, 'Transform', 'scale3d(' + scaleVal + ', ' + scaleVal + ', 1)');
                    image.setAttribute('data-scale', scaleVal);

                    if (_this.core.s.useLeftForZoom) {
                        image.parentElement.style.left = -x + 'px';
                        image.parentElement.style.top = -y + 'px';
                    } else {
                        utils.setVendor(image.parentElement, 'Transform', 'translate3d(-' + x + 'px, -' + y + 'px, 0)');
                    }

                    image.parentElement.setAttribute('data-x', x);
                    image.parentElement.setAttribute('data-y', y);
                };

                var callScale = function callScale() {
                    if (scale > 1) {
                        utils.addClass(_this.core.outer, 'lg-zoomed');
                    } else {
                        _this.resetZoom();
                    }

                    if (scale < 1) {
                        scale = 1;
                    }

                    zoom(scale);
                };

                var actualSize = function actualSize(event, image, index, fromIcon) {
                    if(!image){
                        return false;
                    }
                    var w = image.clientWidth;
                    var nw;
                    if (_this.core.s.dynamic) {
                        nw = _this.core.s.dynamicEl[index].width || image.naturalWidth || w;
                    } else {
                        nw = _this.core.items[index].getAttribute('data-width') || image.naturalWidth || w;
                    }

                    var _scale;

                    if (utils.hasClass(_this.core.outer, 'lg-zoomed')) {
                        scale = 1;
                    } else {
                        if (nw > w) {
                            _scale = nw / w;
                            scale = _scale || 2;
                        }
                    }

                    if (fromIcon) {
                        _this.pageX = window.innerWidth / 2;
                        _this.pageY = window.innerHeight / 2 + (document.documentElement.scrollTop || document.body.scrollTop);
                    } else {
                        _this.pageX = event.pageX || event.targetTouches[0].pageX;
                        _this.pageY = event.pageY || event.targetTouches[0].pageY;
                    }

                    callScale();
                    setTimeout(function () {
                        utils.removeClass(_this.core.outer, 'lg-grabbing');
                        utils.addClass(_this.core.outer, 'lg-grab');
                    }, 10);
                };

                var tapped = false;

                // event triggered after appending slide content
                utils.on(_this.core.el, 'onAferAppendSlide.lgtmzoom', function (event) {

                    var index = event.detail.index;

                    // Get the current element
                    var image = _this.core.___slide[index].querySelector('.lg-image');

                    if (!_this.core.isTouch) {
                        utils.on(image, 'dblclick', function (event) {
                            actualSize(event, image, index);
                        });
                    }

                    if (_this.core.isTouch) {
                        utils.on(image, 'touchstart', function (event) {
                            if (!tapped) {
                                tapped = setTimeout(function () {
                                    tapped = null;
                                }, 300);
                            } else {
                                clearTimeout(tapped);
                                tapped = null;
                                actualSize(event, image, index);
                            }

                            event.preventDefault();
                        });
                    }
                });

                // Update zoom on resize and orientationchange
                utils.on(window, 'resize.lgzoom scroll.lgzoom orientationchange.lgzoom', function () {
                    _this.pageX = window.innerWidth / 2;
                    _this.pageY = window.innerHeight / 2 + (document.documentElement.scrollTop || document.body.scrollTop);
                    zoom(scale);
                });

                utils.on(document.getElementById('lg-zoom-out'), 'click.lg', function () {
                    if (_this.core.outer.querySelector('.lg-current .lg-image')) {
                        scale -= _this.core.s.scale;
                        callScale();
                    }
                });

                utils.on(document.getElementById('lg-zoom-in'), 'click.lg', function () {
                    if (_this.core.outer.querySelector('.lg-current .lg-image')) {
                        scale += _this.core.s.scale;
                        callScale();
                    }
                });

                utils.on(document.getElementById('lg-actual-size'), 'click.lg', function (event) {
                    actualSize(event, _this.core.___slide[_this.core.index].querySelector('.lg-image'), _this.core.index, true);
                });

                // Reset zoom on slide change
                utils.on(_this.core.el, 'onBeforeSlide.lgtm', function () {
                    scale = 1;
                    _this.resetZoom();
                });

                // Drag option after zoom
                if (!_this.core.isTouch) {
                    _this.zoomDrag();
                }

                if (_this.core.isTouch) {
                    _this.zoomSwipe();
                }
            };

            // Reset zoom effect
            Zoom.prototype.resetZoom = function () {
                utils.removeClass(this.core.outer, 'lg-zoomed');
                for (var i = 0; i < this.core.___slide.length; i++) {
                    if (this.core.___slide[i].querySelector('.lg-img-wrap')) {
                        this.core.___slide[i].querySelector('.lg-img-wrap').removeAttribute('style');
                        this.core.___slide[i].querySelector('.lg-img-wrap').removeAttribute('data-x');
                        this.core.___slide[i].querySelector('.lg-img-wrap').removeAttribute('data-y');
                    }
                }

                for (var j = 0; j < this.core.___slide.length; j++) {
                    if (this.core.___slide[j].querySelector('.lg-image')) {
                        this.core.___slide[j].querySelector('.lg-image').removeAttribute('style');
                        this.core.___slide[j].querySelector('.lg-image').removeAttribute('data-scale');
                    }
                }

                // Reset pagx pagy values to center
                this.pageX = window.innerWidth / 2;
                this.pageY = window.innerHeight / 2 + (document.documentElement.scrollTop || document.body.scrollTop);
            };

            Zoom.prototype.zoomSwipe = function () {
                var _this = this;
                var startCoords = {};
                var endCoords = {};
                var isMoved = false;

                // Allow x direction drag
                var allowX = false;

                // Allow Y direction drag
                var allowY = false;

                for (var i = 0; i < _this.core.___slide.length; i++) {

                    /*jshint loopfunc: true */
                    utils.on(_this.core.___slide[i], 'touchstart.lg', function (e) {

                        if (utils.hasClass(_this.core.outer, 'lg-zoomed')) {
                            var image = _this.core.___slide[_this.core.index].querySelector('.lg-object');

                            allowY = image.offsetHeight * image.getAttribute('data-scale') > _this.core.outer.querySelector('.lg').clientHeight;
                            allowX = image.offsetWidth * image.getAttribute('data-scale') > _this.core.outer.querySelector('.lg').clientWidth;
                            if (allowX || allowY) {
                                e.preventDefault();
                                startCoords = {
                                    x: e.targetTouches[0].pageX,
                                    y: e.targetTouches[0].pageY
                                };
                            }
                        }
                    });
                }

                for (var j = 0; j < _this.core.___slide.length; j++) {

                    /*jshint loopfunc: true */
                    utils.on(_this.core.___slide[j], 'touchmove.lg', function (e) {

                        if (utils.hasClass(_this.core.outer, 'lg-zoomed')) {

                            var _el = _this.core.___slide[_this.core.index].querySelector('.lg-img-wrap');
                            var distanceX;
                            var distanceY;

                            e.preventDefault();
                            isMoved = true;

                            endCoords = {
                                x: e.targetTouches[0].pageX,
                                y: e.targetTouches[0].pageY
                            };

                            // reset opacity and transition duration
                            utils.addClass(_this.core.outer, 'lg-zoom-dragging');

                            if (allowY) {
                                distanceY = -Math.abs(_el.getAttribute('data-y')) + (endCoords.y - startCoords.y);
                            } else {
                                distanceY = -Math.abs(_el.getAttribute('data-y'));
                            }

                            if (allowX) {
                                distanceX = -Math.abs(_el.getAttribute('data-x')) + (endCoords.x - startCoords.x);
                            } else {
                                distanceX = -Math.abs(_el.getAttribute('data-x'));
                            }

                            if (Math.abs(endCoords.x - startCoords.x) > 15 || Math.abs(endCoords.y - startCoords.y) > 15) {

                                if (_this.core.s.useLeftForZoom) {
                                    _el.style.left = distanceX + 'px';
                                    _el.style.top = distanceY + 'px';
                                } else {
                                    utils.setVendor(_el, 'Transform', 'translate3d(' + distanceX + 'px, ' + distanceY + 'px, 0)');
                                }
                            }
                        }
                    });
                }

                for (var k = 0; k < _this.core.___slide.length; k++) {

                    /*jshint loopfunc: true */
                    utils.on(_this.core.___slide[k], 'touchend.lg', function () {
                        if (utils.hasClass(_this.core.outer, 'lg-zoomed')) {
                            if (isMoved) {
                                isMoved = false;
                                utils.removeClass(_this.core.outer, 'lg-zoom-dragging');
                                _this.touchendZoom(startCoords, endCoords, allowX, allowY);
                            }
                        }
                    });
                }
            };

            Zoom.prototype.zoomDrag = function () {

                var _this = this;
                var startCoords = {};
                var endCoords = {};
                var isDraging = false;
                var isMoved = false;

                // Allow x direction drag
                var allowX = false;

                // Allow Y direction drag
                var allowY = false;

                for (var i = 0; i < _this.core.___slide.length; i++) {

                    /*jshint loopfunc: true */
                    utils.on(_this.core.___slide[i], 'mousedown.lgzoom', function (e) {

                        // execute only on .lg-object
                        var image = _this.core.___slide[_this.core.index].querySelector('.lg-object');

                        allowY = image.offsetHeight * image.getAttribute('data-scale') > _this.core.outer.querySelector('.lg').clientHeight;
                        allowX = image.offsetWidth * image.getAttribute('data-scale') > _this.core.outer.querySelector('.lg').clientWidth;

                        if (utils.hasClass(_this.core.outer, 'lg-zoomed')) {
                            if (utils.hasClass(e.target, 'lg-object') && (allowX || allowY)) {
                                e.preventDefault();
                                startCoords = {
                                    x: e.pageX,
                                    y: e.pageY
                                };

                                isDraging = true;

                                // ** Fix for webkit cursor issue https://code.google.com/p/chromium/issues/detail?id=26723
                                _this.core.outer.scrollLeft += 1;
                                _this.core.outer.scrollLeft -= 1;

                                utils.removeClass(_this.core.outer, 'lg-grab');
                                utils.addClass(_this.core.outer, 'lg-grabbing');
                            }
                        }
                    });
                }

                utils.on(window, 'mousemove.lgzoom', function (e) {
                    if (isDraging) {
                        var _el = _this.core.___slide[_this.core.index].querySelector('.lg-img-wrap');
                        var distanceX;
                        var distanceY;

                        isMoved = true;
                        endCoords = {
                            x: e.pageX,
                            y: e.pageY
                        };

                        // reset opacity and transition duration
                        utils.addClass(_this.core.outer, 'lg-zoom-dragging');

                        if (allowY) {
                            distanceY = -Math.abs(_el.getAttribute('data-y')) + (endCoords.y - startCoords.y);
                        } else {
                            distanceY = -Math.abs(_el.getAttribute('data-y'));
                        }

                        if (allowX) {
                            distanceX = -Math.abs(_el.getAttribute('data-x')) + (endCoords.x - startCoords.x);
                        } else {
                            distanceX = -Math.abs(_el.getAttribute('data-x'));
                        }

                        if (_this.core.s.useLeftForZoom) {
                            _el.style.left = distanceX + 'px';
                            _el.style.top = distanceY + 'px';
                        } else {
                            utils.setVendor(_el, 'Transform', 'translate3d(' + distanceX + 'px, ' + distanceY + 'px, 0)');
                        }
                    }
                });

                utils.on(window, 'mouseup.lgzoom', function (e) {

                    if (isDraging) {
                        isDraging = false;
                        utils.removeClass(_this.core.outer, 'lg-zoom-dragging');

                        // Fix for chrome mouse move on click
                        if (isMoved && (startCoords.x !== endCoords.x || startCoords.y !== endCoords.y)) {
                            endCoords = {
                                x: e.pageX,
                                y: e.pageY
                            };
                            _this.touchendZoom(startCoords, endCoords, allowX, allowY);
                        }

                        isMoved = false;
                    }

                    utils.removeClass(_this.core.outer, 'lg-grabbing');
                    utils.addClass(_this.core.outer, 'lg-grab');
                });
            };

            Zoom.prototype.touchendZoom = function (startCoords, endCoords, allowX, allowY) {

                var _this = this;
                var _el = _this.core.___slide[_this.core.index].querySelector('.lg-img-wrap');
                var image = _this.core.___slide[_this.core.index].querySelector('.lg-object');
                var distanceX = -Math.abs(_el.getAttribute('data-x')) + (endCoords.x - startCoords.x);
                var distanceY = -Math.abs(_el.getAttribute('data-y')) + (endCoords.y - startCoords.y);
                var minY = (_this.core.outer.querySelector('.lg').clientHeight - image.offsetHeight) / 2;
                var maxY = Math.abs(image.offsetHeight * Math.abs(image.getAttribute('data-scale')) - _this.core.outer.querySelector('.lg').clientHeight + minY);
                var minX = (_this.core.outer.querySelector('.lg').clientWidth - image.offsetWidth) / 2;
                var maxX = Math.abs(image.offsetWidth * Math.abs(image.getAttribute('data-scale')) - _this.core.outer.querySelector('.lg').clientWidth + minX);

                if (Math.abs(endCoords.x - startCoords.x) > 15 || Math.abs(endCoords.y - startCoords.y) > 15) {
                    if (allowY) {
                        if (distanceY <= -maxY) {
                            distanceY = -maxY;
                        } else if (distanceY >= -minY) {
                            distanceY = -minY;
                        }
                    }

                    if (allowX) {
                        if (distanceX <= -maxX) {
                            distanceX = -maxX;
                        } else if (distanceX >= -minX) {
                            distanceX = -minX;
                        }
                    }

                    if (allowY) {
                        _el.setAttribute('data-y', Math.abs(distanceY));
                    } else {
                        distanceY = -Math.abs(_el.getAttribute('data-y'));
                    }

                    if (allowX) {
                        _el.setAttribute('data-x', Math.abs(distanceX));
                    } else {
                        distanceX = -Math.abs(_el.getAttribute('data-x'));
                    }

                    if (_this.core.s.useLeftForZoom) {
                        _el.style.left = distanceX + 'px';
                        _el.style.top = distanceY + 'px';
                    } else {
                        utils.setVendor(_el, 'Transform', 'translate3d(' + distanceX + 'px, ' + distanceY + 'px, 0)');
                    }
                }
            };

            Zoom.prototype.destroy = function () {

                var _this = this;

                // Unbind all events added by lightGallery zoom plugin
                utils.off(_this.core.el, '.lgzoom');
                utils.off(window, '.lgzoom');
                for (var i = 0; i < _this.core.___slide.length; i++) {
                    utils.off(_this.core.___slide[i], '.lgzoom');
                }

                utils.off(_this.core.el, '.lgtmzoom');
                _this.resetZoom();
                clearTimeout(_this.zoomabletimeout);
                _this.zoomabletimeout = false;
            };

            window.lgModules.zoom = Zoom;
        });

    },{}]},{},[1])(1)
});
// lg-thumbnail.js
(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.LgThumbnail = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
        (function (global, factory) {
            if (typeof define === "function" && define.amd) {
                define([], factory);
            } else if (typeof exports !== "undefined") {
                factory();
            } else {
                var mod = {
                    exports: {}
                };
                factory();
                global.lgThumbnail = mod.exports;
            }
        })(this, function () {
            'use strict';

            var _extends = Object.assign || function (target) {
                for (var i = 1; i < arguments.length; i++) {
                    var source = arguments[i];

                    for (var key in source) {
                        if (Object.prototype.hasOwnProperty.call(source, key)) {
                            target[key] = source[key];
                        }
                    }
                }

                return target;
            };

            var thumbnailDefaults = {
                thumbnail: true,

                animateThumb: true,
                currentPagerPosition: 'middle',

                thumbWidth: 100,
                thumbContHeight: 100,
                thumbMargin: 5,

                exThumbImage: false,
                showThumbByDefault: true,
                toggleThumb: true,
                pullCaptionUp: true,

                enableThumbDrag: true,
                enableThumbSwipe: true,
                swipeThreshold: 50,

                loadYoutubeThumbnail: true,
                youtubeThumbSize: 1,

                loadVimeoThumbnail: true,
                vimeoThumbSize: 'thumbnail_small',

                loadDailymotionThumbnail: true
            };

            var Thumbnail = function Thumbnail(element) {

                this.el = element;

                this.core = window.lgData[this.el.getAttribute('lg-uid')];
                this.core.s = _extends({}, thumbnailDefaults, this.core.s);

                this.thumbOuter = null;
                this.thumbOuterWidth = 0;
                this.thumbTotalWidth = this.core.items.length * (this.core.s.thumbWidth + this.core.s.thumbMargin);
                this.thumbIndex = this.core.index;

                // Thumbnail animation value
                this.left = 0;

                this.init();

                return this;
            };

            Thumbnail.prototype.init = function () {
                var _this = this;
                if (this.core.s.thumbnail && this.core.items.length > 1) {
                    if (this.core.s.showThumbByDefault) {
                        setTimeout(function () {
                            utils.addClass(_this.core.outer, 'lg-thumb-open');
                        }, 700);
                    }

                    if (this.core.s.pullCaptionUp) {
                        utils.addClass(this.core.outer, 'lg-pull-caption-up');
                    }

                    this.build();
                    if (this.core.s.animateThumb) {
                        if (this.core.s.enableThumbDrag && !this.core.isTouch && this.core.doCss()) {
                            this.enableThumbDrag();
                        }

                        if (this.core.s.enableThumbSwipe && this.core.isTouch && this.core.doCss()) {
                            this.enableThumbSwipe();
                        }

                        this.thumbClickable = false;
                    } else {
                        this.thumbClickable = true;
                    }

                    this.toggle();
                    this.thumbkeyPress();
                }
            };

            Thumbnail.prototype.build = function () {
                var _this = this;
                var thumbList = '';
                var vimeoErrorThumbSize = '';
                var $thumb;
                var html = '<div class="lg-thumb-outer">' + '<div class="lg-thumb group">' + '</div>' + '</div>';

                switch (this.core.s.vimeoThumbSize) {
                    case 'thumbnail_large':
                        vimeoErrorThumbSize = '640';
                        break;
                    case 'thumbnail_medium':
                        vimeoErrorThumbSize = '200x150';
                        break;
                    case 'thumbnail_small':
                        vimeoErrorThumbSize = '100x75';
                }

                utils.addClass(_this.core.outer, 'lg-has-thumb');

                _this.core.outer.querySelector('.lg').insertAdjacentHTML('beforeend', html);

                _this.thumbOuter = _this.core.outer.querySelector('.lg-thumb-outer');
                _this.thumbOuterWidth = _this.thumbOuter.offsetWidth;

                if (_this.core.s.animateThumb) {
                    _this.core.outer.querySelector('.lg-thumb').style.width = _this.thumbTotalWidth + 'px';
                    _this.core.outer.querySelector('.lg-thumb').style.position = 'relative';
                }

                if (this.core.s.animateThumb) {
                    _this.thumbOuter.style.height = _this.core.s.thumbContHeight + 'px';
                }

                function getThumb(src, thumb, index) {
                    var isVideo = _this.core.isVideo(src, index) || {};
                    var thumbImg;
                    var vimeoId = '';

                    if (isVideo.youtube || isVideo.vimeo || isVideo.dailymotion) {
                        if (isVideo.youtube) {
                            if (_this.core.s.loadYoutubeThumbnail) {
                                thumbImg = '//img.youtube.com/vi/' + isVideo.youtube[1] + '/' + _this.core.s.youtubeThumbSize + '.jpg';
                            } else {
                                thumbImg = thumb;
                            }
                        } else if (isVideo.vimeo) {
                            if (_this.core.s.loadVimeoThumbnail) {
                                thumbImg = '//i.vimeocdn.com/video/error_' + vimeoErrorThumbSize + '.jpg';
                                vimeoId = isVideo.vimeo[1];
                            } else {
                                thumbImg = thumb;
                            }
                        } else if (isVideo.dailymotion) {
                            if (_this.core.s.loadDailymotionThumbnail) {
                                thumbImg = '//www.dailymotion.com/thumbnail/video/' + isVideo.dailymotion[1];
                            } else {
                                thumbImg = thumb;
                            }
                        }
                    } else {
                        thumbImg = thumb;
                    }

                    thumbList += '<div data-vimeo-id="' + vimeoId + '" class="lg-thumb-item" style="width:' + _this.core.s.thumbWidth + 'px; margin-right: ' + _this.core.s.thumbMargin + 'px"><img src="' + thumbImg + '" /></div>';
                    vimeoId = '';
                }

                if (_this.core.s.dynamic) {
                    for (var j = 0; j < _this.core.s.dynamicEl.length; j++) {
                        getThumb(_this.core.s.dynamicEl[j].src, _this.core.s.dynamicEl[j].thumb, j);
                    }
                } else {
                    for (var i = 0; i < _this.core.items.length; i++) {
                        if (!_this.core.s.exThumbImage) {
                            getThumb(_this.core.items[i].getAttribute('href') || _this.core.items[i].getAttribute('data-src'), _this.core.items[i].querySelector('img').getAttribute('src'), i);
                        } else {
                            getThumb(_this.core.items[i].getAttribute('href') || _this.core.items[i].getAttribute('data-src'), _this.core.items[i].getAttribute(_this.core.s.exThumbImage), i);
                        }
                    }
                }

                _this.core.outer.querySelector('.lg-thumb').innerHTML = thumbList;

                $thumb = _this.core.outer.querySelectorAll('.lg-thumb-item');

                for (var n = 0; n < $thumb.length; n++) {

                    /*jshint loopfunc: true */
                    (function (index) {
                        var $this = $thumb[index];
                        var vimeoVideoId = $this.getAttribute('data-vimeo-id');
                        if (vimeoVideoId) {

                            window['lgJsonP' + _this.el.getAttribute('lg-uid') + '' + n] = function (content) {
                                $this.querySelector('img').setAttribute('src', content[0][_this.core.s.vimeoThumbSize]);
                            };

                            var script = document.createElement('script');
                            script.className = 'lg-script';
                            script.src = '//www.vimeo.com/api/v2/video/' + vimeoVideoId + '.json?callback=lgJsonP' + _this.el.getAttribute('lg-uid') + '' + n;
                            document.body.appendChild(script);
                        }
                    })(n);
                }

                // manage active class for thumbnail
                utils.addClass($thumb[_this.core.index], 'active');
                utils.on(_this.core.el, 'onBeforeSlide.lgtm', function () {

                    for (var j = 0; j < $thumb.length; j++) {
                        utils.removeClass($thumb[j], 'active');
                    }

                    utils.addClass($thumb[_this.core.index], 'active');
                });

                for (var k = 0; k < $thumb.length; k++) {

                    /*jshint loopfunc: true */
                    (function (index) {

                        utils.on($thumb[index], 'click.lg touchend.lg', function () {

                            setTimeout(function () {

                                // In IE9 and bellow touch does not support
                                // Go to slide if browser does not support css transitions
                                if (_this.thumbClickable && !_this.core.lgBusy || !_this.core.doCss()) {
                                    _this.core.index = index;
                                    _this.core.slide(_this.core.index, false, true);
                                }
                            }, 50);
                        });
                    })(k);
                }

                utils.on(_this.core.el, 'onBeforeSlide.lgtm', function () {
                    _this.animateThumb(_this.core.index);
                });

                utils.on(window, 'resize.lgthumb orientationchange.lgthumb', function () {
                    setTimeout(function () {
                        _this.animateThumb(_this.core.index);
                        _this.thumbOuterWidth = _this.thumbOuter.offsetWidth;
                    }, 200);
                });
            };

            Thumbnail.prototype.setTranslate = function (value) {
                utils.setVendor(this.core.outer.querySelector('.lg-thumb'), 'Transform', 'translate3d(-' + value + 'px, 0px, 0px)');
            };

            Thumbnail.prototype.animateThumb = function (index) {
                var $thumb = this.core.outer.querySelector('.lg-thumb');
                if (this.core.s.animateThumb) {
                    var position;
                    switch (this.core.s.currentPagerPosition) {
                        case 'left':
                            position = 0;
                            break;
                        case 'middle':
                            position = this.thumbOuterWidth / 2 - this.core.s.thumbWidth / 2;
                            break;
                        case 'right':
                            position = this.thumbOuterWidth - this.core.s.thumbWidth;
                    }
                    this.left = (this.core.s.thumbWidth + this.core.s.thumbMargin) * index - 1 - position;
                    if (this.left > this.thumbTotalWidth - this.thumbOuterWidth) {
                        this.left = this.thumbTotalWidth - this.thumbOuterWidth;
                    }

                    if (this.left < 0) {
                        this.left = 0;
                    }

                    if (this.core.lGalleryOn) {
                        if (!utils.hasClass($thumb, 'on')) {
                            utils.setVendor(this.core.outer.querySelector('.lg-thumb'), 'TransitionDuration', this.core.s.speed + 'ms');
                        }

                        if (!this.core.doCss()) {
                            $thumb.style.left = -this.left + 'px';
                        }
                    } else {
                        if (!this.core.doCss()) {
                            $thumb.style.left = -this.left + 'px';
                        }
                    }

                    this.setTranslate(this.left);
                }
            };

            // Enable thumbnail dragging and swiping
            Thumbnail.prototype.enableThumbDrag = function () {

                var _this = this;
                var startCoords = 0;
                var endCoords = 0;
                var isDraging = false;
                var isMoved = false;
                var tempLeft = 0;

                utils.addClass(_this.thumbOuter, 'lg-grab');

                utils.on(_this.core.outer.querySelector('.lg-thumb'), 'mousedown.lgthumb', function (e) {
                    if (_this.thumbTotalWidth > _this.thumbOuterWidth) {
                        // execute only on .lg-object
                        e.preventDefault();
                        startCoords = e.pageX;
                        isDraging = true;

                        // ** Fix for webkit cursor issue https://code.google.com/p/chromium/issues/detail?id=26723
                        _this.core.outer.scrollLeft += 1;
                        _this.core.outer.scrollLeft -= 1;

                        // *
                        _this.thumbClickable = false;
                        utils.removeClass(_this.thumbOuter, 'lg-grab');
                        utils.addClass(_this.thumbOuter, 'lg-grabbing');
                    }
                });

                utils.on(window, 'mousemove.lgthumb', function (e) {
                    if (isDraging) {
                        tempLeft = _this.left;
                        isMoved = true;
                        endCoords = e.pageX;

                        utils.addClass(_this.thumbOuter, 'lg-dragging');

                        tempLeft = tempLeft - (endCoords - startCoords);

                        if (tempLeft > _this.thumbTotalWidth - _this.thumbOuterWidth) {
                            tempLeft = _this.thumbTotalWidth - _this.thumbOuterWidth;
                        }

                        if (tempLeft < 0) {
                            tempLeft = 0;
                        }

                        // move current slide
                        _this.setTranslate(tempLeft);
                    }
                });

                utils.on(window, 'mouseup.lgthumb', function () {
                    if (isMoved) {
                        isMoved = false;
                        utils.removeClass(_this.thumbOuter, 'lg-dragging');

                        _this.left = tempLeft;

                        if (Math.abs(endCoords - startCoords) < _this.core.s.swipeThreshold) {
                            _this.thumbClickable = true;
                        }
                    } else {
                        _this.thumbClickable = true;
                    }

                    if (isDraging) {
                        isDraging = false;
                        utils.removeClass(_this.thumbOuter, 'lg-grabbing');
                        utils.addClass(_this.thumbOuter, 'lg-grab');
                    }
                });
            };

            Thumbnail.prototype.enableThumbSwipe = function () {
                var _this = this;
                var startCoords = 0;
                var endCoords = 0;
                var isMoved = false;
                var tempLeft = 0;

                utils.on(_this.core.outer.querySelector('.lg-thumb'), 'touchstart.lg', function (e) {
                    if (_this.thumbTotalWidth > _this.thumbOuterWidth) {
                        e.preventDefault();
                        startCoords = e.targetTouches[0].pageX;
                        _this.thumbClickable = false;
                    }
                });

                utils.on(_this.core.outer.querySelector('.lg-thumb'), 'touchmove.lg', function (e) {
                    if (_this.thumbTotalWidth > _this.thumbOuterWidth) {
                        e.preventDefault();
                        endCoords = e.targetTouches[0].pageX;
                        isMoved = true;

                        utils.addClass(_this.thumbOuter, 'lg-dragging');

                        tempLeft = _this.left;

                        tempLeft = tempLeft - (endCoords - startCoords);

                        if (tempLeft > _this.thumbTotalWidth - _this.thumbOuterWidth) {
                            tempLeft = _this.thumbTotalWidth - _this.thumbOuterWidth;
                        }

                        if (tempLeft < 0) {
                            tempLeft = 0;
                        }

                        // move current slide
                        _this.setTranslate(tempLeft);
                    }
                });

                utils.on(_this.core.outer.querySelector('.lg-thumb'), 'touchend.lg', function () {
                    if (_this.thumbTotalWidth > _this.thumbOuterWidth) {

                        if (isMoved) {
                            isMoved = false;
                            utils.removeClass(_this.thumbOuter, 'lg-dragging');
                            if (Math.abs(endCoords - startCoords) < _this.core.s.swipeThreshold) {
                                _this.thumbClickable = true;
                            }

                            _this.left = tempLeft;
                        } else {
                            _this.thumbClickable = true;
                        }
                    } else {
                        _this.thumbClickable = true;
                    }
                });
            };

            Thumbnail.prototype.toggle = function () {
                var _this = this;
                if (_this.core.s.toggleThumb) {
                    utils.addClass(_this.core.outer, 'lg-can-toggle');
                    _this.thumbOuter.insertAdjacentHTML('beforeend', '<span class="lg-toggle-thumb lg-icon"></span>');
                    utils.on(_this.core.outer.querySelector('.lg-toggle-thumb'), 'click.lg', function () {
                        if (utils.hasClass(_this.core.outer, 'lg-thumb-open')) {
                            utils.removeClass(_this.core.outer, 'lg-thumb-open');
                        } else {
                            utils.addClass(_this.core.outer, 'lg-thumb-open');
                        }
                    });
                }
            };

            Thumbnail.prototype.thumbkeyPress = function () {
                var _this = this;
                utils.on(window, 'keydown.lgthumb', function (e) {
                    if (e.keyCode === 38) {
                        e.preventDefault();
                        utils.addClass(_this.core.outer, 'lg-thumb-open');
                    } else if (e.keyCode === 40) {
                        e.preventDefault();
                        utils.removeClass(_this.core.outer, 'lg-thumb-open');
                    }
                });
            };

            Thumbnail.prototype.destroy = function () {
                if (this.core.s.thumbnail && this.core.items.length > 1) {
                    utils.off(window, '.lgthumb');
                    this.thumbOuter.parentNode.removeChild(this.thumbOuter);
                    utils.removeClass(this.core.outer, 'lg-has-thumb');

                    var lgScript = document.getElementsByClassName('lg-script');
                    while (lgScript[0]) {
                        lgScript[0].parentNode.removeChild(lgScript[0]);
                    }
                }
            };

            window.lgModules.thumbnail = Thumbnail;
        });

    },{}]},{},[1])(1)
});
// lg-video.js
(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.LgVideo = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
        (function (global, factory) {
            if (typeof define === "function" && define.amd) {
                define([], factory);
            } else if (typeof exports !== "undefined") {
                factory();
            } else {
                var mod = {
                    exports: {}
                };
                factory();
                global.lgVideo = mod.exports;
            }
        })(this, function () {
            'use strict';

            var _extends = Object.assign || function (target) {
                for (var i = 1; i < arguments.length; i++) {
                    var source = arguments[i];

                    for (var key in source) {
                        if (Object.prototype.hasOwnProperty.call(source, key)) {
                            target[key] = source[key];
                        }
                    }
                }

                return target;
            };

            var videoDefaults = {
                videoMaxWidth: '100%',
                videoMarginRight: '0px',
                youtubePlayerParams: false,
                vimeoPlayerParams: false,
                dailymotionPlayerParams: false,
                vkPlayerParams: false,
                videojs: false,
                videojsOptions: {}
            };

            var Video = function Video(element) {

                this.el = element;

                this.core = window.lgData[this.el.getAttribute('lg-uid')];
                this.core.s = _extends({}, videoDefaults, this.core.s);

                this.videoLoaded = false;

                this.init();

                return this;
            };

            Video.prototype.init = function () {
                var _this = this;

                // Event triggered when video url found without poster
                utils.on(_this.core.el, 'hasVideo.lgtm', function (event) {
                    _this.core.___slide[event.detail.index].querySelector('.lg-video').insertAdjacentHTML('beforeend', _this.loadVideo(event.detail.src, 'lg-object', true, event.detail.index, event.detail.html));
                    if (event.detail.html) {
                        if (_this.core.s.videojs) {
                            try {
                                videojs(_this.core.___slide[event.detail.index].querySelector('.lg-html5'), _this.core.s.videojsOptions, function () {
                                    if (!_this.videoLoaded) {
                                        this.play();
                                    }
                                });
                            } catch (e) {
                                console.error('Make sure you have included videojs');
                            }
                        } else {
                            _this.core.___slide[event.detail.index].querySelector('.lg-html5').play();
                        }
                    }
                });

                // Set max width for video
                utils.on(_this.core.el, 'onAferAppendSlide.lgtm', function (event) {
                    if (_this.core.___slide[event.detail.index].querySelector('.lg-video-cont')) {
                        var v_target = _this.core.___slide[event.detail.index].querySelector('.lg-video-cont');
                        v_target.style.maxWidth = _this.core.s.videoMaxWidth;
                        v_target.style.marginRight = _this.core.s.videoMarginRight;
                        _this.videoLoaded = true;
                    }
                });

                var loadOnClick = function loadOnClick($el) {
                    // check slide has poster
                    if (utils.hasClass($el.querySelector('.lg-object'), 'lg-has-poster') && $el.querySelector('.lg-object').style.display !== 'none') {

                        // check already video element present
                        if (!utils.hasClass($el, 'lg-has-video')) {

                            utils.addClass($el, 'lg-video-playing');
                            utils.addClass($el, 'lg-has-video');

                            var _src;
                            var _html;
                            var _loadVideo = function _loadVideo(_src, _html) {

                                $el.querySelector('.lg-video').insertAdjacentHTML('beforeend', _this.loadVideo(_src, '', false, _this.core.index, _html));

                                if (_html) {
                                    if (_this.core.s.videojs) {
                                        try {
                                            videojs(_this.core.___slide[_this.core.index].querySelector('.lg-html5'), _this.core.s.videojsOptions, function () {
                                                this.play();
                                            });
                                        } catch (e) {
                                            console.error('Make sure you have included videojs');
                                        }
                                    } else {
                                        _this.core.___slide[_this.core.index].querySelector('.lg-html5').play();
                                    }
                                }
                            };

                            if (_this.core.s.dynamic) {

                                _src = _this.core.s.dynamicEl[_this.core.index].src;
                                _html = _this.core.s.dynamicEl[_this.core.index].html;

                                _loadVideo(_src, _html);
                            } else {

                                _src = _this.core.items[_this.core.index].getAttribute('href') || _this.core.items[_this.core.index].getAttribute('data-src');
                                _html = _this.core.items[_this.core.index].getAttribute('data-html');

                                _loadVideo(_src, _html);
                            }

                            var $tempImg = $el.querySelector('.lg-object');
                            $el.querySelector('.lg-video').appendChild($tempImg);

                            // @todo loading icon for html5 videos also
                            // for showing the loading indicator while loading video
                            if (!utils.hasClass($el.querySelector('.lg-video-object'), 'lg-html5')) {
                                utils.removeClass($el, 'lg-complete');
                                utils.on($el.querySelector('.lg-video-object'), 'load.lg error.lg', function () {
                                    utils.addClass($el, 'lg-complete');
                                });
                            }
                        } else {

                            var youtubePlayer = $el.querySelector('.lg-youtube');
                            var vimeoPlayer = $el.querySelector('.lg-vimeo');
                            var dailymotionPlayer = $el.querySelector('.lg-dailymotion');
                            var html5Player = $el.querySelector('.lg-html5');
                            if (youtubePlayer) {
                                youtubePlayer.contentWindow.postMessage('{"event":"command","func":"playVideo","args":""}', '*');
                            } else if (vimeoPlayer) {
                                try {
                                    $f(vimeoPlayer).api('play');
                                } catch (e) {
                                    console.error('Make sure you have included froogaloop2 js');
                                }
                            } else if (dailymotionPlayer) {
                                dailymotionPlayer.contentWindow.postMessage('play', '*');
                            } else if (html5Player) {
                                if (_this.core.s.videojs) {
                                    try {
                                        videojs(html5Player).play();
                                    } catch (e) {
                                        console.error('Make sure you have included videojs');
                                    }
                                } else {
                                    html5Player.play();
                                }
                            }

                            utils.addClass($el, 'lg-video-playing');
                        }
                    }
                };

                if (_this.core.doCss() && _this.core.items.length > 1 && (_this.core.s.enableSwipe && _this.core.isTouch || _this.core.s.enableDrag && !_this.core.isTouch)) {
                    utils.on(_this.core.el, 'onSlideClick.lgtm', function () {
                        var $el = _this.core.___slide[_this.core.index];
                        loadOnClick($el);
                    });
                } else {

                    // For IE 9 and bellow
                    for (var i = 0; i < _this.core.___slide.length; i++) {

                        /*jshint loopfunc: true */
                        (function (index) {
                            utils.on(_this.core.___slide[index], 'click.lg', function () {
                                loadOnClick(_this.core.___slide[index]);
                            });
                        })(i);
                    }
                }

                utils.on(_this.core.el, 'onBeforeSlide.lgtm', function (event) {

                    var $videoSlide = _this.core.___slide[event.detail.prevIndex];
                    var youtubePlayer = $videoSlide.querySelector('.lg-youtube');
                    var vimeoPlayer = $videoSlide.querySelector('.lg-vimeo');
                    var dailymotionPlayer = $videoSlide.querySelector('.lg-dailymotion');
                    var vkPlayer = $videoSlide.querySelector('.lg-vk');
                    var html5Player = $videoSlide.querySelector('.lg-html5');
                    if (youtubePlayer) {
                        youtubePlayer.contentWindow.postMessage('{"event":"command","func":"pauseVideo","args":""}', '*');
                    } else if (vimeoPlayer) {
                        try {
                            $f(vimeoPlayer).api('pause');
                        } catch (e) {
                            console.error('Make sure you have included froogaloop2 js');
                        }
                    } else if (dailymotionPlayer) {
                        dailymotionPlayer.contentWindow.postMessage('pause', '*');
                    } else if (html5Player) {
                        if (_this.core.s.videojs) {
                            try {
                                videojs(html5Player).pause();
                            } catch (e) {
                                console.error('Make sure you have included videojs');
                            }
                        } else {
                            html5Player.pause();
                        }
                    }if (vkPlayer) {

                        vkPlayer.setAttribute('src', vkPlayer.getAttribute('src').replace('&autoplay', '&noplay'));
                    }

                    var _src;
                    if (_this.core.s.dynamic) {
                        _src = _this.core.s.dynamicEl[event.detail.index].src;
                    } else {
                        _src = _this.core.items[event.detail.index].getAttribute('href') || _this.core.items[event.detail.index].getAttribute('data-src');
                    }

                    var _isVideo = _this.core.isVideo(_src, event.detail.index) || {};
                    if (_isVideo.youtube || _isVideo.vimeo || _isVideo.dailymotion || _isVideo.vk) {
                        utils.addClass(_this.core.outer, 'lg-hide-download');
                    }

                    //$videoSlide.addClass('lg-complete');
                });

                utils.on(_this.core.el, 'onAfterSlide.lgtm', function (event) {
                    utils.removeClass(_this.core.___slide[event.detail.prevIndex], 'lg-video-playing');
                });
            };

            Video.prototype.loadVideo = function (src, addClass, noposter, index, html) {
                var video = '';
                var autoplay = 1;
                var a = '';
                var isVideo = this.core.isVideo(src, index) || {};

                // Enable autoplay for first video if poster doesn't exist
                if (noposter) {
                    if (this.videoLoaded) {
                        autoplay = 0;
                    } else {
                        autoplay = 1;
                    }
                }

                if (isVideo.youtube) {

                    a = '?wmode=opaque&autoplay=' + autoplay + '&enablejsapi=1';
                    if (this.core.s.youtubePlayerParams) {
                        a = a + '&' + utils.param(this.core.s.youtubePlayerParams);
                    }

                    video = '<iframe class="lg-video-object lg-youtube ' + addClass + '" width="560" height="315" src="//www.youtube.com/embed/' + isVideo.youtube[1] + a + '" frameborder="0" allowfullscreen></iframe>';
                } else if (isVideo.vimeo) {

                    a = '?autoplay=' + autoplay + '&api=1';
                    if (this.core.s.vimeoPlayerParams) {
                        a = a + '&' + utils.param(this.core.s.vimeoPlayerParams);
                    }

                    video = '<iframe class="lg-video-object lg-vimeo ' + addClass + '" width="560" height="315"  src="//player.vimeo.com/video/' + isVideo.vimeo[1] + a + '" frameborder="0" webkitAllowFullScreen mozallowfullscreen allowFullScreen></iframe>';
                } else if (isVideo.dailymotion) {

                    a = '?wmode=opaque&autoplay=' + autoplay + '&api=postMessage';
                    if (this.core.s.dailymotionPlayerParams) {
                        a = a + '&' + utils.param(this.core.s.dailymotionPlayerParams);
                    }

                    video = '<iframe class="lg-video-object lg-dailymotion ' + addClass + '" width="560" height="315" src="//www.dailymotion.com/embed/video/' + isVideo.dailymotion[1] + a + '" frameborder="0" allowfullscreen></iframe>';
                } else if (isVideo.html5) {
                    var fL = html.substring(0, 1);
                    console.log(html);
                    if (fL === '.' || fL === '#') {
                        html = document.querySelector(html).innerHTML;
                    }

                    video = html;
                } else if (isVideo.vk) {

                    a = '&autoplay=' + autoplay;
                    if (this.core.s.vkPlayerParams) {
                        a = a + '&' + utils.param(this.core.s.vkPlayerParams);
                    }

                    video = '<iframe class="lg-video-object lg-vk ' + addClass + '" width="560" height="315" src="http://vk.com/video_ext.php?' + isVideo.vk[1] + a + '" frameborder="0" allowfullscreen></iframe>';
                }

                return video;
            };

            Video.prototype.destroy = function () {
                this.videoLoaded = false;
            };

            window.lgModules.video = Video;
        });

    },{}]},{},[1])(1)
});
// lg-hash.js
(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.LgHash = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
        (function (global, factory) {
            if (typeof define === "function" && define.amd) {
                define([], factory);
            } else if (typeof exports !== "undefined") {
                factory();
            } else {
                var mod = {
                    exports: {}
                };
                factory();
                global.lgHash = mod.exports;
            }
        })(this, function () {
            'use strict';

            var _extends = Object.assign || function (target) {
                for (var i = 1; i < arguments.length; i++) {
                    var source = arguments[i];

                    for (var key in source) {
                        if (Object.prototype.hasOwnProperty.call(source, key)) {
                            target[key] = source[key];
                        }
                    }
                }

                return target;
            };

            var hashDefaults = {
                hash: true
            };
            var Hash = function Hash(element) {
                this.el = element;
                this.core = window.lgData[this.el.getAttribute('lg-uid')];
                this.core.s = _extends({}, hashDefaults, this.core.s);
                if (this.core.s.hash) {
                    this.oldHash = window.location.hash;
                    this.init();
                }

                return this;
            };

            Hash.prototype.init = function () {
                var _this = this;
                var _hash;

                // Change hash value on after each slide transition
                utils.on(_this.core.el, 'onAfterSlide.lgtm', function (event) {
                    window.location.hash = 'lg=' + _this.core.s.galleryId + '&slide=' + event.detail.index;
                });

                // Listen hash change and change the slide according to slide value
                utils.on(window, 'hashchange.lghash', function () {
                    _hash = window.location.hash;
                    var _idx = parseInt(_hash.split('&slide=')[1], 10);

                    // it galleryId doesn't exist in the url close the gallery
                    if (_hash.indexOf('lg=' + _this.core.s.galleryId) > -1) {
                        _this.core.slide(_idx, false, false);
                    } else if (_this.core.lGalleryOn) {
                        _this.core.destroy();
                    }
                });
            };

            Hash.prototype.destroy = function () {
                if (!this.core.s.hash) {
                    return;
                }

                // Reset to old hash value
                if (this.oldHash && this.oldHash.indexOf('lg=' + this.core.s.galleryId) < 0) {
                    window.location.hash = this.oldHash;
                } else {
                    if (history.pushState) {
                        history.pushState('', document.title, window.location.pathname + window.location.search);
                    } else {
                        window.location.hash = '';
                    }
                }

                utils.off(this.core.el, '.lghash');
            };

            window.lgModules.hash = Hash;
        });

    },{}]},{},[1])(1)
});
/*!
 * Lazy Load - jQuery plugin for lazy loading images
 *
 * Copyright (c) 2007-2015 Mika Tuupola
 *
 * Licensed under the MIT license:
 *   http://www.opensource.org/licenses/mit-license.php
 *
 * Project home:
 *   http://www.appelsiini.net/projects/lazyload
 *
 * Version:  1.9.7
 *
 */

(function($, window, document, undefined) {
    var $window = $(window);

    $.fn.lazyload = function(options) {
        var elements = this;
        var $container;
        var settings = {
            threshold       : 0,
            failure_limit   : 0,
            event           : "scroll",
            effect          : "show",
            container       : window,
            data_attribute  : "original",
            skip_invisible  : false,
            appear          : null,
            load            : null,
            placeholder     : "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC"
        };

        function update() {
            var counter = 0;

            elements.each(function() {
                var $this = $(this);
                if (settings.skip_invisible && !$this.is(":visible")) {
                    return;
                }
                if ($.abovethetop(this, settings) ||
                    $.leftofbegin(this, settings)) {
                    /* Nothing. */
                } else if (!$.belowthefold(this, settings) &&
                    !$.rightoffold(this, settings)) {
                    $this.trigger("appear");
                    /* if we found an image we'll load, reset the counter */
                    counter = 0;
                } else {
                    if (++counter > settings.failure_limit) {
                        return false;
                    }
                }
            });

        }

        if(options) {
            /* Maintain BC for a couple of versions. */
            if (undefined !== options.failurelimit) {
                options.failure_limit = options.failurelimit;
                delete options.failurelimit;
            }
            if (undefined !== options.effectspeed) {
                options.effect_speed = options.effectspeed;
                delete options.effectspeed;
            }

            $.extend(settings, options);
        }

        /* Cache container as jQuery as object. */
        $container = (settings.container === undefined ||
        settings.container === window) ? $window : $(settings.container);

        /* Fire one scroll event per scroll. Not one scroll event per image. */
        if (0 === settings.event.indexOf("scroll")) {
            $container.bind(settings.event, function() {
                return update();
            });
        }

        this.each(function() {
            var self = this;
            var $self = $(self);

            self.loaded = false;

            /* If no src attribute given use data:uri. */
            if ($self.attr("src") === undefined || $self.attr("src") === false) {
                if ($self.is("img")) {
                    $self.attr("src", settings.placeholder);
                }
            }

            /* When appear is triggered load original image. */
            $self.one("appear", function() {
                if (!this.loaded) {
                    if (settings.appear) {
                        var elements_left = elements.length;
                        settings.appear.call(self, elements_left, settings);
                    }
                    $("<img />")
                        .bind("load", function() {

                            var original = $self.attr("data-" + settings.data_attribute);
                            $self.hide();
                            if ($self.is("img")) {
                                $self.attr("src", original);
                            } else {
                                $self.css("background-image", "url('" + original + "')");
                            }
                            $self[settings.effect](settings.effect_speed);

                            self.loaded = true;

                            /* Remove image from array so it is not looped next time. */
                            var temp = $.grep(elements, function(element) {
                                return !element.loaded;
                            });
                            elements = $(temp);

                            if (settings.load) {
                                var elements_left = elements.length;
                                settings.load.call(self, elements_left, settings);
                            }
                        })
                        .attr("src", $self.attr("data-" + settings.data_attribute));
                }
            });

            /* When wanted event is triggered load original image */
            /* by triggering appear.                              */
            if (0 !== settings.event.indexOf("scroll")) {
                $self.bind(settings.event, function() {
                    if (!self.loaded) {
                        $self.trigger("appear");
                    }
                });
            }
        });

        /* Check if something appears when window is resized. */
        $window.bind("resize", function() {
            update();
        });

        /* With IOS5 force loading images when navigating with back button. */
        /* Non optimal workaround. */
        if ((/(?:iphone|ipod|ipad).*os 5/gi).test(navigator.appVersion)) {
            $window.bind("pageshow", function(event) {
                if (event.originalEvent && event.originalEvent.persisted) {
                    elements.each(function() {
                        $(this).trigger("appear");
                    });
                }
            });
        }

        /* Force initial check if images should appear. */
        $(document).ready(function() {
            update();
        });

        return this;
    };

    /* Convenience methods in jQuery namespace.           */
    /* Use as  $.belowthefold(element, {threshold : 100, container : window}) */

    $.belowthefold = function(element, settings) {
        var fold;

        if (settings.container === undefined || settings.container === window) {
            fold = (window.innerHeight ? window.innerHeight : $window.height()) + $window.scrollTop();
        } else {
            fold = $(settings.container).offset().top + $(settings.container).height();
        }

        return fold <= $(element).offset().top - settings.threshold;
    };

    $.rightoffold = function(element, settings) {
        var fold;

        if (settings.container === undefined || settings.container === window) {
            fold = $window.width() + $window.scrollLeft();
        } else {
            fold = $(settings.container).offset().left + $(settings.container).width();
        }

        return fold <= $(element).offset().left - settings.threshold;
    };

    $.abovethetop = function(element, settings) {
        var fold;

        if (settings.container === undefined || settings.container === window) {
            fold = $window.scrollTop();
        } else {
            fold = $(settings.container).offset().top;
        }

        return fold >= $(element).offset().top + settings.threshold  + $(element).height();
    };

    $.leftofbegin = function(element, settings) {
        var fold;

        if (settings.container === undefined || settings.container === window) {
            fold = $window.scrollLeft();
        } else {
            fold = $(settings.container).offset().left;
        }

        return fold >= $(element).offset().left + settings.threshold + $(element).width();
    };

    $.inviewport = function(element, settings) {
        return !$.rightoffold(element, settings) && !$.leftofbegin(element, settings) &&
            !$.belowthefold(element, settings) && !$.abovethetop(element, settings);
    };

    /* Custom selectors for your convenience.   */
    /* Use as $("img:below-the-fold").something() or */
    /* $("img").filter(":below-the-fold").something() which is faster */

    $.extend($.expr[":"], {
        "below-the-fold" : function(a) { return $.belowthefold(a, {threshold : 0}); },
        "above-the-top"  : function(a) { return !$.belowthefold(a, {threshold : 0}); },
        "right-of-screen": function(a) { return $.rightoffold(a, {threshold : 0}); },
        "left-of-screen" : function(a) { return !$.rightoffold(a, {threshold : 0}); },
        "in-viewport"    : function(a) { return $.inviewport(a, {threshold : 0}); },
        /* Maintain BC for couple of versions. */
        "above-the-fold" : function(a) { return !$.belowthefold(a, {threshold : 0}); },
        "right-of-fold"  : function(a) { return $.rightoffold(a, {threshold : 0}); },
        "left-of-fold"   : function(a) { return !$.rightoffold(a, {threshold : 0}); }
    });

})(jQuery, window, document);
/* http://james.padolsey.com/javascript/special-scroll-events-for-jquery/ */
;(function(){
    var special = jQuery.event.special,
        uid1 = "D" + (+new Date()),
        uid2 = "D" + (+new Date() + 1);

    special.scrollstart = {
        setup: function() {

            var timer,
                handler =  function(evt) {

                    var _self = this,
                        _args = arguments;

                    if (timer) {
                        clearTimeout(timer);
                    } else {
                        evt.type = "scrollstart";
                        jQuery.event.dispatch.apply(_self, _args);
                    }

                    timer = setTimeout( function(){
                        timer = null;
                    }, special.scrollstop.latency);

                };

            jQuery(this).bind("scroll", handler).data(uid1, handler);

        },
        teardown: function(){
            jQuery(this).unbind( "scroll", jQuery(this).data(uid1) );
        }
    };

    special.scrollstop = {
        latency: 300,
        setup: function() {

            var timer,
                handler = function(evt) {

                    var _self = this,
                        _args = arguments;

                    if (timer) {
                        clearTimeout(timer);
                    }

                    timer = setTimeout( function(){

                        timer = null;
                        evt.type = "scrollstop";
                        jQuery.event.dispatch.apply(_self, _args);


                    }, special.scrollstop.latency);

                };

            jQuery(this).bind("scroll", handler).data(uid2, handler);

        },
        teardown: function() {
            jQuery(this).unbind( "scroll", jQuery(this).data(uid2) );
        }
    };
})();
/*! layer-v3.0.0 Web弹层组件 LGPL License  http://layer.layui.com/  By 贤心 */
!function(e, t) {
    "use strict";
    var i, n, a = e.layui && layui.define, o = {
        getPath:function() {
            var e = document.scripts, t = e[e.length - 1], i = t.src;
            if (!t.getAttribute("merge")) return i.substring(0, i.lastIndexOf("/") + 1);
        }(),
        config:{},
        end:{},
        minIndex:0,
        minLeft:[],
        btn:[ "&#x786E;&#x5B9A;", "&#x53D6;&#x6D88;" ],
        type:[ "dialog", "page", "iframe", "loading", "tips" ]
    }, r = {
        v:"3.0",
        ie:function() {
            var t = navigator.userAgent.toLowerCase();
            return !!(e.ActiveXObject || "ActiveXObject" in e) && ((t.match(/msie\s(\d+)/) || [])[1] || "11");
        }(),
        index:e.layer && e.layer.v ? 1e5 :0,
        path:o.getPath,
        config:function(e, t) {
            return e = e || {}, r.cache = o.config = i.extend({}, o.config, e), r.path = o.config.path || r.path,
            "string" == typeof e.extend && (e.extend = [ e.extend ]), e.extend ? (a ? layui.addcss("modules/layer/" + e.extend) :r.link("skin/" + e.extend),
                this) :this;
        },
        link:function(t, n, a) {
            if (r.path) {
                var o = i("head")[0], l = document.createElement("link");
                "string" == typeof n && (a = n);
                var s = (a || t).replace(/\.|\//g, ""), f = "layuicss-" + s, c = 0;
                l.rel = "stylesheet", l.href = r.path + t, l.id = f, i("#" + f)[0] || o.appendChild(l),
                "function" == typeof n && !function d() {
                    return ++c > 80 ? e.console && console.error("layer.css: Invalid") :void (1989 === parseInt(i("#" + f).css("width")) ? n() :setTimeout(d, 100));
                }();
            }
        },
        ready:function(e) {
            var t = "skinlayercss", i = "1518";
            return this;
        },
        alert:function(e, t, n) {
            var a = "function" == typeof t;
            return a && (n = t), r.open(i.extend({
                content:e,
                yes:n
            }, a ? {} :t));
        },
        confirm:function(e, t, n, a) {
            var l = "function" == typeof t;
            return l && (a = n, n = t), r.open(i.extend({
                content:e,
                btn:o.btn,
                yes:n,
                btn2:a
            }, l ? {} :t));
        },
        msg:function(e, n, a) {
            var l = "function" == typeof n, f = o.config.skin, c = (f ? f + " " + f + "-msg" :"") || "layui-layer-msg", d = s.anim.length - 1;
            return l && (a = n), r.open(i.extend({
                content:e,
                time:3e3,
                shade:!1,
                skin:c,
                title:!1,
                closeBtn:!1,
                btn:!1,
                resize:!1,
                end:a
            }, l && !o.config.skin ? {
                skin:c + " layui-layer-hui",
                anim:d
            } :function() {
                return n = n || {}, (n.icon === -1 || n.icon === t && !o.config.skin) && (n.skin = c + " " + (n.skin || "layui-layer-hui")),
                    n;
            }()));
        },
        load:function(e, t) {
            return r.open(i.extend({
                type:3,
                icon:e || 0,
                resize:!1,
                shade:.01
            }, t));
        },
        tips:function(e, t, n) {
            return r.open(i.extend({
                type:4,
                content:[ e, t ],
                closeBtn:!1,
                time:3e3,
                shade:!1,
                resize:!1,
                fixed:!1,
                maxWidth:210
            }, n));
        }
    }, l = function(e) {
        var t = this;
        t.index = ++r.index, t.config = i.extend({}, t.config, o.config, e), document.body ? t.creat() :setTimeout(function() {
            t.creat();
        }, 50);
    };
    l.pt = l.prototype;
    var s = [ "layui-layer", ".layui-layer-title", ".layui-layer-main", ".layui-layer-dialog", "layui-layer-iframe", "layui-layer-content", "layui-layer-btn", "layui-layer-close" ];
    s.anim = [ "layer-anim", "layer-anim-01", "layer-anim-02", "layer-anim-03", "layer-anim-04", "layer-anim-05", "layer-anim-06" ],
        l.pt.config = {
            type:0,
            shade:.3,
            fixed:!0,
            move:s[1],
            title:"&#x4FE1;&#x606F;",
            offset:"auto",
            area:"auto",
            closeBtn:1,
            time:0,
            zIndex:19891014,
            maxWidth:360,
            anim:0,
            icon:-1,
            moveType:1,
            resize:!0,
            scrollbar:!0,
            tips:2
        }, l.pt.vessel = function(e, t) {
        var n = this, a = n.index, r = n.config, l = r.zIndex + a, f = "object" == typeof r.title, c = r.maxmin && (1 === r.type || 2 === r.type), d = r.title ? '<div class="layui-layer-title" style="' + (f ? r.title[1] :"") + '">' + (f ? r.title[0] :r.title) + "</div>" :"";
        return r.zIndex = l, t([ r.shade ? '<div class="layui-layer-shade" id="layui-layer-shade' + a + '" times="' + a + '" style="' + ("z-index:" + (l - 1) + "; background-color:" + (r.shade[1] || "#000") + "; opacity:" + (r.shade[0] || r.shade) + "; filter:alpha(opacity=" + (100 * r.shade[0] || 100 * r.shade) + ");") + '"></div>' :"", '<div class="' + s[0] + (" layui-layer-" + o.type[r.type]) + (0 != r.type && 2 != r.type || r.shade ? "" :" layui-layer-border") + " " + (r.skin || "") + '" id="' + s[0] + a + '" type="' + o.type[r.type] + '" times="' + a + '" showtime="' + r.time + '" conType="' + (e ? "object" :"string") + '" style="z-index: ' + l + "; width:" + r.area[0] + ";height:" + r.area[1] + (r.fixed ? "" :";position:absolute;") + '">' + (e && 2 != r.type ? "" :d) + '<div id="' + (r.id || "") + '" class="layui-layer-content' + (0 == r.type && r.icon !== -1 ? " layui-layer-padding" :"") + (3 == r.type ? " layui-layer-loading" + r.icon :"") + '">' + (0 == r.type && r.icon !== -1 ? '<i class="layui-layer-ico layui-layer-ico' + r.icon + '"></i>' :"") + (1 == r.type && e ? "" :r.content || "") + '</div><span class="layui-layer-setwin">' + function() {
            var e = c ? '<a class="layui-layer-min" href="javascript:;"><cite></cite></a><a class="layui-layer-ico layui-layer-max" href="javascript:;"></a>' :"";
            return r.closeBtn && (e += '<a class="layui-layer-ico ' + s[7] + " " + s[7] + (r.title ? r.closeBtn :4 == r.type ? "1" :"2") + '" href="javascript:;"></a>'),
                e;
        }() + "</span>" + (r.btn ? function() {
            var e = "";
            "string" == typeof r.btn && (r.btn = [ r.btn ]);
            for (var t = 0, i = r.btn.length; t < i; t++) e += '<a class="' + s[6] + t + '">' + r.btn[t] + "</a>";
            return '<div class="' + s[6] + " layui-layer-btn-" + (r.btnAlign || "") + '">' + e + "</div>";
        }() :"") + (r.resize ? '<span class="layui-layer-resize"></span>' :"") + "</div>" ], d, i('<div class="layui-layer-move"></div>')),
            n;
    }, l.pt.creat = function() {
        var e = this, t = e.config, a = e.index, l = t.content, f = "object" == typeof l, c = i("body");
        if (!i("#" + t.id)[0]) {
            switch ("string" == typeof t.area && (t.area = "auto" === t.area ? [ "", "" ] :[ t.area, "" ]),
            t.shift && (t.anim = t.shift), 6 == r.ie && (t.fixed = !1), t.type) {
                case 0:
                    t.btn = "btn" in t ? t.btn :o.btn[0], r.closeAll("dialog");
                    break;

                case 2:
                    var l = t.content = f ? t.content :[ t.content || "http://layer.layui.com", "auto" ];
                    t.content = '<iframe scrolling="' + (t.content[1] || "auto") + '" allowtransparency="true" id="' + s[4] + a + '" name="' + s[4] + a + '" onload="this.className=\'\';" class="layui-layer-load" frameborder="0" src="' + t.content[0] + '"></iframe>';
                    break;

                case 3:
                    delete t.title, delete t.closeBtn, t.icon === -1 && 0 === t.icon, r.closeAll("loading");
                    break;

                case 4:
                    f || (t.content = [ t.content, "body" ]), t.follow = t.content[1], t.content = t.content[0] + '<i class="layui-layer-TipsG"></i>',
                        delete t.title, t.tips = "object" == typeof t.tips ? t.tips :[ t.tips, !0 ], t.tipsMore || r.closeAll("tips");
            }
            e.vessel(f, function(n, r, d) {
                c.append(n[0]), f ? function() {
                    2 == t.type || 4 == t.type ? function() {
                        i("body").append(n[1]);
                    }() :function() {
                        l.parents("." + s[0])[0] || (l.data("display", l.css("display")).show().addClass("layui-layer-wrap").wrap(n[1]),
                            i("#" + s[0] + a).find("." + s[5]).before(r));
                    }();
                }() :c.append(n[1]), i(".layui-layer-move")[0] || c.append(o.moveElem = d), e.layero = i("#" + s[0] + a),
                t.scrollbar || s.html.css("overflow", "hidden").attr("layer-full", a);
            }).auto(a), 2 == t.type && 6 == r.ie && e.layero.find("iframe").attr("src", l[0]),
                4 == t.type ? e.tips() :e.offset(), t.fixed && n.on("resize", function() {
                e.offset(), (/^\d+%$/.test(t.area[0]) || /^\d+%$/.test(t.area[1])) && e.auto(a),
                4 == t.type && e.tips();
            }), t.time <= 0 || setTimeout(function() {
                r.close(e.index);
            }, t.time), e.move().callback(), s.anim[t.anim] && e.layero.addClass(s.anim[t.anim]);
        }
    }, l.pt.auto = function(e) {
        function t(e) {
            e = l.find(e), e.height(f[1] - c - d - 2 * (0 | parseFloat(e.css("padding"))));
        }
        var a = this, o = a.config, l = i("#" + s[0] + e);
        "" === o.area[0] && o.maxWidth > 0 && (r.ie && r.ie < 8 && o.btn && l.width(l.innerWidth()),
        l.outerWidth() > o.maxWidth && l.width(o.maxWidth));
        var f = [ l.innerWidth(), l.innerHeight() ], c = l.find(s[1]).outerHeight() || 0, d = l.find("." + s[6]).outerHeight() || 0;
        switch (o.type) {
            case 2:
                t("iframe");
                break;

            default:
                "" === o.area[1] ? o.fixed && f[1] >= n.height() && (f[1] = n.height(), t("." + s[5])) :t("." + s[5]);
        }
        return a;
    }, l.pt.offset = function() {
        var e = this, t = e.config, i = e.layero, a = [ i.outerWidth(), i.outerHeight() ], o = "object" == typeof t.offset;
        e.offsetTop = (n.height() - a[1]) / 2, e.offsetLeft = (n.width() - a[0]) / 2, o ? (e.offsetTop = t.offset[0],
            e.offsetLeft = t.offset[1] || e.offsetLeft) :"auto" !== t.offset && ("t" === t.offset ? e.offsetTop = 0 :"r" === t.offset ? e.offsetLeft = n.width() - a[0] :"b" === t.offset ? e.offsetTop = n.height() - a[1] :"l" === t.offset ? e.offsetLeft = 0 :"lt" === t.offset ? (e.offsetTop = 0,
            e.offsetLeft = 0) :"lb" === t.offset ? (e.offsetTop = n.height() - a[1], e.offsetLeft = 0) :"rt" === t.offset ? (e.offsetTop = 0,
            e.offsetLeft = n.width() - a[0]) :"rb" === t.offset ? (e.offsetTop = n.height() - a[1],
            e.offsetLeft = n.width() - a[0]) :e.offsetTop = t.offset), t.fixed || (e.offsetTop = /%$/.test(e.offsetTop) ? n.height() * parseFloat(e.offsetTop) / 100 :parseFloat(e.offsetTop),
            e.offsetLeft = /%$/.test(e.offsetLeft) ? n.width() * parseFloat(e.offsetLeft) / 100 :parseFloat(e.offsetLeft),
            e.offsetTop += n.scrollTop(), e.offsetLeft += n.scrollLeft()), i.attr("minLeft") && (e.offsetTop = n.height() - (i.find(s[1]).outerHeight() || 0),
            e.offsetLeft = i.css("left")), i.css({
            top:e.offsetTop,
            left:e.offsetLeft
        });
    }, l.pt.tips = function() {
        var e = this, t = e.config, a = e.layero, o = [ a.outerWidth(), a.outerHeight() ], r = i(t.follow);
        r[0] || (r = i("body"));
        var l = {
            width:r.outerWidth(),
            height:r.outerHeight(),
            top:r.offset().top,
            left:r.offset().left
        }, f = a.find(".layui-layer-TipsG"), c = t.tips[0];
        t.tips[1] || f.remove(), l.autoLeft = function() {
            l.left + o[0] - n.width() > 0 ? (l.tipLeft = l.left + l.width - o[0], f.css({
                right:12,
                left:"auto"
            })) :l.tipLeft = l.left;
        }, l.where = [ function() {
            l.autoLeft(), l.tipTop = l.top - o[1] - 10, f.removeClass("layui-layer-TipsB").addClass("layui-layer-TipsT").css("border-right-color", t.tips[1]);
        }, function() {
            l.tipLeft = l.left + l.width + 10, l.tipTop = l.top, f.removeClass("layui-layer-TipsL").addClass("layui-layer-TipsR").css("border-bottom-color", t.tips[1]);
        }, function() {
            l.autoLeft(), l.tipTop = l.top + l.height + 10, f.removeClass("layui-layer-TipsT").addClass("layui-layer-TipsB").css("border-right-color", t.tips[1]);
        }, function() {
            l.tipLeft = l.left - o[0] - 10, l.tipTop = l.top, f.removeClass("layui-layer-TipsR").addClass("layui-layer-TipsL").css("border-bottom-color", t.tips[1]);
        } ], l.where[c - 1](), 1 === c ? l.top - (n.scrollTop() + o[1] + 16) < 0 && l.where[2]() :2 === c ? n.width() - (l.left + l.width + o[0] + 16) > 0 || l.where[3]() :3 === c ? l.top - n.scrollTop() + l.height + o[1] + 16 - n.height() > 0 && l.where[0]() :4 === c && o[0] + 16 - l.left > 0 && l.where[1](),
            a.find("." + s[5]).css({
                "background-color":t.tips[1],
                "padding-right":t.closeBtn ? "30px" :""
            }), a.css({
            left:l.tipLeft - (t.fixed ? n.scrollLeft() :0),
            top:l.tipTop - (t.fixed ? n.scrollTop() :0)
        });
    }, l.pt.move = function() {
        var e = this, t = e.config, a = i(document), l = e.layero, s = l.find(t.move), f = l.find(".layui-layer-resize"), c = {};
        return t.move && s.css("cursor", "move"), s.on("mousedown", function(e) {
            e.preventDefault(), t.move && (c.moveStart = !0, c.offset = [ e.clientX - parseFloat(l.css("left")), e.clientY - parseFloat(l.css("top")) ],
                o.moveElem.css("cursor", "move").show());
        }), f.on("mousedown", function(e) {
            e.preventDefault(), c.resizeStart = !0, c.offset = [ e.clientX, e.clientY ], c.area = [ l.outerWidth(), l.outerHeight() ],
                o.moveElem.css("cursor", "se-resize").show();
        }), a.on("mousemove", function(i) {
            if (c.moveStart) {
                var a = i.clientX - c.offset[0], o = i.clientY - c.offset[1];
                if (i.preventDefault(), c.stX = t.fixed ? 0 :n.scrollLeft(), c.stY = t.fixed ? 0 :n.scrollTop(),
                        !t.moveOut) {
                    var s = n.width() - l.outerWidth() + c.stX, f = n.height() - l.outerHeight() + c.stY;
                    a < c.stX && (a = c.stX), a > s && (a = s), o < c.stY && (o = c.stY), o > f && (o = f);
                }
                l.css({
                    left:a,
                    top:o
                });
            }
            if (t.resize && c.resizeStart) {
                var a = i.clientX - c.offset[0], o = i.clientY - c.offset[1];
                i.preventDefault(), r.style(e.index, {
                    width:c.area[0] + a,
                    height:c.area[1] + o
                }), c.isResize = !0;
            }
        }).on("mouseup", function(e) {
            c.moveStart && (delete c.moveStart, o.moveElem.hide(), t.moveEnd && t.moveEnd()),
            c.resizeStart && (delete c.resizeStart, o.moveElem.hide());
        }), e;
    }, l.pt.callback = function() {
        function e() {
            var e = a.cancel && a.cancel(t.index, n);
            e === !1 || r.close(t.index);
        }
        var t = this, n = t.layero, a = t.config;
        t.openLayer(), a.success && (2 == a.type ? n.find("iframe").on("load", function() {
            a.success(n, t.index);
        }) :a.success(n, t.index)), 6 == r.ie && t.IE6(n), n.find("." + s[6]).children("a").on("click", function() {
            var e = i(this).index();
            if (0 === e) a.yes ? a.yes(t.index, n) :a.btn1 ? a.btn1(t.index, n) :r.close(t.index); else {
                var o = a["btn" + (e + 1)] && a["btn" + (e + 1)](t.index, n);
                o === !1 || r.close(t.index);
            }
        }), n.find("." + s[7]).on("click", e), a.shadeClose && i("#layui-layer-shade" + t.index).on("click", function() {
            r.close(t.index);
        }), n.find(".layui-layer-min").on("click", function() {
            var e = a.min && a.min(n);
            e === !1 || r.min(t.index, a);
        }), n.find(".layui-layer-max").on("click", function() {
            i(this).hasClass("layui-layer-maxmin") ? (r.restore(t.index), a.restore && a.restore(n)) :(r.full(t.index, a),
                setTimeout(function() {
                    a.full && a.full(n);
                }, 100));
        }), a.end && (o.end[t.index] = a.end);
    }, o.reselect = function() {
        i.each(i("select"), function(e, t) {
            var n = i(this);
            n.parents("." + s[0])[0] || 1 == n.attr("layer") && i("." + s[0]).length < 1 && n.removeAttr("layer").show(),
                n = null;
        });
    }, l.pt.IE6 = function(e) {
        i("select").each(function(e, t) {
            var n = i(this);
            n.parents("." + s[0])[0] || "none" === n.css("display") || n.attr({
                layer:"1"
            }).hide(), n = null;
        });
    }, l.pt.openLayer = function() {
        var e = this;
        r.zIndex = e.config.zIndex, r.setTop = function(e) {
            var t = function() {
                r.zIndex++, e.css("z-index", r.zIndex + 1);
            };
            return r.zIndex = parseInt(e[0].style.zIndex), e.on("mousedown", t), r.zIndex;
        };
    }, o.record = function(e) {
        var t = [ e.width(), e.height(), e.position().top, e.position().left + parseFloat(e.css("margin-left")) ];
        e.find(".layui-layer-max").addClass("layui-layer-maxmin"), e.attr({
            area:t
        });
    }, o.rescollbar = function(e) {
        s.html.attr("layer-full") == e && (s.html[0].style.removeProperty ? s.html[0].style.removeProperty("overflow") :s.html[0].style.removeAttribute("overflow"),
            s.html.removeAttr("layer-full"));
    }, e.layer = r, r.getChildFrame = function(e, t) {
        return t = t || i("." + s[4]).attr("times"), i("#" + s[0] + t).find("iframe").contents().find(e);
    }, r.getFrameIndex = function(e) {
        return i("#" + e).parents("." + s[4]).attr("times");
    }, r.iframeAuto = function(e) {
        if (e) {
            var t = r.getChildFrame("html", e).outerHeight(), n = i("#" + s[0] + e), a = n.find(s[1]).outerHeight() || 0, o = n.find("." + s[6]).outerHeight() || 0;
            n.css({
                height:t + a + o
            }), n.find("iframe").css({
                height:t
            });
        }
    }, r.iframeSrc = function(e, t) {
        i("#" + s[0] + e).find("iframe").attr("src", t);
    }, r.style = function(e, t) {
        var n = i("#" + s[0] + e), a = n.find(".layui-layer-content"), r = n.attr("type"), l = n.find(s[1]).outerHeight() || 0, f = n.find("." + s[6]).outerHeight() || 0;
        r !== o.type[3] && r !== o.type[4] && (parseFloat(t.width) <= 260 && (t.width = 260),
        parseFloat(t.height) - l - f <= 64 && (t.height = 64 + l + f), n.css(t), r === o.type[2] ? n.find("iframe").css({
            height:parseFloat(t.height) - l - f
        }) :a.css({
            height:parseFloat(t.height) - l - f - parseFloat(a.css("padding-top")) - parseFloat(a.css("padding-bottom"))
        }));
    }, r.min = function(e, t) {
        var a = i("#" + s[0] + e), l = a.find(s[1]).outerHeight() || 0, f = a.attr("minLeft") || 181 * o.minIndex + "px";
        o.record(a), o.minLeft[0] && (f = o.minLeft[0], o.minLeft.shift()), a.attr("position", a.css("position")),
            r.style(e, {
                width:180,
                height:l,
                left:f,
                top:n.height() - l,
                position:"fixed",
                overflow:"hidden"
            }), a.find(".layui-layer-min").hide(), "page" === a.attr("type") && a.find(s[4]).hide(),
            o.rescollbar(e), a.attr("minLeft") || o.minIndex++, a.attr("minLeft", f);
    }, r.restore = function(e) {
        var t = i("#" + s[0] + e), n = t.attr("area").split(",");
        t.attr("type");
        r.style(e, {
            width:parseFloat(n[0]),
            height:parseFloat(n[1]),
            top:parseFloat(n[2]),
            left:parseFloat(n[3]),
            position:t.attr("position"),
            overflow:"visible"
        }), t.find(".layui-layer-max").removeClass("layui-layer-maxmin"), t.find(".layui-layer-min").show(),
        "page" === t.attr("type") && t.find(s[4]).show(), o.rescollbar(e);
    }, r.full = function(e) {
        var t, a = i("#" + s[0] + e);
        o.record(a), s.html.attr("layer-full") || s.html.css("overflow", "hidden").attr("layer-full", e),
            clearTimeout(t), t = setTimeout(function() {
            var t = "fixed" === a.css("position");
            r.style(e, {
                top:t ? 0 :n.scrollTop(),
                left:t ? 0 :n.scrollLeft(),
                width:n.width(),
                height:n.height()
            }), a.find(".layui-layer-min").hide();
        }, 100);
    }, r.title = function(e, t) {
        var n = i("#" + s[0] + (t || r.index)).find(s[1]);
        n.html(e);
    }, r.close = function(e) {
        var t = i("#" + s[0] + e), n = t.attr("type"), a = "layer-anim-close";
        if (t[0]) {
            var l = function() {
                if (n === o.type[1] && "object" === t.attr("conType")) {
                    t.children(":not(." + s[5] + ")").remove();
                    for (var a = t.find(".layui-layer-wrap"), r = 0; r < 2; r++) a.unwrap();
                    a.css("display", a.data("display"));
                } else {
                    if (n === o.type[2]) try {
                        var l = i("#" + s[4] + e)[0];
                        l.contentWindow.document.write(""), l.contentWindow.close(), t.find("." + s[5])[0].removeChild(l);
                    } catch (f) {}
                    t[0].innerHTML = "", t.remove();
                }
            };
            t.addClass(a), i("#layui-layer-moves, #layui-layer-shade" + e).remove(), 6 == r.ie && o.reselect(),
                o.rescollbar(e), "function" == typeof o.end[e] && o.end[e](), delete o.end[e], t.attr("minLeft") && (o.minIndex--,
                o.minLeft.push(t.attr("minLeft"))), setTimeout(function() {
                l();
            }, r.ie && r.ie < 10 ? 0 :200);
        }
    }, r.closeAll = function(e) {
        i.each(i("." + s[0]), function() {
            var t = i(this), n = e ? t.attr("type") === e :1;
            n && r.close(t.attr("times")), n = null;
        });
    };
    var f = r.cache || {}, c = function(e) {
        return f.skin ? " " + f.skin + " " + f.skin + "-" + e :"";
    };
    r.prompt = function(e, t) {
        var a = "";
        if (e = e || {}, "function" == typeof e && (t = e), e.area) {
            var o = e.area;
            a = 'style="width: ' + o[0] + "; height: " + o[1] + ';"', delete e.area;
        }
        var l, s = 2 == e.formType ? '<textarea class="layui-layer-input"' + a + ">" + (e.value || "") + "</textarea>" :function() {
            return '<input type="' + (1 == e.formType ? "password" :"text") + '" class="layui-layer-input" value="' + (e.value || "") + '">';
        }();
        return r.open(i.extend({
            type:1,
            btn:[ "&#x786E;&#x5B9A;", "&#x53D6;&#x6D88;" ],
            content:s,
            skin:"layui-layer-prompt" + c("prompt"),
            maxWidth:n.width(),
            success:function(e) {
                l = e.find(".layui-layer-input"), l.focus();
            },
            resize:!1,
            yes:function(i) {
                var n = l.val();
                "" === n ? l.focus() :n.length > (e.maxlength || 500) ? r.tips("&#x6700;&#x591A;&#x8F93;&#x5165;" + (e.maxlength || 500) + "&#x4E2A;&#x5B57;&#x6570;", l, {
                    tips:1
                }) :t && t(n, i, l);
            }
        }, e));
    }, r.tab = function(e) {
        e = e || {};
        var t = e.tab || {};
        return r.open(i.extend({
            type:1,
            skin:"layui-layer-tab" + c("tab"),
            resize:!1,
            title:function() {
                var e = t.length, i = 1, n = "";
                if (e > 0) for (n = '<span class="layui-layer-tabnow">' + t[0].title + "</span>"; i < e; i++) n += "<span>" + t[i].title + "</span>";
                return n;
            }(),
            content:'<ul class="layui-layer-tabmain">' + function() {
                var e = t.length, i = 1, n = "";
                if (e > 0) for (n = '<li class="layui-layer-tabli xubox_tab_layer">' + (t[0].content || "no content") + "</li>"; i < e; i++) n += '<li class="layui-layer-tabli">' + (t[i].content || "no  content") + "</li>";
                return n;
            }() + "</ul>",
            success:function(t) {
                var n = t.find(".layui-layer-title").children(), a = t.find(".layui-layer-tabmain").children();
                n.on("mousedown", function(t) {
                    t.stopPropagation ? t.stopPropagation() :t.cancelBubble = !0;
                    var n = i(this), o = n.index();
                    n.addClass("layui-layer-tabnow").siblings().removeClass("layui-layer-tabnow"), a.eq(o).show().siblings().hide(),
                    "function" == typeof e.change && e.change(o);
                });
            }
        }, e));
    }, r.photos = function(t, n, a) {
        function o(e, t, i) {
            var n = new Image();
            return n.src = e, n.complete ? t(n) :(n.onload = function() {
                n.onload = null, t(n);
            }, void (n.onerror = function(e) {
                n.onerror = null, i(e);
            }));
        }
        var l = {};
        if (t = t || {}, t.photos) {
            var s = t.photos.constructor === Object, f = s ? t.photos :{}, d = f.data || [], u = f.start || 0;
            if (l.imgIndex = (0 | u) + 1, t.img = t.img || "img", s) {
                if (0 === d.length) return r.msg("&#x6CA1;&#x6709;&#x56FE;&#x7247;");
            } else {
                var y = i(t.photos), p = function() {
                    d = [], y.find(t.img).each(function(e) {
                        var t = i(this);
                        t.attr("layer-index", e), d.push({
                            alt:t.attr("alt"),
                            pid:t.attr("layer-pid"),
                            src:t.attr("layer-src") || t.attr("src"),
                            thumb:t.attr("src")
                        });
                    });
                };
                if (p(), 0 === d.length) return;
                if (n || y.on("click", t.img, function() {
                        var e = i(this), n = e.attr("layer-index");
                        r.photos(i.extend(t, {
                            photos:{
                                start:n,
                                data:d,
                                tab:t.tab
                            },
                            full:t.full
                        }), !0), p();
                    }), !n) return;
            }
            l.imgprev = function(e) {
                l.imgIndex--, l.imgIndex < 1 && (l.imgIndex = d.length), l.tabimg(e);
            }, l.imgnext = function(e, t) {
                l.imgIndex++, l.imgIndex > d.length && (l.imgIndex = 1, t) || l.tabimg(e);
            }, l.keyup = function(e) {
                if (!l.end) {
                    var t = e.keyCode;
                    e.preventDefault(), 37 === t ? l.imgprev(!0) :39 === t ? l.imgnext(!0) :27 === t && r.close(l.index);
                }
            }, l.tabimg = function(e) {
                d.length <= 1 || (f.start = l.imgIndex - 1, r.close(l.index), r.photos(t, !0, e));
            }, l.event = function() {
                l.bigimg.hover(function() {
                    l.imgsee.show();
                }, function() {
                    l.imgsee.hide();
                }), l.bigimg.find(".layui-layer-imgprev").on("click", function(e) {
                    e.preventDefault(), l.imgprev();
                }), l.bigimg.find(".layui-layer-imgnext").on("click", function(e) {
                    e.preventDefault(), l.imgnext();
                }), i(document).on("keyup", l.keyup);
            }, l.loadi = r.load(1, {
                shade:!("shade" in t) && .9,
                scrollbar:!1
            }), o(d[u].src, function(n) {
                r.close(l.loadi), l.index = r.open(i.extend({
                    type:1,
                    area:function() {
                        var a = [ n.width, n.height ], o = [ i(e).width() - 50, i(e).height() - 50 ];
                        return !t.full && a[0] > o[0] && (a[0] = o[0], a[1] = a[0] * n.height / n.width),
                            [ a[0] + "px", a[1] + "px" ];
                    }(),
                    title:!1,
                    shade:.9,
                    shadeClose:!0,
                    closeBtn:!1,
                    move:".layui-layer-phimg img",
                    moveType:1,
                    scrollbar:!1,
                    moveOut:!0,
                    anim:5 * Math.random() | 0,
                    skin:"layui-layer-photos" + c("photos"),
                    content:'<div class="layui-layer-phimg"><img src="' + d[u].src + '" alt="' + (d[u].alt || "") + '" layer-pid="' + d[u].pid + '"><div class="layui-layer-imgsee">' + (d.length > 1 ? '<span class="layui-layer-imguide"><a href="javascript:;" class="layui-layer-iconext layui-layer-imgprev"></a><a href="javascript:;" class="layui-layer-iconext layui-layer-imgnext"></a></span>' :"") + '<div class="layui-layer-imgbar" style="display:' + (a ? "block" :"") + '"><span class="layui-layer-imgtit"><a href="javascript:;">' + (d[u].alt || "") + "</a><em>" + l.imgIndex + "/" + d.length + "</em></span></div></div></div>",
                    success:function(e, i) {
                        l.bigimg = e.find(".layui-layer-phimg"), l.imgsee = e.find(".layui-layer-imguide,.layui-layer-imgbar"),
                            l.event(e), t.tab && t.tab(d[u], e);
                    },
                    end:function() {
                        l.end = !0, i(document).off("keyup", l.keyup);
                    }
                }, t));
            }, function() {
                r.close(l.loadi), r.msg("&#x5F53;&#x524D;&#x56FE;&#x7247;&#x5730;&#x5740;&#x5F02;&#x5E38;<br>&#x662F;&#x5426;&#x7EE7;&#x7EED;&#x67E5;&#x770B;&#x4E0B;&#x4E00;&#x5F20;&#xFF1F;", {
                    time:3e4,
                    btn:[ "&#x4E0B;&#x4E00;&#x5F20;", "&#x4E0D;&#x770B;&#x4E86;" ],
                    yes:function() {
                        d.length > 1 && l.imgnext(!0, !0);
                    }
                });
            });
        }
    }, o.run = function(t) {
        i = t, n = i(e), s.html = i("html"), r.open = function(e) {
            var t = new l(e);
            return t.index;
        };
    }, e.layui && layui.define ? (r.ready(), layui.define("jquery", function(t) {
        r.path = layui.cache.dir, o.run(layui.jquery), e.layer = r, t("layer", r);
    })) :"function" == typeof define ? define("jquery", function() {
        return o.run(e.jQuery), r;
    }) :function() {
        o.run(e.jQuery), r.ready();
    }();
}(window);
//全屏API
(function(){
    var fullScreenApi = {
            supportsFullScreen: false,
            isFullScreen: function(){ return false;},
            requestFullScreen: function(){},
            cancelFullScreen: function(){},
            fullScreenEventName: '',
            prefix: ''
        },
        browserPrefixes = 'webkit moz o ms khtml'.split(' ');
    // check for native support
    if (typeof document.cancelFullScreen != 'undefined') {
        fullScreenApi.supportsFullScreen = true;
    } else {
        // check for fullscreen support by vendor prefix
        for (var i = 0, il = browserPrefixes.length; i < il; i++ ) {
            fullScreenApi.prefix = browserPrefixes[i];
            if (typeof document[fullScreenApi.prefix + 'CancelFullScreen' ] != 'undefined' ) {
                fullScreenApi.supportsFullScreen = true;
                break;
            }
        }
    }
    // update methods to do something useful
    if (fullScreenApi.supportsFullScreen) {
        fullScreenApi.fullScreenEventName = fullScreenApi.prefix + 'fullscreenchange';
        fullScreenApi.isFullScreen = function() {
            switch (this.prefix) {
                case '':
                    return document.fullScreen;
                case 'webkit':
                    return document.webkitIsFullScreen;
                default:
                    return document[this.prefix + 'FullScreen'];
            }
        }
        fullScreenApi.requestFullScreen = function(el) {
            return (this.prefix === '') ? el.requestFullScreen() : el[this.prefix + 'RequestFullScreen']();
        }
        fullScreenApi.cancelFullScreen = function(el) {
            return (this.prefix === '') ? document.cancelFullScreen() : document[this.prefix + 'CancelFullScreen']();
        }
    }
    // jQuery plugin
    if (typeof jQuery != 'undefined') {
        jQuery.fn.requestFullScreen = function() {
            return this.each(function() {
                if (fullScreenApi.supportsFullScreen) {
                    fullScreenApi.requestFullScreen(this);
                }
            });
        };
    }
    window.fullScreenApi = fullScreenApi;
})();
(function() {
    $.fn.weixinAudio = function(options) {
        var $this = $(this);
        var defaultoptions = {
            autoplay:false,
            src:'',
        };
        function Plugin($context) {
            //dom
            this.$context = $context;
            this.$Audio = $context.children('#media');
            this.Audio = this.$Audio[0];
            this.$audio_area = $context.find('#audio_area');
            this.$audio_length = $context.find('#audio_length');
            this.$audio_progress = $context.find('#audio_progress');
            //属性
            this.currentState = 'pause';
            this.time = null;
            this.settings = $.extend(true, defaultoptions, options);
            //执行初始化
            this.init();
        }
        Plugin.prototype = {
            init: function() {
                var self = this;
                self.updateTotalTime();
                self.events();
                // 设置src
                if(self.settings.src !== ''){
                    self.changeSrc(self.settings.src);
                }
                // 设置自动播放
                if(self.settings.autoplay){
                    self.play();
                }
            },
            play: function() {
                var self = this;
                if (self.currentState === "play") {
                    self.pause();
                    return;
                }
                self.Audio.play();
                clearInterval(self.timer);
                self.timer = setInterval(self.run.bind(self), 50);
                self.currentState = "play";
                self.$audio_area.addClass('playing');
            },
            pause: function() {
                var self = this;
                self.Audio.pause();
                self.currentState = "pause";
                clearInterval(self.timer);
                self.$audio_area.removeClass('playing');
            },
            stop:function(){

            },
            events: function() {
                var self = this;
                var updateTime;
                self.$audio_area.on('click', function() {
                    self.play();
                    if (!updateTime) {
                        self.updateTotalTime();
                        updateTime = true;
                    }
                });
            },
            //正在播放
            run: function() {
                var self = this;
                self.animateProgressBarPosition();
                if (self.Audio.ended) {
                    self.pause();
                }
            },
            //进度条
            animateProgressBarPosition: function() {
                var self = this,
                    percentage = (self.Audio.currentTime * 100 / self.Audio.duration) + '%';
                if (percentage == "NaN%") {
                    percentage = 0 + '%';
                }
                var styles = {
                    "width": percentage
                };
                self.$audio_progress.css(styles);
            },
            //获取时间秒
            getAudioSeconds: function(string) {
                var self = this,
                    string = string % 60;
                string = self.addZero(Math.floor(string), 2);
                (string < 60) ? string = string: string = "00";
                return string;
            },
            //获取时间分
            getAudioMinutes: function(string) {
                var self = this,
                    string = string / 60;
                string = self.addZero(Math.floor(string), 2);
                (string < 60) ? string = string: string = "00";
                return string;
            },
            //时间+0
            addZero: function(word, howManyZero) {
                var word = String(word);
                while (word.length < howManyZero) word = "0" + word;
                return word;
            },
            //更新总时间
            updateTotalTime: function() {
                var self = this,
                    time = self.Audio.duration,
                    minutes = self.getAudioMinutes(time),
                    seconds = self.getAudioSeconds(time),
                    audioTime = minutes + ":" + seconds;
                self.$audio_length.text(audioTime);
            },
            //改变音频源
            changeSrc:function(src,callback){
                var self = this;
                self.pause();
                self.Audio.src = src;
                self.play();
                callback();
            },
        };
        var obj = {}
        // var instantiate = function() {
        // 	 new Plugin($(this));
        // }
        $this.each(function(index,element){
            obj['weixinAudio'+index] = new Plugin($(this));
        }); //多个执行返回对象
        return obj
    }
})();
//中键滚动
(function () {

    var toFix  = ['wheel', 'mousewheel', 'DOMMouseScroll', 'MozMousePixelScroll'],
        toBind = ( 'onwheel' in document || document.documentMode >= 9 ) ?
            ['wheel'] : ['mousewheel', 'DomMouseScroll', 'MozMousePixelScroll'],
        slice  = Array.prototype.slice,
        nullLowestDeltaTimeout, lowestDelta;

    if ( $.event.fixHooks ) {
        for ( var i = toFix.length; i; ) {
            $.event.fixHooks[ toFix[--i] ] = $.event.mouseHooks;
        }
    }

    var special = $.event.special.mousewheel = {
        version: '3.1.9',

        setup: function() {
            if ( this.addEventListener ) {
                for ( var i = toBind.length; i; ) {
                    this.addEventListener( toBind[--i], handler, false );
                }
            } else {
                this.onmousewheel = handler;
            }
            // Store the line height and page height for this particular element
            $.data(this, 'mousewheel-line-height', special.getLineHeight(this));
            $.data(this, 'mousewheel-page-height', special.getPageHeight(this));
        },

        teardown: function() {
            if ( this.removeEventListener ) {
                for ( var i = toBind.length; i; ) {
                    this.removeEventListener( toBind[--i], handler, false );
                }
            } else {
                this.onmousewheel = null;
            }
        },

        getLineHeight: function(elem) {
            return parseInt($(elem)['offsetParent' in $.fn ? 'offsetParent' : 'parent']().css('fontSize'), 10);
        },

        getPageHeight: function(elem) {
            return $(elem).height();
        },

        settings: {
            adjustOldDeltas: true
        }
    };

    $.fn.extend({
        mousewheel: function(fn) {
            return fn ? this.bind('mousewheel', fn) : this.trigger('mousewheel');
        },

        unmousewheel: function(fn) {
            return this.unbind('mousewheel', fn);
        }
    });


    function handler(event) {
        var orgEvent   = event || window.event,
            args       = slice.call(arguments, 1),
            delta      = 0,
            deltaX     = 0,
            deltaY     = 0,
            absDelta   = 0;
        event = $.event.fix(orgEvent);
        event.type = 'mousewheel';

        // Old school scrollwheel delta
        if ( 'detail'      in orgEvent ) { deltaY = orgEvent.detail * -1;      }
        if ( 'wheelDelta'  in orgEvent ) { deltaY = orgEvent.wheelDelta;       }
        if ( 'wheelDeltaY' in orgEvent ) { deltaY = orgEvent.wheelDeltaY;      }
        if ( 'wheelDeltaX' in orgEvent ) { deltaX = orgEvent.wheelDeltaX * -1; }

        // Firefox < 17 horizontal scrolling related to DOMMouseScroll event
        if ( 'axis' in orgEvent && orgEvent.axis === orgEvent.HORIZONTAL_AXIS ) {
            deltaX = deltaY * -1;
            deltaY = 0;
        }

        // Set delta to be deltaY or deltaX if deltaY is 0 for backwards compatabilitiy
        delta = deltaY === 0 ? deltaX : deltaY;

        // New school wheel delta (wheel event)
        if ( 'deltaY' in orgEvent ) {
            deltaY = orgEvent.deltaY * -1;
            delta  = deltaY;
        }
        if ( 'deltaX' in orgEvent ) {
            deltaX = orgEvent.deltaX;
            if ( deltaY === 0 ) { delta  = deltaX * -1; }
        }

        // No change actually happened, no reason to go any further
        if ( deltaY === 0 && deltaX === 0 ) { return; }

        // Need to convert lines and pages to pixels if we aren't already in pixels
        // There are three delta modes:
        //   * deltaMode 0 is by pixels, nothing to do
        //   * deltaMode 1 is by lines
        //   * deltaMode 2 is by pages
        if ( orgEvent.deltaMode === 1 ) {
            var lineHeight = $.data(this, 'mousewheel-line-height');
            delta  *= lineHeight;
            deltaY *= lineHeight;
            deltaX *= lineHeight;
        } else if ( orgEvent.deltaMode === 2 ) {
            var pageHeight = $.data(this, 'mousewheel-page-height');
            delta  *= pageHeight;
            deltaY *= pageHeight;
            deltaX *= pageHeight;
        }

        // Store lowest absolute delta to normalize the delta values
        absDelta = Math.max( Math.abs(deltaY), Math.abs(deltaX) );

        if ( !lowestDelta || absDelta < lowestDelta ) {
            lowestDelta = absDelta;

            // Adjust older deltas if necessary
            if ( shouldAdjustOldDeltas(orgEvent, absDelta) ) {
                lowestDelta /= 40;
            }
        }

        // Adjust older deltas if necessary
        if ( shouldAdjustOldDeltas(orgEvent, absDelta) ) {
            // Divide all the things by 40!
            delta  /= 40;
            deltaX /= 40;
            deltaY /= 40;
        }

        // Get a whole, normalized value for the deltas
        delta  = Math[ delta  >= 1 ? 'floor' : 'ceil' ](delta  / lowestDelta);
        deltaX = Math[ deltaX >= 1 ? 'floor' : 'ceil' ](deltaX / lowestDelta);
        deltaY = Math[ deltaY >= 1 ? 'floor' : 'ceil' ](deltaY / lowestDelta);

        // Add information to the event object
        event.deltaX = deltaX;
        event.deltaY = deltaY;
        event.deltaFactor = lowestDelta;
        // Go ahead and set deltaMode to 0 since we converted to pixels
        // Although this is a little odd since we overwrite the deltaX/Y
        // properties with normalized deltas.
        event.deltaMode = 0;

        // Add event and delta to the front of the arguments
        args.unshift(event, delta, deltaX, deltaY);

        // Clearout lowestDelta after sometime to better
        // handle multiple device types that give different
        // a different lowestDelta
        // Ex: trackpad = 3 and mouse wheel = 120
        if (nullLowestDeltaTimeout) { clearTimeout(nullLowestDeltaTimeout); }
        nullLowestDeltaTimeout = setTimeout(nullLowestDelta, 200);

        return ($.event.dispatch || $.event.handle).apply(this, args);
    }

    function nullLowestDelta() {
        lowestDelta = null;
    }

    function shouldAdjustOldDeltas(orgEvent, absDelta) {
        // If this is an older event and the delta is divisable by 120,
        // then we are assuming that the browser is treating this as an
        // older mouse wheel event and that we should divide the deltas
        // by 40 to try and get a more usable deltaFactor.
        // Side note, this actually impacts the reported scroll distance
        // in older browsers and can cause scrolling to be slower than native.
        // Turn this off by setting $.event.special.mousewheel.settings.adjustOldDeltas to false.
        return special.settings.adjustOldDeltas && orgEvent.type === 'mousewheel' && absDelta % 120 === 0;
    }

})();
;(function ($) {
    'use strict'

    /*
     * Add integers, wrapping at 2^32. This uses 16-bit operations internally
     * to work around bugs in some JS interpreters.
     */
    function safeAdd (x, y) {
        var lsw = (x & 0xFFFF) + (y & 0xFFFF)
        var msw = (x >> 16) + (y >> 16) + (lsw >> 16)
        return (msw << 16) | (lsw & 0xFFFF)
    }

    /*
     * Bitwise rotate a 32-bit number to the left.
     */
    function bitRotateLeft (num, cnt) {
        return (num << cnt) | (num >>> (32 - cnt))
    }

    /*
     * These functions implement the four basic operations the algorithm uses.
     */
    function md5cmn (q, a, b, x, s, t) {
        return safeAdd(bitRotateLeft(safeAdd(safeAdd(a, q), safeAdd(x, t)), s), b)
    }
    function md5ff (a, b, c, d, x, s, t) {
        return md5cmn((b & c) | ((~b) & d), a, b, x, s, t)
    }
    function md5gg (a, b, c, d, x, s, t) {
        return md5cmn((b & d) | (c & (~d)), a, b, x, s, t)
    }
    function md5hh (a, b, c, d, x, s, t) {
        return md5cmn(b ^ c ^ d, a, b, x, s, t)
    }
    function md5ii (a, b, c, d, x, s, t) {
        return md5cmn(c ^ (b | (~d)), a, b, x, s, t)
    }

    /*
     * Calculate the MD5 of an array of little-endian words, and a bit length.
     */
    function binlMD5 (x, len) {
        /* append padding */
        x[len >> 5] |= 0x80 << (len % 32)
        x[(((len + 64) >>> 9) << 4) + 14] = len

        var i
        var olda
        var oldb
        var oldc
        var oldd
        var a = 1732584193
        var b = -271733879
        var c = -1732584194
        var d = 271733878

        for (i = 0; i < x.length; i += 16) {
            olda = a
            oldb = b
            oldc = c
            oldd = d

            a = md5ff(a, b, c, d, x[i], 7, -680876936)
            d = md5ff(d, a, b, c, x[i + 1], 12, -389564586)
            c = md5ff(c, d, a, b, x[i + 2], 17, 606105819)
            b = md5ff(b, c, d, a, x[i + 3], 22, -1044525330)
            a = md5ff(a, b, c, d, x[i + 4], 7, -176418897)
            d = md5ff(d, a, b, c, x[i + 5], 12, 1200080426)
            c = md5ff(c, d, a, b, x[i + 6], 17, -1473231341)
            b = md5ff(b, c, d, a, x[i + 7], 22, -45705983)
            a = md5ff(a, b, c, d, x[i + 8], 7, 1770035416)
            d = md5ff(d, a, b, c, x[i + 9], 12, -1958414417)
            c = md5ff(c, d, a, b, x[i + 10], 17, -42063)
            b = md5ff(b, c, d, a, x[i + 11], 22, -1990404162)
            a = md5ff(a, b, c, d, x[i + 12], 7, 1804603682)
            d = md5ff(d, a, b, c, x[i + 13], 12, -40341101)
            c = md5ff(c, d, a, b, x[i + 14], 17, -1502002290)
            b = md5ff(b, c, d, a, x[i + 15], 22, 1236535329)

            a = md5gg(a, b, c, d, x[i + 1], 5, -165796510)
            d = md5gg(d, a, b, c, x[i + 6], 9, -1069501632)
            c = md5gg(c, d, a, b, x[i + 11], 14, 643717713)
            b = md5gg(b, c, d, a, x[i], 20, -373897302)
            a = md5gg(a, b, c, d, x[i + 5], 5, -701558691)
            d = md5gg(d, a, b, c, x[i + 10], 9, 38016083)
            c = md5gg(c, d, a, b, x[i + 15], 14, -660478335)
            b = md5gg(b, c, d, a, x[i + 4], 20, -405537848)
            a = md5gg(a, b, c, d, x[i + 9], 5, 568446438)
            d = md5gg(d, a, b, c, x[i + 14], 9, -1019803690)
            c = md5gg(c, d, a, b, x[i + 3], 14, -187363961)
            b = md5gg(b, c, d, a, x[i + 8], 20, 1163531501)
            a = md5gg(a, b, c, d, x[i + 13], 5, -1444681467)
            d = md5gg(d, a, b, c, x[i + 2], 9, -51403784)
            c = md5gg(c, d, a, b, x[i + 7], 14, 1735328473)
            b = md5gg(b, c, d, a, x[i + 12], 20, -1926607734)

            a = md5hh(a, b, c, d, x[i + 5], 4, -378558)
            d = md5hh(d, a, b, c, x[i + 8], 11, -2022574463)
            c = md5hh(c, d, a, b, x[i + 11], 16, 1839030562)
            b = md5hh(b, c, d, a, x[i + 14], 23, -35309556)
            a = md5hh(a, b, c, d, x[i + 1], 4, -1530992060)
            d = md5hh(d, a, b, c, x[i + 4], 11, 1272893353)
            c = md5hh(c, d, a, b, x[i + 7], 16, -155497632)
            b = md5hh(b, c, d, a, x[i + 10], 23, -1094730640)
            a = md5hh(a, b, c, d, x[i + 13], 4, 681279174)
            d = md5hh(d, a, b, c, x[i], 11, -358537222)
            c = md5hh(c, d, a, b, x[i + 3], 16, -722521979)
            b = md5hh(b, c, d, a, x[i + 6], 23, 76029189)
            a = md5hh(a, b, c, d, x[i + 9], 4, -640364487)
            d = md5hh(d, a, b, c, x[i + 12], 11, -421815835)
            c = md5hh(c, d, a, b, x[i + 15], 16, 530742520)
            b = md5hh(b, c, d, a, x[i + 2], 23, -995338651)

            a = md5ii(a, b, c, d, x[i], 6, -198630844)
            d = md5ii(d, a, b, c, x[i + 7], 10, 1126891415)
            c = md5ii(c, d, a, b, x[i + 14], 15, -1416354905)
            b = md5ii(b, c, d, a, x[i + 5], 21, -57434055)
            a = md5ii(a, b, c, d, x[i + 12], 6, 1700485571)
            d = md5ii(d, a, b, c, x[i + 3], 10, -1894986606)
            c = md5ii(c, d, a, b, x[i + 10], 15, -1051523)
            b = md5ii(b, c, d, a, x[i + 1], 21, -2054922799)
            a = md5ii(a, b, c, d, x[i + 8], 6, 1873313359)
            d = md5ii(d, a, b, c, x[i + 15], 10, -30611744)
            c = md5ii(c, d, a, b, x[i + 6], 15, -1560198380)
            b = md5ii(b, c, d, a, x[i + 13], 21, 1309151649)
            a = md5ii(a, b, c, d, x[i + 4], 6, -145523070)
            d = md5ii(d, a, b, c, x[i + 11], 10, -1120210379)
            c = md5ii(c, d, a, b, x[i + 2], 15, 718787259)
            b = md5ii(b, c, d, a, x[i + 9], 21, -343485551)

            a = safeAdd(a, olda)
            b = safeAdd(b, oldb)
            c = safeAdd(c, oldc)
            d = safeAdd(d, oldd)
        }
        return [a, b, c, d]
    }

    /*
     * Convert an array of little-endian words to a string
     */
    function binl2rstr (input) {
        var i
        var output = ''
        var length32 = input.length * 32
        for (i = 0; i < length32; i += 8) {
            output += String.fromCharCode((input[i >> 5] >>> (i % 32)) & 0xFF)
        }
        return output
    }

    /*
     * Convert a raw string to an array of little-endian words
     * Characters >255 have their high-byte silently ignored.
     */
    function rstr2binl (input) {
        var i
        var output = []
        output[(input.length >> 2) - 1] = undefined
        for (i = 0; i < output.length; i += 1) {
            output[i] = 0
        }
        var length8 = input.length * 8
        for (i = 0; i < length8; i += 8) {
            output[i >> 5] |= (input.charCodeAt(i / 8) & 0xFF) << (i % 32)
        }
        return output
    }

    /*
     * Calculate the MD5 of a raw string
     */
    function rstrMD5 (s) {
        return binl2rstr(binlMD5(rstr2binl(s), s.length * 8))
    }

    /*
     * Calculate the HMAC-MD5, of a key and some data (raw strings)
     */
    function rstrHMACMD5 (key, data) {
        var i
        var bkey = rstr2binl(key)
        var ipad = []
        var opad = []
        var hash
        ipad[15] = opad[15] = undefined
        if (bkey.length > 16) {
            bkey = binlMD5(bkey, key.length * 8)
        }
        for (i = 0; i < 16; i += 1) {
            ipad[i] = bkey[i] ^ 0x36363636
            opad[i] = bkey[i] ^ 0x5C5C5C5C
        }
        hash = binlMD5(ipad.concat(rstr2binl(data)), 512 + data.length * 8)
        return binl2rstr(binlMD5(opad.concat(hash), 512 + 128))
    }

    /*
     * Convert a raw string to a hex string
     */
    function rstr2hex (input) {
        var hexTab = '0123456789abcdef'
        var output = ''
        var x
        var i
        for (i = 0; i < input.length; i += 1) {
            x = input.charCodeAt(i)
            output += hexTab.charAt((x >>> 4) & 0x0F) +
                hexTab.charAt(x & 0x0F)
        }
        return output
    }

    /*
     * Encode a string as utf-8
     */
    function str2rstrUTF8 (input) {
        return unescape(encodeURIComponent(input))
    }

    /*
     * Take string arguments and return either raw or hex encoded strings
     */
    function rawMD5 (s) {
        return rstrMD5(str2rstrUTF8(s))
    }
    function hexMD5 (s) {
        return rstr2hex(rawMD5(s))
    }
    function rawHMACMD5 (k, d) {
        return rstrHMACMD5(str2rstrUTF8(k), str2rstrUTF8(d))
    }
    function hexHMACMD5 (k, d) {
        return rstr2hex(rawHMACMD5(k, d))
    }

    function md5 (string, key, raw) {
        if (!key) {
            if (!raw) {
                return hexMD5(string)
            }
            return rawMD5(string)
        }
        if (!raw) {
            return hexHMACMD5(key, string)
        }
        return rawHMACMD5(key, string)
    }

    if (typeof define === 'function' && define.amd) {
        define(function () {
            return md5
        })
    } else if (typeof module === 'object' && module.exports) {
        module.exports = md5
    } else {
        $.md5 = md5
    }
}(this));
//剪切板
(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.Clipboard = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
    var DOCUMENT_NODE_TYPE = 9;

    /**
     * A polyfill for Element.matches()
     */
    if (typeof Element !== 'undefined' && !Element.prototype.matches) {
        var proto = Element.prototype;

        proto.matches = proto.matchesSelector ||
            proto.mozMatchesSelector ||
            proto.msMatchesSelector ||
            proto.oMatchesSelector ||
            proto.webkitMatchesSelector;
    }

    /**
     * Finds the closest parent that matches a selector.
     *
     * @param {Element} element
     * @param {String} selector
     * @return {Function}
     */
    function closest (element, selector) {
        while (element && element.nodeType !== DOCUMENT_NODE_TYPE) {
            if (typeof element.matches === 'function' &&
                element.matches(selector)) {
                return element;
            }
            element = element.parentNode;
        }
    }

    module.exports = closest;

},{}],2:[function(require,module,exports){
    var closest = require('./closest');

    /**
     * Delegates event to a selector.
     *
     * @param {Element} element
     * @param {String} selector
     * @param {String} type
     * @param {Function} callback
     * @param {Boolean} useCapture
     * @return {Object}
     */
    function delegate(element, selector, type, callback, useCapture) {
        var listenerFn = listener.apply(this, arguments);

        element.addEventListener(type, listenerFn, useCapture);

        return {
            destroy: function() {
                element.removeEventListener(type, listenerFn, useCapture);
            }
        }
    }

    /**
     * Finds closest match and invokes callback.
     *
     * @param {Element} element
     * @param {String} selector
     * @param {String} type
     * @param {Function} callback
     * @return {Function}
     */
    function listener(element, selector, type, callback) {
        return function(e) {
            e.delegateTarget = closest(e.target, selector);

            if (e.delegateTarget) {
                callback.call(element, e);
            }
        }
    }

    module.exports = delegate;

},{"./closest":1}],3:[function(require,module,exports){
    /**
     * Check if argument is a HTML element.
     *
     * @param {Object} value
     * @return {Boolean}
     */
    exports.node = function(value) {
        return value !== undefined
            && value instanceof HTMLElement
            && value.nodeType === 1;
    };

    /**
     * Check if argument is a list of HTML elements.
     *
     * @param {Object} value
     * @return {Boolean}
     */
    exports.nodeList = function(value) {
        var type = Object.prototype.toString.call(value);

        return value !== undefined
            && (type === '[object NodeList]' || type === '[object HTMLCollection]')
            && ('length' in value)
            && (value.length === 0 || exports.node(value[0]));
    };

    /**
     * Check if argument is a string.
     *
     * @param {Object} value
     * @return {Boolean}
     */
    exports.string = function(value) {
        return typeof value === 'string'
            || value instanceof String;
    };

    /**
     * Check if argument is a function.
     *
     * @param {Object} value
     * @return {Boolean}
     */
    exports.fn = function(value) {
        var type = Object.prototype.toString.call(value);

        return type === '[object Function]';
    };

},{}],4:[function(require,module,exports){
    var is = require('./is');
    var delegate = require('delegate');

    /**
     * Validates all params and calls the right
     * listener function based on its target type.
     *
     * @param {String|HTMLElement|HTMLCollection|NodeList} target
     * @param {String} type
     * @param {Function} callback
     * @return {Object}
     */
    function listen(target, type, callback) {
        if (!target && !type && !callback) {
            throw new Error('Missing required arguments');
        }

        if (!is.string(type)) {
            throw new TypeError('Second argument must be a String');
        }

        if (!is.fn(callback)) {
            throw new TypeError('Third argument must be a Function');
        }

        if (is.node(target)) {
            return listenNode(target, type, callback);
        }
        else if (is.nodeList(target)) {
            return listenNodeList(target, type, callback);
        }
        else if (is.string(target)) {
            return listenSelector(target, type, callback);
        }
        else {
            throw new TypeError('First argument must be a String, HTMLElement, HTMLCollection, or NodeList');
        }
    }

    /**
     * Adds an event listener to a HTML element
     * and returns a remove listener function.
     *
     * @param {HTMLElement} node
     * @param {String} type
     * @param {Function} callback
     * @return {Object}
     */
    function listenNode(node, type, callback) {
        node.addEventListener(type, callback);

        return {
            destroy: function() {
                node.removeEventListener(type, callback);
            }
        }
    }

    /**
     * Add an event listener to a list of HTML elements
     * and returns a remove listener function.
     *
     * @param {NodeList|HTMLCollection} nodeList
     * @param {String} type
     * @param {Function} callback
     * @return {Object}
     */
    function listenNodeList(nodeList, type, callback) {
        Array.prototype.forEach.call(nodeList, function(node) {
            node.addEventListener(type, callback);
        });

        return {
            destroy: function() {
                Array.prototype.forEach.call(nodeList, function(node) {
                    node.removeEventListener(type, callback);
                });
            }
        }
    }

    /**
     * Add an event listener to a selector
     * and returns a remove listener function.
     *
     * @param {String} selector
     * @param {String} type
     * @param {Function} callback
     * @return {Object}
     */
    function listenSelector(selector, type, callback) {
        return delegate(document.body, selector, type, callback);
    }

    module.exports = listen;

},{"./is":3,"delegate":2}],5:[function(require,module,exports){
    function select(element) {
        var selectedText;

        if (element.nodeName === 'SELECT') {
            element.focus();

            selectedText = element.value;
        }
        else if (element.nodeName === 'INPUT' || element.nodeName === 'TEXTAREA') {
            var isReadOnly = element.hasAttribute('readonly');

            if (!isReadOnly) {
                element.setAttribute('readonly', '');
            }

            element.select();
            element.setSelectionRange(0, element.value.length);

            if (!isReadOnly) {
                element.removeAttribute('readonly');
            }

            selectedText = element.value;
        }
        else {
            if (element.hasAttribute('contenteditable')) {
                element.focus();
            }

            var selection = window.getSelection();
            var range = document.createRange();

            range.selectNodeContents(element);
            selection.removeAllRanges();
            selection.addRange(range);

            selectedText = selection.toString();
        }

        return selectedText;
    }

    module.exports = select;

},{}],6:[function(require,module,exports){
    function E () {
        // Keep this empty so it's easier to inherit from
        // (via https://github.com/lipsmack from https://github.com/scottcorgan/tiny-emitter/issues/3)
    }

    E.prototype = {
        on: function (name, callback, ctx) {
            var e = this.e || (this.e = {});

            (e[name] || (e[name] = [])).push({
                fn: callback,
                ctx: ctx
            });

            return this;
        },

        once: function (name, callback, ctx) {
            var self = this;
            function listener () {
                self.off(name, listener);
                callback.apply(ctx, arguments);
            };

            listener._ = callback
            return this.on(name, listener, ctx);
        },

        emit: function (name) {
            var data = [].slice.call(arguments, 1);
            var evtArr = ((this.e || (this.e = {}))[name] || []).slice();
            var i = 0;
            var len = evtArr.length;

            for (i; i < len; i++) {
                evtArr[i].fn.apply(evtArr[i].ctx, data);
            }

            return this;
        },

        off: function (name, callback) {
            var e = this.e || (this.e = {});
            var evts = e[name];
            var liveEvents = [];

            if (evts && callback) {
                for (var i = 0, len = evts.length; i < len; i++) {
                    if (evts[i].fn !== callback && evts[i].fn._ !== callback)
                        liveEvents.push(evts[i]);
                }
            }

            // Remove event from queue to prevent memory leak
            // Suggested by https://github.com/lazd
            // Ref: https://github.com/scottcorgan/tiny-emitter/commit/c6ebfaa9bc973b33d110a84a307742b7cf94c953#commitcomment-5024910

            (liveEvents.length)
                ? e[name] = liveEvents
                : delete e[name];

            return this;
        }
    };

    module.exports = E;

},{}],7:[function(require,module,exports){
    (function (global, factory) {
        if (typeof define === "function" && define.amd) {
            define(['module', 'select'], factory);
        } else if (typeof exports !== "undefined") {
            factory(module, require('select'));
        } else {
            var mod = {
                exports: {}
            };
            factory(mod, global.select);
            global.clipboardAction = mod.exports;
        }
    })(this, function (module, _select) {
        'use strict';

        var _select2 = _interopRequireDefault(_select);

        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }

        var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
            return typeof obj;
        } : function (obj) {
            return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
        };

        function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
            }
        }

        var _createClass = function () {
            function defineProperties(target, props) {
                for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || false;
                    descriptor.configurable = true;
                    if ("value" in descriptor) descriptor.writable = true;
                    Object.defineProperty(target, descriptor.key, descriptor);
                }
            }

            return function (Constructor, protoProps, staticProps) {
                if (protoProps) defineProperties(Constructor.prototype, protoProps);
                if (staticProps) defineProperties(Constructor, staticProps);
                return Constructor;
            };
        }();

        var ClipboardAction = function () {
            /**
             * @param {Object} options
             */
            function ClipboardAction(options) {
                _classCallCheck(this, ClipboardAction);

                this.resolveOptions(options);
                this.initSelection();
            }

            /**
             * Defines base properties passed from constructor.
             * @param {Object} options
             */


            _createClass(ClipboardAction, [{
                key: 'resolveOptions',
                value: function resolveOptions() {
                    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

                    this.action = options.action;
                    this.container = options.container;
                    this.emitter = options.emitter;
                    this.target = options.target;
                    this.text = options.text;
                    this.trigger = options.trigger;

                    this.selectedText = '';
                }
            }, {
                key: 'initSelection',
                value: function initSelection() {
                    if (this.text) {
                        this.selectFake();
                    } else if (this.target) {
                        this.selectTarget();
                    }
                }
            }, {
                key: 'selectFake',
                value: function selectFake() {
                    var _this = this;

                    var isRTL = document.documentElement.getAttribute('dir') == 'rtl';

                    this.removeFake();

                    this.fakeHandlerCallback = function () {
                        return _this.removeFake();
                    };
                    this.fakeHandler = this.container.addEventListener('click', this.fakeHandlerCallback) || true;

                    this.fakeElem = document.createElement('textarea');
                    // Prevent zooming on iOS
                    this.fakeElem.style.fontSize = '12pt';
                    // Reset box model
                    this.fakeElem.style.border = '0';
                    this.fakeElem.style.padding = '0';
                    this.fakeElem.style.margin = '0';
                    // Move element out of screen horizontally
                    this.fakeElem.style.position = 'absolute';
                    this.fakeElem.style[isRTL ? 'right' : 'left'] = '-9999px';
                    // Move element to the same position vertically
                    var yPosition = window.pageYOffset || document.documentElement.scrollTop;
                    this.fakeElem.style.top = yPosition + 'px';

                    this.fakeElem.setAttribute('readonly', '');
                    this.fakeElem.value = this.text;

                    this.container.appendChild(this.fakeElem);

                    this.selectedText = (0, _select2.default)(this.fakeElem);
                    this.copyText();
                }
            }, {
                key: 'removeFake',
                value: function removeFake() {
                    if (this.fakeHandler) {
                        this.container.removeEventListener('click', this.fakeHandlerCallback);
                        this.fakeHandler = null;
                        this.fakeHandlerCallback = null;
                    }

                    if (this.fakeElem) {
                        this.container.removeChild(this.fakeElem);
                        this.fakeElem = null;
                    }
                }
            }, {
                key: 'selectTarget',
                value: function selectTarget() {
                    this.selectedText = (0, _select2.default)(this.target);
                    this.copyText();
                }
            }, {
                key: 'copyText',
                value: function copyText() {
                    var succeeded = void 0;

                    try {
                        succeeded = document.execCommand(this.action);
                    } catch (err) {
                        succeeded = false;
                    }

                    this.handleResult(succeeded);
                }
            }, {
                key: 'handleResult',
                value: function handleResult(succeeded) {
                    this.emitter.emit(succeeded ? 'success' : 'error', {
                        action: this.action,
                        text: this.selectedText,
                        trigger: this.trigger,
                        clearSelection: this.clearSelection.bind(this)
                    });
                }
            }, {
                key: 'clearSelection',
                value: function clearSelection() {
                    if (this.trigger) {
                        this.trigger.focus();
                    }

                    window.getSelection().removeAllRanges();
                }
            }, {
                key: 'destroy',
                value: function destroy() {
                    this.removeFake();
                }
            }, {
                key: 'action',
                set: function set() {
                    var action = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'copy';

                    this._action = action;

                    if (this._action !== 'copy' && this._action !== 'cut') {
                        throw new Error('Invalid "action" value, use either "copy" or "cut"');
                    }
                },
                get: function get() {
                    return this._action;
                }
            }, {
                key: 'target',
                set: function set(target) {
                    if (target !== undefined) {
                        if (target && (typeof target === 'undefined' ? 'undefined' : _typeof(target)) === 'object' && target.nodeType === 1) {
                            if (this.action === 'copy' && target.hasAttribute('disabled')) {
                                throw new Error('Invalid "target" attribute. Please use "readonly" instead of "disabled" attribute');
                            }

                            if (this.action === 'cut' && (target.hasAttribute('readonly') || target.hasAttribute('disabled'))) {
                                throw new Error('Invalid "target" attribute. You can\'t cut text from elements with "readonly" or "disabled" attributes');
                            }

                            this._target = target;
                        } else {
                            throw new Error('Invalid "target" value, use a valid Element');
                        }
                    }
                },
                get: function get() {
                    return this._target;
                }
            }]);

            return ClipboardAction;
        }();

        module.exports = ClipboardAction;
    });

},{"select":5}],8:[function(require,module,exports){
    (function (global, factory) {
        if (typeof define === "function" && define.amd) {
            define(['module', './clipboard-action', 'tiny-emitter', 'good-listener'], factory);
        } else if (typeof exports !== "undefined") {
            factory(module, require('./clipboard-action'), require('tiny-emitter'), require('good-listener'));
        } else {
            var mod = {
                exports: {}
            };
            factory(mod, global.clipboardAction, global.tinyEmitter, global.goodListener);
            global.clipboard = mod.exports;
        }
    })(this, function (module, _clipboardAction, _tinyEmitter, _goodListener) {
        'use strict';

        var _clipboardAction2 = _interopRequireDefault(_clipboardAction);

        var _tinyEmitter2 = _interopRequireDefault(_tinyEmitter);

        var _goodListener2 = _interopRequireDefault(_goodListener);

        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }

        var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
            return typeof obj;
        } : function (obj) {
            return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
        };

        function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
            }
        }

        var _createClass = function () {
            function defineProperties(target, props) {
                for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || false;
                    descriptor.configurable = true;
                    if ("value" in descriptor) descriptor.writable = true;
                    Object.defineProperty(target, descriptor.key, descriptor);
                }
            }

            return function (Constructor, protoProps, staticProps) {
                if (protoProps) defineProperties(Constructor.prototype, protoProps);
                if (staticProps) defineProperties(Constructor, staticProps);
                return Constructor;
            };
        }();

        function _possibleConstructorReturn(self, call) {
            if (!self) {
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }

            return call && (typeof call === "object" || typeof call === "function") ? call : self;
        }

        function _inherits(subClass, superClass) {
            if (typeof superClass !== "function" && superClass !== null) {
                throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
            }

            subClass.prototype = Object.create(superClass && superClass.prototype, {
                constructor: {
                    value: subClass,
                    enumerable: false,
                    writable: true,
                    configurable: true
                }
            });
            if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
        }

        var Clipboard = function (_Emitter) {
            _inherits(Clipboard, _Emitter);

            /**
             * @param {String|HTMLElement|HTMLCollection|NodeList} trigger
             * @param {Object} options
             */
            function Clipboard(trigger, options) {
                _classCallCheck(this, Clipboard);

                var _this = _possibleConstructorReturn(this, (Clipboard.__proto__ || Object.getPrototypeOf(Clipboard)).call(this));

                _this.resolveOptions(options);
                _this.listenClick(trigger);
                return _this;
            }

            /**
             * Defines if attributes would be resolved using internal setter functions
             * or custom functions that were passed in the constructor.
             * @param {Object} options
             */


            _createClass(Clipboard, [{
                key: 'resolveOptions',
                value: function resolveOptions() {
                    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

                    this.action = typeof options.action === 'function' ? options.action : this.defaultAction;
                    this.target = typeof options.target === 'function' ? options.target : this.defaultTarget;
                    this.text = typeof options.text === 'function' ? options.text : this.defaultText;
                    this.container = _typeof(options.container) === 'object' ? options.container : document.body;
                }
            }, {
                key: 'listenClick',
                value: function listenClick(trigger) {
                    var _this2 = this;

                    this.listener = (0, _goodListener2.default)(trigger, 'click', function (e) {
                        return _this2.onClick(e);
                    });
                }
            }, {
                key: 'onClick',
                value: function onClick(e) {
                    var trigger = e.delegateTarget || e.currentTarget;

                    if (this.clipboardAction) {
                        this.clipboardAction = null;
                    }

                    this.clipboardAction = new _clipboardAction2.default({
                        action: this.action(trigger),
                        target: this.target(trigger),
                        text: this.text(trigger),
                        container: this.container,
                        trigger: trigger,
                        emitter: this
                    });
                }
            }, {
                key: 'defaultAction',
                value: function defaultAction(trigger) {
                    return getAttributeValue('action', trigger);
                }
            }, {
                key: 'defaultTarget',
                value: function defaultTarget(trigger) {
                    var selector = getAttributeValue('target', trigger);

                    if (selector) {
                        return document.querySelector(selector);
                    }
                }
            }, {
                key: 'defaultText',
                value: function defaultText(trigger) {
                    return getAttributeValue('text', trigger);
                }
            }, {
                key: 'destroy',
                value: function destroy() {
                    this.listener.destroy();

                    if (this.clipboardAction) {
                        this.clipboardAction.destroy();
                        this.clipboardAction = null;
                    }
                }
            }], [{
                key: 'isSupported',
                value: function isSupported() {
                    var action = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : ['copy', 'cut'];

                    var actions = typeof action === 'string' ? [action] : action;
                    var support = !!document.queryCommandSupported;

                    actions.forEach(function (action) {
                        support = support && !!document.queryCommandSupported(action);
                    });

                    return support;
                }
            }]);

            return Clipboard;
        }(_tinyEmitter2.default);

        /**
         * Helper function to retrieve attribute value.
         * @param {String} suffix
         * @param {Element} element
         */
        function getAttributeValue(suffix, element) {
            var attribute = 'data-clipboard-' + suffix;

            if (!element.hasAttribute(attribute)) {
                return;
            }

            return element.getAttribute(attribute);
        }

        module.exports = Clipboard;
    });

},{"./clipboard-action":7,"good-listener":4,"tiny-emitter":6}]},{},[8])(8)
});
/*!
 * Nestable jQuery Plugin - Copyright (c) 2012 David Bushell - http://dbushell.com/
 * Dual-licensed under the BSD or MIT licenses
 */
;(function($, window, document, undefined)
{
    var hasTouch = 'ontouchstart' in document;

    /**
     * Detect CSS pointer-events property
     * events are normally disabled on the dragging element to avoid conflicts
     * https://github.com/ausi/Feature-detection-technique-for-pointer-events/blob/master/modernizr-pointerevents.js
     */
    var hasPointerEvents = (function()
    {
        var el    = document.createElement('div'),
            docEl = document.documentElement;
        if (!('pointerEvents' in el.style)) {
            return false;
        }
        el.style.pointerEvents = 'auto';
        el.style.pointerEvents = 'x';
        docEl.appendChild(el);
        var supports = window.getComputedStyle && window.getComputedStyle(el, '').pointerEvents === 'auto';
        docEl.removeChild(el);
        return !!supports;
    })();

    var defaults = {
        listNodeName    : 'ol',
        itemNodeName    : 'li',
        rootClass       : 'dd',
        listClass       : 'dd-list',
        itemClass       : 'dd-item',
        dragClass       : 'dd-dragel',
        handleClass     : 'dd-handle',
        collapsedClass  : 'dd-collapsed',
        placeClass      : 'dd-placeholder',
        noDragClass     : 'dd-nodrag',
        emptyClass      : 'dd-empty',
        expandBtnHTML   : '<button data-action="expand" type="button">Expand</button>',
        collapseBtnHTML : '<button data-action="collapse" type="button">Collapse</button>',
        group           : 0,
        maxDepth        : 5,
        threshold       : 20
    };

    function Plugin(element, options)
    {
        this.w  = $(document);
        this.el = $(element);
        this.options = $.extend({}, defaults, options);
        this.init();
    }

    Plugin.prototype = {

        init: function()
        {
            var list = this;

            list.reset();

            list.el.data('nestable-group', this.options.group);

            list.placeEl = $('<div class="' + list.options.placeClass + '"/>');

            $.each(this.el.find(list.options.itemNodeName), function(k, el) {
                list.setParent($(el));
            });

            list.el.on('click', 'button', function(e) {
                if (list.dragEl) {
                    return;
                }
                var target = $(e.currentTarget),
                    action = target.data('action'),
                    item   = target.parent(list.options.itemNodeName);
                if (action === 'collapse') {
                    list.collapseItem(item);
                }
                if (action === 'expand') {
                    list.expandItem(item);
                }
            });

            var onStartEvent = function(e)
            {
                var handle = $(e.target);
                if (!handle.hasClass(list.options.handleClass)) {
                    if (handle.closest('.' + list.options.noDragClass).length) {
                        return;
                    }
                    handle = handle.closest('.' + list.options.handleClass);
                }

                if (!handle.length || list.dragEl) {
                    return;
                }

                list.isTouch = /^touch/.test(e.type);
                if (list.isTouch && e.touches.length !== 1) {
                    return;
                }

                e.preventDefault();
                list.dragStart(e.touches ? e.touches[0] : e);
            };

            var onMoveEvent = function(e)
            {
                if (list.dragEl) {
                    e.preventDefault();
                    list.dragMove(e.touches ? e.touches[0] : e);
                }
            };

            var onEndEvent = function(e)
            {
                if (list.dragEl) {
                    e.preventDefault();
                    list.dragStop(e.touches ? e.touches[0] : e);
                }
            };

            if (hasTouch) {
                list.el[0].addEventListener('touchstart', onStartEvent, false);
                window.addEventListener('touchmove', onMoveEvent, false);
                window.addEventListener('touchend', onEndEvent, false);
                window.addEventListener('touchcancel', onEndEvent, false);
            }

            list.el.on('mousedown', onStartEvent);
            list.w.on('mousemove', onMoveEvent);
            list.w.on('mouseup', onEndEvent);

        },

        serialize: function()
        {
            var data,
                depth = 0,
                list  = this;
            step  = function(level, depth)
            {
                var array = [ ],
                    items = level.children(list.options.itemNodeName);
                items.each(function()
                {
                    var li   = $(this),
                        item = $.extend({}, li.data()),
                        sub  = li.children(list.options.listNodeName);
                    if (sub.length) {
                        item.children = step(sub, depth + 1);
                    }
                    array.push(item);
                });
                return array;
            };
            data = step(list.el.find(list.options.listNodeName).first(), depth);
            return data;
        },

        serialise: function()
        {
            return this.serialize();
        },

        reset: function()
        {
            this.mouse = {
                offsetX   : 0,
                offsetY   : 0,
                startX    : 0,
                startY    : 0,
                lastX     : 0,
                lastY     : 0,
                nowX      : 0,
                nowY      : 0,
                distX     : 0,
                distY     : 0,
                dirAx     : 0,
                dirX      : 0,
                dirY      : 0,
                lastDirX  : 0,
                lastDirY  : 0,
                distAxX   : 0,
                distAxY   : 0
            };
            this.isTouch    = false;
            this.moving     = false;
            this.dragEl     = null;
            this.dragRootEl = null;
            this.dragDepth  = 0;
            this.hasNewRoot = false;
            this.pointEl    = null;
        },

        expandItem: function(li)
        {
            li.removeClass(this.options.collapsedClass);
            li.children('[data-action="expand"]').hide();
            li.children('[data-action="collapse"]').show();
            li.children(this.options.listNodeName).show();
        },

        collapseItem: function(li)
        {
            var lists = li.children(this.options.listNodeName);
            if (lists.length) {
                li.addClass(this.options.collapsedClass);
                li.children('[data-action="collapse"]').hide();
                li.children('[data-action="expand"]').show();
                li.children(this.options.listNodeName).hide();
            }
        },

        Expand_All: function()
        {
            var list = this;
            list.el.find(list.options.itemNodeName).each(function() {
                list.expandItem($(this));
            });
        },

        collapseAll: function()
        {
            var list = this;
            list.el.find(list.options.itemNodeName).each(function() {
                list.collapseItem($(this));
            });
        },

        setParent: function(li)
        {
            if (li.children(this.options.listNodeName).length) {
                li.prepend($(this.options.expandBtnHTML));
                li.prepend($(this.options.collapseBtnHTML));
            }
            li.children('[data-action="expand"]').hide();
        },

        unsetParent: function(li)
        {
            li.removeClass(this.options.collapsedClass);
            li.children('[data-action]').remove();
            li.children(this.options.listNodeName).remove();
        },

        dragStart: function(e)
        {
            var mouse    = this.mouse,
                target   = $(e.target),
                dragItem = target.closest(this.options.itemNodeName);

            this.placeEl.css('height', dragItem.height());

            mouse.offsetX = e.offsetX !== undefined ? e.offsetX : e.pageX - target.offset().left;
            mouse.offsetY = e.offsetY !== undefined ? e.offsetY : e.pageY - target.offset().top;
            mouse.startX = mouse.lastX = e.pageX;
            mouse.startY = mouse.lastY = e.pageY;

            this.dragRootEl = this.el;

            this.dragEl = $(document.createElement(this.options.listNodeName)).addClass(this.options.listClass + ' ' + this.options.dragClass);
            this.dragEl.css('width', dragItem.width());

            dragItem.after(this.placeEl);
            dragItem[0].parentNode.removeChild(dragItem[0]);
            dragItem.appendTo(this.dragEl);

            $(document.body).append(this.dragEl);
            this.dragEl.css({
                'left' : e.pageX - mouse.offsetX,
                'top'  : e.pageY - mouse.offsetY
            });
            // total depth of dragging item
            var i, depth,
                items = this.dragEl.find(this.options.itemNodeName);
            for (i = 0; i < items.length; i++) {
                depth = $(items[i]).parents(this.options.listNodeName).length;
                if (depth > this.dragDepth) {
                    this.dragDepth = depth;
                }
            }
        },

        dragStop: function(e)
        {
            var el = this.dragEl.children(this.options.itemNodeName).first();
            el[0].parentNode.removeChild(el[0]);
            this.placeEl.replaceWith(el);

            this.dragEl.remove();
            this.el.trigger('change');
            if (this.hasNewRoot) {
                this.dragRootEl.trigger('change');
            }
            this.reset();
        },

        dragMove: function(e)
        {
            var list, parent, prev, next, depth,
                opt   = this.options,
                mouse = this.mouse;

            this.dragEl.css({
                'left' : e.pageX - mouse.offsetX,
                'top'  : e.pageY - mouse.offsetY
            });

            // mouse position last events
            mouse.lastX = mouse.nowX;
            mouse.lastY = mouse.nowY;
            // mouse position this events
            mouse.nowX  = e.pageX;
            mouse.nowY  = e.pageY;
            // distance mouse moved between events
            mouse.distX = mouse.nowX - mouse.lastX;
            mouse.distY = mouse.nowY - mouse.lastY;
            // direction mouse was moving
            mouse.lastDirX = mouse.dirX;
            mouse.lastDirY = mouse.dirY;
            // direction mouse is now moving (on both axis)
            mouse.dirX = mouse.distX === 0 ? 0 : mouse.distX > 0 ? 1 : -1;
            mouse.dirY = mouse.distY === 0 ? 0 : mouse.distY > 0 ? 1 : -1;
            // axis mouse is now moving on
            var newAx   = Math.abs(mouse.distX) > Math.abs(mouse.distY) ? 1 : 0;

            // do nothing on first move
            if (!mouse.moving) {
                mouse.dirAx  = newAx;
                mouse.moving = true;
                return;
            }

            // calc distance moved on this axis (and direction)
            if (mouse.dirAx !== newAx) {
                mouse.distAxX = 0;
                mouse.distAxY = 0;
            } else {
                mouse.distAxX += Math.abs(mouse.distX);
                if (mouse.dirX !== 0 && mouse.dirX !== mouse.lastDirX) {
                    mouse.distAxX = 0;
                }
                mouse.distAxY += Math.abs(mouse.distY);
                if (mouse.dirY !== 0 && mouse.dirY !== mouse.lastDirY) {
                    mouse.distAxY = 0;
                }
            }
            mouse.dirAx = newAx;

            /**
             * move horizontal
             */
            if (mouse.dirAx && mouse.distAxX >= opt.threshold) {
                // reset move distance on x-axis for new phase
                mouse.distAxX = 0;
                prev = this.placeEl.prev(opt.itemNodeName);
                // increase horizontal level if previous sibling exists and is not collapsed
                if (mouse.distX > 0 && prev.length && !prev.hasClass(opt.collapsedClass)) {
                    // cannot increase level when item above is collapsed
                    list = prev.find(opt.listNodeName).last();
                    // check if depth limit has reached
                    depth = this.placeEl.parents(opt.listNodeName).length;
                    if (depth + this.dragDepth <= opt.maxDepth) {
                        // create new sub-level if one doesn't exist
                        if (!list.length) {
                            list = $('<' + opt.listNodeName + '/>').addClass(opt.listClass);
                            list.append(this.placeEl);
                            prev.append(list);
                            this.setParent(prev);
                        } else {
                            // else append to next level up
                            list = prev.children(opt.listNodeName).last();
                            list.append(this.placeEl);
                        }
                    }
                }
                // decrease horizontal level
                if (mouse.distX < 0) {
                    // we can't decrease a level if an item preceeds the current one
                    next = this.placeEl.next(opt.itemNodeName);
                    if (!next.length) {
                        parent = this.placeEl.parent();
                        this.placeEl.closest(opt.itemNodeName).after(this.placeEl);
                        if (!parent.children().length) {
                            this.unsetParent(parent.parent());
                        }
                    }
                }
            }

            var isEmpty = false;

            // find list item under cursor
            if (!hasPointerEvents) {
                this.dragEl[0].style.visibility = 'hidden';
            }
            this.pointEl = $(document.elementFromPoint(e.pageX - document.body.scrollLeft, e.pageY - (window.pageYOffset || document.documentElement.scrollTop)));
            if (!hasPointerEvents) {
                this.dragEl[0].style.visibility = 'visible';
            }
            if (this.pointEl.hasClass(opt.handleClass)) {
                this.pointEl = this.pointEl.parent(opt.itemNodeName);
            }
            if (this.pointEl.hasClass(opt.emptyClass)) {
                isEmpty = true;
            }
            else if (!this.pointEl.length || !this.pointEl.hasClass(opt.itemClass)) {
                return;
            }

            // find parent list of item under cursor
            var pointElRoot = this.pointEl.closest('.' + opt.rootClass),
                isNewRoot   = this.dragRootEl.data('nestable-id') !== pointElRoot.data('nestable-id');

            /**
             * move vertical
             */
            if (!mouse.dirAx || isNewRoot || isEmpty) {
                // check if groups match if dragging over new root
                if (isNewRoot && opt.group !== pointElRoot.data('nestable-group')) {
                    return;
                }
                // check depth limit
                depth = this.dragDepth - 1 + this.pointEl.parents(opt.listNodeName).length;
                if (depth > opt.maxDepth) {
                    return;
                }
                var before = e.pageY < (this.pointEl.offset().top + this.pointEl.height() / 2);
                parent = this.placeEl.parent();
                // if empty create new list to replace empty placeholder
                if (isEmpty) {
                    list = $(document.createElement(opt.listNodeName)).addClass(opt.listClass);
                    list.append(this.placeEl);
                    this.pointEl.replaceWith(list);
                }
                else if (before) {
                    this.pointEl.before(this.placeEl);
                }
                else {
                    this.pointEl.after(this.placeEl);
                }
                if (!parent.children().length) {
                    this.unsetParent(parent.parent());
                }
                if (!this.dragRootEl.find(opt.itemNodeName).length) {
                    this.dragRootEl.append('<div class="' + opt.emptyClass + '"/>');
                }
                // parent root list has changed
                if (isNewRoot) {
                    this.dragRootEl = pointElRoot;
                    this.hasNewRoot = this.el[0] !== this.dragRootEl[0];
                }
            }
        }

    };

    $.fn.nestable = function(params)
    {
        var lists  = this,
            retval = this;

        lists.each(function()
        {
            var plugin = $(this).data("nestable");

            if (!plugin) {
                $(this).data("nestable", new Plugin(this, params));
                $(this).data("nestable-id", new Date().getTime());
            } else {
                if (typeof params === 'string' && typeof plugin[params] === 'function') {
                    retval = plugin[params]();
                }
            }
        });

        return retval || lists;
    };

})(window.jQuery || window.Zepto, window, document);
(function($){
    $.fn.step = function(options) {
        var opts = $.extend({}, $.fn.step.defaults, options);
        var size=this.find(".step-header li").length;
        var barWidth=opts.initStep<size?100/(1*size)+100*(opts.initStep-1)/size : 100;
        var curPage=opts.initStep;
        var steps = this;
        var bar_w = (100 - (100/size)) + '%';
        this.find(".step-header").prepend("<div class=\"step-bar\" style='width:"+bar_w+"'><div class=\"step-bar-active\"></div></div>");
        this.find(".step-list").eq(opts.initStep).show();
        if (size<opts.initStep) {
            opts.initStep=size;
        }
        if (opts.animate==false) {
            opts.speed=0;
        }
        this.find(".step-header li").each(function (i, li) {
            if(i == 0){
                $(li).addClass("step-current")
                    .append('<a href="javascript:;" class="jump-steps" data-step="'+(i+1)+'">'+(i+1)+'</a>');
            } else if (i<opts.initStep){
                $(li).addClass("step-active")
                    .append('<a href="javascript:;" class="jump-steps" data-step="'+(i+1)+'"></a>');
            }else{
                $(li).append('<a href="javascript:;" class="jump-steps" data-step="'+(i+1)+'">'+(i+1)+'</a>');
            }
        });
        this.find(".step-header li").css({
            "width": 100/size+"%"
        });
        this.find(".step-header").show();
        this.find(".step-bar-active").animate({
                "width": barWidth+"%"},
            opts.speed, function() {

            });

        this.find(".jump-steps").on('click',function () {
            var step_id = $(this).attr("data-step");
            if(step_id !==0 && step_id <= size && opts.stepCallBack){
                opts.stepCallBack(step_id);
            }else {
                steps.goStep(step_id);
            }
        });

        // 获取当前页码
        this.getCurrentPage = function () {
            return curPage;
        };

        this.nextStep=function() {
            if (curPage>=size) {
                return false;
            }

            var next_step_num = curPage == 0? 2: curPage+1 == size ? size : curPage+1;
            if(opts.stepCallBack){
                opts.stepCallBack(next_step_num);
            }else {
                return this.goStep(next_step_num);
            }
        };

        this.preStep=function() {
            if (curPage<=1) {
                return false;
            }
            var pre_step_num = curPage == 1? 1: curPage-1;
            if(opts.stepCallBack){
                opts.stepCallBack(pre_step_num);
            }else {
                return this.goStep(pre_step_num);
            }
        };

        this.goStep=function(page) {
            if (page ==undefined || isNaN(page) || page<0) {
                if(window.console&&window.console.error){
                    console.error('the method goStep has a error,page:'+page);
                }
                return false;
            }
            curPage=parseInt(page);
            this.find(".step-list").hide();
            this.find(".step-list").eq(curPage-1).show();
            this.find(".step-header li").each(function (i, li) {
                var $li=$(li);
                $li.removeClass('step-current')
                    .removeClass('step-active');
                $li.find("a").html(i+1);
                if ((i+1)<page){
                    $li.addClass('step-active');
                    $li.find("a").empty();
                    if(opts.scrollTop){
                        $('html,body').animate({scrollTop:0}, 'slow');
                    }
                }else if((i+1) == page){
                    $li.addClass('step-current');
                }
            });
            var bar_acw = (100/(100-(100/size)))*(100/size)*(page-1);
            barWidth= page<size? bar_acw : 100;
            this.find(".step-bar-active").animate({
                    "width": barWidth+"%"},
                opts.speed, function() {

                });
            return true;
        };
        return this;
    };
    $.fn.step.defaults = {
        animate:true,
        speed:200,
        initStep:0,
        scrollTop:true,
        mustStep: [],
        stepCallBack: {}
    };

})( jQuery, window, document );
/*!
 * jQuery Color Animations v3.0.0-alpha.1
 * https://github.com/jquery/jquery-color
 */

( function( root, factory ) {
    if ( typeof define === "function" && define.amd ) {

        // AMD. Register as an anonymous module.
        define( [ "jquery" ], factory );
    } else if ( typeof exports === "object" ) {
        module.exports = factory( require( "jquery" ) );
    } else {
        factory( root.jQuery );
    }
} )( this, function( jQuery, undefined ) {

    var stepHooks = "backgroundColor borderBottomColor borderLeftColor borderRightColor " +
            "borderTopColor color columnRuleColor outlineColor textDecorationColor textEmphasisColor",

        class2type = {},
        toString = class2type.toString,

        // plusequals test for += 100 -= 100
        rplusequals = /^([\-+])=\s*(\d+\.?\d*)/,

        // a set of RE's that can match strings and generate color tuples.
        stringParsers = [ {
            re: /rgba?\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*(?:,\s*(\d?(?:\.\d+)?)\s*)?\)/,
            parse: function( execResult ) {
                return [
                    execResult[ 1 ],
                    execResult[ 2 ],
                    execResult[ 3 ],
                    execResult[ 4 ]
                ];
            }
        }, {
            re: /rgba?\(\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*(?:,\s*(\d?(?:\.\d+)?)\s*)?\)/,
            parse: function( execResult ) {
                return [
                    execResult[ 1 ] * 2.55,
                    execResult[ 2 ] * 2.55,
                    execResult[ 3 ] * 2.55,
                    execResult[ 4 ]
                ];
            }
        }, {

            // this regex ignores A-F because it's compared against an already lowercased string
            re: /#([a-f0-9]{2})([a-f0-9]{2})([a-f0-9]{2})/,
            parse: function( execResult ) {
                return [
                    parseInt( execResult[ 1 ], 16 ),
                    parseInt( execResult[ 2 ], 16 ),
                    parseInt( execResult[ 3 ], 16 )
                ];
            }
        }, {

            // this regex ignores A-F because it's compared against an already lowercased string
            re: /#([a-f0-9])([a-f0-9])([a-f0-9])/,
            parse: function( execResult ) {
                return [
                    parseInt( execResult[ 1 ] + execResult[ 1 ], 16 ),
                    parseInt( execResult[ 2 ] + execResult[ 2 ], 16 ),
                    parseInt( execResult[ 3 ] + execResult[ 3 ], 16 )
                ];
            }
        }, {
            re: /hsla?\(\s*(\d+(?:\.\d+)?)\s*,\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*(?:,\s*(\d?(?:\.\d+)?)\s*)?\)/,
            space: "hsla",
            parse: function( execResult ) {
                return [
                    execResult[ 1 ],
                    execResult[ 2 ] / 100,
                    execResult[ 3 ] / 100,
                    execResult[ 4 ]
                ];
            }
        } ],

        // jQuery.Color( )
        color = jQuery.Color = function( color, green, blue, alpha ) {
            return new jQuery.Color.fn.parse( color, green, blue, alpha );
        },
        spaces = {
            rgba: {
                props: {
                    red: {
                        idx: 0,
                        type: "byte"
                    },
                    green: {
                        idx: 1,
                        type: "byte"
                    },
                    blue: {
                        idx: 2,
                        type: "byte"
                    }
                }
            },

            hsla: {
                props: {
                    hue: {
                        idx: 0,
                        type: "degrees"
                    },
                    saturation: {
                        idx: 1,
                        type: "percent"
                    },
                    lightness: {
                        idx: 2,
                        type: "percent"
                    }
                }
            }
        },
        propTypes = {
            "byte": {
                floor: true,
                max: 255
            },
            "percent": {
                max: 1
            },
            "degrees": {
                mod: 360,
                floor: true
            }
        },

        // colors = jQuery.Color.names
        colors,

        // local aliases of functions called often
        each = jQuery.each;

// define cache name and alpha properties
// for rgba and hsla spaces
    each( spaces, function( spaceName, space ) {
        space.cache = "_" + spaceName;
        space.props.alpha = {
            idx: 3,
            type: "percent",
            def: 1
        };
    } );

// Populate the class2type map
    jQuery.each( "Boolean Number String Function Array Date RegExp Object Error Symbol".split( " " ),
        function( i, name ) {
            class2type[ "[object " + name + "]" ] = name.toLowerCase();
        } );

    function getType( obj ) {
        if ( obj == null ) {
            return obj + "";
        }

        return typeof obj === "object" ?
        class2type[ toString.call( obj ) ] || "object" :
            typeof obj;
    }

    function clamp( value, prop, allowEmpty ) {
        var type = propTypes[ prop.type ] || {};

        if ( value == null ) {
            return ( allowEmpty || !prop.def ) ? null : prop.def;
        }

        // ~~ is an short way of doing floor for positive numbers
        value = type.floor ? ~~value : parseFloat( value );

        if ( type.mod ) {

            // we add mod before modding to make sure that negatives values
            // get converted properly: -10 -> 350
            return ( value + type.mod ) % type.mod;
        }

        // for now all property types without mod have min and max
        return Math.min( type.max, Math.max( 0, value ) );
    }

    function stringParse( string ) {
        var inst = color(),
            rgba = inst._rgba = [];

        string = string.toLowerCase();

        each( stringParsers, function( i, parser ) {
            var parsed,
                match = parser.re.exec( string ),
                values = match && parser.parse( match ),
                spaceName = parser.space || "rgba";

            if ( values ) {
                parsed = inst[ spaceName ]( values );

                // if this was an rgba parse the assignment might happen twice
                // oh well....
                inst[ spaces[ spaceName ].cache ] = parsed[ spaces[ spaceName ].cache ];
                rgba = inst._rgba = parsed._rgba;

                // exit each( stringParsers ) here because we matched
                return false;
            }
        } );

        // Found a stringParser that handled it
        if ( rgba.length ) {

            // if this came from a parsed string, force "transparent" when alpha is 0
            // chrome, (and maybe others) return "transparent" as rgba(0,0,0,0)
            if ( rgba.join() === "0,0,0,0" ) {
                jQuery.extend( rgba, colors.transparent );
            }
            return inst;
        }

        // named colors
        return colors[ string ];
    }

    color.fn = jQuery.extend( color.prototype, {
        parse: function( red, green, blue, alpha ) {
            if ( red === undefined ) {
                this._rgba = [ null, null, null, null ];
                return this;
            }
            if ( red.jquery || red.nodeType ) {
                red = jQuery( red ).css( green );
                green = undefined;
            }

            var inst = this,
                type = getType( red ),
                rgba = this._rgba = [];

            // more than 1 argument specified - assume ( red, green, blue, alpha )
            if ( green !== undefined ) {
                red = [ red, green, blue, alpha ];
                type = "array";
            }

            if ( type === "string" ) {
                return this.parse( stringParse( red ) || colors._default );
            }

            if ( type === "array" ) {
                each( spaces.rgba.props, function( key, prop ) {
                    rgba[ prop.idx ] = clamp( red[ prop.idx ], prop );
                } );
                return this;
            }

            if ( type === "object" ) {
                if ( red instanceof color ) {
                    each( spaces, function( spaceName, space ) {
                        if ( red[ space.cache ] ) {
                            inst[ space.cache ] = red[ space.cache ].slice();
                        }
                    } );
                } else {
                    each( spaces, function( spaceName, space ) {
                        var cache = space.cache;
                        each( space.props, function( key, prop ) {

                            // if the cache doesn't exist, and we know how to convert
                            if ( !inst[ cache ] && space.to ) {

                                // if the value was null, we don't need to copy it
                                // if the key was alpha, we don't need to copy it either
                                if ( key === "alpha" || red[ key ] == null ) {
                                    return;
                                }
                                inst[ cache ] = space.to( inst._rgba );
                            }

                            // this is the only case where we allow nulls for ALL properties.
                            // call clamp with alwaysAllowEmpty
                            inst[ cache ][ prop.idx ] = clamp( red[ key ], prop, true );
                        } );

                        // everything defined but alpha?
                        if ( inst[ cache ] && jQuery.inArray( null, inst[ cache ].slice( 0, 3 ) ) < 0 ) {

                            // use the default of 1
                            if ( inst[ cache ][ 3 ] == null ) {
                                inst[ cache ][ 3 ] = 1;
                            }

                            if ( space.from ) {
                                inst._rgba = space.from( inst[ cache ] );
                            }
                        }
                    } );
                }
                return this;
            }
        },
        is: function( compare ) {
            var is = color( compare ),
                same = true,
                inst = this;

            each( spaces, function( _, space ) {
                var localCache,
                    isCache = is[ space.cache ];
                if ( isCache ) {
                    localCache = inst[ space.cache ] || space.to && space.to( inst._rgba ) || [];
                    each( space.props, function( _, prop ) {
                        if ( isCache[ prop.idx ] != null ) {
                            same = ( isCache[ prop.idx ] === localCache[ prop.idx ] );
                            return same;
                        }
                    } );
                }
                return same;
            } );
            return same;
        },
        _space: function() {
            var used = [],
                inst = this;
            each( spaces, function( spaceName, space ) {
                if ( inst[ space.cache ] ) {
                    used.push( spaceName );
                }
            } );
            return used.pop();
        },
        transition: function( other, distance ) {
            var end = color( other ),
                spaceName = end._space(),
                space = spaces[ spaceName ],
                startColor = this.alpha() === 0 ? color( "transparent" ) : this,
                start = startColor[ space.cache ] || space.to( startColor._rgba ),
                result = start.slice();

            end = end[ space.cache ];
            each( space.props, function( key, prop ) {
                var index = prop.idx,
                    startValue = start[ index ],
                    endValue = end[ index ],
                    type = propTypes[ prop.type ] || {};

                // if null, don't override start value
                if ( endValue === null ) {
                    return;
                }

                // if null - use end
                if ( startValue === null ) {
                    result[ index ] = endValue;
                } else {
                    if ( type.mod ) {
                        if ( endValue - startValue > type.mod / 2 ) {
                            startValue += type.mod;
                        } else if ( startValue - endValue > type.mod / 2 ) {
                            startValue -= type.mod;
                        }
                    }
                    result[ index ] = clamp( ( endValue - startValue ) * distance + startValue, prop );
                }
            } );
            return this[ spaceName ]( result );
        },
        blend: function( opaque ) {

            // if we are already opaque - return ourself
            if ( this._rgba[ 3 ] === 1 ) {
                return this;
            }

            var rgb = this._rgba.slice(),
                a = rgb.pop(),
                blend = color( opaque )._rgba;

            return color( jQuery.map( rgb, function( v, i ) {
                return ( 1 - a ) * blend[ i ] + a * v;
            } ) );
        },
        toRgbaString: function() {
            var prefix = "rgba(",
                rgba = jQuery.map( this._rgba, function( v, i ) {
                    if ( v != null ) {
                        return v;
                    }
                    return i > 2 ? 1 : 0;
                } );

            if ( rgba[ 3 ] === 1 ) {
                rgba.pop();
                prefix = "rgb(";
            }

            return prefix + rgba.join() + ")";
        },
        toHslaString: function() {
            var prefix = "hsla(",
                hsla = jQuery.map( this.hsla(), function( v, i ) {
                    if ( v == null ) {
                        v = i > 2 ? 1 : 0;
                    }

                    // catch 1 and 2
                    if ( i && i < 3 ) {
                        v = Math.round( v * 100 ) + "%";
                    }
                    return v;
                } );

            if ( hsla[ 3 ] === 1 ) {
                hsla.pop();
                prefix = "hsl(";
            }
            return prefix + hsla.join() + ")";
        },
        toHexString: function( includeAlpha ) {
            var rgba = this._rgba.slice(),
                alpha = rgba.pop();

            if ( includeAlpha ) {
                rgba.push( ~~( alpha * 255 ) );
            }

            return "#" + jQuery.map( rgba, function( v ) {

                    // default to 0 when nulls exist
                    return ( "0" + ( v || 0 ).toString( 16 ) ).substr( -2 );
                } ).join( "" );
        },
        toString: function() {
            return this._rgba[ 3 ] === 0 ? "transparent" : this.toRgbaString();
        }
    } );
    color.fn.parse.prototype = color.fn;

// hsla conversions adapted from:
// https://code.google.com/p/maashaack/source/browse/packages/graphics/trunk/src/graphics/colors/HUE2RGB.as?r=5021

    function hue2rgb( p, q, h ) {
        h = ( h + 1 ) % 1;
        if ( h * 6 < 1 ) {
            return p + ( q - p ) * h * 6;
        }
        if ( h * 2 < 1 ) {
            return q;
        }
        if ( h * 3 < 2 ) {
            return p + ( q - p ) * ( ( 2 / 3 ) - h ) * 6;
        }
        return p;
    }

    spaces.hsla.to = function( rgba ) {
        if ( rgba[ 0 ] == null || rgba[ 1 ] == null || rgba[ 2 ] == null ) {
            return [ null, null, null, rgba[ 3 ] ];
        }
        var r = rgba[ 0 ] / 255,
            g = rgba[ 1 ] / 255,
            b = rgba[ 2 ] / 255,
            a = rgba[ 3 ],
            max = Math.max( r, g, b ),
            min = Math.min( r, g, b ),
            diff = max - min,
            add = max + min,
            l = add * 0.5,
            h, s;

        if ( min === max ) {
            h = 0;
        } else if ( r === max ) {
            h = ( 60 * ( g - b ) / diff ) + 360;
        } else if ( g === max ) {
            h = ( 60 * ( b - r ) / diff ) + 120;
        } else {
            h = ( 60 * ( r - g ) / diff ) + 240;
        }

        // chroma (diff) == 0 means greyscale which, by definition, saturation = 0%
        // otherwise, saturation is based on the ratio of chroma (diff) to lightness (add)
        if ( diff === 0 ) {
            s = 0;
        } else if ( l <= 0.5 ) {
            s = diff / add;
        } else {
            s = diff / ( 2 - add );
        }
        return [ Math.round( h ) % 360, s, l, a == null ? 1 : a ];
    };

    spaces.hsla.from = function( hsla ) {
        if ( hsla[ 0 ] == null || hsla[ 1 ] == null || hsla[ 2 ] == null ) {
            return [ null, null, null, hsla[ 3 ] ];
        }
        var h = hsla[ 0 ] / 360,
            s = hsla[ 1 ],
            l = hsla[ 2 ],
            a = hsla[ 3 ],
            q = l <= 0.5 ? l * ( 1 + s ) : l + s - l * s,
            p = 2 * l - q;

        return [
            Math.round( hue2rgb( p, q, h + ( 1 / 3 ) ) * 255 ),
            Math.round( hue2rgb( p, q, h ) * 255 ),
            Math.round( hue2rgb( p, q, h - ( 1 / 3 ) ) * 255 ),
            a
        ];
    };


    each( spaces, function( spaceName, space ) {
        var props = space.props,
            cache = space.cache,
            to = space.to,
            from = space.from;

        // makes rgba() and hsla()
        color.fn[ spaceName ] = function( value ) {

            // generate a cache for this space if it doesn't exist
            if ( to && !this[ cache ] ) {
                this[ cache ] = to( this._rgba );
            }
            if ( value === undefined ) {
                return this[ cache ].slice();
            }

            var ret,
                type = getType( value ),
                arr = ( type === "array" || type === "object" ) ? value : arguments,
                local = this[ cache ].slice();

            each( props, function( key, prop ) {
                var val = arr[ type === "object" ? key : prop.idx ];
                if ( val == null ) {
                    val = local[ prop.idx ];
                }
                local[ prop.idx ] = clamp( val, prop );
            } );

            if ( from ) {
                ret = color( from( local ) );
                ret[ cache ] = local;
                return ret;
            } else {
                return color( local );
            }
        };

        // makes red() green() blue() alpha() hue() saturation() lightness()
        each( props, function( key, prop ) {

            // alpha is included in more than one space
            if ( color.fn[ key ] ) {
                return;
            }
            color.fn[ key ] = function( value ) {
                var local, cur, match, fn,
                    vtype = getType( value );

                if ( key === "alpha" ) {
                    fn = this._hsla ? "hsla" : "rgba";
                } else {
                    fn = spaceName;
                }
                local = this[ fn ]();
                cur = local[ prop.idx ];

                if ( vtype === "undefined" ) {
                    return cur;
                }

                if ( vtype === "function" ) {
                    value = value.call( this, cur );
                    vtype = getType( value );
                }
                if ( value == null && prop.empty ) {
                    return this;
                }
                if ( vtype === "string" ) {
                    match = rplusequals.exec( value );
                    if ( match ) {
                        value = cur + parseFloat( match[ 2 ] ) * ( match[ 1 ] === "+" ? 1 : -1 );
                    }
                }
                local[ prop.idx ] = value;
                return this[ fn ]( local );
            };
        } );
    } );

// add cssHook and .fx.step function for each named hook.
// accept a space separated string of properties
    color.hook = function( hook ) {
        var hooks = hook.split( " " );
        each( hooks, function( i, hook ) {
            jQuery.cssHooks[ hook ] = {
                set: function( elem, value ) {
                    var parsed;

                    if ( value !== "transparent" && ( getType( value ) !== "string" || ( parsed = stringParse( value ) ) ) ) {
                        value = color( parsed || value );
                        value = value.toRgbaString();
                    }
                    elem.style[ hook ] = value;
                }
            };
            jQuery.fx.step[ hook ] = function( fx ) {
                if ( !fx.colorInit ) {
                    fx.start = color( fx.elem, hook );
                    fx.end = color( fx.end );
                    fx.colorInit = true;
                }
                jQuery.cssHooks[ hook ].set( fx.elem, fx.start.transition( fx.end, fx.pos ) );
            };
        } );

    };

    color.hook( stepHooks );

    jQuery.cssHooks.borderColor = {
        expand: function( value ) {
            var expanded = {};

            each( [ "Top", "Right", "Bottom", "Left" ], function( i, part ) {
                expanded[ "border" + part + "Color" ] = value;
            } );
            return expanded;
        }
    };

// Basic color names only.
// Usage of any of the other color names requires adding yourself or including
// jquery.color.svg-names.js.
    colors = jQuery.Color.names = {

        // 4.1. Basic color keywords
        aqua: "#00ffff",
        black: "#000000",
        blue: "#0000ff",
        fuchsia: "#ff00ff",
        gray: "#808080",
        green: "#008000",
        lime: "#00ff00",
        maroon: "#800000",
        navy: "#000080",
        olive: "#808000",
        purple: "#800080",
        red: "#ff0000",
        silver: "#c0c0c0",
        teal: "#008080",
        white: "#ffffff",
        yellow: "#ffff00",

        // 4.2.3. "transparent" color keyword
        transparent: [ null, null, null, 0 ],
        _default: "#ffffff"
    };

} );

/*
 _ _      _       _
 ___| (_) ___| | __  (_)___
 / __| | |/ __| |/ /  | / __|
 \__ \ | | (__|   < _ | \__ \
 |___/_|_|\___|_|\_(_)/ |___/
 |__/

 Version: 1.8.0
 Author: Ken Wheeler
 Website: http://kenwheeler.github.io
 Docs: http://kenwheeler.github.io/slick
 Repo: http://github.com/kenwheeler/slick
 Issues: http://github.com/kenwheeler/slick/issues

 */
/* global window, document, define, jQuery, setInterval, clearInterval */
;(function(factory) {
    'use strict';
    if (typeof define === 'function' && define.amd) {
        define(['jquery'], factory);
    } else if (typeof exports !== 'undefined') {
        module.exports = factory(require('jquery'));
    } else {
        factory(jQuery);
    }

}(function($) {
    'use strict';
    var Slick = window.Slick || {};

    Slick = (function() {

        var instanceUid = 0;

        function Slick(element, settings) {

            var _ = this, dataSettings;

            _.defaults = {
                accessibility: true,
                adaptiveHeight: false,
                appendArrows: $(element),
                appendDots: $(element),
                arrows: false,
                asNavFor: null,
                prevArrow: '<button class="slick-prev" aria-label="Previous" type="button">Previous</button>',
                nextArrow: '<button class="slick-next" aria-label="Next" type="button">Next</button>',
                autoplay: false,
                autoplaySpeed: 3000,
                centerMode: false,
                centerPadding: '50px',
                cssEase: 'ease',
                customPaging: function(slider, i) {
                    return $('<button type="button" />').text(i + 1);
                },
                dots: false,
                dotsClass: 'slick-dots',
                draggable: true,
                easing: 'linear',
                edgeFriction: 0.35,
                fade: false,
                focusOnSelect: false,
                focusOnChange: false,
                infinite: true,
                initialSlide: 0,
                lazyLoad: 'ondemand',
                mobileFirst: false,
                pauseOnHover: true,
                pauseOnFocus: true,
                pauseOnDotsHover: false,
                respondTo: 'window',
                responsive: null,
                rows: 1,
                rtl: false,
                slide: '',
                slidesPerRow: 1,
                slidesToShow: 1,
                slidesToScroll: 1,
                speed: 500,
                swipe: true,
                swipeToSlide: false,
                touchMove: true,
                touchThreshold: 5,
                useCSS: true,
                useTransform: true,
                variableWidth: true,
                vertical: false,
                verticalSwiping: false,
                waitForAnimate: true,
                zIndex: 1000
            };

            _.initials = {
                animating: false,
                dragging: false,
                autoPlayTimer: null,
                currentDirection: 0,
                currentLeft: null,
                currentSlide: 0,
                direction: 1,
                $dots: null,
                listWidth: null,
                listHeight: null,
                loadIndex: 0,
                $nextArrow: null,
                $prevArrow: null,
                scrolling: false,
                slideCount: null,
                slideWidth: null,
                $slideTrack: null,
                $slides: null,
                sliding: false,
                slideOffset: 0,
                swipeLeft: null,
                swiping: false,
                $list: null,
                touchObject: {},
                transformsEnabled: false,
                unslicked: false
            };

            $.extend(_, _.initials);

            _.activeBreakpoint = null;
            _.animType = null;
            _.animProp = null;
            _.breakpoints = [];
            _.breakpointSettings = [];
            _.cssTransitions = false;
            _.focussed = false;
            _.interrupted = false;
            _.hidden = 'hidden';
            _.paused = true;
            _.positionProp = null;
            _.respondTo = null;
            _.rowCount = 1;
            _.shouldClick = true;
            _.$slider = $(element);
            _.$slidesCache = null;
            _.transformType = null;
            _.transitionType = null;
            _.visibilityChange = 'visibilitychange';
            _.windowWidth = 0;
            _.windowTimer = null;

            dataSettings = $(element).data('slick') || {};

            _.options = $.extend({}, _.defaults, settings, dataSettings);

            _.currentSlide = _.options.initialSlide;

            _.originalSettings = _.options;

            if (typeof document.mozHidden !== 'undefined') {
                _.hidden = 'mozHidden';
                _.visibilityChange = 'mozvisibilitychange';
            } else if (typeof document.webkitHidden !== 'undefined') {
                _.hidden = 'webkitHidden';
                _.visibilityChange = 'webkitvisibilitychange';
            }

            _.autoPlay = $.proxy(_.autoPlay, _);
            _.autoPlayClear = $.proxy(_.autoPlayClear, _);
            _.autoPlayIterator = $.proxy(_.autoPlayIterator, _);
            _.changeSlide = $.proxy(_.changeSlide, _);
            _.clickHandler = $.proxy(_.clickHandler, _);
            _.selectHandler = $.proxy(_.selectHandler, _);
            _.setPosition = $.proxy(_.setPosition, _);
            _.swipeHandler = $.proxy(_.swipeHandler, _);
            _.dragHandler = $.proxy(_.dragHandler, _);
            _.keyHandler = $.proxy(_.keyHandler, _);

            _.instanceUid = instanceUid++;

            // A simple way to check for HTML strings
            // Strict HTML recognition (must start with <)
            // Extracted from jQuery v1.11 source
            _.htmlExpr = /^(?:\s*(<[\w\W]+>)[^>]*)$/;


            _.registerBreakpoints();
            _.init(true);

        }

        return Slick;

    }());

    Slick.prototype.activateADA = function() {
        var _ = this;

        _.$slideTrack.find('.slick-active').attr({
            'aria-hidden': 'false'
        }).find('a, input, button, select').attr({
            'tabindex': '0'
        });

    };

    Slick.prototype.addSlide = Slick.prototype.slickAdd = function(markup, index, addBefore) {

        var _ = this;

        if (typeof(index) === 'boolean') {
            addBefore = index;
            index = null;
        } else if (index < 0 || (index >= _.slideCount)) {
            return false;
        }

        _.unload();

        if (typeof(index) === 'number') {
            if (index === 0 && _.$slides.length === 0) {
                $(markup).appendTo(_.$slideTrack);
            } else if (addBefore) {
                $(markup).insertBefore(_.$slides.eq(index));
            } else {
                $(markup).insertAfter(_.$slides.eq(index));
            }
        } else {
            if (addBefore === true) {
                $(markup).prependTo(_.$slideTrack);
            } else {
                $(markup).appendTo(_.$slideTrack);
            }
        }

        _.$slides = _.$slideTrack.children(this.options.slide);

        _.$slideTrack.children(this.options.slide).detach();

        _.$slideTrack.append(_.$slides);

        _.$slides.each(function(index, element) {
            $(element).attr('data-slick-index', index);
        });

        _.$slidesCache = _.$slides;

        _.reinit();

    };

    Slick.prototype.animateHeight = function() {
        var _ = this;
        if (_.options.slidesToShow === 1 && _.options.adaptiveHeight === true && _.options.vertical === false) {
            var targetHeight = _.$slides.eq(_.currentSlide).outerHeight(true);
            _.$list.animate({
                height: targetHeight
            }, _.options.speed);
        }
    };

    Slick.prototype.animateSlide = function(targetLeft, callback) {

        var animProps = {},
            _ = this;

        _.animateHeight();

        if (_.options.rtl === true && _.options.vertical === false) {
            targetLeft = -targetLeft;
        }
        if (_.transformsEnabled === false) {
            if (_.options.vertical === false) {
                _.$slideTrack.animate({
                    left: targetLeft
                }, _.options.speed, _.options.easing, callback);
            } else {
                _.$slideTrack.animate({
                    top: targetLeft
                }, _.options.speed, _.options.easing, callback);
            }

        } else {

            if (_.cssTransitions === false) {
                if (_.options.rtl === true) {
                    _.currentLeft = -(_.currentLeft);
                }
                $({
                    animStart: _.currentLeft
                }).animate({
                    animStart: targetLeft
                }, {
                    duration: _.options.speed,
                    easing: _.options.easing,
                    step: function(now) {
                        now = Math.ceil(now);
                        if (_.options.vertical === false) {
                            animProps[_.animType] = 'translate(' +
                                now + 'px, 0px)';
                            _.$slideTrack.css(animProps);
                        } else {
                            animProps[_.animType] = 'translate(0px,' +
                                now + 'px)';
                            _.$slideTrack.css(animProps);
                        }
                    },
                    complete: function() {
                        if (callback) {
                            callback.call();
                        }
                    }
                });

            } else {

                _.applyTransition();
                targetLeft = Math.ceil(targetLeft);

                if (_.options.vertical === false) {
                    animProps[_.animType] = 'translate3d(' + targetLeft + 'px, 0px, 0px)';
                } else {
                    animProps[_.animType] = 'translate3d(0px,' + targetLeft + 'px, 0px)';
                }
                _.$slideTrack.css(animProps);

                if (callback) {
                    setTimeout(function() {

                        _.disableTransition();

                        callback.call();
                    }, _.options.speed);
                }

            }

        }

    };

    Slick.prototype.getNavTarget = function() {

        var _ = this,
            asNavFor = _.options.asNavFor;

        if ( asNavFor && asNavFor !== null ) {
            asNavFor = $(asNavFor).not(_.$slider);
        }

        return asNavFor;

    };

    Slick.prototype.asNavFor = function(index) {

        var _ = this,
            asNavFor = _.getNavTarget();

        if ( asNavFor !== null && typeof asNavFor === 'object' ) {
            asNavFor.each(function() {
                var target = $(this).slick('getSlick');
                if(!target.unslicked) {
                    target.slideHandler(index, true);
                }
            });
        }

    };

    Slick.prototype.applyTransition = function(slide) {

        var _ = this,
            transition = {};

        if (_.options.fade === false) {
            transition[_.transitionType] = _.transformType + ' ' + _.options.speed + 'ms ' + _.options.cssEase;
        } else {
            transition[_.transitionType] = 'opacity ' + _.options.speed + 'ms ' + _.options.cssEase;
        }

        if (_.options.fade === false) {
            _.$slideTrack.css(transition);
        } else {
            _.$slides.eq(slide).css(transition);
        }

    };

    Slick.prototype.autoPlay = function() {

        var _ = this;

        _.autoPlayClear();

        if ( _.slideCount > _.options.slidesToShow ) {
            _.autoPlayTimer = setInterval( _.autoPlayIterator, _.options.autoplaySpeed );
        }

    };

    Slick.prototype.autoPlayClear = function() {

        var _ = this;

        if (_.autoPlayTimer) {
            clearInterval(_.autoPlayTimer);
        }

    };

    Slick.prototype.autoPlayIterator = function() {

        var _ = this,
            slideTo = _.currentSlide + _.options.slidesToScroll;

        if ( !_.paused && !_.interrupted && !_.focussed ) {

            if ( _.options.infinite === false ) {

                if ( _.direction === 1 && ( _.currentSlide + 1 ) === ( _.slideCount - 1 )) {
                    _.direction = 0;
                }

                else if ( _.direction === 0 ) {

                    slideTo = _.currentSlide - _.options.slidesToScroll;

                    if ( _.currentSlide - 1 === 0 ) {
                        _.direction = 1;
                    }

                }

            }

            _.slideHandler( slideTo );

        }

    };

    Slick.prototype.buildArrows = function() {

        var _ = this;

        if (_.options.arrows === true ) {

            _.$prevArrow = $(_.options.prevArrow).addClass('slick-arrow');
            _.$nextArrow = $(_.options.nextArrow).addClass('slick-arrow');

            if( _.slideCount > _.options.slidesToShow ) {

                _.$prevArrow.removeClass('slick-hidden').removeAttr('aria-hidden tabindex');
                _.$nextArrow.removeClass('slick-hidden').removeAttr('aria-hidden tabindex');

                if (_.htmlExpr.test(_.options.prevArrow)) {
                    _.$prevArrow.prependTo(_.options.appendArrows);
                }

                if (_.htmlExpr.test(_.options.nextArrow)) {
                    _.$nextArrow.appendTo(_.options.appendArrows);
                }

                if (_.options.infinite !== true) {
                    _.$prevArrow
                        .addClass('slick-disabled')
                        .attr('aria-disabled', 'true');
                }

            } else {

                _.$prevArrow.add( _.$nextArrow )

                    .addClass('slick-hidden')
                    .attr({
                        'aria-disabled': 'true',
                        'tabindex': '-1'
                    });

            }

        }

    };

    Slick.prototype.buildDots = function() {

        var _ = this,
            i, dot;

        if (_.options.dots === true) {

            _.$slider.addClass('slick-dotted');

            dot = $('<ul />').addClass(_.options.dotsClass);

            for (i = 0; i <= _.getDotCount(); i += 1) {
                dot.append($('<li />').append(_.options.customPaging.call(this, _, i)));
            }

            _.$dots = dot.appendTo(_.options.appendDots);

            _.$dots.find('li').first().addClass('slick-active');

        }

    };

    Slick.prototype.buildOut = function() {

        var _ = this;

        _.$slides =
            _.$slider
                .children( _.options.slide + ':not(.slick-cloned)')
                .addClass('slick-slide');

        _.slideCount = _.$slides.length;

        _.$slides.each(function(index, element) {
            $(element)
                .attr('data-slick-index', index)
                .data('originalStyling', $(element).attr('style') || '');
        });

        _.$slider.addClass('slick-slider');

        _.$slideTrack = (_.slideCount === 0) ?
            $('<div class="slick-track"/>').appendTo(_.$slider) :
            _.$slides.wrapAll('<div class="slick-track"/>').parent();

        _.$list = _.$slideTrack.wrap(
            '<div class="slick-list"/>').parent();
        _.$slideTrack.css('opacity', 0);

        if (_.options.centerMode === true || _.options.swipeToSlide === true) {
            _.options.slidesToScroll = 1;
        }

        $('img[data-lazy]', _.$slider).not('[src]').addClass('slick-loading');

        _.setupInfinite();

        _.buildArrows();

        _.buildDots();

        _.updateDots();


        _.setSlideClasses(typeof _.currentSlide === 'number' ? _.currentSlide : 0);

        if (_.options.draggable === true) {
            _.$list.addClass('draggable');
        }

    };

    Slick.prototype.buildRows = function() {

        var _ = this, a, b, c, newSlides, numOfSlides, originalSlides,slidesPerSection;

        newSlides = document.createDocumentFragment();
        originalSlides = _.$slider.children();

        if(_.options.rows > 1) {

            slidesPerSection = _.options.slidesPerRow * _.options.rows;
            numOfSlides = Math.ceil(
                originalSlides.length / slidesPerSection
            );

            for(a = 0; a < numOfSlides; a++){
                var slide = document.createElement('div');
                for(b = 0; b < _.options.rows; b++) {
                    var row = document.createElement('div');
                    for(c = 0; c < _.options.slidesPerRow; c++) {
                        var target = (a * slidesPerSection + ((b * _.options.slidesPerRow) + c));
                        if (originalSlides.get(target)) {
                            row.appendChild(originalSlides.get(target));
                        }
                    }
                    slide.appendChild(row);
                }
                newSlides.appendChild(slide);
            }

            _.$slider.empty().append(newSlides);
            _.$slider.children().children().children()
                .css({
                    'width':(100 / _.options.slidesPerRow) + '%',
                    'display': 'inline-block'
                });

        }

    };

    Slick.prototype.checkResponsive = function(initial, forceUpdate) {

        var _ = this,
            breakpoint, targetBreakpoint, respondToWidth, triggerBreakpoint = false;
        var sliderWidth = _.$slider.width();
        var windowWidth = window.innerWidth || $(window).width();

        if (_.respondTo === 'window') {
            respondToWidth = windowWidth;
        } else if (_.respondTo === 'slider') {
            respondToWidth = sliderWidth;
        } else if (_.respondTo === 'min') {
            respondToWidth = Math.min(windowWidth, sliderWidth);
        }

        if ( _.options.responsive &&
            _.options.responsive.length &&
            _.options.responsive !== null) {

            targetBreakpoint = null;

            for (breakpoint in _.breakpoints) {
                if (_.breakpoints.hasOwnProperty(breakpoint)) {
                    if (_.originalSettings.mobileFirst === false) {
                        if (respondToWidth < _.breakpoints[breakpoint]) {
                            targetBreakpoint = _.breakpoints[breakpoint];
                        }
                    } else {
                        if (respondToWidth > _.breakpoints[breakpoint]) {
                            targetBreakpoint = _.breakpoints[breakpoint];
                        }
                    }
                }
            }

            if (targetBreakpoint !== null) {
                if (_.activeBreakpoint !== null) {
                    if (targetBreakpoint !== _.activeBreakpoint || forceUpdate) {
                        _.activeBreakpoint =
                            targetBreakpoint;
                        if (_.breakpointSettings[targetBreakpoint] === 'unslick') {
                            _.unslick(targetBreakpoint);
                        } else {
                            _.options = $.extend({}, _.originalSettings,
                                _.breakpointSettings[
                                    targetBreakpoint]);
                            if (initial === true) {
                                _.currentSlide = _.options.initialSlide;
                            }
                            _.refresh(initial);
                        }
                        triggerBreakpoint = targetBreakpoint;
                    }
                } else {
                    _.activeBreakpoint = targetBreakpoint;
                    if (_.breakpointSettings[targetBreakpoint] === 'unslick') {
                        _.unslick(targetBreakpoint);
                    } else {
                        _.options = $.extend({}, _.originalSettings,
                            _.breakpointSettings[
                                targetBreakpoint]);
                        if (initial === true) {
                            _.currentSlide = _.options.initialSlide;
                        }
                        _.refresh(initial);
                    }
                    triggerBreakpoint = targetBreakpoint;
                }
            } else {
                if (_.activeBreakpoint !== null) {
                    _.activeBreakpoint = null;
                    _.options = _.originalSettings;
                    if (initial === true) {
                        _.currentSlide = _.options.initialSlide;
                    }
                    _.refresh(initial);
                    triggerBreakpoint = targetBreakpoint;
                }
            }

            // only trigger breakpoints during an actual break. not on initialize.
            if( !initial && triggerBreakpoint !== false ) {
                _.$slider.trigger('breakpoint', [_, triggerBreakpoint]);
            }
        }

    };

    Slick.prototype.changeSlide = function(event, dontAnimate) {

        var _ = this,
            $target = $(event.currentTarget),
            indexOffset, slideOffset, unevenOffset;

        // If target is a link, prevent default action.
        if($target.is('a')) {
            event.preventDefault();
        }

        // If target is not the <li> element (ie: a child), find the <li>.
        if(!$target.is('li')) {
            $target = $target.closest('li');
        }

        unevenOffset = (_.slideCount % _.options.slidesToScroll !== 0);
        indexOffset = unevenOffset ? 0 : (_.slideCount - _.currentSlide) % _.options.slidesToScroll;

        switch (event.data.message) {

            case 'previous':
                slideOffset = indexOffset === 0 ? _.options.slidesToScroll : _.options.slidesToShow - indexOffset;
                if (_.slideCount > _.options.slidesToShow) {
                    _.slideHandler(_.currentSlide - slideOffset, false, dontAnimate);
                }
                break;

            case 'next':
                slideOffset = indexOffset === 0 ? _.options.slidesToScroll : indexOffset;
                if (_.slideCount > _.options.slidesToShow) {
                    _.slideHandler(_.currentSlide + slideOffset, false, dontAnimate);
                }
                break;

            case 'index':
                var index = event.data.index === 0 ? 0 :
                event.data.index || $target.index() * _.options.slidesToScroll;

                _.slideHandler(_.checkNavigable(index), false, dontAnimate);
                $target.children().trigger('focus');
                break;

            default:
                return;
        }

    };

    Slick.prototype.checkNavigable = function(index) {

        var _ = this,
            navigables, prevNavigable;

        navigables = _.getNavigableIndexes();
        prevNavigable = 0;
        if (index > navigables[navigables.length - 1]) {
            index = navigables[navigables.length - 1];
        } else {
            for (var n in navigables) {
                if (index < navigables[n]) {
                    index = prevNavigable;
                    break;
                }
                prevNavigable = navigables[n];
            }
        }

        return index;
    };

    Slick.prototype.cleanUpEvents = function() {

        var _ = this;

        if (_.options.dots && _.$dots !== null) {

            $('li', _.$dots)
                .off('click.slick', _.changeSlide)
                .off('mouseenter.slick', $.proxy(_.interrupt, _, true))
                .off('mouseleave.slick', $.proxy(_.interrupt, _, false));

            if (_.options.accessibility === true) {
                _.$dots.off('keydown.slick', _.keyHandler);
            }
        }

        _.$slider.off('focus.slick blur.slick');

        if (_.options.arrows === true && _.slideCount > _.options.slidesToShow) {
            _.$prevArrow && _.$prevArrow.off('click.slick', _.changeSlide);
            _.$nextArrow && _.$nextArrow.off('click.slick', _.changeSlide);

            if (_.options.accessibility === true) {
                _.$prevArrow && _.$prevArrow.off('keydown.slick', _.keyHandler);
                _.$nextArrow && _.$nextArrow.off('keydown.slick', _.keyHandler);
            }
        }

        _.$list.off('touchstart.slick mousedown.slick', _.swipeHandler);
        _.$list.off('touchmove.slick mousemove.slick', _.swipeHandler);
        _.$list.off('touchend.slick mouseup.slick', _.swipeHandler);
        _.$list.off('touchcancel.slick mouseleave.slick', _.swipeHandler);

        _.$list.off('click.slick', _.clickHandler);

        $(document).off(_.visibilityChange, _.visibility);

        _.cleanUpSlideEvents();

        if (_.options.accessibility === true) {
            _.$list.off('keydown.slick', _.keyHandler);
        }

        if (_.options.focusOnSelect === true) {
            $(_.$slideTrack).children().off('click.slick', _.selectHandler);
        }

        $(window).off('orientationchange.slick.slick-' + _.instanceUid, _.orientationChange);

        $(window).off('resize.slick.slick-' + _.instanceUid, _.resize);

        $('[draggable!=true]', _.$slideTrack).off('dragstart', _.preventDefault);

        $(window).off('load.slick.slick-' + _.instanceUid, _.setPosition);

    };

    Slick.prototype.cleanUpSlideEvents = function() {

        var _ = this;

        _.$list.off('mouseenter.slick', $.proxy(_.interrupt, _, true));
        _.$list.off('mouseleave.slick', $.proxy(_.interrupt, _, false));

    };

    Slick.prototype.cleanUpRows = function() {

        var _ = this, originalSlides;

        if(_.options.rows > 1) {
            originalSlides = _.$slides.children().children();
            originalSlides.removeAttr('style');
            _.$slider.empty().append(originalSlides);
        }

    };

    Slick.prototype.clickHandler = function(event) {

        var _ = this;

        if (_.shouldClick === false) {
            event.stopImmediatePropagation();
            event.stopPropagation();
            event.preventDefault();
        }

    };

    Slick.prototype.destroy = function(refresh) {

        var _ = this;

        _.autoPlayClear();

        _.touchObject = {};

        _.cleanUpEvents();

        $('.slick-cloned', _.$slider).detach();

        if (_.$dots) {
            _.$dots.remove();
        }

        if ( _.$prevArrow && _.$prevArrow.length ) {

            _.$prevArrow
                .removeClass('slick-disabled slick-arrow slick-hidden')
                .removeAttr('aria-hidden aria-disabled tabindex')
                .css('display','');

            if ( _.htmlExpr.test( _.options.prevArrow )) {
                _.$prevArrow.remove();
            }
        }

        if ( _.$nextArrow && _.$nextArrow.length ) {

            _.$nextArrow
                .removeClass('slick-disabled slick-arrow slick-hidden')
                .removeAttr('aria-hidden aria-disabled tabindex')
                .css('display','');

            if ( _.htmlExpr.test( _.options.nextArrow )) {
                _.$nextArrow.remove();
            }
        }


        if (_.$slides) {

            _.$slides
                .removeClass('slick-slide slick-active slick-center slick-visible slick-current')
                .removeAttr('aria-hidden')
                .removeAttr('data-slick-index')
                .each(function(){
                    $(this).attr('style', $(this).data('originalStyling'));
                });

            _.$slideTrack.children(this.options.slide).detach();

            _.$slideTrack.detach();

            _.$list.detach();

            _.$slider.append(_.$slides);
        }

        _.cleanUpRows();

        _.$slider.removeClass('slick-slider');
        _.$slider.removeClass('slick-initialized');
        _.$slider.removeClass('slick-dotted');

        _.unslicked = true;

        if(!refresh) {
            _.$slider.trigger('destroy', [_]);
        }

    };

    Slick.prototype.disableTransition = function(slide) {

        var _ = this,
            transition = {};

        transition[_.transitionType] = '';

        if (_.options.fade === false) {
            _.$slideTrack.css(transition);
        } else {
            _.$slides.eq(slide).css(transition);
        }

    };

    Slick.prototype.fadeSlide = function(slideIndex, callback) {

        var _ = this;

        if (_.cssTransitions === false) {

            _.$slides.eq(slideIndex).css({
                zIndex: _.options.zIndex
            });

            _.$slides.eq(slideIndex).animate({
                opacity: 1
            }, _.options.speed, _.options.easing, callback);

        } else {

            _.applyTransition(slideIndex);

            _.$slides.eq(slideIndex).css({
                opacity: 1,
                zIndex: _.options.zIndex
            });

            if (callback) {
                setTimeout(function() {

                    _.disableTransition(slideIndex);

                    callback.call();
                }, _.options.speed);
            }

        }

    };

    Slick.prototype.fadeSlideOut = function(slideIndex) {

        var _ = this;

        if (_.cssTransitions === false) {

            _.$slides.eq(slideIndex).animate({
                opacity: 0,
                zIndex: _.options.zIndex - 2
            }, _.options.speed, _.options.easing);

        } else {

            _.applyTransition(slideIndex);

            _.$slides.eq(slideIndex).css({
                opacity: 0,
                zIndex: _.options.zIndex - 2
            });

        }

    };

    Slick.prototype.filterSlides = Slick.prototype.slickFilter = function(filter) {

        var _ = this;

        if (filter !== null) {

            _.$slidesCache = _.$slides;

            _.unload();

            _.$slideTrack.children(this.options.slide).detach();

            _.$slidesCache.filter(filter).appendTo(_.$slideTrack);

            _.reinit();

        }

    };

    Slick.prototype.focusHandler = function() {

        var _ = this;

        _.$slider
            .off('focus.slick blur.slick')
            .on('focus.slick blur.slick', '*', function(event) {

                event.stopImmediatePropagation();
                var $sf = $(this);

                setTimeout(function() {

                    if( _.options.pauseOnFocus ) {
                        _.focussed = $sf.is(':focus');
                        _.autoPlay();
                    }

                }, 0);

            });
    };

    Slick.prototype.getCurrent = Slick.prototype.slickCurrentSlide = function() {

        var _ = this;
        return _.currentSlide;

    };

    Slick.prototype.getDotCount = function() {

        var _ = this;

        var breakPoint = 0;
        var counter = 0;
        var pagerQty = 0;

        if (_.options.infinite === true) {
            if (_.slideCount <= _.options.slidesToShow) {
                ++pagerQty;
            } else {
                while (breakPoint < _.slideCount) {
                    ++pagerQty;
                    breakPoint = counter + _.options.slidesToScroll;
                    counter += _.options.slidesToScroll <= _.options.slidesToShow ? _.options.slidesToScroll : _.options.slidesToShow;
                }
            }
        } else if (_.options.centerMode === true) {
            pagerQty = _.slideCount;
        } else if(!_.options.asNavFor) {
            pagerQty = 1 + Math.ceil((_.slideCount - _.options.slidesToShow) / _.options.slidesToScroll);
        }else {
            while (breakPoint < _.slideCount) {
                ++pagerQty;
                breakPoint = counter + _.options.slidesToScroll;
                counter += _.options.slidesToScroll <= _.options.slidesToShow ? _.options.slidesToScroll : _.options.slidesToShow;
            }
        }

        return pagerQty - 1;

    };

    Slick.prototype.getLeft = function(slideIndex) {

        var _ = this,
            targetLeft,
            verticalHeight,
            verticalOffset = 0,
            targetSlide,
            coef;

        _.slideOffset = 0;
        verticalHeight = _.$slides.first().outerHeight(true);

        if (_.options.infinite === true) {
            if (_.slideCount > _.options.slidesToShow) {
                _.slideOffset = (_.slideWidth * _.options.slidesToShow) * -1;
                coef = -1

                if (_.options.vertical === true && _.options.centerMode === true) {
                    if (_.options.slidesToShow === 2) {
                        coef = -1.5;
                    } else if (_.options.slidesToShow === 1) {
                        coef = -2
                    }
                }
                verticalOffset = (verticalHeight * _.options.slidesToShow) * coef;
            }
            if (_.slideCount % _.options.slidesToScroll !== 0) {
                if (slideIndex + _.options.slidesToScroll > _.slideCount && _.slideCount > _.options.slidesToShow) {
                    if (slideIndex > _.slideCount) {
                        _.slideOffset = ((_.options.slidesToShow - (slideIndex - _.slideCount)) * _.slideWidth) * -1;
                        verticalOffset = ((_.options.slidesToShow - (slideIndex - _.slideCount)) * verticalHeight) * -1;
                    } else {
                        _.slideOffset = ((_.slideCount % _.options.slidesToScroll) * _.slideWidth) * -1;
                        verticalOffset = ((_.slideCount % _.options.slidesToScroll) * verticalHeight) * -1;
                    }
                }
            }
        } else {
            if (slideIndex + _.options.slidesToShow > _.slideCount) {
                _.slideOffset = ((slideIndex + _.options.slidesToShow) - _.slideCount) * _.slideWidth;
                verticalOffset = ((slideIndex + _.options.slidesToShow) - _.slideCount) * verticalHeight;
            }
        }

        if (_.slideCount <= _.options.slidesToShow) {
            _.slideOffset = 0;
            verticalOffset = 0;
        }

        if (_.options.centerMode === true && _.slideCount <= _.options.slidesToShow) {
            _.slideOffset = ((_.slideWidth * Math.floor(_.options.slidesToShow)) / 2) - ((_.slideWidth * _.slideCount) / 2);
        } else if (_.options.centerMode === true && _.options.infinite === true) {
            _.slideOffset += _.slideWidth * Math.floor(_.options.slidesToShow / 2) - _.slideWidth;
        } else if (_.options.centerMode === true) {
            _.slideOffset = 0;
            _.slideOffset += _.slideWidth * Math.floor(_.options.slidesToShow / 2);
        }

        if (_.options.vertical === false) {
            targetLeft = ((slideIndex * _.slideWidth) * -1) + _.slideOffset;
        } else {
            targetLeft = ((slideIndex * verticalHeight) * -1) + verticalOffset;
        }

        if (_.options.variableWidth === true) {

            if (_.slideCount <= _.options.slidesToShow || _.options.infinite === false) {
                targetSlide = _.$slideTrack.children('.slick-slide').eq(slideIndex);
            } else {
                targetSlide = _.$slideTrack.children('.slick-slide').eq(slideIndex + _.options.slidesToShow);
            }

            if (_.options.rtl === true) {
                if (targetSlide[0]) {
                    targetLeft = (_.$slideTrack.width() - targetSlide[0].offsetLeft - targetSlide.width()) * -1;
                } else {
                    targetLeft =  0;
                }
            } else {
                targetLeft = targetSlide[0] ? targetSlide[0].offsetLeft * -1 : 0;
            }

            if (_.options.centerMode === true) {
                if (_.slideCount <= _.options.slidesToShow || _.options.infinite === false) {
                    targetSlide = _.$slideTrack.children('.slick-slide').eq(slideIndex);
                } else {
                    targetSlide = _.$slideTrack.children('.slick-slide').eq(slideIndex + _.options.slidesToShow + 1);
                }

                if (_.options.rtl === true) {
                    if (targetSlide[0]) {
                        targetLeft = (_.$slideTrack.width() - targetSlide[0].offsetLeft - targetSlide.width()) * -1;
                    } else {
                        targetLeft =  0;
                    }
                } else {
                    targetLeft = targetSlide[0] ? targetSlide[0].offsetLeft * -1 : 0;
                }

                targetLeft += (_.$list.width() - targetSlide.outerWidth()) / 2;
            }
        }

        return targetLeft;

    };

    Slick.prototype.getOption = Slick.prototype.slickGetOption = function(option) {

        var _ = this;

        return _.options[option];

    };

    Slick.prototype.getNavigableIndexes = function() {

        var _ = this,
            breakPoint = 0,
            counter = 0,
            indexes = [],
            max;

        if (_.options.infinite === false) {
            max = _.slideCount;
        } else {
            breakPoint = _.options.slidesToScroll * -1;
            counter = _.options.slidesToScroll * -1;
            max = _.slideCount * 2;
        }

        while (breakPoint < max) {
            indexes.push(breakPoint);
            breakPoint = counter + _.options.slidesToScroll;
            counter += _.options.slidesToScroll <= _.options.slidesToShow ? _.options.slidesToScroll : _.options.slidesToShow;
        }

        return indexes;

    };

    Slick.prototype.getSlick = function() {

        return this;

    };

    Slick.prototype.getSlideCount = function() {

        var _ = this,
            slidesTraversed, swipedSlide, centerOffset;

        centerOffset = _.options.centerMode === true ? _.slideWidth * Math.floor(_.options.slidesToShow / 2) : 0;

        if (_.options.swipeToSlide === true) {
            _.$slideTrack.find('.slick-slide').each(function(index, slide) {
                if (slide.offsetLeft - centerOffset + ($(slide).outerWidth() / 2) > (_.swipeLeft * -1)) {
                    swipedSlide = slide;
                    return false;
                }
            });

            slidesTraversed = Math.abs($(swipedSlide).attr('data-slick-index') - _.currentSlide) || 1;

            return slidesTraversed;

        } else {
            return _.options.slidesToScroll;
        }

    };

    Slick.prototype.goTo = Slick.prototype.slickGoTo = function(slide, dontAnimate) {

        var _ = this;

        _.changeSlide({
            data: {
                message: 'index',
                index: parseInt(slide)
            }
        }, dontAnimate);

    };

    Slick.prototype.init = function(creation) {

        var _ = this;

        if (!$(_.$slider).hasClass('slick-initialized')) {

            $(_.$slider).addClass('slick-initialized');

            _.buildRows();
            _.buildOut();
            _.setProps();
            _.startLoad();
            _.loadSlider();
            _.initializeEvents();
            _.updateArrows();
            _.updateDots();
            _.checkResponsive(true);
            _.focusHandler();

        }

        if (creation) {
            _.$slider.trigger('init', [_]);
        }

        if (_.options.accessibility === true) {
            _.initADA();
        }

        if ( _.options.autoplay ) {

            _.paused = false;
            _.autoPlay();

        }

    };

    Slick.prototype.initADA = function() {
        var _ = this,
            numDotGroups = Math.ceil(_.slideCount / _.options.slidesToShow),
            tabControlIndexes = _.getNavigableIndexes().filter(function(val) {
                return (val >= 0) && (val < _.slideCount);
            });

        _.$slides.add(_.$slideTrack.find('.slick-cloned')).attr({
            'aria-hidden': 'true',
            'tabindex': '-1'
        }).find('a, input, button, select').attr({
            'tabindex': '-1'
        });

        if (_.$dots !== null) {
            _.$slides.not(_.$slideTrack.find('.slick-cloned')).each(function(i) {
                var slideControlIndex = tabControlIndexes.indexOf(i);

                $(this).attr({
                    'role': 'tabpanel',
                    'id': 'slick-slide' + _.instanceUid + i,
                    'tabindex': -1
                });

                if (slideControlIndex !== -1) {
                    $(this).attr({
                        'aria-describedby': 'slick-slide-control' + _.instanceUid + slideControlIndex
                    });
                }
            });

            _.$dots.attr('role', 'tablist').find('li').each(function(i) {
                var mappedSlideIndex = tabControlIndexes[i];

                $(this).attr({
                    'role': 'presentation'
                });

                $(this).find('button').first().attr({
                    'role': 'tab',
                    'id': 'slick-slide-control' + _.instanceUid + i,
                    'aria-controls': 'slick-slide' + _.instanceUid + mappedSlideIndex,
                    'aria-label': (i + 1) + ' of ' + numDotGroups,
                    'aria-selected': null,
                    'tabindex': '-1'
                });

            }).eq(_.currentSlide).find('button').attr({
                'aria-selected': 'true',
                'tabindex': '0'
            }).end();
        }

        for (var i=_.currentSlide, max=i+_.options.slidesToShow; i < max; i++) {
            _.$slides.eq(i).attr('tabindex', 0);
        }

        _.activateADA();

    };

    Slick.prototype.initArrowEvents = function() {

        var _ = this;

        if (_.options.arrows === true && _.slideCount > _.options.slidesToShow) {
            _.$prevArrow
                .off('click.slick')
                .on('click.slick', {
                    message: 'previous'
                }, _.changeSlide);
            _.$nextArrow
                .off('click.slick')
                .on('click.slick', {
                    message: 'next'
                }, _.changeSlide);

            if (_.options.accessibility === true) {
                _.$prevArrow.on('keydown.slick', _.keyHandler);
                _.$nextArrow.on('keydown.slick', _.keyHandler);
            }
        }

    };

    Slick.prototype.initDotEvents = function() {

        var _ = this;

        if (_.options.dots === true) {
            $('li', _.$dots).on('click.slick', {
                message: 'index'
            }, _.changeSlide);

            if (_.options.accessibility === true) {
                _.$dots.on('keydown.slick', _.keyHandler);
            }
        }

        if ( _.options.dots === true && _.options.pauseOnDotsHover === true ) {

            $('li', _.$dots)
                .on('mouseenter.slick', $.proxy(_.interrupt, _, true))
                .on('mouseleave.slick', $.proxy(_.interrupt, _, false));

        }

    };

    Slick.prototype.initSlideEvents = function() {

        var _ = this;

        if ( _.options.pauseOnHover ) {

            _.$list.on('mouseenter.slick', $.proxy(_.interrupt, _, true));
            _.$list.on('mouseleave.slick', $.proxy(_.interrupt, _, false));

        }

    };

    Slick.prototype.initializeEvents = function() {

        var _ = this;

        _.initArrowEvents();

        _.initDotEvents();
        _.initSlideEvents();

        _.$list.on('touchstart.slick mousedown.slick', {
            action: 'start'
        }, _.swipeHandler);
        _.$list.on('touchmove.slick mousemove.slick', {
            action: 'move'
        }, _.swipeHandler);
        _.$list.on('touchend.slick mouseup.slick', {
            action: 'end'
        }, _.swipeHandler);
        _.$list.on('touchcancel.slick mouseleave.slick', {
            action: 'end'
        }, _.swipeHandler);

        _.$list.on('click.slick', _.clickHandler);

        $(document).on(_.visibilityChange, $.proxy(_.visibility, _));

        if (_.options.accessibility === true) {
            _.$list.on('keydown.slick', _.keyHandler);
        }

        if (_.options.focusOnSelect === true) {
            $(_.$slideTrack).children().on('click.slick', _.selectHandler);
        }

        $(window).on('orientationchange.slick.slick-' + _.instanceUid, $.proxy(_.orientationChange, _));

        $(window).on('resize.slick.slick-' + _.instanceUid, $.proxy(_.resize, _));

        $('[draggable!=true]', _.$slideTrack).on('dragstart', _.preventDefault);

        $(window).on('load.slick.slick-' + _.instanceUid, _.setPosition);
        $(_.setPosition);

    };

    Slick.prototype.initUI = function() {

        var _ = this;

        if (_.options.arrows === true && _.slideCount > _.options.slidesToShow) {

            _.$prevArrow.show();
            _.$nextArrow.show();

        }

        if (_.options.dots === true && _.slideCount > _.options.slidesToShow) {

            _.$dots.show();

        }

    };

    Slick.prototype.keyHandler = function(event) {

        var _ = this;
        //Dont slide if the cursor is inside the form fields and arrow keys are pressed
        if(!event.target.tagName.match('TEXTAREA|INPUT|SELECT')) {
            if (event.keyCode === 37 && _.options.accessibility === true) {
                _.changeSlide({
                    data: {
                        message: _.options.rtl === true ? 'next' :  'previous'
                    }
                });
            } else if (event.keyCode === 39 && _.options.accessibility === true) {
                _.changeSlide({
                    data: {
                        message: _.options.rtl === true ? 'previous' : 'next'
                    }
                });
            }
        }

    };

    Slick.prototype.lazyLoad = function() {

        var _ = this,
            loadRange, cloneRange, rangeStart, rangeEnd;

        function loadImages(imagesScope) {

            $('img[data-lazy]', imagesScope).each(function() {

                var image = $(this),
                    imageSource = $(this).attr('data-lazy'),
                    imageSrcSet = $(this).attr('data-srcset'),
                    imageSizes  = $(this).attr('data-sizes') || _.$slider.attr('data-sizes'),
                    imageToLoad = document.createElement('img');

                imageToLoad.onload = function() {

                    image
                        .animate({ opacity: 0 }, 100, function() {

                            if (imageSrcSet) {
                                image
                                    .attr('srcset', imageSrcSet );

                                if (imageSizes) {
                                    image
                                        .attr('sizes', imageSizes );
                                }
                            }

                            image
                                .attr('src', imageSource)
                                .animate({ opacity: 1 }, 200, function() {
                                    image
                                        .removeAttr('data-lazy data-srcset data-sizes')
                                        .removeClass('slick-loading');
                                });
                            _.$slider.trigger('lazyLoaded', [_, image, imageSource]);
                        });

                };

                imageToLoad.onerror = function() {

                    image
                        .removeAttr( 'data-lazy' )
                        .removeClass( 'slick-loading' )
                        .addClass( 'slick-lazyload-error' );

                    _.$slider.trigger('lazyLoadError', [ _, image, imageSource ]);

                };

                imageToLoad.src = imageSource;

            });

        }

        if (_.options.centerMode === true) {
            if (_.options.infinite === true) {
                rangeStart = _.currentSlide + (_.options.slidesToShow / 2 + 1);
                rangeEnd = rangeStart + _.options.slidesToShow + 2;
            } else {
                rangeStart = Math.max(0, _.currentSlide - (_.options.slidesToShow / 2 + 1));
                rangeEnd = 2 + (_.options.slidesToShow / 2 + 1) + _.currentSlide;
            }
        } else {
            rangeStart = _.options.infinite ? _.options.slidesToShow + _.currentSlide : _.currentSlide;
            rangeEnd = Math.ceil(rangeStart + _.options.slidesToShow);
            if (_.options.fade === true) {
                if (rangeStart > 0) rangeStart--;
                if (rangeEnd <= _.slideCount) rangeEnd++;
            }
        }

        loadRange = _.$slider.find('.slick-slide').slice(rangeStart, rangeEnd);

        if (_.options.lazyLoad === 'anticipated') {
            var prevSlide = rangeStart - 1,
                nextSlide = rangeEnd,
                $slides = _.$slider.find('.slick-slide');

            for (var i = 0; i < _.options.slidesToScroll; i++) {
                if (prevSlide < 0) prevSlide = _.slideCount - 1;
                loadRange = loadRange.add($slides.eq(prevSlide));
                loadRange = loadRange.add($slides.eq(nextSlide));
                prevSlide--;
                nextSlide++;
            }
        }

        loadImages(loadRange);

        if (_.slideCount <= _.options.slidesToShow) {
            cloneRange = _.$slider.find('.slick-slide');
            loadImages(cloneRange);
        } else
        if (_.currentSlide >= _.slideCount - _.options.slidesToShow) {
            cloneRange = _.$slider.find('.slick-cloned').slice(0, _.options.slidesToShow);
            loadImages(cloneRange);
        } else if (_.currentSlide === 0) {
            cloneRange = _.$slider.find('.slick-cloned').slice(_.options.slidesToShow * -1);
            loadImages(cloneRange);
        }

    };

    Slick.prototype.loadSlider = function() {

        var _ = this;

        _.setPosition();

        _.$slideTrack.css({
            opacity: 1
        });

        _.$slider.removeClass('slick-loading');

        _.initUI();

        if (_.options.lazyLoad === 'progressive') {
            _.progressiveLazyLoad();
        }

    };

    Slick.prototype.next = Slick.prototype.slickNext = function() {

        var _ = this;

        _.changeSlide({
            data: {
                message: 'next'
            }
        });

    };

    Slick.prototype.orientationChange = function() {

        var _ = this;

        _.checkResponsive();
        _.setPosition();

    };

    Slick.prototype.pause = Slick.prototype.slickPause = function() {

        var _ = this;

        _.autoPlayClear();
        _.paused = true;

    };

    Slick.prototype.play = Slick.prototype.slickPlay = function() {

        var _ = this;

        _.autoPlay();
        _.options.autoplay = true;
        _.paused = false;
        _.focussed = false;
        _.interrupted = false;

    };

    Slick.prototype.postSlide = function(index) {

        var _ = this;

        if( !_.unslicked ) {

            _.$slider.trigger('afterChange', [_, index]);

            _.animating = false;

            if (_.slideCount > _.options.slidesToShow) {
                _.setPosition();
            }

            _.swipeLeft = null;

            if ( _.options.autoplay ) {
                _.autoPlay();
            }

            if (_.options.accessibility === true) {
                _.initADA();

                if (_.options.focusOnChange) {
                    var $currentSlide = $(_.$slides.get(_.currentSlide));
                    $currentSlide.attr('tabindex', 0).focus();
                }
            }

        }

    };

    Slick.prototype.prev = Slick.prototype.slickPrev = function() {

        var _ = this;

        _.changeSlide({
            data: {
                message: 'previous'
            }
        });

    };

    Slick.prototype.preventDefault = function(event) {

        event.preventDefault();

    };

    Slick.prototype.progressiveLazyLoad = function( tryCount ) {

        tryCount = tryCount || 1;

        var _ = this,
            $imgsToLoad = $( 'img[data-lazy]', _.$slider ),
            image,
            imageSource,
            imageSrcSet,
            imageSizes,
            imageToLoad;

        if ( $imgsToLoad.length ) {

            image = $imgsToLoad.first();
            imageSource = image.attr('data-lazy');
            imageSrcSet = image.attr('data-srcset');
            imageSizes  = image.attr('data-sizes') || _.$slider.attr('data-sizes');
            imageToLoad = document.createElement('img');

            imageToLoad.onload = function() {

                if (imageSrcSet) {
                    image
                        .attr('srcset', imageSrcSet );

                    if (imageSizes) {
                        image
                            .attr('sizes', imageSizes );
                    }
                }

                image
                    .attr( 'src', imageSource )
                    .removeAttr('data-lazy data-srcset data-sizes')
                    .removeClass('slick-loading');

                if ( _.options.adaptiveHeight === true ) {
                    _.setPosition();
                }

                _.$slider.trigger('lazyLoaded', [ _, image, imageSource ]);
                _.progressiveLazyLoad();

            };

            imageToLoad.onerror = function() {

                if ( tryCount < 3 ) {

                    /**
                     * try to load the image 3 times,
                     * leave a slight delay so we don't get
                     * servers blocking the request.
                     */
                    setTimeout( function() {
                        _.progressiveLazyLoad( tryCount + 1 );
                    }, 500 );

                } else {

                    image
                        .removeAttr( 'data-lazy' )
                        .removeClass( 'slick-loading' )
                        .addClass( 'slick-lazyload-error' );

                    _.$slider.trigger('lazyLoadError', [ _, image, imageSource ]);

                    _.progressiveLazyLoad();

                }

            };

            imageToLoad.src = imageSource;

        } else {

            _.$slider.trigger('allImagesLoaded', [ _ ]);

        }

    };

    Slick.prototype.refresh = function( initializing ) {

        var _ = this, currentSlide, lastVisibleIndex;

        lastVisibleIndex = _.slideCount - _.options.slidesToShow;

        // in non-infinite sliders, we don't want to go past the
        // last visible index.
        if( !_.options.infinite && ( _.currentSlide > lastVisibleIndex )) {
            _.currentSlide = lastVisibleIndex;
        }

        // if less slides than to show, go to start.
        if ( _.slideCount <= _.options.slidesToShow ) {
            _.currentSlide = 0;

        }

        currentSlide = _.currentSlide;

        _.destroy(true);

        $.extend(_, _.initials, { currentSlide: currentSlide });

        _.init();

        if( !initializing ) {

            _.changeSlide({
                data: {
                    message: 'index',
                    index: currentSlide
                }
            }, false);

        }

    };

    Slick.prototype.registerBreakpoints = function() {

        var _ = this, breakpoint, currentBreakpoint, l,
            responsiveSettings = _.options.responsive || null;

        if ( $.type(responsiveSettings) === 'array' && responsiveSettings.length ) {

            _.respondTo = _.options.respondTo || 'window';

            for ( breakpoint in responsiveSettings ) {

                l = _.breakpoints.length-1;

                if (responsiveSettings.hasOwnProperty(breakpoint)) {
                    currentBreakpoint = responsiveSettings[breakpoint].breakpoint;

                    // loop through the breakpoints and cut out any existing
                    // ones with the same breakpoint number, we don't want dupes.
                    while( l >= 0 ) {
                        if( _.breakpoints[l] && _.breakpoints[l] === currentBreakpoint ) {
                            _.breakpoints.splice(l,1);
                        }
                        l--;
                    }

                    _.breakpoints.push(currentBreakpoint);
                    _.breakpointSettings[currentBreakpoint] = responsiveSettings[breakpoint].settings;

                }

            }

            _.breakpoints.sort(function(a, b) {
                return ( _.options.mobileFirst ) ? a-b : b-a;
            });

        }

    };

    Slick.prototype.reinit = function() {

        var _ = this;

        _.$slides =
            _.$slideTrack
                .children(_.options.slide)
                .addClass('slick-slide');

        _.slideCount = _.$slides.length;

        if (_.currentSlide >= _.slideCount && _.currentSlide !== 0) {
            _.currentSlide = _.currentSlide - _.options.slidesToScroll;
        }

        if (_.slideCount <= _.options.slidesToShow) {
            _.currentSlide = 0;
        }

        _.registerBreakpoints();

        _.setProps();
        _.setupInfinite();
        _.buildArrows();
        _.updateArrows();
        _.initArrowEvents();
        _.buildDots();
        _.updateDots();
        _.initDotEvents();
        _.cleanUpSlideEvents();
        _.initSlideEvents();

        _.checkResponsive(false, true);

        if (_.options.focusOnSelect === true) {
            $(_.$slideTrack).children().on('click.slick', _.selectHandler);
        }

        _.setSlideClasses(typeof _.currentSlide === 'number' ? _.currentSlide : 0);

        _.setPosition();
        _.focusHandler();

        _.paused = !_.options.autoplay;
        _.autoPlay();

        _.$slider.trigger('reInit', [_]);

    };

    Slick.prototype.resize = function() {

        var _ = this;

        if ($(window).width() !== _.windowWidth) {
            clearTimeout(_.windowDelay);
            _.windowDelay = window.setTimeout(function() {
                _.windowWidth = $(window).width();
                _.checkResponsive();
                if( !_.unslicked ) { _.setPosition(); }
            }, 50);
        }
    };

    Slick.prototype.removeSlide = Slick.prototype.slickRemove = function(index, removeBefore, removeAll) {

        var _ = this;

        if (typeof(index) === 'boolean') {
            removeBefore = index;
            index = removeBefore === true ? 0 : _.slideCount - 1;
        } else {
            index = removeBefore === true ? --index : index;
        }

        if (_.slideCount < 1 || index < 0 || index > _.slideCount - 1) {
            return false;
        }

        _.unload();

        if (removeAll === true) {
            _.$slideTrack.children().remove();
        } else {
            _.$slideTrack.children(this.options.slide).eq(index).remove();
        }

        _.$slides = _.$slideTrack.children(this.options.slide);

        _.$slideTrack.children(this.options.slide).detach();

        _.$slideTrack.append(_.$slides);

        _.$slidesCache = _.$slides;

        _.reinit();

    };

    Slick.prototype.setCSS = function(position) {

        var _ = this,
            positionProps = {},
            x, y;

        if (_.options.rtl === true) {
            position = -position;
        }
        x = _.positionProp == 'left' ? Math.ceil(position) + 'px' : '0px';
        y = _.positionProp == 'top' ? Math.ceil(position) + 'px' : '0px';

        positionProps[_.positionProp] = position;

        if (_.transformsEnabled === false) {
            _.$slideTrack.css(positionProps);
        } else {
            positionProps = {};
            if (_.cssTransitions === false) {
                positionProps[_.animType] = 'translate(' + x + ', ' + y + ')';
                _.$slideTrack.css(positionProps);
            } else {
                positionProps[_.animType] = 'translate3d(' + x + ', ' + y + ', 0px)';
                _.$slideTrack.css(positionProps);
            }
        }

    };

    Slick.prototype.setDimensions = function() {

        var _ = this;

        if (_.options.vertical === false) {
            if (_.options.centerMode === true) {
                _.$list.css({
                    padding: ('0px ' + _.options.centerPadding)
                });
            }
        } else {
            _.$list.height(_.$slides.first().outerHeight(true) * _.options.slidesToShow);
            if (_.options.centerMode === true) {
                _.$list.css({
                    padding: (_.options.centerPadding + ' 0px')
                });
            }
        }

        _.listWidth = _.$list.width();
        _.listHeight = _.$list.height();


        if (_.options.vertical === false && _.options.variableWidth === false) {
            _.slideWidth = Math.ceil(_.listWidth / _.options.slidesToShow);
            _.$slideTrack.width(Math.ceil((_.slideWidth * _.$slideTrack.children('.slick-slide').length)));

        } else if (_.options.variableWidth === true) {
            _.$slideTrack.width(5000 * _.slideCount);
        } else {
            _.slideWidth = Math.ceil(_.listWidth);
            _.$slideTrack.height(Math.ceil((_.$slides.first().outerHeight(true) * _.$slideTrack.children('.slick-slide').length)));
        }

        var offset = _.$slides.first().outerWidth(true) - _.$slides.first().width();
        if (_.options.variableWidth === false) _.$slideTrack.children('.slick-slide').width(_.slideWidth - offset);

    };

    Slick.prototype.setFade = function() {

        var _ = this,
            targetLeft;

        _.$slides.each(function(index, element) {
            targetLeft = (_.slideWidth * index) * -1;
            if (_.options.rtl === true) {
                $(element).css({
                    position: 'relative',
                    right: targetLeft,
                    top: 0,
                    zIndex: _.options.zIndex - 2,
                    opacity: 0
                });
            } else {
                $(element).css({
                    position: 'relative',
                    left: targetLeft,
                    top: 0,
                    zIndex: _.options.zIndex - 2,
                    opacity: 0
                });
            }
        });

        _.$slides.eq(_.currentSlide).css({
            zIndex: _.options.zIndex - 1,
            opacity: 1
        });

    };

    Slick.prototype.setHeight = function() {

        var _ = this;

        if (_.options.slidesToShow === 1 && _.options.adaptiveHeight === true && _.options.vertical === false) {
            var targetHeight = _.$slides.eq(_.currentSlide).outerHeight(true);
            _.$list.css('height', targetHeight);
        }

    };

    Slick.prototype.setOption =
        Slick.prototype.slickSetOption = function() {

            /**
             * accepts arguments in format of:
             *
             *  - for changing a single option's value:
             *     .slick("setOption", option, value, refresh )
             *
             *  - for changing a set of responsive options:
             *     .slick("setOption", 'responsive', [{}, ...], refresh )
             *
             *  - for updating multiple values at once (not responsive)
             *     .slick("setOption", { 'option': value, ... }, refresh )
             */

            var _ = this, l, item, option, value, refresh = false, type;

            if( $.type( arguments[0] ) === 'object' ) {

                option =  arguments[0];
                refresh = arguments[1];
                type = 'multiple';

            } else if ( $.type( arguments[0] ) === 'string' ) {

                option =  arguments[0];
                value = arguments[1];
                refresh = arguments[2];

                if ( arguments[0] === 'responsive' && $.type( arguments[1] ) === 'array' ) {

                    type = 'responsive';

                } else if ( typeof arguments[1] !== 'undefined' ) {

                    type = 'single';

                }

            }

            if ( type === 'single' ) {

                _.options[option] = value;


            } else if ( type === 'multiple' ) {

                $.each( option , function( opt, val ) {

                    _.options[opt] = val;

                });


            } else if ( type === 'responsive' ) {

                for ( item in value ) {

                    if( $.type( _.options.responsive ) !== 'array' ) {

                        _.options.responsive = [ value[item] ];

                    } else {

                        l = _.options.responsive.length-1;

                        // loop through the responsive object and splice out duplicates.
                        while( l >= 0 ) {

                            if( _.options.responsive[l].breakpoint === value[item].breakpoint ) {

                                _.options.responsive.splice(l,1);

                            }

                            l--;

                        }

                        _.options.responsive.push( value[item] );

                    }

                }

            }

            if ( refresh ) {

                _.unload();
                _.reinit();

            }

        };

    Slick.prototype.setPosition = function() {

        var _ = this;

        _.setDimensions();

        _.setHeight();

        if (_.options.fade === false) {
            _.setCSS(_.getLeft(_.currentSlide));
        } else {
            _.setFade();
        }

        _.$slider.trigger('setPosition', [_]);

    };

    Slick.prototype.setProps = function() {

        var _ = this,
            bodyStyle = document.body.style;

        _.positionProp = _.options.vertical === true ? 'top' : 'left';

        if (_.positionProp === 'top') {
            _.$slider.addClass('slick-vertical');
        } else {
            _.$slider.removeClass('slick-vertical');
        }

        if (bodyStyle.WebkitTransition !== undefined ||
            bodyStyle.MozTransition !== undefined ||
            bodyStyle.msTransition !== undefined) {
            if (_.options.useCSS === true) {
                _.cssTransitions = true;
            }
        }

        if ( _.options.fade ) {
            if ( typeof _.options.zIndex === 'number' ) {
                if( _.options.zIndex < 3 ) {
                    _.options.zIndex = 3;
                }
            } else {
                _.options.zIndex = _.defaults.zIndex;
            }
        }

        if (bodyStyle.OTransform !== undefined) {
            _.animType = 'OTransform';
            _.transformType = '-o-transform';
            _.transitionType = 'OTransition';
            if (bodyStyle.perspectiveProperty === undefined && bodyStyle.webkitPerspective === undefined) _.animType = false;
        }
        if (bodyStyle.MozTransform !== undefined) {
            _.animType = 'MozTransform';
            _.transformType = '-moz-transform';
            _.transitionType = 'MozTransition';
            if (bodyStyle.perspectiveProperty === undefined && bodyStyle.MozPerspective === undefined) _.animType = false;
        }
        if (bodyStyle.webkitTransform !== undefined) {
            _.animType = 'webkitTransform';
            _.transformType = '-webkit-transform';
            _.transitionType = 'webkitTransition';
            if (bodyStyle.perspectiveProperty === undefined && bodyStyle.webkitPerspective === undefined) _.animType = false;
        }
        if (bodyStyle.msTransform !== undefined) {
            _.animType = 'msTransform';
            _.transformType = '-ms-transform';
            _.transitionType = 'msTransition';
            if (bodyStyle.msTransform === undefined) _.animType = false;
        }
        if (bodyStyle.transform !== undefined && _.animType !== false) {
            _.animType = 'transform';
            _.transformType = 'transform';
            _.transitionType = 'transition';
        }
        _.transformsEnabled = _.options.useTransform && (_.animType !== null && _.animType !== false);
    };


    Slick.prototype.setSlideClasses = function(index) {

        var _ = this,
            centerOffset, allSlides, indexOffset, remainder;

        allSlides = _.$slider
            .find('.slick-slide')
            .removeClass('slick-active slick-center slick-current')
            .attr('aria-hidden', 'true');

        _.$slides
            .eq(index)
            .addClass('slick-current');

        if (_.options.centerMode === true) {

            var evenCoef = _.options.slidesToShow % 2 === 0 ? 1 : 0;

            centerOffset = Math.floor(_.options.slidesToShow / 2);

            if (_.options.infinite === true) {

                if (index >= centerOffset && index <= (_.slideCount - 1) - centerOffset) {
                    _.$slides
                        .slice(index - centerOffset + evenCoef, index + centerOffset + 1)
                        .addClass('slick-active')
                        .attr('aria-hidden', 'false');

                } else {

                    indexOffset = _.options.slidesToShow + index;
                    allSlides
                        .slice(indexOffset - centerOffset + 1 + evenCoef, indexOffset + centerOffset + 2)
                        .addClass('slick-active')
                        .attr('aria-hidden', 'false');

                }

                if (index === 0) {

                    allSlides
                        .eq(allSlides.length - 1 - _.options.slidesToShow)
                        .addClass('slick-center');

                } else if (index === _.slideCount - 1) {

                    allSlides
                        .eq(_.options.slidesToShow)
                        .addClass('slick-center');

                }

            }

            _.$slides
                .eq(index)
                .addClass('slick-center');

        } else {

            if (index >= 0 && index <= (_.slideCount - _.options.slidesToShow)) {

                _.$slides
                    .slice(index, index + _.options.slidesToShow)
                    .addClass('slick-active')
                    .attr('aria-hidden', 'false');

            } else if (allSlides.length <= _.options.slidesToShow) {

                allSlides
                    .addClass('slick-active')
                    .attr('aria-hidden', 'false');

            } else {

                remainder = _.slideCount % _.options.slidesToShow;
                indexOffset = _.options.infinite === true ? _.options.slidesToShow + index : index;

                if (_.options.slidesToShow == _.options.slidesToScroll && (_.slideCount - index) < _.options.slidesToShow) {

                    allSlides
                        .slice(indexOffset - (_.options.slidesToShow - remainder), indexOffset + remainder)
                        .addClass('slick-active')
                        .attr('aria-hidden', 'false');

                } else {

                    allSlides
                        .slice(indexOffset, indexOffset + _.options.slidesToShow)
                        .addClass('slick-active')
                        .attr('aria-hidden', 'false');

                }

            }

        }

        if (_.options.lazyLoad === 'ondemand' || _.options.lazyLoad === 'anticipated') {
            _.lazyLoad();
        }
    };

    Slick.prototype.setupInfinite = function() {

        var _ = this,
            i, slideIndex, infiniteCount;

        if (_.options.fade === true) {
            _.options.centerMode = false;
        }

        if (_.options.infinite === true && _.options.fade === false) {

            slideIndex = null;

            if (_.slideCount > _.options.slidesToShow) {

                if (_.options.centerMode === true) {
                    infiniteCount = _.options.slidesToShow + 1;
                } else {
                    infiniteCount = _.options.slidesToShow;
                }

                for (i = _.slideCount; i > (_.slideCount -
                infiniteCount); i -= 1) {
                    slideIndex = i - 1;
                    $(_.$slides[slideIndex]).clone(true).attr('id', '')
                        .attr('data-slick-index', slideIndex - _.slideCount)
                        .prependTo(_.$slideTrack).addClass('slick-cloned');
                }
                for (i = 0; i < infiniteCount  + _.slideCount; i += 1) {
                    slideIndex = i;
                    $(_.$slides[slideIndex]).clone(true).attr('id', '')
                        .attr('data-slick-index', slideIndex + _.slideCount)
                        .appendTo(_.$slideTrack).addClass('slick-cloned');
                }
                _.$slideTrack.find('.slick-cloned').find('[id]').each(function() {
                    $(this).attr('id', '');
                });

            }

        }

    };

    Slick.prototype.interrupt = function( toggle ) {

        var _ = this;

        if( !toggle ) {
            _.autoPlay();
        }
        _.interrupted = toggle;

    };

    Slick.prototype.selectHandler = function(event) {

        var _ = this;

        var targetElement =
            $(event.target).is('.slick-slide') ?
                $(event.target) :
                $(event.target).parents('.slick-slide');

        var index = parseInt(targetElement.attr('data-slick-index'));

        if (!index) index = 0;

        if (_.slideCount <= _.options.slidesToShow) {

            _.slideHandler(index, false, true);
            return;

        }

        _.slideHandler(index);

    };

    Slick.prototype.slideHandler = function(index, sync, dontAnimate) {

        var targetSlide, animSlide, oldSlide, slideLeft, targetLeft = null,
            _ = this, navTarget;

        sync = sync || false;

        if (_.animating === true && _.options.waitForAnimate === true) {
            return;
        }

        if (_.options.fade === true && _.currentSlide === index) {
            return;
        }

        if (sync === false) {
            _.asNavFor(index);
        }

        targetSlide = index;
        targetLeft = _.getLeft(targetSlide);
        slideLeft = _.getLeft(_.currentSlide);

        _.currentLeft = _.swipeLeft === null ? slideLeft : _.swipeLeft;

        if (_.options.infinite === false && _.options.centerMode === false && (index < 0 || index > _.getDotCount() * _.options.slidesToScroll)) {
            if (_.options.fade === false) {
                targetSlide = _.currentSlide;
                if (dontAnimate !== true) {
                    _.animateSlide(slideLeft, function() {
                        _.postSlide(targetSlide);
                    });
                } else {
                    _.postSlide(targetSlide);
                }
            }
            return;
        } else if (_.options.infinite === false && _.options.centerMode === true && (index < 0 || index > (_.slideCount - _.options.slidesToScroll))) {
            if (_.options.fade === false) {
                targetSlide = _.currentSlide;
                if (dontAnimate !== true) {
                    _.animateSlide(slideLeft, function() {
                        _.postSlide(targetSlide);
                    });
                } else {
                    _.postSlide(targetSlide);
                }
            }
            return;
        }

        if ( _.options.autoplay ) {
            clearInterval(_.autoPlayTimer);
        }

        if (targetSlide < 0) {
            if (_.slideCount % _.options.slidesToScroll !== 0) {
                animSlide = _.slideCount - (_.slideCount % _.options.slidesToScroll);
            } else {
                animSlide = _.slideCount + targetSlide;
            }
        } else if (targetSlide >= _.slideCount) {
            if (_.slideCount % _.options.slidesToScroll !== 0) {
                animSlide = 0;
            } else {
                animSlide = targetSlide - _.slideCount;
            }
        } else {
            animSlide = targetSlide;
        }

        _.animating = true;

        _.$slider.trigger('beforeChange', [_, _.currentSlide, animSlide]);

        oldSlide = _.currentSlide;
        _.currentSlide = animSlide;

        _.setSlideClasses(_.currentSlide);

        if ( _.options.asNavFor ) {

            navTarget = _.getNavTarget();
            navTarget = navTarget.slick('getSlick');

            if ( navTarget.slideCount <= navTarget.options.slidesToShow ) {
                navTarget.setSlideClasses(_.currentSlide);
            }

        }

        _.updateDots();
        _.updateArrows();

        if (_.options.fade === true) {
            if (dontAnimate !== true) {

                _.fadeSlideOut(oldSlide);

                _.fadeSlide(animSlide, function() {
                    _.postSlide(animSlide);
                });

            } else {
                _.postSlide(animSlide);
            }
            _.animateHeight();
            return;
        }

        if (dontAnimate !== true) {
            _.animateSlide(targetLeft, function() {
                _.postSlide(animSlide);
            });
        } else {
            _.postSlide(animSlide);
        }

    };

    Slick.prototype.startLoad = function() {

        var _ = this;

        if (_.options.arrows === true && _.slideCount > _.options.slidesToShow) {

            _.$prevArrow.hide();
            _.$nextArrow.hide();

        }

        if (_.options.dots === true && _.slideCount > _.options.slidesToShow) {

            _.$dots.hide();

        }


        _.$slider.addClass('slick-loading');

    };

    Slick.prototype.swipeDirection = function() {

        var xDist, yDist, r, swipeAngle, _ = this;

        xDist = _.touchObject.startX - _.touchObject.curX;
        yDist = _.touchObject.startY - _.touchObject.curY;
        r = Math.atan2(yDist, xDist);

        swipeAngle = Math.round(r * 180 / Math.PI);
        if (swipeAngle < 0) {
            swipeAngle = 360 - Math.abs(swipeAngle);
        }

        if ((swipeAngle <= 45) && (swipeAngle >= 0)) {
            return (_.options.rtl === false ? 'left' : 'right');
        }
        if ((swipeAngle <= 360) && (swipeAngle >= 315)) {
            return (_.options.rtl === false ? 'left' : 'right');
        }
        if ((swipeAngle >= 135) && (swipeAngle <= 225)) {
            return (_.options.rtl === false ? 'right' : 'left');
        }
        if (_.options.verticalSwiping === true) {
            if ((swipeAngle >= 35) && (swipeAngle <= 135)) {
                return 'down';
            } else {
                return 'up';
            }
        }

        return 'vertical';

    };

    Slick.prototype.swipeEnd = function(event) {

        var _ = this,
            slideCount,
            direction;

        _.dragging = false;
        _.swiping = false;

        if (_.scrolling) {
            _.scrolling = false;
            return false;
        }

        _.interrupted = false;
        _.shouldClick = ( _.touchObject.swipeLength > 10 ) ? false : true;

        if ( _.touchObject.curX === undefined ) {
            return false;
        }

        if ( _.touchObject.edgeHit === true ) {
            _.$slider.trigger('edge', [_, _.swipeDirection() ]);
        }

        if ( _.touchObject.swipeLength >= _.touchObject.minSwipe ) {

            direction = _.swipeDirection();

            switch ( direction ) {

                case 'left':
                case 'down':

                    slideCount =
                        _.options.swipeToSlide ?
                            _.checkNavigable( _.currentSlide + _.getSlideCount() ) :
                        _.currentSlide + _.getSlideCount();

                    _.currentDirection = 0;

                    break;

                case 'right':
                case 'up':

                    slideCount =
                        _.options.swipeToSlide ?
                            _.checkNavigable( _.currentSlide - _.getSlideCount() ) :
                        _.currentSlide - _.getSlideCount();

                    _.currentDirection = 1;

                    break;

                default:


            }

            if( direction != 'vertical' ) {

                _.slideHandler( slideCount );
                _.touchObject = {};
                _.$slider.trigger('swipe', [_, direction ]);

            }

        } else {

            if ( _.touchObject.startX !== _.touchObject.curX ) {

                _.slideHandler( _.currentSlide );
                _.touchObject = {};

            }

        }

    };

    Slick.prototype.swipeHandler = function(event) {

        var _ = this;

        if ((_.options.swipe === false) || ('ontouchend' in document && _.options.swipe === false)) {
            return;
        } else if (_.options.draggable === false && event.type.indexOf('mouse') !== -1) {
            return;
        }

        _.touchObject.fingerCount = event.originalEvent && event.originalEvent.touches !== undefined ?
            event.originalEvent.touches.length : 1;

        _.touchObject.minSwipe = _.listWidth / _.options
                .touchThreshold;

        if (_.options.verticalSwiping === true) {
            _.touchObject.minSwipe = _.listHeight / _.options
                    .touchThreshold;
        }

        switch (event.data.action) {

            case 'start':
                _.swipeStart(event);
                break;

            case 'move':
                _.swipeMove(event);
                break;

            case 'end':
                _.swipeEnd(event);
                break;

        }

    };

    Slick.prototype.swipeMove = function(event) {

        var _ = this,
            edgeWasHit = false,
            curLeft, swipeDirection, swipeLength, positionOffset, touches, verticalSwipeLength;

        touches = event.originalEvent !== undefined ? event.originalEvent.touches : null;

        if (!_.dragging || _.scrolling || touches && touches.length !== 1) {
            return false;
        }

        curLeft = _.getLeft(_.currentSlide);

        _.touchObject.curX = touches !== undefined ? touches[0].pageX : event.clientX;
        _.touchObject.curY = touches !== undefined ? touches[0].pageY : event.clientY;

        _.touchObject.swipeLength = Math.round(Math.sqrt(
            Math.pow(_.touchObject.curX - _.touchObject.startX, 2)));

        verticalSwipeLength = Math.round(Math.sqrt(
            Math.pow(_.touchObject.curY - _.touchObject.startY, 2)));

        if (!_.options.verticalSwiping && !_.swiping && verticalSwipeLength > 4) {
            _.scrolling = true;
            return false;
        }

        if (_.options.verticalSwiping === true) {
            _.touchObject.swipeLength = verticalSwipeLength;
        }

        swipeDirection = _.swipeDirection();

        if (event.originalEvent !== undefined && _.touchObject.swipeLength > 4) {
            _.swiping = true;
            event.preventDefault();
        }

        positionOffset = (_.options.rtl === false ? 1 : -1) * (_.touchObject.curX > _.touchObject.startX ? 1 : -1);
        if (_.options.verticalSwiping === true) {
            positionOffset = _.touchObject.curY > _.touchObject.startY ? 1 : -1;
        }


        swipeLength = _.touchObject.swipeLength;

        _.touchObject.edgeHit = false;

        if (_.options.infinite === false) {
            if ((_.currentSlide === 0 && swipeDirection === 'right') || (_.currentSlide >= _.getDotCount() && swipeDirection === 'left')) {
                swipeLength = _.touchObject.swipeLength * _.options.edgeFriction;
                _.touchObject.edgeHit = true;
            }
        }

        if (_.options.vertical === false) {
            _.swipeLeft = curLeft + swipeLength * positionOffset;
        } else {
            _.swipeLeft = curLeft + (swipeLength * (_.$list.height() / _.listWidth)) * positionOffset;
        }
        if (_.options.verticalSwiping === true) {
            _.swipeLeft = curLeft + swipeLength * positionOffset;
        }

        if (_.options.fade === true || _.options.touchMove === false) {
            return false;
        }

        if (_.animating === true) {
            _.swipeLeft = null;
            return false;
        }

        _.setCSS(_.swipeLeft);

    };

    Slick.prototype.swipeStart = function(event) {

        var _ = this,
            touches;

        _.interrupted = true;

        if (_.touchObject.fingerCount !== 1 || _.slideCount <= _.options.slidesToShow) {
            _.touchObject = {};
            return false;
        }

        if (event.originalEvent !== undefined && event.originalEvent.touches !== undefined) {
            touches = event.originalEvent.touches[0];
        }

        _.touchObject.startX = _.touchObject.curX = touches !== undefined ? touches.pageX : event.clientX;
        _.touchObject.startY = _.touchObject.curY = touches !== undefined ? touches.pageY : event.clientY;

        _.dragging = true;

    };

    Slick.prototype.unfilterSlides = Slick.prototype.slickUnfilter = function() {

        var _ = this;

        if (_.$slidesCache !== null) {

            _.unload();

            _.$slideTrack.children(this.options.slide).detach();

            _.$slidesCache.appendTo(_.$slideTrack);

            _.reinit();

        }

    };

    Slick.prototype.unload = function() {

        var _ = this;

        $('.slick-cloned', _.$slider).remove();

        if (_.$dots) {
            _.$dots.remove();
        }

        if (_.$prevArrow && _.htmlExpr.test(_.options.prevArrow)) {
            _.$prevArrow.remove();
        }

        if (_.$nextArrow && _.htmlExpr.test(_.options.nextArrow)) {
            _.$nextArrow.remove();
        }

        _.$slides
            .removeClass('slick-slide slick-active slick-visible slick-current')
            .attr('aria-hidden', 'true')
            .css('width', '');

    };

    Slick.prototype.unslick = function(fromBreakpoint) {

        var _ = this;
        _.$slider.trigger('unslick', [_, fromBreakpoint]);
        _.destroy();

    };

    Slick.prototype.updateArrows = function() {

        var _ = this,
            centerOffset;

        centerOffset = Math.floor(_.options.slidesToShow / 2);

        if ( _.options.arrows === true &&
            _.slideCount > _.options.slidesToShow &&
            !_.options.infinite ) {

            _.$prevArrow.removeClass('slick-disabled').attr('aria-disabled', 'false');
            _.$nextArrow.removeClass('slick-disabled').attr('aria-disabled', 'false');

            if (_.currentSlide === 0) {

                _.$prevArrow.addClass('slick-disabled').attr('aria-disabled', 'true');
                _.$nextArrow.removeClass('slick-disabled').attr('aria-disabled', 'false');

            } else if (_.currentSlide >= _.slideCount - _.options.slidesToShow && _.options.centerMode === false) {

                _.$nextArrow.addClass('slick-disabled').attr('aria-disabled', 'true');
                _.$prevArrow.removeClass('slick-disabled').attr('aria-disabled', 'false');

            } else if (_.currentSlide >= _.slideCount - 1 && _.options.centerMode === true) {

                _.$nextArrow.addClass('slick-disabled').attr('aria-disabled', 'true');
                _.$prevArrow.removeClass('slick-disabled').attr('aria-disabled', 'false');

            }

        }

    };

    Slick.prototype.updateDots = function() {

        var _ = this;

        if (_.$dots !== null) {

            _.$dots
                .find('li')
                .removeClass('slick-active')
                .end();

            _.$dots
                .find('li')
                .eq(Math.floor(_.currentSlide / _.options.slidesToScroll))
                .addClass('slick-active');

        }

    };

    Slick.prototype.visibility = function() {

        var _ = this;

        if ( _.options.autoplay ) {

            if ( document[_.hidden] ) {

                _.interrupted = true;

            } else {

                _.interrupted = false;

            }

        }

    };

    $.fn.slick = function() {
        var _ = this,
            opt = arguments[0],
            args = Array.prototype.slice.call(arguments, 1),
            l = _.length,
            i,
            ret;
        for (i = 0; i < l; i++) {
            if (typeof opt == 'object' || typeof opt == 'undefined')
                _[i].slick = new Slick(_[i], opt);
            else
                ret = _[i].slick[opt].apply(_[i].slick, args);
            if (typeof ret != 'undefined') return ret;
        }
        return _;
    };

}));

(function($) {
    $.fn.ellipsis = function(options) {

        // default option
        var defaults = {
            'row' : 1, // show rows
            'onlyFullWords': false, // set to true to avoid cutting the text in the middle of a word
            'char' : '...', // ellipsis
            'callback': function() {},
            'position': 'tail' // middle, tail
        };

        options = $.extend(defaults, options);

        this.each(function() {
            // get element text
            var $this = $(this);
            var text = $this.text();
            var origText = text;
            var origLength = origText.length;
            var origHeight = $this.height();

            // get height
            $this.text('a');
            var lineHeight =  parseFloat($this.css("lineHeight"), 10);
            var rowHeight = $this.height();
            var gapHeight =lineHeight > rowHeight ? (lineHeight - rowHeight) : 0;
            var targetHeight = gapHeight * (options.row - 1) + rowHeight * options.row;

            if (origHeight <= targetHeight) {
                $this.text(text);
                $this.css("height", 34);
                options.callback.call(this);
                return;
            }

            var start = 1, length = 0;
            var end = text.length;

            if(options.position === 'tail') {
                while (start < end) { // Binary search for max length
                    length = Math.ceil((start + end) / 2);

                    $this.text(text.slice(0, length) + options['char']);

                    if ($this.height() <= targetHeight) {
                        start = length;
                    } else {
                        end = length - 1;
                    }
                }

                text = text.slice(0, start);

                if (options.onlyFullWords) {
                    text = text.replace(/[\u00AD\w\uac00-\ud7af]+$/, ''); // remove fragment of the last word together with possible soft-hyphen characters
                }
                text += options['char'];

            }else if(options.position === 'middle') {

                var sliceLength = 0;
                while (start < end) { // Binary search for max length
                    length = Math.ceil((start + end) / 2);
                    sliceLength = Math.max(origLength - length, 0);

                    $this.text(
                        origText.slice(0, Math.floor((origLength - sliceLength) / 2)) +
                        options['char'] +
                        origText.slice(Math.floor((origLength + sliceLength) / 2), origLength)
                    );

                    if ($this.height() <= targetHeight) {
                        start = length;
                    } else {
                        end = length - 1;
                    }
                }

                sliceLength = Math.max(origLength - start, 0);
                var head = origText.slice(0, Math.floor((origLength - sliceLength) / 2));
                var tail = origText.slice(Math.floor((origLength + sliceLength) / 2), origLength);

                if (options.onlyFullWords) {
                    // remove fragment of the last or first word together with possible soft-hyphen characters
                    head = head.replace(/[\u00AD\w\uac00-\ud7af]+$/, '');
                }

                text = head + options['char'] + tail;
            }

            $this.css("height", 34);

            $this.text(text);

            options.callback.call(this);
        });

        return this;
    };
}) (jQuery);
/*!
 * jsoneditor.js
 */
!function(e, t) {
    "object" == typeof exports && "object" == typeof module ? module.exports = t() :"function" == typeof define && define.amd ? define([], t) :"object" == typeof exports ? exports.JSONEditor = t() :e.JSONEditor = t();
}(this, function() {
    return function(e) {
        function t(i) {
            if (n[i]) return n[i].exports;
            var o = n[i] = {
                exports:{},
                id:i,
                loaded:!1
            };
            return e[i].call(o.exports, o, o.exports, t), o.loaded = !0, o.exports;
        }
        var n = {};
        return t.m = e, t.c = n, t.p = "", t(0);
    }([ function(e, t, n) {
        "use strict";
        function i(e, t, n) {
            if (!(this instanceof i)) throw new Error('JSONEditor constructor called without "new".');
            var o = a.getInternetExplorerVersion();
            if (-1 != o && o < 9) throw new Error("Unsupported browser, IE9 or newer required. Please install the newest version of your browser.");
            t && (t.error && (console.warn('Option "error" has been renamed to "onError"'),
                t.onError = t.error, delete t.error), t.change && (console.warn('Option "change" has been renamed to "onChange"'),
                t.onChange = t.change, delete t.change), t.editable && (console.warn('Option "editable" has been renamed to "onEditable"'),
                t.onEditable = t.editable, delete t.editable), t.onChangeJSON && ("text" === t.mode || "code" === t.mode || t.modes && (-1 !== t.modes.indexOf("text") || -1 !== t.modes.indexOf("code"))) && console.warn('Option "onChangeJSON" is not applicable to modes "text" and "code". Use "onChangeText" or "onChange" instead.'),
            t && Object.keys(t).forEach(function(e) {
                -1 === i.VALID_OPTIONS.indexOf(e) && console.warn('Unknown option "' + e + '". This option will be ignored');
            })), arguments.length && this._create(e, t, n);
        }
        var o;
        try {
            o = n(!function() {
                var e = new Error('Cannot find module "ajv"');
                throw e.code = "MODULE_NOT_FOUND", e;
            }());
        } catch (e) {}
        var r = n(1), s = n(21), a = n(6);
        i.modes = {}, i.prototype.DEBOUNCE_INTERVAL = 150, i.VALID_OPTIONS = [ "ajv", "schema", "schemaRefs", "templates", "ace", "theme", "autocomplete", "onChange", "onChangeJSON", "onChangeText", "onEditable", "onError", "onModeChange", "onSelectionChange", "onTextSelectionChange", "escapeUnicode", "history", "search", "mode", "modes", "name", "indentation", "sortObjectKeys", "navigationBar", "statusBar", "languages", "language" ],
            i.prototype._create = function(e, t, n) {
                this.container = e, this.options = t || {}, this.json = n || {};
                var i = this.options.mode || this.options.modes && this.options.modes[0] || "tree";
                this.setMode(i);
            }, i.prototype.destroy = function() {}, i.prototype.set = function(e) {
            this.json = e;
        }, i.prototype.get = function() {
            return this.json;
        }, i.prototype.setText = function(e) {
            this.json = a.parse(e);
        }, i.prototype.getText = function() {
            return JSON.stringify(this.json);
        }, i.prototype.setName = function(e) {
            this.options || (this.options = {}), this.options.name = e;
        }, i.prototype.getName = function() {
            return this.options && this.options.name;
        }, i.prototype.setMode = function(e) {
            if (e !== this.options.mode || !this.create) {
                var t, n, o = this.container, r = a.extend({}, this.options), s = r.mode;
                r.mode = e;
                var l = i.modes[e];
                if (!l) throw new Error('Unknown mode "' + r.mode + '"');
                try {
                    var c = "text" == l.data;
                    if (n = this.getName(), t = this[c ? "getText" :"get"](), this.destroy(), a.clear(this),
                            a.extend(this, l.mixin), this.create(o, r), this.setName(n), this[c ? "setText" :"set"](t),
                        "function" == typeof l.load) try {
                        l.load.call(this);
                    } catch (e) {
                        console.error(e);
                    }
                    if ("function" == typeof r.onModeChange && e !== s) try {
                        r.onModeChange(e, s);
                    } catch (e) {
                        console.error(e);
                    }
                } catch (e) {
                    this._onError(e);
                }
            }
        }, i.prototype.getMode = function() {
            return this.options.mode;
        }, i.prototype._onError = function(e) {
            if (!this.options || "function" != typeof this.options.onError) throw e;
            this.options.onError(e);
        }, i.prototype.setSchema = function(e, t) {
            if (e) {
                var n;
                try {
                    n = this.options.ajv || o({
                        allErrors:!0,
                        verbose:!0
                    });
                } catch (e) {
                    console.warn("Failed to create an instance of Ajv, JSON Schema validation is not available. Please use a JSONEditor bundle including Ajv, or pass an instance of Ajv as via the configuration option `ajv`.");
                }
                if (n) {
                    if (t) {
                        for (var i in t) n.removeSchema(i), t[i] && n.addSchema(t[i], i);
                        this.options.schemaRefs = t;
                    }
                    this.validateSchema = n.compile(e), this.options.schema = e, this.validate();
                }
                this.refresh();
            } else this.validateSchema = null, this.options.schema = null, this.options.schemaRefs = null,
                this.validate(), this.refresh();
        }, i.prototype.validate = function() {}, i.prototype.refresh = function() {}, i.registerMode = function(e) {
            var t, n;
            if (a.isArray(e)) for (t = 0; t < e.length; t++) i.registerMode(e[t]); else {
                if (!("mode" in e)) throw new Error('Property "mode" missing');
                if (!("mixin" in e)) throw new Error('Property "mixin" missing');
                if (!("data" in e)) throw new Error('Property "data" missing');
                var o = e.mode;
                if (o in i.modes) throw new Error('Mode "' + o + '" already registered');
                if ("function" != typeof e.mixin.create) throw new Error('Required function "create" missing on mixin');
                var r = [ "setMode", "registerMode", "modes" ];
                for (t = 0; t < r.length; t++) if ((n = r[t]) in e.mixin) throw new Error('Reserved property "' + n + '" not allowed in mixin');
                i.modes[o] = e;
            }
        }, i.registerMode(r), i.registerMode(s), e.exports = i;
    }, function(e, t, n) {
        "use strict";
        var i = n(2), o = n(3), r = n(4), s = n(5), a = n(9), l = n(10), c = n(19), h = n(6), d = n(20), u = n(15), p = n(17), f = n(8).translate, m = n(8).setLanguages, g = n(8).setLanguage, v = document.body, y = {};
        y.create = function(e, t) {
            if (!e) throw new Error("No container element provided.");
            this.container = e, this.dom = {}, this.highlighter = new i(), this.selection = void 0,
                this.multiselection = {
                    nodes:[]
                }, this.validateSchema = null, this.errorNodes = [], this.node = null, this.focusTarget = null,
                this._setOptions(t), t.autocomplete && (this.autocomplete = new d(t.autocomplete)),
            this.options.history && "view" !== this.options.mode && (this.history = new o(this)),
                this._createFrame(), this._createTable();
        }, y.destroy = function() {
            this.frame && this.container && this.frame.parentNode == this.container && (this.container.removeChild(this.frame),
                this.frame = null), this.container = null, this.dom = null, this.clear(), this.node = null,
                this.focusTarget = null, this.selection = null, this.multiselection = null, this.errorNodes = null,
                this.validateSchema = null, this._debouncedValidate = null, this.history && (this.history.destroy(),
                this.history = null), this.searchBox && (this.searchBox.destroy(), this.searchBox = null),
            this.modeSwitcher && (this.modeSwitcher.destroy(), this.modeSwitcher = null);
        }, y._setOptions = function(e) {
            if (this.options = {
                    search:!0,
                    history:!0,
                    mode:"tree",
                    name:void 0,
                    schema:null,
                    schemaRefs:null,
                    autocomplete:null,
                    navigationBar:!0,
                    onSelectionChange:null
                }, e) for (var t in e) e.hasOwnProperty(t) && (this.options[t] = e[t]);
            this.setSchema(this.options.schema, this.options.schemaRefs), this._debouncedValidate = h.debounce(this.validate.bind(this), this.DEBOUNCE_INTERVAL),
            e.onSelectionChange && this.onSelectionChange(e.onSelectionChange), m(this.options.languages),
                g(this.options.language);
        }, y.set = function(e) {
            if (e instanceof Function || void 0 === e) this.clear(); else {
                this.content.removeChild(this.table);
                var t = {
                    field:this.options.name,
                    value:e
                }, n = new l(this, t);
                this._setRoot(n), this.validate();
                this.node.expand(!1), this.content.appendChild(this.table);
            }
            this.history && this.history.clear(), this.searchBox && this.searchBox.clear();
        }, y.update = function(e) {
            if (!this.node.deepEqual(e)) {
                var t = this.getSelection();
                if (this.onChangeDisabled = !0, this.node.update(e), this.onChangeDisabled = !1,
                        this.validate(), this.searchBox && !this.searchBox.isEmpty() && this.searchBox.forceSearch(),
                    t && t.start && t.end) {
                    var n = this.node.findNodeByPath(t.start.path), i = this.node.findNodeByPath(t.end.path);
                    n && i ? this.setSelection(t.start, t.end) :this.setSelection({}, {});
                } else this.setSelection({}, {});
            }
        }, y.get = function() {
            if (this.focusTarget) {
                var e = l.getNodeFromTarget(this.focusTarget);
                e && e.blur();
            }
            return this.node ? this.node.getValue() :void 0;
        }, y.getText = function() {
            return JSON.stringify(this.get());
        }, y.setText = function(e) {
            try {
                this.set(h.parse(e));
            } catch (n) {
                var t = h.sanitize(e);
                this.set(h.parse(t));
            }
        }, y.updateText = function(e) {
            try {
                this.update(h.parse(e));
            } catch (n) {
                var t = h.sanitize(e);
                this.update(h.parse(t));
            }
        }, y.setName = function(e) {
            this.options.name = e, this.node && this.node.updateField(this.options.name);
        }, y.getName = function() {
            return this.options.name;
        }, y.focus = function() {
            var e = this.scrollableContent.querySelector("[contenteditable=true]");
            e ? e.focus() :this.node.dom.expand ? this.node.dom.expand.focus() :this.node.dom.menu ? this.node.dom.menu.focus() :(e = this.frame.querySelector("button")) && e.focus();
        }, y.clear = function() {
            this.node && (this.node.hide(), delete this.node), this.treePath && this.treePath.reset();
        }, y._setRoot = function(e) {
            this.clear(), this.node = e, this.tbody.appendChild(e.getDom());
        }, y.search = function(e) {
            var t;
            return this.node ? (this.content.removeChild(this.table), t = this.node.search(e),
                this.content.appendChild(this.table)) :t = [], t;
        }, y.expandAll = function() {
            this.node && (this.content.removeChild(this.table), this.node.expand(), this.content.appendChild(this.table));
        }, y.collapseAll = function() {
            this.node && (this.content.removeChild(this.table), this.node.collapse(), this.content.appendChild(this.table));
        }, y._onAction = function(e, t) {
            this.history && this.history.add(e, t), this._onChange();
        }, y._onChange = function() {
            if (!this.onChangeDisabled) {
                if (this._debouncedValidate(), this.options.onChange) try {
                    this.options.onChange();
                } catch (e) {
                    console.error("Error in onChange callback: ", e);
                }
                if (this.options.onChangeJSON) try {
                    this.options.onChangeJSON(this.get());
                } catch (e) {
                    console.error("Error in onChangeJSON callback: ", e);
                }
                if (this.options.onChangeText) try {
                    this.options.onChangeText(this.getText());
                } catch (e) {
                    console.error("Error in onChangeText callback: ", e);
                }
            }
        }, y.validate = function() {
            this.errorNodes && this.errorNodes.forEach(function(e) {
                e.setError(null);
            });
            var e = this.node;
            if (e) {
                var t = e.validate(), n = [];
                if (this.validateSchema) {
                    this.validateSchema(e.getValue()) || (n = this.validateSchema.errors.map(function(e) {
                        return h.improveSchemaError(e);
                    }).map(function(t) {
                        return {
                            node:e.findNode(t.dataPath),
                            error:t
                        };
                    }).filter(function(e) {
                        return null != e.node;
                    }));
                }
                var i = t.concat(n), o = i.reduce(function(e, t) {
                    return t.node.findParents().filter(function(t) {
                        return !e.some(function(e) {
                            return e[0] === t;
                        });
                    }).map(function(e) {
                        return [ e, t.node ];
                    }).concat(e);
                }, []);
                this.errorNodes = o.map(function(e) {
                    return {
                        node:e[0],
                        child:e[1],
                        error:{
                            message:"object" === e[0].type ? "Contains invalid properties" :"Contains invalid items"
                        }
                    };
                }).concat(i).map(function(e) {
                    return e.node.setError(e.error, e.child), e.node;
                });
            }
        }, y.refresh = function() {
            this.node && this.node.updateDom({
                recurse:!0
            });
        }, y.startAutoScroll = function(e) {
            var t = this, n = this.scrollableContent, i = h.getAbsoluteTop(n), o = n.clientHeight, r = i + o;
            e < i + 24 && n.scrollTop > 0 ? this.autoScrollStep = (i + 24 - e) / 3 :e > r - 24 && o + n.scrollTop < n.scrollHeight ? this.autoScrollStep = (r - 24 - e) / 3 :this.autoScrollStep = void 0,
                this.autoScrollStep ? this.autoScrollTimer || (this.autoScrollTimer = setInterval(function() {
                    t.autoScrollStep ? n.scrollTop -= t.autoScrollStep :t.stopAutoScroll();
                }, 50)) :this.stopAutoScroll();
        }, y.stopAutoScroll = function() {
            this.autoScrollTimer && (clearTimeout(this.autoScrollTimer), delete this.autoScrollTimer),
            this.autoScrollStep && delete this.autoScrollStep;
        }, y.setDomSelection = function(e) {
            if (e) if ("scrollTop" in e && this.scrollableContent && (this.scrollableContent.scrollTop = e.scrollTop),
                    e.paths) {
                var t = this, n = e.paths.map(function(e) {
                    return t.node.findNodeByInternalPath(e);
                });
                this.select(n);
            } else {
                var i = e.path ? this.node.findNodeByInternalPath(e.path) :null, o = i && e.domName ? i.dom[e.domName] :null;
                if (e.range && o) {
                    var r = Object.assign({}, e.range, {
                        container:o
                    });
                    h.setSelectionOffset(r);
                } else i && i.focus();
            }
        }, y.getDomSelection = function() {
            var e = l.getNodeFromTarget(this.focusTarget), t = this.focusTarget, n = e ? Object.keys(e.dom).find(function(n) {
                return e.dom[n] === t;
            }) :null, i = h.getSelectionOffset();
            return i && "DIV" !== i.container.nodeName && (i = null), i && i.container !== t && (i = null),
            i && delete i.container, {
                path:e ? e.getInternalPath() :null,
                domName:n,
                range:i,
                paths:this.multiselection.length > 0 ? this.multiselection.nodes.map(function(e) {
                    return e.getInternalPath();
                }) :null,
                scrollTop:this.scrollableContent ? this.scrollableContent.scrollTop :0
            };
        }, y.scrollTo = function(e, t) {
            var n = this.scrollableContent;
            if (n) {
                var i = this;
                i.animateTimeout && (clearTimeout(i.animateTimeout), delete i.animateTimeout), i.animateCallback && (i.animateCallback(!1),
                    delete i.animateCallback);
                var o = n.clientHeight, r = n.scrollHeight - o, s = Math.min(Math.max(e - o / 4, 0), r), a = function() {
                    var e = n.scrollTop, o = s - e;
                    Math.abs(o) > 3 ? (n.scrollTop += o / 3, i.animateCallback = t, i.animateTimeout = setTimeout(a, 50)) :(t && t(!0),
                        n.scrollTop = s, delete i.animateTimeout, delete i.animateCallback);
                };
                a();
            } else t && t(!1);
        }, y._createFrame = function() {
            function e(e) {
                t._onEvent && t._onEvent(e);
            }
            this.frame = document.createElement("div"), this.frame.className = "jsoneditor jsoneditor-mode-" + this.options.mode,
                this.container.appendChild(this.frame);
            var t = this;
            this.frame.onclick = function(t) {
                var n = t.target;
                e(t), "BUTTON" == n.nodeName && t.preventDefault();
            }, this.frame.oninput = e, this.frame.onchange = e, this.frame.onkeydown = e, this.frame.onkeyup = e,
                this.frame.oncut = e, this.frame.onpaste = e, this.frame.onmousedown = e, this.frame.onmouseup = e,
                this.frame.onmouseover = e, this.frame.onmouseout = e, h.addEventListener(this.frame, "focus", e, !0),
                h.addEventListener(this.frame, "blur", e, !0), this.frame.onfocusin = e, this.frame.onfocusout = e,
                this.menu = document.createElement("div"), this.menu.className = "jsoneditor-menu",
                this.frame.appendChild(this.menu);
            var n = document.createElement("button");
            n.type = "button", n.className = "jsoneditor-expand-all", n.title = f("expandAll"),
                n.onclick = function() {
                    t.expandAll();
                }, this.menu.appendChild(n);
            var i = document.createElement("button");
            i.type = "button", i.title = f("collapseAll"), i.className = "jsoneditor-collapse-all",
                i.onclick = function() {
                    t.collapseAll();
                }, this.menu.appendChild(i);
            var o = document.createElement("button");
            o.type = "button", o.className = "jsoneditor-sort", o.title = f("sortTitleShort"),
                o.onclick = function() {
                    var e = t.options.modalAnchor || v;
                    u(t.node, e);
                }, this.menu.appendChild(o);
            var s = document.createElement("button");
            if (s.type = "button", s.title = f("transformTitleShort"), s.className = "jsoneditor-transform",
                    s.onclick = function() {
                        var e = t.options.modalAnchor || v;
                        p(t.node, e);
                    }, this.menu.appendChild(s), this.history) {
                var l = document.createElement("button");
                l.type = "button", l.className = "jsoneditor-undo jsoneditor-separator", l.title = f("undo"),
                    l.onclick = function() {
                        t._onUndo();
                    }, this.menu.appendChild(l), this.dom.undo = l;
                var d = document.createElement("button");
                d.type = "button", d.className = "jsoneditor-redo", d.title = f("redo"), d.onclick = function() {
                    t._onRedo();
                }, this.menu.appendChild(d), this.dom.redo = d, this.history.onChange = function() {
                    l.disabled = !t.history.canUndo(), d.disabled = !t.history.canRedo();
                }, this.history.onChange();
            }
            if (this.options && this.options.modes && this.options.modes.length) {
                var m = this;
                this.modeSwitcher = new c(this.menu, this.options.modes, this.options.mode, function(e) {
                    m.modeSwitcher.destroy(), m.setMode(e), m.modeSwitcher.focus();
                });
            }
            this.options.search && (this.searchBox = new r(this, this.menu)), this.options.navigationBar && (this.navBar = document.createElement("div"),
                this.navBar.className = "jsoneditor-navigation-bar nav-bar-empty", this.frame.appendChild(this.navBar),
                this.treePath = new a(this.navBar), this.treePath.onSectionSelected(this._onTreePathSectionSelected.bind(this)),
                this.treePath.onContextMenuItemSelected(this._onTreePathMenuItemSelected.bind(this)));
        }, y._onUndo = function() {
            this.history && (this.history.undo(), this._onChange());
        }, y._onRedo = function() {
            this.history && (this.history.redo(), this._onChange());
        }, y._onEvent = function(e) {
            "keydown" === e.type && this._onKeyDown(e), "focus" === e.type && (this.focusTarget = e.target),
            "mousedown" === e.type && this._startDragDistance(e), "mousemove" !== e.type && "mouseup" !== e.type && "click" !== e.type || this._updateDragDistance(e);
            var t = l.getNodeFromTarget(e.target);
            if (t && this.options && this.options.navigationBar && t && ("keydown" === e.type || "mousedown" === e.type)) {
                var n = this;
                setTimeout(function() {
                    n._updateTreePath(t.getNodePath());
                });
            }
            if (t && t.selected) {
                if ("click" === e.type) {
                    if (e.target === t.dom.menu) return void this.showContextMenu(e.target);
                    e.hasMoved || this.deselect();
                }
                "mousedown" === e.type && l.onDragStart(this.multiselection.nodes, e);
            } else "mousedown" === e.type && (this.deselect(), t && e.target === t.dom.drag ? l.onDragStart(t, e) :(!t || e.target !== t.dom.field && e.target !== t.dom.value && e.target !== t.dom.select) && this._onMultiSelectStart(e));
            t && t.onEvent(e);
        }, y._updateTreePath = function(e) {
            function t(e) {
                return e.parent ? "array" === e.parent.type ? e.index :e.field :e.type;
            }
            if (e && e.length) {
                h.removeClassName(this.navBar, "nav-bar-empty");
                var n = [];
                e.forEach(function(e) {
                    var i = {
                        name:t(e),
                        node:e,
                        children:[]
                    };
                    e.childs && e.childs.length && e.childs.forEach(function(e) {
                        i.children.push({
                            name:t(e),
                            node:e
                        });
                    }), n.push(i);
                }), this.treePath.setPath(n);
            } else h.addClassName(this.navBar, "nav-bar-empty");
        }, y._onTreePathSectionSelected = function(e) {
            e && e.node && (e.node.expandTo(), e.node.focus());
        }, y._onTreePathMenuItemSelected = function(e, t) {
            if (e && e.children.length) {
                var n = e.children.find(function(e) {
                    return e.name === t;
                });
                n && n.node && (this._updateTreePath(n.node.getNodePath()), n.node.expandTo(), n.node.focus());
            }
        }, y._startDragDistance = function(e) {
            this.dragDistanceEvent = {
                initialTarget:e.target,
                initialPageX:e.pageX,
                initialPageY:e.pageY,
                dragDistance:0,
                hasMoved:!1
            };
        }, y._updateDragDistance = function(e) {
            this.dragDistanceEvent || this._startDragDistance(e);
            var t = e.pageX - this.dragDistanceEvent.initialPageX, n = e.pageY - this.dragDistanceEvent.initialPageY;
            return this.dragDistanceEvent.dragDistance = Math.sqrt(t * t + n * n), this.dragDistanceEvent.hasMoved = this.dragDistanceEvent.hasMoved || this.dragDistanceEvent.dragDistance > 10,
                e.dragDistance = this.dragDistanceEvent.dragDistance, e.hasMoved = this.dragDistanceEvent.hasMoved,
                e.dragDistance;
        }, y._onMultiSelectStart = function(e) {
            var t = l.getNodeFromTarget(e.target);
            if ("tree" === this.options.mode && void 0 === this.options.onEditable) {
                this.multiselection = {
                    start:t || null,
                    end:null,
                    nodes:[]
                }, this._startDragDistance(e);
                var n = this;
                this.mousemove || (this.mousemove = h.addEventListener(window, "mousemove", function(e) {
                    n._onMultiSelect(e);
                })), this.mouseup || (this.mouseup = h.addEventListener(window, "mouseup", function(e) {
                    n._onMultiSelectEnd(e);
                }));
            }
        }, y._onMultiSelect = function(e) {
            if (e.preventDefault(), this._updateDragDistance(e), e.hasMoved) {
                var t = l.getNodeFromTarget(e.target);
                t && (null == this.multiselection.start && (this.multiselection.start = t), this.multiselection.end = t),
                    this.deselect();
                var n = this.multiselection.start, i = this.multiselection.end || this.multiselection.start;
                if (n && i) {
                    if (this.multiselection.nodes = this._findTopLevelNodes(n, i), this.multiselection.nodes && this.multiselection.nodes.length) {
                        var o = this.multiselection.nodes[0];
                        this.multiselection.start === o || this.multiselection.start.isDescendantOf(o) ? this.multiselection.direction = "down" :this.multiselection.direction = "up";
                    }
                    this.select(this.multiselection.nodes);
                }
            }
        }, y._onMultiSelectEnd = function(e) {
            this.multiselection.nodes[0] && this.multiselection.nodes[0].dom.menu.focus(), this.multiselection.start = null,
                this.multiselection.end = null, this.mousemove && (h.removeEventListener(window, "mousemove", this.mousemove),
                delete this.mousemove), this.mouseup && (h.removeEventListener(window, "mouseup", this.mouseup),
                delete this.mouseup);
        }, y.deselect = function(e) {
            var t = !!this.multiselection.nodes.length;
            this.multiselection.nodes.forEach(function(e) {
                e.setSelected(!1);
            }), this.multiselection.nodes = [], e && (this.multiselection.start = null, this.multiselection.end = null),
            t && this._selectionChangedHandler && this._selectionChangedHandler();
        }, y.select = function(e) {
            if (!Array.isArray(e)) return this.select([ e ]);
            if (e) {
                this.deselect(), this.multiselection.nodes = e.slice(0);
                var t = e[0];
                if (e.forEach(function(e) {
                        e.expandPathToNode(), e.setSelected(!0, e === t);
                    }), this._selectionChangedHandler) {
                    var n = this.getSelection();
                    this._selectionChangedHandler(n.start, n.end);
                }
            }
        }, y._findTopLevelNodes = function(e, t) {
            for (var n = e.getNodePath(), i = t.getNodePath(), o = 0; o < n.length && n[o] === i[o]; ) o++;
            var r = n[o - 1], s = n[o], a = i[o];
            if (s && a || (r.parent ? (s = r, a = r, r = r.parent) :(s = r.childs[0], a = r.childs[r.childs.length - 1])),
                r && s && a) {
                var l = r.childs.indexOf(s), c = r.childs.indexOf(a), h = Math.min(l, c), d = Math.max(l, c);
                return r.childs.slice(h, d + 1);
            }
            return [];
        }, y._onKeyDown = function(e) {
            var t = e.which || e.keyCode, n = e.altKey, i = e.ctrlKey, o = e.metaKey, r = e.shiftKey, s = !1;
            if (9 == t) {
                var a = this;
                setTimeout(function() {
                    h.selectContentEditable(a.focusTarget);
                }, 0);
            }
            if (this.searchBox) if (i && 70 == t) this.searchBox.dom.search.focus(), this.searchBox.dom.search.select(),
                s = !0; else if (114 == t || i && 71 == t) {
                r ? this.searchBox.previous(!0) :this.searchBox.next(!0), s = !0;
            }
            if (this.history && (i && !r && 90 == t ? (this._onUndo(), s = !0) :i && r && 90 == t && (this._onRedo(),
                    s = !0)), this.options.autocomplete && !s && !(i || n || o || 1 != e.key.length && 8 != t && 46 != t)) {
                s = !1;
                var c = "";
                e.target.className.indexOf("jsoneditor-value") >= 0 && (c = "value"), e.target.className.indexOf("jsoneditor-field") >= 0 && (c = "field");
                var d = l.getNodeFromTarget(e.target);
                setTimeout(function(e, t) {
                    if (t.innerText.length > 0) {
                        var n = this.options.autocomplete.getOptions(t.innerText, e.getPath(), c, e.editor);
                        null === n ? this.autocomplete.hideDropDown() :"function" == typeof n.then ? n.then(function(e) {
                            null === e ? this.autocomplete.hideDropDown() :e.options ? this.autocomplete.show(t, e.startFrom, e.options) :this.autocomplete.show(t, 0, e);
                        }.bind(this)) :n.options ? this.autocomplete.show(t, n.startFrom, n.options) :this.autocomplete.show(t, 0, n);
                    } else this.autocomplete.hideDropDown();
                }.bind(this, d, e.target), 50);
            }
            s && (e.preventDefault(), e.stopPropagation());
        }, y._createTable = function() {
            var e = document.createElement("div");
            e.className = "jsoneditor-outer", this.options.navigationBar && h.addClassName(e, "has-nav-bar"),
                this.contentOuter = e, this.scrollableContent = document.createElement("div"), this.scrollableContent.className = "jsoneditor-tree",
                e.appendChild(this.scrollableContent), this.content = document.createElement("div"),
                this.content.className = "jsoneditor-tree-inner", this.scrollableContent.appendChild(this.content),
                this.table = document.createElement("table"), this.table.className = "jsoneditor-tree",
                this.content.appendChild(this.table);
            var t;
            this.colgroupContent = document.createElement("colgroup"), "tree" === this.options.mode && (t = document.createElement("col"),
                t.width = "24px", this.colgroupContent.appendChild(t)), t = document.createElement("col"),
                t.width = "24px", this.colgroupContent.appendChild(t), t = document.createElement("col"),
                this.colgroupContent.appendChild(t), this.table.appendChild(this.colgroupContent),
                this.tbody = document.createElement("tbody"), this.table.appendChild(this.tbody),
                this.frame.appendChild(e);
        }, y.showContextMenu = function(e, t) {
            var n = [], i = this;
            n.push({
                text:f("duplicateText"),
                title:f("duplicateTitle"),
                className:"jsoneditor-duplicate",
                click:function() {
                    l.onDuplicate(i.multiselection.nodes);
                }
            }), n.push({
                text:f("remove"),
                title:f("removeTitle"),
                className:"jsoneditor-remove",
                click:function() {
                    l.onRemove(i.multiselection.nodes);
                }
            }), new s(n, {
                close:t
            }).show(e, this.content);
        }, y.getSelection = function() {
            var e = {
                start:null,
                end:null
            };
            if (this.multiselection.nodes && this.multiselection.nodes.length && this.multiselection.nodes.length) {
                var t = this.multiselection.nodes[0], n = this.multiselection.nodes[this.multiselection.nodes.length - 1];
                "down" === this.multiselection.direction ? (e.start = t.serialize(), e.end = n.serialize()) :(e.start = n.serialize(),
                    e.end = t.serialize());
            }
            return e;
        }, y.onSelectionChange = function(e) {
            "function" == typeof e && (this._selectionChangedHandler = h.debounce(e, this.DEBOUNCE_INTERVAL));
        }, y.setSelection = function(e, t) {
            e && e.dom && e.range && (console.warn("setSelection/getSelection usage for text selection is depracated and should not be used, see documantaion for supported selection options"),
                this.setDomSelection(e));
            var n = this._getNodeInstancesByRange(e, t);
            n.forEach(function(e) {
                e.expandTo();
            }), this.select(n);
        }, y._getNodeInstancesByRange = function(e, t) {
            var n, i;
            e && e.path && (n = this.node.findNodeByPath(e.path), t && t.path && (i = this.node.findNodeByPath(t.path)));
            var o = [];
            if (n instanceof l) if (i instanceof l && i !== n) if (n.parent === i.parent) {
                var e, t;
                n.getIndex() < i.getIndex() ? (e = n, t = i) :(e = i, t = n);
                var r = e;
                o.push(r);
                do {
                    r = r.nextSibling(), o.push(r);
                } while (r && r !== t);
            } else o = this._findTopLevelNodes(n, i); else o.push(n);
            return o;
        }, y.getNodesByRange = function(e, t) {
            var n = this._getNodeInstancesByRange(e, t), i = [];
            return n.forEach(function(e) {
                i.push(e.serialize());
            }), i;
        }, e.exports = [ {
            mode:"tree",
            mixin:y,
            data:"json"
        }, {
            mode:"view",
            mixin:y,
            data:"json"
        }, {
            mode:"form",
            mixin:y,
            data:"json"
        } ];
    }, function(e, t) {
        "use strict";
        function n() {
            this.locked = !1;
        }
        n.prototype.highlight = function(e) {
            this.locked || (this.node != e && (this.node && this.node.setHighlight(!1), this.node = e,
                this.node.setHighlight(!0)), this._cancelUnhighlight());
        }, n.prototype.unhighlight = function() {
            if (!this.locked) {
                var e = this;
                this.node && (this._cancelUnhighlight(), this.unhighlightTimer = setTimeout(function() {
                    e.node.setHighlight(!1), e.node = void 0, e.unhighlightTimer = void 0;
                }, 0));
            }
        }, n.prototype._cancelUnhighlight = function() {
            this.unhighlightTimer && (clearTimeout(this.unhighlightTimer), this.unhighlightTimer = void 0);
        }, n.prototype.lock = function() {
            this.locked = !0;
        }, n.prototype.unlock = function() {
            this.locked = !1;
        }, e.exports = n;
    }, function(e, t) {
        "use strict";
        function n(e) {
            function t(t) {
                return e.node.findNodeByInternalPath(t);
            }
            this.editor = e, this.history = [], this.index = -1, this.clear(), this.actions = {
                editField:{
                    undo:function(e) {
                        t(e.parentPath).childs[e.index].updateField(e.oldValue);
                    },
                    redo:function(e) {
                        t(e.parentPath).childs[e.index].updateField(e.newValue);
                    }
                },
                editValue:{
                    undo:function(e) {
                        t(e.path).updateValue(e.oldValue);
                    },
                    redo:function(e) {
                        t(e.path).updateValue(e.newValue);
                    }
                },
                changeType:{
                    undo:function(e) {
                        t(e.path).changeType(e.oldType);
                    },
                    redo:function(e) {
                        t(e.path).changeType(e.newType);
                    }
                },
                appendNodes:{
                    undo:function(e) {
                        var n = t(e.parentPath);
                        e.paths.map(t).forEach(function(e) {
                            n.removeChild(e);
                        });
                    },
                    redo:function(e) {
                        var n = t(e.parentPath);
                        e.nodes.forEach(function(e) {
                            n.appendChild(e);
                        });
                    }
                },
                insertBeforeNodes:{
                    undo:function(e) {
                        var n = t(e.parentPath);
                        e.paths.map(t).forEach(function(e) {
                            n.removeChild(e);
                        });
                    },
                    redo:function(e) {
                        var n = t(e.parentPath), i = t(e.beforePath);
                        e.nodes.forEach(function(e) {
                            n.insertBefore(e, i);
                        });
                    }
                },
                insertAfterNodes:{
                    undo:function(e) {
                        var n = t(e.parentPath);
                        e.paths.map(t).forEach(function(e) {
                            n.removeChild(e);
                        });
                    },
                    redo:function(e) {
                        var n = t(e.parentPath), i = t(e.afterPath);
                        e.nodes.forEach(function(e) {
                            n.insertAfter(e, i), i = e;
                        });
                    }
                },
                removeNodes:{
                    undo:function(e) {
                        var n = t(e.parentPath), i = n.childs[e.index] || n.append;
                        e.nodes.forEach(function(e) {
                            n.insertBefore(e, i);
                        });
                    },
                    redo:function(e) {
                        var n = t(e.parentPath);
                        e.paths.map(t).forEach(function(e) {
                            n.removeChild(e);
                        });
                    }
                },
                duplicateNodes:{
                    undo:function(e) {
                        var n = t(e.parentPath);
                        e.clonePaths.map(t).forEach(function(e) {
                            n.removeChild(e);
                        });
                    },
                    redo:function(e) {
                        var n = t(e.parentPath), i = t(e.afterPath);
                        e.paths.map(t).forEach(function(e) {
                            var t = e.clone();
                            n.insertAfter(t, i), i = t;
                        });
                    }
                },
                moveNodes:{
                    undo:function(e) {
                        var n = t(e.oldParentPath), i = t(e.newParentPath), o = n.childs[e.oldIndex] || n.append;
                        i.childs.slice(e.newIndex, e.newIndex + e.count).forEach(function(t, i) {
                            t.field = e.fieldNames[i], n.moveBefore(t, o);
                        }), null === e.newParentPathRedo && (e.newParentPathRedo = i.getInternalPath());
                    },
                    redo:function(e) {
                        var n = t(e.oldParentPathRedo), i = t(e.newParentPathRedo), o = i.childs[e.newIndexRedo] || i.append;
                        n.childs.slice(e.oldIndexRedo, e.oldIndexRedo + e.count).forEach(function(t, n) {
                            t.field = e.fieldNames[n], i.moveBefore(t, o);
                        });
                    }
                },
                sort:{
                    undo:function(e) {
                        var n = t(e.path);
                        n.hideChilds(), n.childs = e.oldChilds, n.updateDom({
                            updateIndexes:!0
                        }), n.showChilds();
                    },
                    redo:function(e) {
                        var n = t(e.path);
                        n.hideChilds(), n.childs = e.newChilds, n.updateDom({
                            updateIndexes:!0
                        }), n.showChilds();
                    }
                },
                transform:{
                    undo:function(e) {
                        t(e.path).setInternalValue(e.oldValue);
                    },
                    redo:function(e) {
                        t(e.path).setInternalValue(e.newValue);
                    }
                }
            };
        }
        n.prototype.onChange = function() {}, n.prototype.add = function(e, t) {
            this.index++, this.history[this.index] = {
                action:e,
                params:t,
                timestamp:new Date()
            }, this.index < this.history.length - 1 && this.history.splice(this.index + 1, this.history.length - this.index - 1),
                this.onChange();
        }, n.prototype.clear = function() {
            this.history = [], this.index = -1, this.onChange();
        }, n.prototype.canUndo = function() {
            return this.index >= 0;
        }, n.prototype.canRedo = function() {
            return this.index < this.history.length - 1;
        }, n.prototype.undo = function() {
            if (this.canUndo()) {
                var e = this.history[this.index];
                if (e) {
                    var t = this.actions[e.action];
                    if (t && t.undo) {
                        if (t.undo(e.params), e.params.oldSelection) try {
                            this.editor.setDomSelection(e.params.oldSelection);
                        } catch (e) {
                            console.error(e);
                        }
                    } else console.error(new Error('unknown action "' + e.action + '"'));
                }
                this.index--, this.onChange();
            }
        }, n.prototype.redo = function() {
            if (this.canRedo()) {
                this.index++;
                var e = this.history[this.index];
                if (e) {
                    var t = this.actions[e.action];
                    if (t && t.redo) {
                        if (t.redo(e.params), e.params.newSelection) try {
                            this.editor.setDomSelection(e.params.newSelection);
                        } catch (e) {
                            console.error(e);
                        }
                    } else console.error(new Error('unknown action "' + e.action + '"'));
                }
                this.onChange();
            }
        }, n.prototype.destroy = function() {
            this.editor = null, this.history = [], this.index = -1;
        }, e.exports = n;
    }, function(e, t) {
        "use strict";
        function n(e, t) {
            var n = this;
            this.editor = e, this.timeout = void 0, this.delay = 200, this.lastText = void 0,
                this.dom = {}, this.dom.container = t;
            var i = document.createElement("table");
            this.dom.table = i, i.className = "jsoneditor-search", t.appendChild(i);
            var o = document.createElement("tbody");
            this.dom.tbody = o, i.appendChild(o);
            var r = document.createElement("tr");
            o.appendChild(r);
            var s = document.createElement("td");
            r.appendChild(s);
            var a = document.createElement("div");
            this.dom.results = a, a.className = "jsoneditor-results", s.appendChild(a), s = document.createElement("td"),
                r.appendChild(s);
            var l = document.createElement("div");
            this.dom.input = l, l.className = "jsoneditor-frame", l.title = "Search fields and values",
                s.appendChild(l);
            var c = document.createElement("table");
            l.appendChild(c);
            var h = document.createElement("tbody");
            c.appendChild(h), r = document.createElement("tr"), h.appendChild(r);
            var d = document.createElement("button");
            d.type = "button", d.className = "jsoneditor-refresh", s = document.createElement("td"),
                s.appendChild(d), r.appendChild(s);
            var u = document.createElement("input");
            this.dom.search = u, u.oninput = function(e) {
                n._onDelayedSearch(e);
            }, u.onchange = function(e) {
                n._onSearch();
            }, u.onkeydown = function(e) {
                n._onKeyDown(e);
            }, u.onkeyup = function(e) {
                n._onKeyUp(e);
            }, d.onclick = function(e) {
                u.select();
            }, s = document.createElement("td"), s.appendChild(u), r.appendChild(s);
            var p = document.createElement("button");
            p.type = "button", p.title = "Next result (Enter)", p.className = "jsoneditor-next",
                p.onclick = function() {
                    n.next();
                }, s = document.createElement("td"), s.appendChild(p), r.appendChild(s);
            var f = document.createElement("button");
            f.type = "button", f.title = "Previous result (Shift+Enter)", f.className = "jsoneditor-previous",
                f.onclick = function() {
                    n.previous();
                }, s = document.createElement("td"), s.appendChild(f), r.appendChild(s);
        }
        n.prototype.next = function(e) {
            if (void 0 != this.results) {
                var t = void 0 != this.resultIndex ? this.resultIndex + 1 :0;
                t > this.results.length - 1 && (t = 0), this._setActiveResult(t, e);
            }
        }, n.prototype.previous = function(e) {
            if (void 0 != this.results) {
                var t = this.results.length - 1, n = void 0 != this.resultIndex ? this.resultIndex - 1 :t;
                n < 0 && (n = t), this._setActiveResult(n, e);
            }
        }, n.prototype._setActiveResult = function(e, t) {
            if (this.activeResult) {
                var n = this.activeResult.node;
                "field" == this.activeResult.elem ? delete n.searchFieldActive :delete n.searchValueActive,
                    n.updateDom();
            }
            if (!this.results || !this.results[e]) return this.resultIndex = void 0, void (this.activeResult = void 0);
            this.resultIndex = e;
            var i = this.results[this.resultIndex].node, o = this.results[this.resultIndex].elem;
            "field" == o ? i.searchFieldActive = !0 :i.searchValueActive = !0, this.activeResult = this.results[this.resultIndex],
                i.updateDom(), i.scrollTo(function() {
                t && i.focus(o);
            });
        }, n.prototype._clearDelay = function() {
            void 0 != this.timeout && (clearTimeout(this.timeout), delete this.timeout);
        }, n.prototype._onDelayedSearch = function(e) {
            this._clearDelay();
            var t = this;
            this.timeout = setTimeout(function(e) {
                t._onSearch();
            }, this.delay);
        }, n.prototype._onSearch = function(e) {
            this._clearDelay();
            var t = this.dom.search.value, n = t.length > 0 ? t :void 0;
            if (n !== this.lastText || e) {
                this.lastText = n, this.results = this.editor.search(n);
                var i = this.results[0] ? this.results[0].node.MAX_SEARCH_RESULTS :1 / 0, o = 0;
                if (this.activeResult) for (var r = 0; r < this.results.length; r++) if (this.results[r].node === this.activeResult.node) {
                    o = r;
                    break;
                }
                if (this._setActiveResult(o, !1), void 0 !== n) {
                    var s = this.results.length;
                    this.dom.results.innerHTML = 0 === s ? "no&nbsp;results" :1 === s ? "1&nbsp;result" :s > i ? i + "+&nbsp;results" :s + "&nbsp;results";
                } else this.dom.results.innerHTML = "";
            }
        }, n.prototype._onKeyDown = function(e) {
            var t = e.which;
            27 == t ? (this.dom.search.value = "", this._onSearch(), e.preventDefault(), e.stopPropagation()) :13 == t && (e.ctrlKey ? this._onSearch(!0) :e.shiftKey ? this.previous() :this.next(),
                e.preventDefault(), e.stopPropagation());
        }, n.prototype._onKeyUp = function(e) {
            var t = e.keyCode;
            27 != t && 13 != t && this._onDelayedSearch(e);
        }, n.prototype.clear = function() {
            this.dom.search.value = "", this._onSearch();
        }, n.prototype.forceSearch = function() {
            this._onSearch(!0);
        }, n.prototype.isEmpty = function() {
            return "" === this.dom.search.value;
        }, n.prototype.destroy = function() {
            this.editor = null, this.dom.container.removeChild(this.dom.table), this.dom = null,
                this.results = null, this.activeResult = null, this._clearDelay();
        }, e.exports = n;
    }, function(e, t, n) {
        "use strict";
        function i(e) {
            return e.getRootNode && e.getRootNode() || window;
        }
        function o(e, t) {
            function n(e, t, o) {
                o.forEach(function(o) {
                    if ("separator" == o.type) {
                        var r = document.createElement("div");
                        r.className = "jsoneditor-separator", l = document.createElement("li"), l.appendChild(r),
                            e.appendChild(l);
                    } else {
                        var a = {}, l = document.createElement("li");
                        e.appendChild(l);
                        var c = document.createElement("button");
                        if (c.type = "button", c.className = o.className, a.button = c, o.title && (c.title = o.title),
                            o.click && (c.onclick = function(e) {
                                e.preventDefault(), i.hide(), o.click();
                            }), l.appendChild(c), o.submenu) {
                            var h = document.createElement("div");
                            h.className = "jsoneditor-icon", c.appendChild(h);
                            var d = document.createElement("div");
                            d.className = "jsoneditor-text" + (o.click ? "" :" jsoneditor-right-margin"), d.appendChild(document.createTextNode(o.text)),
                                c.appendChild(d);
                            var u;
                            if (o.click) {
                                c.className += " jsoneditor-default";
                                var p = document.createElement("button");
                                p.type = "button", a.buttonExpand = p, p.className = "jsoneditor-expand", p.innerHTML = '<div class="jsoneditor-expand"></div>',
                                    l.appendChild(p), o.submenuTitle && (p.title = o.submenuTitle), u = p;
                            } else {
                                var f = document.createElement("div");
                                f.className = "jsoneditor-expand", c.appendChild(f), u = c;
                            }
                            u.onclick = function(e) {
                                e.preventDefault(), i._onExpandItem(a), u.focus();
                            };
                            var m = [];
                            a.subItems = m;
                            var g = document.createElement("ul");
                            a.ul = g, g.className = "jsoneditor-menu", g.style.height = "0", l.appendChild(g),
                                n(g, m, o.submenu);
                        } else c.innerHTML = '<div class="jsoneditor-icon"></div><div class="jsoneditor-text">' + s(o.text) + "</div>";
                        t.push(a);
                    }
                });
            }
            this.dom = {};
            var i = this, o = this.dom;
            this.anchor = void 0, this.items = e, this.eventListeners = {}, this.selection = void 0,
                this.onClose = t ? t.close :void 0;
            var r = document.createElement("div");
            r.className = "jsoneditor-contextmenu-root", o.root = r;
            var a = document.createElement("div");
            a.className = "jsoneditor-contextmenu", o.menu = a, r.appendChild(a);
            var l = document.createElement("ul");
            l.className = "jsoneditor-menu", a.appendChild(l), o.list = l, o.items = [];
            var c = document.createElement("button");
            c.type = "button", o.focusButton = c;
            var h = document.createElement("li");
            h.style.overflow = "hidden", h.style.height = "0", h.appendChild(c), l.appendChild(h),
                n(l, this.dom.items, e), this.maxHeight = 0, e.forEach(function(t) {
                var n = 24 * (e.length + (t.submenu ? t.submenu.length :0));
                i.maxHeight = Math.max(i.maxHeight, n);
            });
        }
        var r = n(6), s = n(8).translate;
        o.prototype._getVisibleButtons = function() {
            var e = [], t = this;
            return this.dom.items.forEach(function(n) {
                e.push(n.button), n.buttonExpand && e.push(n.buttonExpand), n.subItems && n == t.expandedItem && n.subItems.forEach(function(t) {
                    e.push(t.button), t.buttonExpand && e.push(t.buttonExpand);
                });
            }), e;
        }, o.visibleMenu = void 0, o.prototype.show = function(e, t) {
            this.hide();
            var n = !0, s = e.parentNode, a = e.getBoundingClientRect(), l = s.getBoundingClientRect();
            if (t) {
                var c = t.getBoundingClientRect();
                a.bottom + this.maxHeight < c.bottom || a.top - this.maxHeight > c.top && (n = !1);
            }
            var h = a.left - l.left, d = a.top - l.top;
            if (n) {
                var u = e.offsetHeight;
                this.dom.menu.style.left = h + "px", this.dom.menu.style.top = d + u + "px", this.dom.menu.style.bottom = "";
            } else this.dom.menu.style.left = h + "px", this.dom.menu.style.top = d + "px",
                this.dom.menu.style.bottom = "0px";
            this.rootNode = i(e), s.insertBefore(this.dom.root, s.firstChild);
            var p = this, f = this.dom.list;
            this.eventListeners.mousedown = r.addEventListener(this.rootNode, "mousedown", function(e) {
                var t = e.target;
                t == f || p._isChildOf(t, f) || (p.hide(), e.stopPropagation(), e.preventDefault());
            }), this.eventListeners.keydown = r.addEventListener(this.rootNode, "keydown", function(e) {
                p._onKeyDown(e);
            }), this.selection = r.getSelection(), this.anchor = e, setTimeout(function() {
                p.dom.focusButton.focus();
            }, 0), o.visibleMenu && o.visibleMenu.hide(), o.visibleMenu = this;
        }, o.prototype.hide = function() {
            this.dom.root.parentNode && (this.dom.root.parentNode.removeChild(this.dom.root),
            this.onClose && this.onClose());
            for (var e in this.eventListeners) if (this.eventListeners.hasOwnProperty(e)) {
                var t = this.eventListeners[e];
                t && r.removeEventListener(this.rootNode, e, t), delete this.eventListeners[e];
            }
            o.visibleMenu == this && (o.visibleMenu = void 0);
        }, o.prototype._onExpandItem = function(e) {
            var t = this, n = e == this.expandedItem, i = this.expandedItem;
            if (i && (i.ul.style.height = "0", i.ul.style.padding = "", setTimeout(function() {
                    t.expandedItem != i && (i.ul.style.display = "", r.removeClassName(i.ul.parentNode, "jsoneditor-selected"));
                }, 300), this.expandedItem = void 0), !n) {
                var o = e.ul;
                o.style.display = "block";
                o.clientHeight;
                setTimeout(function() {
                    if (t.expandedItem == e) {
                        for (var n = 0, i = 0; i < o.childNodes.length; i++) n += o.childNodes[i].clientHeight;
                        o.style.height = n + "px", o.style.padding = "5px 10px";
                    }
                }, 0), r.addClassName(o.parentNode, "jsoneditor-selected"), this.expandedItem = e;
            }
        }, o.prototype._onKeyDown = function(e) {
            var t, n, i, o, s = e.target, a = e.which, l = !1;
            27 == a ? (this.selection && r.setSelection(this.selection), this.anchor && this.anchor.focus(),
                this.hide(), l = !0) :9 == a ? e.shiftKey ? (t = this._getVisibleButtons(), 0 == (n = t.indexOf(s)) && (t[t.length - 1].focus(),
                l = !0)) :(t = this._getVisibleButtons(), (n = t.indexOf(s)) == t.length - 1 && (t[0].focus(),
                l = !0)) :37 == a ? ("jsoneditor-expand" == s.className && (t = this._getVisibleButtons(),
                n = t.indexOf(s), (i = t[n - 1]) && i.focus()), l = !0) :38 == a ? (t = this._getVisibleButtons(),
                n = t.indexOf(s), i = t[n - 1], i && "jsoneditor-expand" == i.className && (i = t[n - 2]),
            i || (i = t[t.length - 1]), i && i.focus(), l = !0) :39 == a ? (t = this._getVisibleButtons(),
                n = t.indexOf(s), o = t[n + 1], o && "jsoneditor-expand" == o.className && o.focus(),
                l = !0) :40 == a && (t = this._getVisibleButtons(), n = t.indexOf(s), o = t[n + 1],
            o && "jsoneditor-expand" == o.className && (o = t[n + 2]), o || (o = t[0]), o && (o.focus(),
                l = !0), l = !0), l && (e.stopPropagation(), e.preventDefault());
        }, o.prototype._isChildOf = function(e, t) {
            for (var n = e.parentNode; n; ) {
                if (n == t) return !0;
                n = n.parentNode;
            }
            return !1;
        }, e.exports = o;
    }, function(e, t, n) {
        "use strict";
        var i = n(7);
        t.parse = function(e) {
            try {
                return JSON.parse(e);
            } catch (n) {
                throw t.validate(e), n;
            }
        }, t.sanitize = function(e) {
            function t() {
                return e.charAt(s);
            }
            function n() {
                return e.charAt(s + 1);
            }
            function i() {
                return e.charAt(s - 1);
            }
            function o(n) {
                r.push('"'), s++;
                for (var o = t(); s < e.length && o !== n; ) '"' === o && "\\" !== i() ? r.push('\\"') :l.hasOwnProperty(o) ? r.push(l[o]) :"\\" === o ? (s++,
                    o = t(), "'" !== o && r.push("\\"), r.push(o)) :r.push(o), s++, o = t();
                o === n && (r.push('"'), s++);
            }
            var r = [], s = 0, a = e.match(/^\s*(\/\*(.|[\r\n])*?\*\/)?\s*[\da-zA-Z_$]+\s*\(([\s\S]*)\)\s*;?\s*$/);
            a && (e = a[3]);
            for (var l = {
                "\b":"\\b",
                "\f":"\\f",
                "\n":"\\n",
                "\r":"\\r",
                "	":"\\t"
            }; s < e.length; ) {
                var c = t();
                "/" === c && "*" === n() ? function() {
                    for (s += 2; s < e.length && ("*" !== t() || "/" !== n()); ) s++;
                    s += 2;
                }() :"/" === c && "/" === n() ? function() {
                    for (s += 2; s < e.length && "\n" !== t(); ) s++;
                }() :" " === c || c >= " " && c <= " " || " " === c || " " === c || "　" === c ? (r.push(" "),
                    s++) :"'" === c ? o("'") :'"' === c ? o('"') :"`" === c ? o("´") :"‘" === c ? o("’") :"“" === c ? o("”") :/[a-zA-Z_$]/.test(c) && -1 !== [ "{", "," ].indexOf(function() {
                    for (var e = r.length - 1; e >= 0; ) {
                        var t = r[e];
                        if (" " !== t && "\n" !== t && "\r" !== t && "	" !== t) return t;
                        e--;
                    }
                    return "";
                }()) ? function() {
                    for (var e = [ "null", "true", "false" ], n = "", i = t(), o = /[a-zA-Z_$\d]/; o.test(i); ) n += i,
                        s++, i = t();
                    -1 === e.indexOf(n) ? r.push('"' + n + '"') :r.push(n);
                }() :(r.push(c), s++);
            }
            return r.join("");
        }, t.escapeUnicodeChars = function(e) {
            return e.replace(/[\u007F-\uFFFF]/g, function(e) {
                return "\\u" + ("0000" + e.charCodeAt(0).toString(16)).slice(-4);
            });
        }, t.validate = function(e) {
            void 0 !== i ? i.parse(e) :JSON.parse(e);
        }, t.extend = function(e, t) {
            for (var n in t) t.hasOwnProperty(n) && (e[n] = t[n]);
            return e;
        }, t.clear = function(e) {
            for (var t in e) e.hasOwnProperty(t) && delete e[t];
            return e;
        }, t.type = function(e) {
            return null === e ? "null" :void 0 === e ? "undefined" :e instanceof Number || "number" == typeof e ? "number" :e instanceof String || "string" == typeof e ? "string" :e instanceof Boolean || "boolean" == typeof e ? "boolean" :e instanceof RegExp || "regexp" == typeof e ? "regexp" :t.isArray(e) ? "array" :"object";
        };
        var o = /^https?:\/\/\S+$/;
        t.isUrl = function(e) {
            return ("string" == typeof e || e instanceof String) && o.test(e);
        }, t.isArray = function(e) {
            return "[object Array]" === Object.prototype.toString.call(e);
        }, t.getAbsoluteLeft = function(e) {
            return e.getBoundingClientRect().left + window.pageXOffset || document.scrollLeft || 0;
        }, t.getAbsoluteTop = function(e) {
            return e.getBoundingClientRect().top + window.pageYOffset || document.scrollTop || 0;
        }, t.addClassName = function(e, t) {
            var n = e.className.split(" ");
            -1 == n.indexOf(t) && (n.push(t), e.className = n.join(" "));
        }, t.removeClassName = function(e, t) {
            var n = e.className.split(" "), i = n.indexOf(t);
            -1 != i && (n.splice(i, 1), e.className = n.join(" "));
        }, t.stripFormatting = function(e) {
            for (var n = e.childNodes, i = 0, o = n.length; i < o; i++) {
                var r = n[i];
                r.style && r.removeAttribute("style");
                var s = r.attributes;
                if (s) for (var a = s.length - 1; a >= 0; a--) {
                    var l = s[a];
                    !0 === l.specified && r.removeAttribute(l.name);
                }
                t.stripFormatting(r);
            }
        }, t.setEndOfContentEditable = function(e) {
            var t, n;
            document.createRange && (t = document.createRange(), t.selectNodeContents(e), t.collapse(!1),
                n = window.getSelection(), n.removeAllRanges(), n.addRange(t));
        }, t.selectContentEditable = function(e) {
            if (e && "DIV" == e.nodeName) {
                var t, n;
                window.getSelection && document.createRange && (n = document.createRange(), n.selectNodeContents(e),
                    t = window.getSelection(), t.removeAllRanges(), t.addRange(n));
            }
        }, t.getSelection = function() {
            if (window.getSelection) {
                var e = window.getSelection();
                if (e.getRangeAt && e.rangeCount) return e.getRangeAt(0);
            }
            return null;
        }, t.setSelection = function(e) {
            if (e && window.getSelection) {
                var t = window.getSelection();
                t.removeAllRanges(), t.addRange(e);
            }
        }, t.getSelectionOffset = function() {
            var e = t.getSelection();
            return e && "startOffset" in e && "endOffset" in e && e.startContainer && e.startContainer == e.endContainer ? {
                startOffset:e.startOffset,
                endOffset:e.endOffset,
                container:e.startContainer.parentNode
            } :null;
        }, t.setSelectionOffset = function(e) {
            if (document.createRange && window.getSelection) {
                if (window.getSelection()) {
                    var n = document.createRange();
                    e.container.firstChild || e.container.appendChild(document.createTextNode("")),
                        n.setStart(e.container.firstChild, e.startOffset), n.setEnd(e.container.firstChild, e.endOffset),
                        t.setSelection(n);
                }
            }
        }, t.getInnerText = function(e, n) {
            if (void 0 == n && (n = {
                    text:"",
                    flush:function() {
                        var e = this.text;
                        return this.text = "", e;
                    },
                    set:function(e) {
                        this.text = e;
                    }
                }), e.nodeValue) return n.flush() + e.nodeValue;
            if (e.hasChildNodes()) {
                for (var i = e.childNodes, o = "", r = 0, s = i.length; r < s; r++) {
                    var a = i[r];
                    if ("DIV" == a.nodeName || "P" == a.nodeName) {
                        var l = i[r - 1], c = l ? l.nodeName :void 0;
                        c && "DIV" != c && "P" != c && "BR" != c && (o += "\n", n.flush()), o += t.getInnerText(a, n),
                            n.set("\n");
                    } else "BR" == a.nodeName ? (o += n.flush(), n.set("\n")) :o += t.getInnerText(a, n);
                }
                return o;
            }
            return "P" == e.nodeName && -1 != t.getInternetExplorerVersion() ? n.flush() :"";
        }, t.getInternetExplorerVersion = function() {
            if (-1 == r) {
                var e = -1;
                if ("undefined" != typeof navigator && "Microsoft Internet Explorer" == navigator.appName) {
                    var t = navigator.userAgent;
                    null != new RegExp("MSIE ([0-9]{1,}[.0-9]{0,})").exec(t) && (e = parseFloat(RegExp.$1));
                }
                r = e;
            }
            return r;
        }, t.isFirefox = function() {
            return "undefined" != typeof navigator && -1 !== navigator.userAgent.indexOf("Firefox");
        };
        var r = -1;
        t.addEventListener = function(e, n, i, o) {
            if (e.addEventListener) return void 0 === o && (o = !1), "mousewheel" === n && t.isFirefox() && (n = "DOMMouseScroll"),
                e.addEventListener(n, i, o), i;
            if (e.attachEvent) {
                var r = function() {
                    return i.call(e, window.event);
                };
                return e.attachEvent("on" + n, r), r;
            }
        }, t.removeEventListener = function(e, n, i, o) {
            e.removeEventListener ? (void 0 === o && (o = !1), "mousewheel" === n && t.isFirefox() && (n = "DOMMouseScroll"),
                e.removeEventListener(n, i, o)) :e.detachEvent && e.detachEvent("on" + n, i);
        }, t.parsePath = function e(t) {
            var n, i;
            if (0 === t.length) return [];
            var o = t.match(/^\.(\w+)/);
            if (o) n = o[1], i = t.substr(n.length + 1); else {
                if ("[" !== t[0]) throw new SyntaxError("Failed to parse path");
                var r = t.indexOf("]");
                if (-1 === r) throw new SyntaxError("Character ] expected in path");
                if (1 === r) throw new SyntaxError("Index expected after [");
                var s = t.substring(1, r);
                "'" === s[0] && (s = '"' + s.substring(1, s.length - 1) + '"'), n = "*" === s ? s :JSON.parse(s),
                    i = t.substr(r + 1);
            }
            return [ n ].concat(e(i));
        }, t.improveSchemaError = function(e) {
            if ("enum" === e.keyword && Array.isArray(e.schema)) {
                var t = e.schema;
                if (t) {
                    if (t = t.map(function(e) {
                            return JSON.stringify(e);
                        }), t.length > 5) {
                        var n = [ "(" + (t.length - 5) + " more...)" ];
                        t = t.slice(0, 5), t.push(n);
                    }
                    e.message = "should be equal to one of: " + t.join(", ");
                }
            }
            return "additionalProperties" === e.keyword && (e.message = "should NOT have additional property: " + e.params.additionalProperty),
                e;
        }, t.insideRect = function(e, t, n) {
            var i = void 0 !== n ? n :0;
            return t.left - i >= e.left && t.right + i <= e.right && t.top - i >= e.top && t.bottom + i <= e.bottom;
        }, t.debounce = function(e, t, n) {
            var i;
            return function() {
                var o = this, r = arguments, s = function() {
                    i = null, n || e.apply(o, r);
                }, a = n && !i;
                clearTimeout(i), i = setTimeout(s, t), a && e.apply(o, r);
            };
        }, t.textDiff = function(e, t) {
            for (var n = t.length, i = 0, o = e.length, r = t.length; t.charAt(i) === e.charAt(i) && i < n; ) i++;
            for (;t.charAt(r - 1) === e.charAt(o - 1) && r > i && o > 0; ) r--, o--;
            return {
                start:i,
                end:r
            };
        }, t.getInputSelection = function(e) {
            function t(t) {
                var n = e.value.substring(0, t);
                return {
                    row:(n.match(/\n/g) || []).length + 1,
                    column:n.length - n.lastIndexOf("\n")
                };
            }
            var n, i, o, r, s, a = 0, l = 0;
            return "number" == typeof e.selectionStart && "number" == typeof e.selectionEnd ? (a = e.selectionStart,
                l = e.selectionEnd) :(i = document.selection.createRange()) && i.parentElement() == e && (r = e.value.length,
                n = e.value.replace(/\r\n/g, "\n"), o = e.createTextRange(), o.moveToBookmark(i.getBookmark()),
                s = e.createTextRange(), s.collapse(!1), o.compareEndPoints("StartToEnd", s) > -1 ? a = l = r :(a = -o.moveStart("character", -r),
                a += n.slice(0, a).split("\n").length - 1, o.compareEndPoints("EndToEnd", s) > -1 ? l = r :(l = -o.moveEnd("character", -r),
                l += n.slice(0, l).split("\n").length - 1))), {
                startIndex:a,
                endIndex:l,
                start:t(a),
                end:t(l)
            };
        }, t.getIndexForPosition = function(e, t, n) {
            var i = e.value || "";
            if (t > 0 && n > 0) {
                var o = i.split("\n", t);
                t = Math.min(o.length, t), n = Math.min(o[t - 1].length, n - 1);
                var r = 1 == t ? n :n + 1;
                return o.slice(0, t - 1).join("\n").length + r;
            }
            return -1;
        }, "undefined" != typeof Element && function() {
            function e(e) {
                e.hasOwnProperty("remove") || Object.defineProperty(e, "remove", {
                    configurable:!0,
                    enumerable:!0,
                    writable:!0,
                    value:function() {
                        null != this.parentNode && this.parentNode.removeChild(this);
                    }
                });
            }
            "undefined" != typeof Element && e(Element.prototype), "undefined" != typeof CharacterData && e(CharacterData.prototype),
            "undefined" != typeof DocumentType && e(DocumentType.prototype);
        }(), String.prototype.startsWith || (String.prototype.startsWith = function(e, t) {
            return t = t || 0, this.substr(t, e.length) === e;
        }), Array.prototype.find || (Array.prototype.find = function(e) {
            for (var t = 0; t < this.length; t++) {
                var n = this[t];
                if (e.call(this, n, t, this)) return n;
            }
        });
    }, function(e, t, n) {
        var i = function() {
            var e = {
                trace:function() {},
                yy:{},
                symbols_:{
                    error:2,
                    JSONString:3,
                    STRING:4,
                    JSONNumber:5,
                    NUMBER:6,
                    JSONNullLiteral:7,
                    NULL:8,
                    JSONBooleanLiteral:9,
                    TRUE:10,
                    FALSE:11,
                    JSONText:12,
                    JSONValue:13,
                    EOF:14,
                    JSONObject:15,
                    JSONArray:16,
                    "{":17,
                    "}":18,
                    JSONMemberList:19,
                    JSONMember:20,
                    ":":21,
                    ",":22,
                    "[":23,
                    "]":24,
                    JSONElementList:25,
                    $accept:0,
                    $end:1
                },
                terminals_:{
                    2:"error",
                    4:"STRING",
                    6:"NUMBER",
                    8:"NULL",
                    10:"TRUE",
                    11:"FALSE",
                    14:"EOF",
                    17:"{",
                    18:"}",
                    21:":",
                    22:",",
                    23:"[",
                    24:"]"
                },
                productions_:[ 0, [ 3, 1 ], [ 5, 1 ], [ 7, 1 ], [ 9, 1 ], [ 9, 1 ], [ 12, 2 ], [ 13, 1 ], [ 13, 1 ], [ 13, 1 ], [ 13, 1 ], [ 13, 1 ], [ 13, 1 ], [ 15, 2 ], [ 15, 3 ], [ 20, 3 ], [ 19, 1 ], [ 19, 3 ], [ 16, 2 ], [ 16, 3 ], [ 25, 1 ], [ 25, 3 ] ],
                performAction:function(e, t, n, i, o, r, s) {
                    var a = r.length - 1;
                    switch (o) {
                        case 1:
                            this.$ = e.replace(/\\(\\|")/g, "$1").replace(/\\n/g, "\n").replace(/\\r/g, "\r").replace(/\\t/g, "	").replace(/\\v/g, "").replace(/\\f/g, "\f").replace(/\\b/g, "\b");
                            break;

                        case 2:
                            this.$ = Number(e);
                            break;

                        case 3:
                            this.$ = null;
                            break;

                        case 4:
                            this.$ = !0;
                            break;

                        case 5:
                            this.$ = !1;
                            break;

                        case 6:
                            return this.$ = r[a - 1];

                        case 13:
                            this.$ = {};
                            break;

                        case 14:
                            this.$ = r[a - 1];
                            break;

                        case 15:
                            this.$ = [ r[a - 2], r[a] ];
                            break;

                        case 16:
                            this.$ = {}, this.$[r[a][0]] = r[a][1];
                            break;

                        case 17:
                            this.$ = r[a - 2], r[a - 2][r[a][0]] = r[a][1];
                            break;

                        case 18:
                            this.$ = [];
                            break;

                        case 19:
                            this.$ = r[a - 1];
                            break;

                        case 20:
                            this.$ = [ r[a] ];
                            break;

                        case 21:
                            this.$ = r[a - 2], r[a - 2].push(r[a]);
                    }
                },
                table:[ {
                    3:5,
                    4:[ 1, 12 ],
                    5:6,
                    6:[ 1, 13 ],
                    7:3,
                    8:[ 1, 9 ],
                    9:4,
                    10:[ 1, 10 ],
                    11:[ 1, 11 ],
                    12:1,
                    13:2,
                    15:7,
                    16:8,
                    17:[ 1, 14 ],
                    23:[ 1, 15 ]
                }, {
                    1:[ 3 ]
                }, {
                    14:[ 1, 16 ]
                }, {
                    14:[ 2, 7 ],
                    18:[ 2, 7 ],
                    22:[ 2, 7 ],
                    24:[ 2, 7 ]
                }, {
                    14:[ 2, 8 ],
                    18:[ 2, 8 ],
                    22:[ 2, 8 ],
                    24:[ 2, 8 ]
                }, {
                    14:[ 2, 9 ],
                    18:[ 2, 9 ],
                    22:[ 2, 9 ],
                    24:[ 2, 9 ]
                }, {
                    14:[ 2, 10 ],
                    18:[ 2, 10 ],
                    22:[ 2, 10 ],
                    24:[ 2, 10 ]
                }, {
                    14:[ 2, 11 ],
                    18:[ 2, 11 ],
                    22:[ 2, 11 ],
                    24:[ 2, 11 ]
                }, {
                    14:[ 2, 12 ],
                    18:[ 2, 12 ],
                    22:[ 2, 12 ],
                    24:[ 2, 12 ]
                }, {
                    14:[ 2, 3 ],
                    18:[ 2, 3 ],
                    22:[ 2, 3 ],
                    24:[ 2, 3 ]
                }, {
                    14:[ 2, 4 ],
                    18:[ 2, 4 ],
                    22:[ 2, 4 ],
                    24:[ 2, 4 ]
                }, {
                    14:[ 2, 5 ],
                    18:[ 2, 5 ],
                    22:[ 2, 5 ],
                    24:[ 2, 5 ]
                }, {
                    14:[ 2, 1 ],
                    18:[ 2, 1 ],
                    21:[ 2, 1 ],
                    22:[ 2, 1 ],
                    24:[ 2, 1 ]
                }, {
                    14:[ 2, 2 ],
                    18:[ 2, 2 ],
                    22:[ 2, 2 ],
                    24:[ 2, 2 ]
                }, {
                    3:20,
                    4:[ 1, 12 ],
                    18:[ 1, 17 ],
                    19:18,
                    20:19
                }, {
                    3:5,
                    4:[ 1, 12 ],
                    5:6,
                    6:[ 1, 13 ],
                    7:3,
                    8:[ 1, 9 ],
                    9:4,
                    10:[ 1, 10 ],
                    11:[ 1, 11 ],
                    13:23,
                    15:7,
                    16:8,
                    17:[ 1, 14 ],
                    23:[ 1, 15 ],
                    24:[ 1, 21 ],
                    25:22
                }, {
                    1:[ 2, 6 ]
                }, {
                    14:[ 2, 13 ],
                    18:[ 2, 13 ],
                    22:[ 2, 13 ],
                    24:[ 2, 13 ]
                }, {
                    18:[ 1, 24 ],
                    22:[ 1, 25 ]
                }, {
                    18:[ 2, 16 ],
                    22:[ 2, 16 ]
                }, {
                    21:[ 1, 26 ]
                }, {
                    14:[ 2, 18 ],
                    18:[ 2, 18 ],
                    22:[ 2, 18 ],
                    24:[ 2, 18 ]
                }, {
                    22:[ 1, 28 ],
                    24:[ 1, 27 ]
                }, {
                    22:[ 2, 20 ],
                    24:[ 2, 20 ]
                }, {
                    14:[ 2, 14 ],
                    18:[ 2, 14 ],
                    22:[ 2, 14 ],
                    24:[ 2, 14 ]
                }, {
                    3:20,
                    4:[ 1, 12 ],
                    20:29
                }, {
                    3:5,
                    4:[ 1, 12 ],
                    5:6,
                    6:[ 1, 13 ],
                    7:3,
                    8:[ 1, 9 ],
                    9:4,
                    10:[ 1, 10 ],
                    11:[ 1, 11 ],
                    13:30,
                    15:7,
                    16:8,
                    17:[ 1, 14 ],
                    23:[ 1, 15 ]
                }, {
                    14:[ 2, 19 ],
                    18:[ 2, 19 ],
                    22:[ 2, 19 ],
                    24:[ 2, 19 ]
                }, {
                    3:5,
                    4:[ 1, 12 ],
                    5:6,
                    6:[ 1, 13 ],
                    7:3,
                    8:[ 1, 9 ],
                    9:4,
                    10:[ 1, 10 ],
                    11:[ 1, 11 ],
                    13:31,
                    15:7,
                    16:8,
                    17:[ 1, 14 ],
                    23:[ 1, 15 ]
                }, {
                    18:[ 2, 17 ],
                    22:[ 2, 17 ]
                }, {
                    18:[ 2, 15 ],
                    22:[ 2, 15 ]
                }, {
                    22:[ 2, 21 ],
                    24:[ 2, 21 ]
                } ],
                defaultActions:{
                    16:[ 2, 6 ]
                },
                parseError:function(e, t) {
                    throw new Error(e);
                },
                parse:function(e) {
                    function t() {
                        var e;
                        return e = n.lexer.lex() || 1, "number" != typeof e && (e = n.symbols_[e] || e),
                            e;
                    }
                    var n = this, i = [ 0 ], o = [ null ], r = [], s = this.table, a = "", l = 0, c = 0, h = 0, d = 2;
                    this.lexer.setInput(e), this.lexer.yy = this.yy, this.yy.lexer = this.lexer, void 0 === this.lexer.yylloc && (this.lexer.yylloc = {});
                    var u = this.lexer.yylloc;
                    r.push(u), "function" == typeof this.yy.parseError && (this.parseError = this.yy.parseError);
                    for (var p, f, m, g, v, y, b, x, w, _ = {}; ;) {
                        if (m = i[i.length - 1], this.defaultActions[m] ? g = this.defaultActions[m] :(null == p && (p = t()),
                                g = s[m] && s[m][p]), void 0 === g || !g.length || !g[0]) {
                            if (!h) {
                                w = [];
                                for (y in s[m]) this.terminals_[y] && y > 2 && w.push("'" + this.terminals_[y] + "'");
                                var C = "";
                                C = this.lexer.showPosition ? "Parse error on line " + (l + 1) + ":\n" + this.lexer.showPosition() + "\nExpecting " + w.join(", ") + ", got '" + this.terminals_[p] + "'" :"Parse error on line " + (l + 1) + ": Unexpected " + (1 == p ? "end of input" :"'" + (this.terminals_[p] || p) + "'"),
                                    this.parseError(C, {
                                        text:this.lexer.match,
                                        token:this.terminals_[p] || p,
                                        line:this.lexer.yylineno,
                                        loc:u,
                                        expected:w
                                    });
                            }
                            if (3 == h) {
                                if (1 == p) throw new Error(C || "Parsing halted.");
                                c = this.lexer.yyleng, a = this.lexer.yytext, l = this.lexer.yylineno, u = this.lexer.yylloc,
                                    p = t();
                            }
                            for (;;) {
                                if (d.toString() in s[m]) break;
                                if (0 == m) throw new Error(C || "Parsing halted.");
                                !function(e) {
                                    i.length = i.length - 2 * e, o.length = o.length - e, r.length = r.length - e;
                                }(1), m = i[i.length - 1];
                            }
                            f = p, p = d, m = i[i.length - 1], g = s[m] && s[m][d], h = 3;
                        }
                        if (g[0] instanceof Array && g.length > 1) throw new Error("Parse Error: multiple actions possible at state: " + m + ", token: " + p);
                        switch (g[0]) {
                            case 1:
                                i.push(p), o.push(this.lexer.yytext), r.push(this.lexer.yylloc), i.push(g[1]), p = null,
                                    f ? (p = f, f = null) :(c = this.lexer.yyleng, a = this.lexer.yytext, l = this.lexer.yylineno,
                                        u = this.lexer.yylloc, h > 0 && h--);
                                break;

                            case 2:
                                if (b = this.productions_[g[1]][1], _.$ = o[o.length - b], _._$ = {
                                        first_line:r[r.length - (b || 1)].first_line,
                                        last_line:r[r.length - 1].last_line,
                                        first_column:r[r.length - (b || 1)].first_column,
                                        last_column:r[r.length - 1].last_column
                                    }, void 0 !== (v = this.performAction.call(_, a, c, l, this.yy, g[1], o, r))) return v;
                                b && (i = i.slice(0, -1 * b * 2), o = o.slice(0, -1 * b), r = r.slice(0, -1 * b)),
                                    i.push(this.productions_[g[1]][0]), o.push(_.$), r.push(_._$), x = s[i[i.length - 2]][i[i.length - 1]],
                                    i.push(x);
                                break;

                            case 3:
                                return !0;
                        }
                    }
                    return !0;
                }
            }, t = function() {
                var e = {
                    EOF:1,
                    parseError:function(e, t) {
                        if (!this.yy.parseError) throw new Error(e);
                        this.yy.parseError(e, t);
                    },
                    setInput:function(e) {
                        return this._input = e, this._more = this._less = this.done = !1, this.yylineno = this.yyleng = 0,
                            this.yytext = this.matched = this.match = "", this.conditionStack = [ "INITIAL" ],
                            this.yylloc = {
                                first_line:1,
                                first_column:0,
                                last_line:1,
                                last_column:0
                            }, this;
                    },
                    input:function() {
                        var e = this._input[0];
                        return this.yytext += e, this.yyleng++, this.match += e, this.matched += e, e.match(/\n/) && this.yylineno++,
                            this._input = this._input.slice(1), e;
                    },
                    unput:function(e) {
                        return this._input = e + this._input, this;
                    },
                    more:function() {
                        return this._more = !0, this;
                    },
                    less:function(e) {
                        this._input = this.match.slice(e) + this._input;
                    },
                    pastInput:function() {
                        var e = this.matched.substr(0, this.matched.length - this.match.length);
                        return (e.length > 20 ? "..." :"") + e.substr(-20).replace(/\n/g, "");
                    },
                    upcomingInput:function() {
                        var e = this.match;
                        return e.length < 20 && (e += this._input.substr(0, 20 - e.length)), (e.substr(0, 20) + (e.length > 20 ? "..." :"")).replace(/\n/g, "");
                    },
                    showPosition:function() {
                        var e = this.pastInput(), t = new Array(e.length + 1).join("-");
                        return e + this.upcomingInput() + "\n" + t + "^";
                    },
                    next:function() {
                        if (this.done) return this.EOF;
                        this._input || (this.done = !0);
                        var e, t, n, i, o;
                        this._more || (this.yytext = "", this.match = "");
                        for (var r = this._currentRules(), s = 0; s < r.length && (!(n = this._input.match(this.rules[r[s]])) || t && !(n[0].length > t[0].length) || (t = n,
                            i = s, this.options.flex)); s++) ;
                        return t ? (o = t[0].match(/\n.*/g), o && (this.yylineno += o.length), this.yylloc = {
                            first_line:this.yylloc.last_line,
                            last_line:this.yylineno + 1,
                            first_column:this.yylloc.last_column,
                            last_column:o ? o[o.length - 1].length - 1 :this.yylloc.last_column + t[0].length
                        }, this.yytext += t[0], this.match += t[0], this.yyleng = this.yytext.length, this._more = !1,
                            this._input = this._input.slice(t[0].length), this.matched += t[0], e = this.performAction.call(this, this.yy, this, r[i], this.conditionStack[this.conditionStack.length - 1]),
                        this.done && this._input && (this.done = !1), e || void 0) :"" === this._input ? this.EOF :void this.parseError("Lexical error on line " + (this.yylineno + 1) + ". Unrecognized text.\n" + this.showPosition(), {
                            text:"",
                            token:null,
                            line:this.yylineno
                        });
                    },
                    lex:function() {
                        var e = this.next();
                        return void 0 !== e ? e :this.lex();
                    },
                    begin:function(e) {
                        this.conditionStack.push(e);
                    },
                    popState:function() {
                        return this.conditionStack.pop();
                    },
                    _currentRules:function() {
                        return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;
                    },
                    topState:function() {
                        return this.conditionStack[this.conditionStack.length - 2];
                    },
                    pushState:function(e) {
                        this.begin(e);
                    }
                };
                return e.options = {}, e.performAction = function(e, t, n, i) {
                    switch (n) {
                        case 0:
                            break;

                        case 1:
                            return 6;

                        case 2:
                            return t.yytext = t.yytext.substr(1, t.yyleng - 2), 4;

                        case 3:
                            return 17;

                        case 4:
                            return 18;

                        case 5:
                            return 23;

                        case 6:
                            return 24;

                        case 7:
                            return 22;

                        case 8:
                            return 21;

                        case 9:
                            return 10;

                        case 10:
                            return 11;

                        case 11:
                            return 8;

                        case 12:
                            return 14;

                        case 13:
                            return "INVALID";
                    }
                }, e.rules = [ /^(?:\s+)/, /^(?:(-?([0-9]|[1-9][0-9]+))(\.[0-9]+)?([eE][-+]?[0-9]+)?\b)/, /^(?:"(?:\\[\\"bfnrt\/]|\\u[a-fA-F0-9]{4}|[^\\\0-\x09\x0a-\x1f"])*")/, /^(?:\{)/, /^(?:\})/, /^(?:\[)/, /^(?:\])/, /^(?:,)/, /^(?::)/, /^(?:true\b)/, /^(?:false\b)/, /^(?:null\b)/, /^(?:$)/, /^(?:.)/ ],
                    e.conditions = {
                        INITIAL:{
                            rules:[ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13 ],
                            inclusive:!0
                        }
                    }, e;
            }();
            return e.lexer = t, e;
        }();
        t.parser = i, t.parse = i.parse.bind(i);
    }, function(e, t) {
        "use strict";
        var n, i = [ "en", "pt-BR" ], o = {
            en:{
                array:"Array",
                auto:"Auto",
                appendText:"Append",
                appendTitle:"Append a new field with type 'auto' after this field (Ctrl+Shift+Ins)",
                appendSubmenuTitle:"Select the type of the field to be appended",
                appendTitleAuto:"Append a new field with type 'auto' (Ctrl+Shift+Ins)",
                ascending:"Ascending",
                ascendingTitle:"Sort the childs of this ${type} in ascending order",
                actionsMenu:"Click to open the actions menu (Ctrl+M)",
                collapseAll:"Collapse all fields",
                descending:"Descending",
                descendingTitle:"Sort the childs of this ${type} in descending order",
                drag:"Drag to move this field (Alt+Shift+Arrows)",
                duplicateKey:"duplicate key",
                duplicateText:"Duplicate",
                duplicateTitle:"Duplicate selected fields (Ctrl+D)",
                duplicateField:"Duplicate this field (Ctrl+D)",
                empty:"empty",
                expandAll:"Expand all fields",
                expandTitle:"Click to expand/collapse this field (Ctrl+E). \nCtrl+Click to expand/collapse including all childs.",
                insert:"Insert",
                insertTitle:"Insert a new field with type 'auto' before this field (Ctrl+Ins)",
                insertSub:"Select the type of the field to be inserted",
                object:"Object",
                ok:"Ok",
                redo:"Redo (Ctrl+Shift+Z)",
                removeText:"Remove",
                removeTitle:"Remove selected fields (Ctrl+Del)",
                removeField:"Remove this field (Ctrl+Del)",
                selectNode:"Select a node...",
                showAll:"show all",
                showMore:"show more",
                showMoreStatus:"displaying ${visibleChilds} of ${totalChilds} items.",
                sort:"Sort",
                sortTitle:"Sort the childs of this ${type}",
                sortTitleShort:"Sort contents",
                sortFieldLabel:"Field:",
                sortDirectionLabel:"Direction:",
                sortFieldTitle:"Select the nested field by which to sort the array or object",
                sortAscending:"Ascending",
                sortAscendingTitle:"Sort the selected field in ascending order",
                sortDescending:"Descending",
                sortDescendingTitle:"Sort the selected field in descending order",
                string:"String",
                transform:"Transform",
                transformTitle:"Filter, sort, or transform the childs of this ${type}",
                transformTitleShort:"Filter, sort, or transform contents",
                transformQueryTitle:"Enter a JMESPath query",
                transformWizardLabel:"Wizard",
                transformWizardFilter:"Filter",
                transformWizardSortBy:"Sort by",
                transformWizardSelectFields:"Select fields",
                transformQueryLabel:"Query",
                transformPreviewLabel:"Preview",
                type:"Type",
                typeTitle:"Change the type of this field",
                openUrl:"Ctrl+Click or Ctrl+Enter to open url in new window",
                undo:"Undo last action (Ctrl+Z)",
                validationCannotMove:"Cannot move a field into a child of itself",
                autoType:'Field type "auto". The field type is automatically determined from the value and can be a string, number, boolean, or null.',
                objectType:'Field type "object". An object contains an unordered set of key/value pairs.',
                arrayType:'Field type "array". An array contains an ordered collection of values.',
                stringType:'Field type "string". Field type is not determined from the value, but always returned as string.'
            },
            "pt-BR":{
                array:"Lista",
                auto:"Automatico",
                appendText:"Adicionar",
                appendTitle:"Adicionar novo campo com tipo 'auto' depois deste campo (Ctrl+Shift+Ins)",
                appendSubmenuTitle:"Selecione o tipo do campo a ser adicionado",
                appendTitleAuto:"Adicionar novo campo com tipo 'auto' (Ctrl+Shift+Ins)",
                ascending:"Ascendente",
                ascendingTitle:"Organizar filhor do tipo ${type} em crescente",
                actionsMenu:"Clique para abrir o menu de ações (Ctrl+M)",
                collapseAll:"Fechar todos campos",
                descending:"Descendente",
                descendingTitle:"Organizar o filhos do tipo ${type} em decrescente",
                duplicateKey:"chave duplicada",
                drag:"Arraste para mover este campo (Alt+Shift+Arrows)",
                duplicateText:"Duplicar",
                duplicateTitle:"Duplicar campos selecionados (Ctrl+D)",
                duplicateField:"Duplicar este campo (Ctrl+D)",
                empty:"vazio",
                expandAll:"Expandir todos campos",
                expandTitle:"Clique para expandir/encolher este campo (Ctrl+E). \nCtrl+Click para expandir/encolher incluindo todos os filhos.",
                insert:"Inserir",
                insertTitle:"Inserir um novo campo do tipo 'auto' antes deste campo (Ctrl+Ins)",
                insertSub:"Selecionar o tipo de campo a ser inserido",
                object:"Objeto",
                ok:"Ok",
                redo:"Refazer (Ctrl+Shift+Z)",
                removeText:"Remover",
                removeTitle:"Remover campos selecionados (Ctrl+Del)",
                removeField:"Remover este campo (Ctrl+Del)",
                selectNode:"Select a node...",
                showAll:"mostre tudo",
                showMore:"mostre mais",
                showMoreStatus:"exibindo ${visibleChilds} de ${totalChilds} itens.",
                sort:"Organizar",
                sortTitle:"Organizar os filhos deste ${type}",
                sortTitleShort:"Organizar os filhos",
                sortFieldLabel:"Field:",
                sortDirectionLabel:"Direction:",
                sortFieldTitle:"Select the nested field by which to sort the array or object",
                sortAscending:"Ascending",
                sortAscendingTitle:"Sort the selected field in ascending order",
                sortDescending:"Descending",
                sortDescendingTitle:"Sort the selected field in descending order",
                string:"Texto",
                transform:"Transform",
                transformTitle:"Filter, sort, or transform the childs of this ${type}",
                transformTitleShort:"Filter, sort, or transform contents",
                transformQueryTitle:"Enter a JMESPath query",
                transformWizardLabel:"Wizard",
                transformWizardFilter:"Filter",
                transformWizardSortBy:"Sort by",
                transformWizardSelectFields:"Select fields",
                transformQueryLabel:"Query",
                transformPreviewLabel:"Preview",
                type:"Tipo",
                typeTitle:"Mudar o tipo deste campo",
                openUrl:"Ctrl+Click ou Ctrl+Enter para abrir link em nova janela",
                undo:"Desfazer último ação (Ctrl+Z)",
                validationCannotMove:"Não pode mover um campo como filho dele mesmo",
                autoType:'Campo do tipo "auto". O tipo do campo é determinao automaticamente a partir do seu valor e pode ser texto, número, verdade/falso ou nulo.',
                objectType:'Campo do tipo "objeto". Um objeto contém uma lista de pares com chave e valor.',
                arrayType:'Campo do tipo "lista". Uma lista contem uma coleção de valores ordenados.',
                stringType:'Campo do tipo "string". Campo do tipo nao é determinado através do seu valor, mas sempre retornara um texto.'
            }
        }, r = "undefined" != typeof navigator ? navigator.language || navigator.userLanguage :void 0;
        n = i.find(function(e) {
            return e === r;
        }), n || (n = "en"), e.exports = {
            _locales:i,
            _defs:o,
            _lang:n,
            setLanguage:function(e) {
                if (e) {
                    var t = i.find(function(t) {
                        return t === e;
                    });
                    t ? n = t :console.error("Language not found");
                }
            },
            setLanguages:function(e) {
                if (e) for (var t in e) {
                    var n = i.find(function(e) {
                        return e === t;
                    });
                    n || i.push(t), o[t] = Object.assign({}, o.en, o[t], e[t]);
                }
            },
            translate:function(e, t, i) {
                i || (i = n);
                var r = o[i][e];
                if (t) for (e in t) r = r.replace("${" + e + "}", t[e]);
                return r || e;
            }
        };
    }, function(e, t, n) {
        "use strict";
        function i(e) {
            e && (this.path = document.createElement("div"), this.path.className = "jsoneditor-treepath",
                e.appendChild(this.path), this.reset());
        }
        var o = n(5), r = n(8).translate;
        i.prototype.reset = function() {
            this.path.innerHTML = r("selectNode");
        }, i.prototype.setPath = function(e) {
            function t(e) {
                this.selectionCallback && this.selectionCallback(e);
            }
            function n(e, t) {
                this.contextMenuCallback && this.contextMenuCallback(e, t);
            }
            var i = this;
            this.path.innerHTML = "", e && e.length && e.forEach(function(r, s) {
                var a, l = document.createElement("span");
                if (l.className = "jsoneditor-treepath-element", l.innerText = r.name, l.onclick = t.bind(i, r),
                        i.path.appendChild(l), r.children.length && (a = document.createElement("span"),
                        a.className = "jsoneditor-treepath-seperator", a.innerHTML = "&#9658;", a.onclick = function() {
                        var t = [];
                        r.children.forEach(function(o) {
                            t.push({
                                text:o.name,
                                className:"jsoneditor-type-modes" + (e[s + 1] + 1 && e[s + 1].name === o.name ? " jsoneditor-selected" :""),
                                click:n.bind(i, r, o.name)
                            });
                        }), new o(t).show(a);
                    }, i.path.appendChild(a, i.container)), s === e.length - 1) {
                    var c = (a || l).getBoundingClientRect().left;
                    i.path.offsetWidth < c && (i.path.scrollLeft = c);
                }
            });
        }, i.prototype.onSectionSelected = function(e) {
            "function" == typeof e && (this.selectionCallback = e);
        }, i.prototype.onContextMenuItemSelected = function(e) {
            "function" == typeof e && (this.contextMenuCallback = e);
        }, e.exports = i;
    }, function(e, t, n) {
        "use strict";
        function i(e, t) {
            this.editor = e, this.dom = {}, this.expanded = !1, t && t instanceof Object ? (this.setField(t.field, t.fieldEditable),
            "value" in t && this.setValue(t.value, t.type), "internalValue" in t && this.setInternalValue(t.internalValue)) :(this.setField(""),
                this.setValue(null)), this._debouncedOnChangeValue = p.debounce(this._onChangeValue.bind(this), i.prototype.DEBOUNCE_INTERVAL),
                this._debouncedOnChangeField = p.debounce(this._onChangeField.bind(this), i.prototype.DEBOUNCE_INTERVAL);
        }
        function o(e) {
            return e.getInternalPath();
        }
        function r(e) {
            return e.getField();
        }
        var s = n(11), a = n(12), l = n(5), c = n(13), h = n(14), d = n(15), u = n(17), p = n(6), f = n(8).translate, m = document.body;
        i.prototype.DEBOUNCE_INTERVAL = 150, i.prototype.MAX_SEARCH_RESULTS = 999, i.prototype.MAX_VISIBLE_CHILDS = 100,
            i.prototype.visibleChilds = i.prototype.MAX_VISIBLE_CHILDS, i.prototype._updateEditability = function() {
            if (this.editable = {
                    field:!0,
                    value:!0
                }, this.editor && (this.editable.field = "tree" === this.editor.options.mode, this.editable.value = "view" !== this.editor.options.mode,
                ("tree" === this.editor.options.mode || "form" === this.editor.options.mode) && "function" == typeof this.editor.options.onEditable)) {
                var e = this.editor.options.onEditable({
                    field:this.field,
                    value:this.value,
                    path:this.getPath()
                });
                "boolean" == typeof e ? (this.editable.field = e, this.editable.value = e) :("boolean" == typeof e.field && (this.editable.field = e.field),
                "boolean" == typeof e.value && (this.editable.value = e.value));
            }
        }, i.prototype.getPath = function() {
            for (var e = this, t = []; e; ) {
                var n = e.getName();
                void 0 !== n && t.unshift(n), e = e.parent;
            }
            return t;
        }, i.prototype.getInternalPath = function() {
            for (var e = this, t = []; e; ) e.parent && t.unshift(e.getIndex()), e = e.parent;
            return t;
        }, i.prototype.getName = function() {
            return this.parent ? "array" != this.parent.type ? this.field :this.index :void 0;
        }, i.prototype.findNodeByPath = function(e) {
            if (e) {
                if (0 == e.length) return this;
                if (e.length && this.childs && this.childs.length) for (var t = 0; t < this.childs.length; ++t) if ("" + e[0] == "" + this.childs[t].getName()) return this.childs[t].findNodeByPath(e.slice(1));
            }
        }, i.prototype.findNodeByInternalPath = function(e) {
            if (e) {
                for (var t = this, n = 0; n < e.length && t; n++) {
                    var i = e[n];
                    t = t.childs[i];
                }
                return t;
            }
        }, i.prototype.serialize = function() {
            return {
                value:this.getValue(),
                path:this.getPath()
            };
        }, i.prototype.findNode = function(e) {
            for (var t = p.parsePath(e), n = this; n && t.length > 0; ) {
                var i = t.shift();
                if ("number" == typeof i) {
                    if ("array" !== n.type) throw new Error("Cannot get child node at index " + i + ": node is no array");
                    n = n.childs[i];
                } else {
                    if ("object" !== n.type) throw new Error("Cannot get child node " + i + ": node is no object");
                    n = n.childs.filter(function(e) {
                        return e.field === i;
                    })[0];
                }
            }
            return n;
        }, i.prototype.findParents = function() {
            for (var e = [], t = this.parent; t; ) e.unshift(t), t = t.parent;
            return e;
        }, i.prototype.setError = function(e, t) {
            this.error = e, this.errorChild = t, this.dom && this.dom.tr && this.updateError();
        }, i.prototype.updateError = function() {
            var e = this.error, t = this.dom.tdError;
            if (e && this.dom && this.dom.tr) {
                t || (t = document.createElement("td"), this.dom.tdError = t, this.dom.tdValue.parentNode.appendChild(t));
                var n = document.createElement("div");
                n.className = "jsoneditor-popover jsoneditor-right", n.appendChild(document.createTextNode(e.message));
                var i = document.createElement("button");
                i.type = "button", i.className = "jsoneditor-schema-error", i.appendChild(n), i.onmouseover = i.onfocus = function() {
                    for (var e = [ "right", "above", "below", "left" ], t = 0; t < e.length; t++) {
                        var i = e[t];
                        n.className = "jsoneditor-popover jsoneditor-" + i;
                        var o = this.editor.content.getBoundingClientRect(), r = n.getBoundingClientRect();
                        if (p.insideRect(o, r, 20)) break;
                    }
                }.bind(this);
                var o = this.errorChild;
                for (o && (i.onclick = function() {
                    o.findParents().forEach(function(e) {
                        e.expand(!1);
                    }), o.scrollTo(function() {
                        o.focus();
                    });
                }); t.firstChild; ) t.removeChild(t.firstChild);
                t.appendChild(i);
            } else t && (this.dom.tdError.parentNode.removeChild(this.dom.tdError), delete this.dom.tdError);
        }, i.prototype.getIndex = function() {
            if (this.parent) {
                var e = this.parent.childs.indexOf(this);
                return -1 !== e ? e :null;
            }
            return -1;
        }, i.prototype.setParent = function(e) {
            this.parent = e;
        }, i.prototype.setField = function(e, t) {
            this.field = e, this.previousField = e, this.fieldEditable = !0 === t;
        }, i.prototype.getField = function() {
            return void 0 === this.field && this._getDomField(), this.field;
        }, i.prototype.setValue = function(e, t) {
            var n, o, r, s, a, l = this.childs;
            if (this.type = this._getType(e), t && t !== this.type) {
                if ("string" !== t || "auto" !== this.type) throw new Error('Type mismatch: cannot cast value of type "' + this.type + ' to the specified type "' + t + '"');
                this.type = t;
            }
            if ("array" === this.type) {
                for (this.childs || (this.childs = []), s = 0; s < e.length; s++) void 0 === (n = e[s]) || n instanceof Function || (s < this.childs.length ? (o = this.childs[s],
                    o.fieldEditable = !1, o.index = s, o.setValue(n)) :(o = new i(this.editor, {
                    value:n
                }), r = s < this.MAX_VISIBLE_CHILDS, this.appendChild(o, r, !1)));
                for (a = this.childs.length; a >= e.length; a--) this.removeChild(this.childs[a], !1);
            } else if ("object" === this.type) {
                for (this.childs || (this.childs = []), a = this.childs.length - 1; a >= 0; a--) e.hasOwnProperty(this.childs[a].field) || this.removeChild(this.childs[a], !1);
                s = 0;
                for (var c in e) e.hasOwnProperty(c) && (n = e[c], void 0 === n || n instanceof Function || (o = this.findChildByProperty(c),
                    o ? (o.setField(c, !0), o.setValue(n)) :(o = new i(this.editor, {
                        field:c,
                        value:n
                    }), r = s < this.MAX_VISIBLE_CHILDS, this.appendChild(o, r, !1))), s++);
                this.value = "", !0 === this.editor.options.sortObjectKeys && this.sort([], "asc");
            } else this.hideChilds(), delete this.append, delete this.showMore, delete this.expanded,
                delete this.childs, this.value = e;
            Array.isArray(l) !== Array.isArray(this.childs) && this.recreateDom(), this.updateDom({
                updateIndexes:!0
            }), this.previousValue = this.value;
        }, i.prototype.setInternalValue = function(e) {
            var t, n, o, r, s, a = this.childs;
            if (this.type = e.type, "array" === e.type) {
                for (this.childs || (this.childs = []), r = 0; r < e.childs.length; r++) void 0 === (t = e.childs[r]) || t instanceof Function || (r < this.childs.length ? (n = this.childs[r],
                    n.fieldEditable = !1, n.index = r, n.setInternalValue(t)) :(n = new i(this.editor, {
                    internalValue:t
                }), o = r < this.MAX_VISIBLE_CHILDS, this.appendChild(n, o, !1)));
                for (s = this.childs.length; s >= e.childs.length; s--) this.removeChild(this.childs[s], !1);
            } else if ("object" === e.type) {
                for (this.childs || (this.childs = []), r = 0; r < e.childs.length; r++) void 0 === (t = e.childs[r]) || t instanceof Function || (r < this.childs.length ? (n = this.childs[r],
                    delete n.index, n.setField(t.field, !0), n.setInternalValue(t.value)) :(n = new i(this.editor, {
                    field:t.field,
                    internalValue:t.value
                }), o = r < this.MAX_VISIBLE_CHILDS, this.appendChild(n, o, !1)));
                for (s = this.childs.length; s >= e.childs.length; s--) this.removeChild(this.childs[s], !1);
            } else this.hideChilds(), delete this.append, delete this.showMore, delete this.expanded,
                delete this.childs, this.value = e.value;
            Array.isArray(a) !== Array.isArray(this.childs) && this.recreateDom(), this.updateDom({
                updateIndexes:!0
            }), this.previousValue = this.value;
        }, i.prototype.recreateDom = function() {
            if (this.dom && this.dom.tr && this.dom.tr.parentNode) {
                var e = this._detachFromDom();
                this.clearDom(), this._attachToDom(e);
            }
        }, i.prototype.getValue = function() {
            if ("array" == this.type) {
                var e = [];
                return this.childs.forEach(function(t) {
                    e.push(t.getValue());
                }), e;
            }
            if ("object" == this.type) {
                var t = {};
                return this.childs.forEach(function(e) {
                    t[e.getField()] = e.getValue();
                }), t;
            }
            return void 0 === this.value && this._getDomValue(), this.value;
        }, i.prototype.getInternalValue = function() {
            return "array" === this.type ? {
                type:this.type,
                childs:this.childs.map(function(e) {
                    return e.getInternalValue();
                })
            } :"object" === this.type ? {
                type:this.type,
                childs:this.childs.map(function(e) {
                    return {
                        field:e.getField(),
                        value:e.getInternalValue()
                    };
                })
            } :(void 0 === this.value && this._getDomValue(), {
                type:this.type,
                value:this.value
            });
        }, i.prototype.getLevel = function() {
            return this.parent ? this.parent.getLevel() + 1 :0;
        }, i.prototype.getNodePath = function() {
            var e = this.parent ? this.parent.getNodePath() :[];
            return e.push(this), e;
        }, i.prototype.clone = function() {
            var e = new i(this.editor);
            if (e.type = this.type, e.field = this.field, e.fieldInnerText = this.fieldInnerText,
                    e.fieldEditable = this.fieldEditable, e.previousField = this.previousField, e.value = this.value,
                    e.valueInnerText = this.valueInnerText, e.previousValue = this.previousValue, e.expanded = this.expanded,
                    e.visibleChilds = this.visibleChilds, this.childs) {
                var t = [];
                this.childs.forEach(function(n) {
                    var i = n.clone();
                    i.setParent(e), t.push(i);
                }), e.childs = t;
            } else e.childs = void 0;
            return e;
        }, i.prototype.expand = function(e) {
            this.childs && (this.expanded = !0, this.dom.expand && (this.dom.expand.className = "jsoneditor-expanded"),
                this.showChilds(), !1 !== e && this.childs.forEach(function(t) {
                t.expand(e);
            }));
        }, i.prototype.collapse = function(e) {
            this.childs && (this.hideChilds(), !1 !== e && this.childs.forEach(function(t) {
                t.collapse(e);
            }), this.dom.expand && (this.dom.expand.className = "jsoneditor-collapsed"), this.expanded = !1);
        }, i.prototype.showChilds = function() {
            if (this.childs && this.expanded) {
                var e = this.dom.tr, t = e ? e.parentNode :void 0;
                if (t) {
                    var n = this.getAppendDom();
                    if (!n.parentNode) {
                        var i = e.nextSibling;
                        i ? t.insertBefore(n, i) :t.appendChild(n);
                    }
                    for (var o = Math.min(this.childs.length, this.visibleChilds), i = this._getNextTr(), r = 0; r < o; r++) {
                        var s = this.childs[r];
                        s.getDom().parentNode || t.insertBefore(s.getDom(), i), s.showChilds();
                    }
                    var a = this.getShowMoreDom(), i = this._getNextTr();
                    a.parentNode || t.insertBefore(a, i), this.showMore.updateDom();
                }
            }
        }, i.prototype._getNextTr = function() {
            return this.showMore && this.showMore.getDom().parentNode ? this.showMore.getDom() :this.append && this.append.getDom().parentNode ? this.append.getDom() :void 0;
        }, i.prototype.hide = function(e) {
            var t = this.dom.tr, n = t ? t.parentNode :void 0;
            n && n.removeChild(t), this.hideChilds(e);
        }, i.prototype.hideChilds = function(e) {
            if (this.childs && this.expanded) {
                var t = this.getAppendDom();
                t.parentNode && t.parentNode.removeChild(t), this.childs.forEach(function(e) {
                    e.hide();
                });
                var n = this.getShowMoreDom();
                n.parentNode && n.parentNode.removeChild(n), e && !e.resetVisibleChilds || delete this.visibleChilds;
            }
        }, i.prototype.expandTo = function() {
            for (var e = this.parent; e; ) e.expanded || e.expand(), e = e.parent;
        }, i.prototype.appendChild = function(e, t, n) {
            if (this._hasChilds()) {
                if (e.setParent(this), e.fieldEditable = "object" == this.type, "array" == this.type && (e.index = this.childs.length),
                    "object" === this.type && void 0 == e.field && e.setField(""), this.childs.push(e),
                    this.expanded && !1 !== t) {
                    var i = e.getDom(), o = this._getNextTr(), r = o ? o.parentNode :void 0;
                    o && r && r.insertBefore(i, o), e.showChilds(), this.visibleChilds++;
                }
                !1 !== n && (this.updateDom({
                    updateIndexes:!0
                }), e.updateDom({
                    recurse:!0
                }));
            }
        }, i.prototype.moveBefore = function(e, t) {
            if (this._hasChilds()) {
                var n = this.dom.tr ? this.dom.tr.parentNode :void 0;
                if (n) {
                    var i = document.createElement("tr");
                    i.style.height = n.clientHeight + "px", n.appendChild(i);
                }
                if (e.parent && e.parent.removeChild(e), t instanceof g || !t) if (this.childs.length + 1 > this.visibleChilds) {
                    var o = this.childs[this.visibleChilds - 1];
                    this.insertBefore(e, o);
                } else this.appendChild(e); else this.insertBefore(e, t);
                n && n.removeChild(i);
            }
        }, i.prototype.insertBefore = function(e, t) {
            if (this._hasChilds()) {
                if (this.visibleChilds++, "object" === this.type && void 0 == e.field && e.setField(""),
                    t === this.append) e.setParent(this), e.fieldEditable = "object" == this.type, this.childs.push(e); else {
                    var n = this.childs.indexOf(t);
                    if (-1 == n) throw new Error("Node not found");
                    e.setParent(this), e.fieldEditable = "object" == this.type, this.childs.splice(n, 0, e);
                }
                if (this.expanded) {
                    var i = e.getDom(), o = t.getDom(), r = o ? o.parentNode :void 0;
                    o && r && r.insertBefore(i, o), e.showChilds(), this.showChilds();
                }
                this.updateDom({
                    updateIndexes:!0
                }), e.updateDom({
                    recurse:!0
                });
            }
        }, i.prototype.insertAfter = function(e, t) {
            if (this._hasChilds()) {
                var n = this.childs.indexOf(t), i = this.childs[n + 1];
                i ? this.insertBefore(e, i) :this.appendChild(e);
            }
        }, i.prototype.search = function(e, t) {
            Array.isArray(t) || (t = []);
            var n, i = e ? e.toLowerCase() :void 0;
            if (delete this.searchField, delete this.searchValue, void 0 !== this.field && t.length <= this.MAX_SEARCH_RESULTS) {
                n = String(this.field).toLowerCase().indexOf(i), -1 !== n && (this.searchField = !0,
                    t.push({
                        node:this,
                        elem:"field"
                    })), this._updateDomField();
            }
            if (this._hasChilds()) this.childs && this.childs.forEach(function(n) {
                n.search(e, t);
            }); else if (void 0 !== this.value && t.length <= this.MAX_SEARCH_RESULTS) {
                var o = String(this.value).toLowerCase();
                n = o.indexOf(i), -1 !== n && (this.searchValue = !0, t.push({
                    node:this,
                    elem:"value"
                })), this._updateDomValue();
            }
            return t;
        }, i.prototype.scrollTo = function(e) {
            this.expandPathToNode(), this.dom.tr && this.dom.tr.parentNode && this.editor.scrollTo(this.dom.tr.offsetTop, e);
        }, i.prototype.expandPathToNode = function() {
            for (var e = this; e && e.parent; ) {
                for (var t = "array" === e.parent.type ? e.index :e.parent.childs.indexOf(e); e.parent.visibleChilds < t + 1; ) e.parent.visibleChilds += i.prototype.MAX_VISIBLE_CHILDS;
                e.parent.expand(!1), e = e.parent;
            }
        }, i.focusElement = void 0, i.prototype.focus = function(e) {
            if (i.focusElement = e, this.dom.tr && this.dom.tr.parentNode) {
                var t = this.dom;
                switch (e) {
                    case "drag":
                        t.drag ? t.drag.focus() :t.menu.focus();
                        break;

                    case "menu":
                        t.menu.focus();
                        break;

                    case "expand":
                        this._hasChilds() ? t.expand.focus() :t.field && this.fieldEditable ? (t.field.focus(),
                            p.selectContentEditable(t.field)) :t.value && !this._hasChilds() ? (t.value.focus(),
                            p.selectContentEditable(t.value)) :t.menu.focus();
                        break;

                    case "field":
                        t.field && this.fieldEditable ? (t.field.focus(), p.selectContentEditable(t.field)) :t.value && !this._hasChilds() ? (t.value.focus(),
                            p.selectContentEditable(t.value)) :this._hasChilds() ? t.expand.focus() :t.menu.focus();
                        break;

                    case "value":
                    default:
                        t.select ? t.select.focus() :t.value && !this._hasChilds() ? (t.value.focus(), p.selectContentEditable(t.value)) :t.field && this.fieldEditable ? (t.field.focus(),
                            p.selectContentEditable(t.field)) :this._hasChilds() ? t.expand.focus() :t.menu.focus();
                }
            }
        }, i.select = function(e) {
            setTimeout(function() {
                p.selectContentEditable(e);
            }, 0);
        }, i.prototype.blur = function() {
            this._getDomValue(!1), this._getDomField(!1);
        }, i.prototype.containsNode = function(e) {
            if (this == e) return !0;
            var t = this.childs;
            if (t) for (var n = 0, i = t.length; n < i; n++) if (t[n].containsNode(e)) return !0;
            return !1;
        }, i.prototype.removeChild = function(e, t) {
            if (this.childs) {
                var n = this.childs.indexOf(e);
                if (-1 !== n) {
                    n < this.visibleChilds && this.expanded && this.visibleChilds--, e.hide(), delete e.searchField,
                        delete e.searchValue;
                    var i = this.childs.splice(n, 1)[0];
                    return i.parent = null, !1 !== t && this.updateDom({
                        updateIndexes:!0
                    }), i;
                }
            }
        }, i.prototype._remove = function(e) {
            this.removeChild(e);
        }, i.prototype.changeType = function(e) {
            var t = this.type;
            if (t != e) {
                if ("string" != e && "auto" != e || "string" != t && "auto" != t) {
                    var n = this._detachFromDom();
                    this.clearDom(), this.type = e, "object" == e ? (this.childs || (this.childs = []),
                        this.childs.forEach(function(e, t) {
                            e.clearDom(), delete e.index, e.fieldEditable = !0, void 0 == e.field && (e.field = "");
                        }), "string" != t && "auto" != t || (this.expanded = !0)) :"array" == e ? (this.childs || (this.childs = []),
                        this.childs.forEach(function(e, t) {
                            e.clearDom(), e.fieldEditable = !1, e.index = t;
                        }), "string" != t && "auto" != t || (this.expanded = !0)) :this.expanded = !1, this._attachToDom(n);
                } else this.type = e;
                "auto" != e && "string" != e || (this.value = "string" == e ? String(this.value) :this._stringCast(String(this.value)),
                    this.focus()), this.updateDom({
                    updateIndexes:!0
                });
            }
        }, i.prototype.deepEqual = function(e) {
            var t;
            if ("array" === this.type) {
                if (!Array.isArray(e)) return !1;
                if (this.childs.length !== e.length) return !1;
                for (t = 0; t < this.childs.length; t++) if (!this.childs[t].deepEqual(e[t])) return !1;
            } else if ("object" === this.type) {
                if ("object" != typeof e) return !1;
                var n = {}, i = 0;
                for (t = 0; t < this.childs.length; t++) {
                    var o = this.childs[t];
                    if (!n[o.field]) {
                        if (n[o.field] = !0, i++, !(o.field in e)) return !1;
                        if (!o.deepEqual(e[o.field])) return !1;
                    }
                }
                if (i !== Object.keys(e).length) return !1;
            } else if (this.value !== e) return !1;
            return !0;
        }, i.prototype._getDomValue = function(e) {
            if (this.dom.value && "array" != this.type && "object" != this.type && (this.valueInnerText = p.getInnerText(this.dom.value)),
                void 0 != this.valueInnerText) try {
                var t;
                if ("string" == this.type) t = this._unescapeHTML(this.valueInnerText); else {
                    var n = this._unescapeHTML(this.valueInnerText);
                    t = this._stringCast(n);
                }
                t !== this.value && (this.value = t, this._debouncedOnChangeValue());
            } catch (t) {
                if (this.value = void 0, !0 !== e) throw t;
            }
        }, i.prototype._onChangeValue = function() {
            var e = this.editor.getDomSelection();
            if (e.range) {
                var t = p.textDiff(String(this.value), String(this.previousValue));
                e.range.startOffset = t.start, e.range.endOffset = t.end;
            }
            var n = this.editor.getDomSelection();
            if (n.range) {
                var i = p.textDiff(String(this.previousValue), String(this.value));
                n.range.startOffset = i.start, n.range.endOffset = i.end;
            }
            this.editor._onAction("editValue", {
                path:this.getInternalPath(),
                oldValue:this.previousValue,
                newValue:this.value,
                oldSelection:e,
                newSelection:n
            }), this.previousValue = this.value;
        }, i.prototype._onChangeField = function() {
            var e = this.editor.getDomSelection(), t = this.previousField || "";
            if (e.range) {
                var n = p.textDiff(this.field, t);
                e.range.startOffset = n.start, e.range.endOffset = n.end;
            }
            var i = this.editor.getDomSelection();
            if (i.range) {
                var o = p.textDiff(t, this.field);
                i.range.startOffset = o.start, i.range.endOffset = o.end;
            }
            this.editor._onAction("editField", {
                parentPath:this.parent.getInternalPath(),
                index:this.getIndex(),
                oldValue:this.previousField,
                newValue:this.field,
                oldSelection:e,
                newSelection:i
            }), this.previousField = this.field;
        }, i.prototype._updateDomValue = function() {
            var e = this.dom.value;
            if (e) {
                var t = [ "jsoneditor-value" ], n = this.value, i = "auto" == this.type ? p.type(n) :this.type, o = "string" == i && p.isUrl(n);
                t.push("jsoneditor-" + i), o && t.push("jsoneditor-url");
                if ("" == String(this.value) && "array" != this.type && "object" != this.type && t.push("jsoneditor-empty"),
                    this.searchValueActive && t.push("jsoneditor-highlight-active"), this.searchValue && t.push("jsoneditor-highlight"),
                        e.className = t.join(" "), "array" == i || "object" == i) {
                    var r = this.childs ? this.childs.length :0;
                    e.title = this.type + " containing " + r + " items";
                } else o && this.editable.value ? e.title = f("openUrl") :e.title = "";
                if ("boolean" === i && this.editable.value ? (this.dom.checkbox || (this.dom.checkbox = document.createElement("input"),
                        this.dom.checkbox.type = "checkbox", this.dom.tdCheckbox = document.createElement("td"),
                        this.dom.tdCheckbox.className = "jsoneditor-tree", this.dom.tdCheckbox.appendChild(this.dom.checkbox),
                        this.dom.tdValue.parentNode.insertBefore(this.dom.tdCheckbox, this.dom.tdValue)),
                        this.dom.checkbox.checked = this.value) :this.dom.tdCheckbox && (this.dom.tdCheckbox.parentNode.removeChild(this.dom.tdCheckbox),
                        delete this.dom.tdCheckbox, delete this.dom.checkbox), this.enum && this.editable.value) {
                    if (!this.dom.select) {
                        this.dom.select = document.createElement("select"), this.id = this.field + "_" + new Date().getUTCMilliseconds(),
                            this.dom.select.id = this.id, this.dom.select.name = this.dom.select.id, this.dom.select.option = document.createElement("option"),
                            this.dom.select.option.value = "", this.dom.select.option.innerHTML = "--", this.dom.select.appendChild(this.dom.select.option);
                        for (var s = 0; s < this.enum.length; s++) this.dom.select.option = document.createElement("option"),
                            this.dom.select.option.value = this.enum[s], this.dom.select.option.innerHTML = this.enum[s],
                        this.dom.select.option.value == this.value && (this.dom.select.option.selected = !0),
                            this.dom.select.appendChild(this.dom.select.option);
                        this.dom.tdSelect = document.createElement("td"), this.dom.tdSelect.className = "jsoneditor-tree",
                            this.dom.tdSelect.appendChild(this.dom.select), this.dom.tdValue.parentNode.insertBefore(this.dom.tdSelect, this.dom.tdValue);
                    }
                    !this.schema || this.schema.hasOwnProperty("oneOf") || this.schema.hasOwnProperty("anyOf") || this.schema.hasOwnProperty("allOf") ? delete this.valueFieldHTML :(this.valueFieldHTML = this.dom.tdValue.innerHTML,
                        this.dom.tdValue.style.visibility = "hidden", this.dom.tdValue.innerHTML = "");
                } else this.dom.tdSelect && (this.dom.tdSelect.parentNode.removeChild(this.dom.tdSelect),
                    delete this.dom.tdSelect, delete this.dom.select, this.dom.tdValue.innerHTML = this.valueFieldHTML,
                    this.dom.tdValue.style.visibility = "", delete this.valueFieldHTML);
                p.stripFormatting(e);
            }
        }, i.prototype._updateDomField = function() {
            var e = this.dom.field;
            if (e) {
                "" == String(this.field) && "array" != this.parent.type ? p.addClassName(e, "jsoneditor-empty") :p.removeClassName(e, "jsoneditor-empty"),
                    this.searchFieldActive ? p.addClassName(e, "jsoneditor-highlight-active") :p.removeClassName(e, "jsoneditor-highlight-active"),
                    this.searchField ? p.addClassName(e, "jsoneditor-highlight") :p.removeClassName(e, "jsoneditor-highlight"),
                    p.stripFormatting(e);
            }
        }, i.prototype._getDomField = function(e) {
            if (this.dom.field && this.fieldEditable && (this.fieldInnerText = p.getInnerText(this.dom.field)),
                void 0 != this.fieldInnerText) try {
                var t = this._unescapeHTML(this.fieldInnerText);
                t !== this.field && (this.field = t, this._debouncedOnChangeField());
            } catch (t) {
                if (this.field = void 0, !0 !== e) throw t;
            }
        }, i.prototype.validate = function() {
            var e = [];
            if ("object" === this.type) {
                for (var t = {}, n = [], i = 0; i < this.childs.length; i++) {
                    var o = this.childs[i];
                    t.hasOwnProperty(o.field) && n.push(o.field), t[o.field] = !0;
                }
                n.length > 0 && (e = this.childs.filter(function(e) {
                    return -1 !== n.indexOf(e.field);
                }).map(function(e) {
                    return {
                        node:e,
                        error:{
                            message:f("duplicateKey") + ' "' + e.field + '"'
                        }
                    };
                }));
            }
            if (this.childs) for (var i = 0; i < this.childs.length; i++) {
                var r = this.childs[i].validate();
                r.length > 0 && (e = e.concat(r));
            }
            return e;
        }, i.prototype.clearDom = function() {
            this.dom = {};
        }, i.prototype.getDom = function() {
            var e = this.dom;
            if (e.tr) return e.tr;
            if (this._updateEditability(), e.tr = document.createElement("tr"), e.tr.node = this,
                "tree" === this.editor.options.mode) {
                var t = document.createElement("td");
                if (this.editable.field && this.parent) {
                    var n = document.createElement("button");
                    n.type = "button", e.drag = n, n.className = "jsoneditor-dragarea", n.title = f("drag"),
                        t.appendChild(n);
                }
                e.tr.appendChild(t);
                var i = document.createElement("td"), o = document.createElement("button");
                o.type = "button", e.menu = o, o.className = "jsoneditor-contextmenu", o.title = f("actionsMenu"),
                    i.appendChild(e.menu), e.tr.appendChild(i);
            }
            var r = document.createElement("td");
            return e.tr.appendChild(r), e.tree = this._createDomTree(), r.appendChild(e.tree),
                this.updateDom({
                    updateIndexes:!0
                }), e.tr;
        }, i.prototype.isVisible = function() {
            return this.dom && this.dom.tr && this.dom.tr.parentNode || !1;
        }, i.onDragStart = function(e, t) {
            if (!Array.isArray(e)) return i.onDragStart([ e ], t);
            if (0 !== e.length) {
                var n = e[0], r = e[e.length - 1], s = n.parent, a = i.getNodeFromTarget(t.target), l = n.editor, c = p.getAbsoluteTop(a.dom.tr) - p.getAbsoluteTop(n.dom.tr);
                l.mousemove || (l.mousemove = p.addEventListener(window, "mousemove", function(t) {
                    i.onDrag(e, t);
                })), l.mouseup || (l.mouseup = p.addEventListener(window, "mouseup", function(t) {
                    i.onDragEnd(e, t);
                })), l.highlighter.lock(), l.drag = {
                    oldCursor:document.body.style.cursor,
                    oldSelection:l.getDomSelection(),
                    oldPaths:e.map(o),
                    oldParent:s,
                    oldNextNode:s.childs[r.getIndex() + 1] || s.append,
                    oldParentPathRedo:s.getInternalPath(),
                    oldIndexRedo:n.getIndex(),
                    mouseX:t.pageX,
                    offsetY:c,
                    level:n.getLevel()
                }, document.body.style.cursor = "move", t.preventDefault();
            }
        }, i.onDrag = function(e, t) {
            if (!Array.isArray(e)) return i.onDrag([ e ], t);
            if (0 !== e.length) {
                var n, o, r, s, a, l, c, h, d, u, f, m, v, y, b = e[0].editor, x = t.pageY - b.drag.offsetY, w = t.pageX, _ = !1, C = e[0];
                if (n = C.dom.tr, d = p.getAbsoluteTop(n), m = n.offsetHeight, x < d) {
                    o = n;
                    do {
                        o = o.previousSibling, c = i.getNodeFromTarget(o), u = o ? p.getAbsoluteTop(o) :0;
                    } while (o && x < u);
                    c && !c.parent && (c = void 0), c || (l = n.parentNode.firstChild, o = l ? l.nextSibling :void 0,
                    (c = i.getNodeFromTarget(o)) == C && (c = void 0)), c && c.isVisible() && (o = c.dom.tr,
                        u = o ? p.getAbsoluteTop(o) :0, x > u + m && (c = void 0)), c && (e.forEach(function(e) {
                        c.parent.moveBefore(e, c);
                    }), _ = !0);
                } else {
                    var E = e[e.length - 1];
                    if (a = E.expanded && E.append ? E.append.getDom() :E.dom.tr, s = a ? a.nextSibling :void 0) {
                        f = p.getAbsoluteTop(s), r = s;
                        do {
                            h = i.getNodeFromTarget(r), r && (v = r.nextSibling ? p.getAbsoluteTop(r.nextSibling) :0,
                                y = r ? v - f :0, h && h.parent.childs.length == e.length && h.parent.childs[e.length - 1] == E && (d += 27),
                                r = r.nextSibling);
                        } while (r && x > d + y);
                        if (h && h.parent) {
                            var S = w - b.drag.mouseX, j = Math.round(S / 24 / 2), N = b.drag.level + j, k = h.getLevel();
                            for (o = h.dom.tr && h.dom.tr.previousSibling; k < N && o; ) {
                                c = i.getNodeFromTarget(o);
                                if (e.some(function(e) {
                                        return e === c || c.isDescendantOf(e);
                                    })) ; else {
                                    if (!(c instanceof g)) break;
                                    var T = c.parent.childs;
                                    if (T.length == e.length && T[e.length - 1] == E) break;
                                    h = i.getNodeFromTarget(o), k = h.getLevel();
                                }
                                o = o.previousSibling;
                            }
                            h instanceof g && !h.isVisible() && h.parent.showMore.isVisible() && (h = h._nextNode()),
                            h && h.dom.tr && a.nextSibling != h.dom.tr && (e.forEach(function(e) {
                                h.parent.moveBefore(e, h);
                            }), _ = !0);
                        }
                    }
                }
                _ && (b.drag.mouseX = w, b.drag.level = C.getLevel()), b.startAutoScroll(x), t.preventDefault();
            }
        }, i.onDragEnd = function(e, t) {
            if (!Array.isArray(e)) return i.onDrag([ e ], t);
            if (0 !== e.length) {
                var n = e[0], o = n.editor;
                e[0] && e[0].dom.menu.focus();
                var s = o.drag.oldParent.getInternalPath(), a = n.parent.getInternalPath(), l = o.drag.oldParent === n.parent, c = o.drag.oldNextNode.getIndex(), h = n.getIndex(), d = o.drag.oldParentPathRedo, u = o.drag.oldIndexRedo, f = l && u < h ? h + e.length :h;
                l && u === h || o._onAction("moveNodes", {
                    count:e.length,
                    fieldNames:e.map(r),
                    oldParentPath:s,
                    newParentPath:a,
                    oldIndex:c,
                    newIndex:h,
                    oldIndexRedo:u,
                    newIndexRedo:f,
                    oldParentPathRedo:d,
                    newParentPathRedo:null,
                    oldSelection:o.drag.oldSelection,
                    newSelection:o.getDomSelection()
                }), document.body.style.cursor = o.drag.oldCursor, o.highlighter.unlock(), e.forEach(function(e) {
                    t.target !== e.dom.drag && t.target !== e.dom.menu && o.highlighter.unhighlight();
                }), delete o.drag, o.mousemove && (p.removeEventListener(window, "mousemove", o.mousemove),
                    delete o.mousemove), o.mouseup && (p.removeEventListener(window, "mouseup", o.mouseup),
                    delete o.mouseup), o.stopAutoScroll(), t.preventDefault();
            }
        }, i.prototype.isDescendantOf = function(e) {
            for (var t = this.parent; t; ) {
                if (t == e) return !0;
                t = t.parent;
            }
            return !1;
        }, i.prototype._createDomField = function() {
            return document.createElement("div");
        }, i.prototype.setHighlight = function(e) {
            this.dom.tr && (e ? p.addClassName(this.dom.tr, "jsoneditor-highlight") :p.removeClassName(this.dom.tr, "jsoneditor-highlight"),
            this.append && this.append.setHighlight(e), this.childs && this.childs.forEach(function(t) {
                t.setHighlight(e);
            }));
        }, i.prototype.setSelected = function(e, t) {
            this.selected = e, this.dom.tr && (e ? p.addClassName(this.dom.tr, "jsoneditor-selected") :p.removeClassName(this.dom.tr, "jsoneditor-selected"),
                t ? p.addClassName(this.dom.tr, "jsoneditor-first") :p.removeClassName(this.dom.tr, "jsoneditor-first"),
            this.append && this.append.setSelected(e), this.showMore && this.showMore.setSelected(e),
            this.childs && this.childs.forEach(function(t) {
                t.setSelected(e);
            }));
        }, i.prototype.updateValue = function(e) {
            this.value = e, this.previousValue = e, this.updateDom();
        }, i.prototype.updateField = function(e) {
            this.field = e, this.previousField = e, this.updateDom();
        }, i.prototype.updateDom = function(e) {
            var t = this.dom.tree;
            t && (t.style.marginLeft = 24 * this.getLevel() + "px");
            var n = this.dom.field;
            if (n) {
                this.fieldEditable ? (n.contentEditable = this.editable.field, n.spellcheck = !1,
                    n.className = "jsoneditor-field") :n.className = "jsoneditor-readonly";
                var i;
                i = void 0 != this.index ? this.index :void 0 != this.field ? this.field :this._hasChilds() ? this.type :"",
                    n.innerHTML = this._escapeHTML(i), this._updateSchema();
            }
            var o = this.dom.value;
            if (o) {
                var r = this.childs ? this.childs.length :0;
                "array" == this.type ? (o.innerHTML = "[" + r + "]", p.addClassName(this.dom.tr, "jsoneditor-expandable")) :"object" == this.type ? (o.innerHTML = "{" + r + "}",
                    p.addClassName(this.dom.tr, "jsoneditor-expandable")) :(o.innerHTML = this._escapeHTML(this.value),
                    p.removeClassName(this.dom.tr, "jsoneditor-expandable"));
            }
            this._updateDomField(), this._updateDomValue(), e && !0 === e.updateIndexes && this._updateDomIndexes(),
            e && !0 === e.recurse && this.childs && this.childs.forEach(function(t) {
                t.updateDom(e);
            }), this.error && this.updateError(), this.append && this.append.updateDom(), this.showMore && this.showMore.updateDom();
        }, i.prototype._updateSchema = function() {
            this.editor && this.editor.options && (this.schema = this.editor.options.schema ? i._findSchema(this.editor.options.schema, this.getPath()) :null,
                this.schema ? this.enum = i._findEnum(this.schema) :delete this.enum);
        }, i._findEnum = function(e) {
            if (e.enum) return e.enum;
            var t = e.oneOf || e.anyOf || e.allOf;
            if (t) {
                var n = t.filter(function(e) {
                    return e.enum;
                });
                if (n.length > 0) return n[0].enum;
            }
            return null;
        }, i._findSchema = function(e, t) {
            var n = e, o = n, r = e.oneOf || e.anyOf || e.allOf;
            r || (r = [ e ]);
            for (var s = 0; s < r.length; s++) {
                n = r[s];
                for (var a = 0; a < t.length && n; a++) {
                    var l = t[a];
                    if ("string" == typeof l && n.patternProperties && a == t.length - 1) for (var c in n.patternProperties) o = i._findSchema(n.patternProperties[c], t.slice(a, t.length)); else n.items && n.items.properties ? (n = n.items.properties[l]) && (o = i._findSchema(n, t.slice(a, t.length))) :"string" == typeof l && n.properties ? (n = n.properties[l] || null) && (o = i._findSchema(n, t.slice(a, t.length))) :"number" == typeof l && n.items && (n = n.items) && (o = i._findSchema(n, t.slice(a, t.length)));
                }
            }
            return o;
        }, i.prototype._updateDomIndexes = function() {
            var e = this.dom.value, t = this.childs;
            e && t && ("array" == this.type ? t.forEach(function(e, t) {
                e.index = t;
                var n = e.dom.field;
                n && (n.innerHTML = t);
            }) :"object" == this.type && t.forEach(function(e) {
                void 0 != e.index && (delete e.index, void 0 == e.field && (e.field = ""));
            }));
        }, i.prototype._createDomValue = function() {
            var e;
            return "array" == this.type ? (e = document.createElement("div"), e.innerHTML = "[...]") :"object" == this.type ? (e = document.createElement("div"),
                e.innerHTML = "{...}") :!this.editable.value && p.isUrl(this.value) ? (e = document.createElement("a"),
                e.href = this.value, e.innerHTML = this._escapeHTML(this.value)) :(e = document.createElement("div"),
                e.contentEditable = this.editable.value, e.spellcheck = !1, e.innerHTML = this._escapeHTML(this.value)),
                e;
        }, i.prototype._createDomExpandButton = function() {
            var e = document.createElement("button");
            return e.type = "button", this._hasChilds() ? (e.className = this.expanded ? "jsoneditor-expanded" :"jsoneditor-collapsed",
                e.title = f("expandTitle")) :(e.className = "jsoneditor-invisible", e.title = ""),
                e;
        }, i.prototype._createDomTree = function() {
            var e = this.dom, t = document.createElement("table"), n = document.createElement("tbody");
            t.style.borderCollapse = "collapse", t.className = "jsoneditor-values", t.appendChild(n);
            var i = document.createElement("tr");
            n.appendChild(i);
            var o = document.createElement("td");
            o.className = "jsoneditor-tree", i.appendChild(o), e.expand = this._createDomExpandButton(),
                o.appendChild(e.expand), e.tdExpand = o;
            var r = document.createElement("td");
            r.className = "jsoneditor-tree", i.appendChild(r), e.field = this._createDomField(),
                r.appendChild(e.field), e.tdField = r;
            var s = document.createElement("td");
            s.className = "jsoneditor-tree", i.appendChild(s), "object" != this.type && "array" != this.type && (s.appendChild(document.createTextNode(":")),
                s.className = "jsoneditor-separator"), e.tdSeparator = s;
            var a = document.createElement("td");
            return a.className = "jsoneditor-tree", i.appendChild(a), e.value = this._createDomValue(),
                a.appendChild(e.value), e.tdValue = a, t;
        }, i.prototype.onEvent = function(e) {
            var t = e.type, n = e.target || e.srcElement, i = this.dom, o = this, r = this._hasChilds();
            if (n != i.drag && n != i.menu || ("mouseover" == t ? this.editor.highlighter.highlight(this) :"mouseout" == t && this.editor.highlighter.unhighlight()),
                "click" == t && n == i.menu) {
                var s = o.editor.highlighter;
                s.highlight(o), s.lock(), p.addClassName(i.menu, "jsoneditor-selected"), this.showContextMenu(i.menu, function() {
                    p.removeClassName(i.menu, "jsoneditor-selected"), s.unlock(), s.unhighlight();
                });
            }
            if ("click" == t && (n == i.expand || ("view" === o.editor.options.mode || "form" === o.editor.options.mode) && "DIV" === n.nodeName) && r) {
                var a = e.ctrlKey;
                this._onExpand(a);
            }
            "change" == t && n == i.checkbox && (this.dom.value.innerHTML = !this.value, this._getDomValue()),
            "change" == t && n == i.select && (this.dom.value.innerHTML = i.select.value, this._getDomValue(),
                this._updateDomValue());
            var l = i.value;
            if (n == l) switch (t) {
                case "blur":
                case "change":
                    this._getDomValue(!0), this._updateDomValue(), this.value && (l.innerHTML = this._escapeHTML(this.value));
                    break;

                case "input":
                    this._getDomValue(!0), this._updateDomValue();
                    break;

                case "keydown":
                case "mousedown":
                    this.editor.selection = this.editor.getDomSelection();
                    break;

                case "click":
                    e.ctrlKey && this.editable.value && p.isUrl(this.value) && (e.preventDefault(),
                        window.open(this.value, "_blank"));
                    break;

                case "keyup":
                    this._getDomValue(!0), this._updateDomValue();
                    break;

                case "cut":
                case "paste":
                    setTimeout(function() {
                        o._getDomValue(!0), o._updateDomValue();
                    }, 1);
            }
            var c = i.field;
            if (n == c) switch (t) {
                case "blur":
                case "change":
                    this._getDomField(!0), this._updateDomField(), this.field && (c.innerHTML = this._escapeHTML(this.field));
                    break;

                case "input":
                    this._getDomField(!0), this._updateSchema(), this._updateDomField(), this._updateDomValue();
                    break;

                case "keydown":
                case "mousedown":
                    this.editor.selection = this.editor.getDomSelection();
                    break;

                case "keyup":
                    this._getDomField(!0), this._updateDomField();
                    break;

                case "cut":
                case "paste":
                    setTimeout(function() {
                        o._getDomField(!0), o._updateDomField();
                    }, 1);
            }
            var h = i.tree;
            if (h && n == h.parentNode && "click" == t && !e.hasMoved) {
                (void 0 != e.offsetX ? e.offsetX < 24 * (this.getLevel() + 1) :e.pageX < p.getAbsoluteLeft(i.tdSeparator)) || r ? c && (p.setEndOfContentEditable(c),
                    c.focus()) :l && !this.enum && (p.setEndOfContentEditable(l), l.focus());
            }
            (n != i.tdExpand || r) && n != i.tdField && n != i.tdSeparator || "click" != t || e.hasMoved || c && (p.setEndOfContentEditable(c),
                c.focus()), "keydown" == t && this.onKeyDown(e);
        }, i.prototype.onKeyDown = function(e) {
            var t, n, o, s, a, l, c, h, d, u, f, m, v, y = e.which || e.keyCode, b = e.target || e.srcElement, x = e.ctrlKey, w = e.shiftKey, _ = e.altKey, C = !1, E = "tree" === this.editor.options.mode, S = this.editor.multiselection.nodes.length > 0 ? this.editor.multiselection.nodes :[ this ], j = S[0], N = S[S.length - 1];
            if (13 == y) {
                if (b == this.dom.value) this.editable.value && !e.ctrlKey || p.isUrl(this.value) && (window.open(this.value, "_blank"),
                    C = !0); else if (b == this.dom.expand) {
                    var k = this._hasChilds();
                    if (k) {
                        var T = e.ctrlKey;
                        this._onExpand(T), b.focus(), C = !0;
                    }
                }
            } else if (68 == y) x && E && (i.onDuplicate(S), C = !0); else if (69 == y) x && (this._onExpand(w),
                b.focus(), C = !0); else if (77 == y && E) x && (this.showContextMenu(b), C = !0); else if (46 == y && E) x && (i.onRemove(S),
                C = !0); else if (45 == y && E) x && !w ? (this._onInsertBefore(), C = !0) :x && w && (this._onInsertAfter(),
                C = !0); else if (35 == y) {
                if (_) {
                    var I = this._lastNode();
                    I && I.focus(i.focusElement || this._getElementName(b)), C = !0;
                }
            } else if (36 == y) {
                if (_) {
                    var O = this._firstNode();
                    O && O.focus(i.focusElement || this._getElementName(b)), C = !0;
                }
            } else if (37 == y) {
                if (_ && !w) {
                    var P = this._previousElement(b);
                    P && this.focus(this._getElementName(P)), C = !0;
                } else if (_ && w && E) {
                    if (N.expanded) {
                        var D = N.getAppendDom();
                        o = D ? D.nextSibling :void 0;
                    } else {
                        var A = N.getDom();
                        o = A.nextSibling;
                    }
                    o && (n = i.getNodeFromTarget(o), s = o.nextSibling, M = i.getNodeFromTarget(s),
                    n && n instanceof g && 1 != N.parent.childs.length && M && M.parent && (a = this.editor.getDomSelection(),
                        c = j.parent, l = c.childs[N.getIndex() + 1] || c.append, h = j.getIndex(), d = M.getIndex(),
                        u = c.getInternalPath(), f = M.parent.getInternalPath(), S.forEach(function(e) {
                        M.parent.moveBefore(e, M);
                    }), this.focus(i.focusElement || this._getElementName(b)), this.editor._onAction("moveNodes", {
                        count:S.length,
                        fieldNames:S.map(r),
                        oldParentPath:c.getInternalPath(),
                        newParentPath:j.parent.getInternalPath(),
                        oldIndex:l.getIndex(),
                        newIndex:j.getIndex(),
                        oldIndexRedo:h,
                        newIndexRedo:d,
                        oldParentPathRedo:u,
                        newParentPathRedo:f,
                        oldSelection:a,
                        newSelection:this.editor.getDomSelection()
                    })));
                }
            } else if (38 == y) _ && !w ? (t = this._previousNode(), t && (this.editor.deselect(!0),
                t.focus(i.focusElement || this._getElementName(b))), C = !0) :!_ && x && w && E ? (t = this._previousNode(),
            t && (v = this.editor.multiselection, v.start = v.start || this, v.end = t, m = this.editor._findTopLevelNodes(v.start, v.end),
                this.editor.select(m), t.focus("field")), C = !0) :_ && w && E && (t = j._previousNode(),
            t && t.parent && (a = this.editor.getDomSelection(), c = j.parent, l = c.childs[N.getIndex() + 1] || c.append,
                h = j.getIndex(), d = t.getIndex(), u = c.getInternalPath(), f = t.parent.getInternalPath(),
                S.forEach(function(e) {
                    t.parent.moveBefore(e, t);
                }), this.focus(i.focusElement || this._getElementName(b)), this.editor._onAction("moveNodes", {
                count:S.length,
                fieldNames:S.map(r),
                oldParentPath:c.getInternalPath(),
                newParentPath:j.parent.getInternalPath(),
                oldIndex:l.getIndex(),
                newIndex:j.getIndex(),
                oldIndexRedo:h,
                newIndexRedo:d,
                oldParentPathRedo:u,
                newParentPathRedo:f,
                oldSelection:a,
                newSelection:this.editor.getDomSelection()
            })), C = !0); else if (39 == y) {
                if (_ && !w) {
                    var R = this._nextElement(b);
                    R && this.focus(this._getElementName(R)), C = !0;
                } else if (_ && w && E) {
                    A = j.getDom();
                    var L = A.previousSibling;
                    L && (t = i.getNodeFromTarget(L)) && t.parent && !t.isVisible() && (a = this.editor.getDomSelection(),
                        c = j.parent, l = c.childs[N.getIndex() + 1] || c.append, h = j.getIndex(), d = t.getIndex(),
                        u = c.getInternalPath(), f = t.parent.getInternalPath(), S.forEach(function(e) {
                        t.parent.moveBefore(e, t);
                    }), this.focus(i.focusElement || this._getElementName(b)), this.editor._onAction("moveNodes", {
                        count:S.length,
                        fieldNames:S.map(r),
                        oldParentPath:c.getInternalPath(),
                        newParentPath:j.parent.getInternalPath(),
                        oldIndex:l.getIndex(),
                        newIndex:j.getIndex(),
                        oldIndexRedo:h,
                        newIndexRedo:d,
                        oldParentPathRedo:u,
                        newParentPathRedo:f,
                        oldSelection:a,
                        newSelection:this.editor.getDomSelection()
                    }));
                }
            } else if (40 == y) if (_ && !w) n = this._nextNode(), n && (this.editor.deselect(!0),
                n.focus(i.focusElement || this._getElementName(b))), C = !0; else if (!_ && x && w && E) n = this._nextNode(),
            n && (v = this.editor.multiselection, v.start = v.start || this, v.end = n, m = this.editor._findTopLevelNodes(v.start, v.end),
                this.editor.select(m), n.focus("field")), C = !0; else if (_ && w && E) {
                n = N.expanded ? N.append ? N.append._nextNode() :void 0 :N._nextNode(), n && !n.isVisible() && (n = n.parent.showMore),
                n && n instanceof g && (n = N);
                var M = n && (n._nextNode() || n.parent.append);
                M && M.parent && (a = this.editor.getDomSelection(), c = j.parent, l = c.childs[N.getIndex() + 1] || c.append,
                    h = j.getIndex(), d = M.getIndex(), u = c.getInternalPath(), f = M.parent.getInternalPath(),
                    S.forEach(function(e) {
                        M.parent.moveBefore(e, M);
                    }), this.focus(i.focusElement || this._getElementName(b)), this.editor._onAction("moveNodes", {
                    count:S.length,
                    fieldNames:S.map(r),
                    oldParentPath:c.getInternalPath(),
                    newParentPath:j.parent.getInternalPath(),
                    oldParentPathRedo:u,
                    newParentPathRedo:f,
                    oldIndexRedo:h,
                    newIndexRedo:d,
                    oldIndex:l.getIndex(),
                    newIndex:j.getIndex(),
                    oldSelection:a,
                    newSelection:this.editor.getDomSelection()
                })), C = !0;
            }
            C && (e.preventDefault(), e.stopPropagation());
        }, i.prototype._onExpand = function(e) {
            if (e) {
                var t = this.dom.tr.parentNode, n = t.parentNode, i = n.scrollTop;
                n.removeChild(t);
            }
            this.expanded ? this.collapse(e) :this.expand(e), e && (n.appendChild(t), n.scrollTop = i);
        }, i.onRemove = function(e) {
            if (!Array.isArray(e)) return i.onRemove([ e ]);
            if (e && e.length > 0) {
                var t = e[0], n = t.parent, r = t.editor, s = t.getIndex();
                r.highlighter.unhighlight();
                var a = r.getDomSelection();
                i.blurNodes(e);
                var l = r.getDomSelection(), c = e.map(o);
                e.forEach(function(e) {
                    e.parent._remove(e);
                }), r._onAction("removeNodes", {
                    nodes:e,
                    paths:c,
                    parentPath:n.getInternalPath(),
                    index:s,
                    oldSelection:a,
                    newSelection:l
                });
            }
        }, i.onDuplicate = function(e) {
            if (!Array.isArray(e)) return i.onDuplicate([ e ]);
            if (e && e.length > 0) {
                var t = e[e.length - 1], n = t.parent, r = t.editor;
                r.deselect(r.multiselection.nodes);
                var s = r.getDomSelection(), a = t, l = e.map(function(e) {
                    var t = e.clone();
                    return n.insertAfter(t, a), a = t, t;
                });
                1 === e.length ? l[0].focus() :r.select(l);
                var c = r.getDomSelection();
                r._onAction("duplicateNodes", {
                    paths:e.map(o),
                    clonePaths:l.map(o),
                    afterPath:t.getInternalPath(),
                    parentPath:n.getInternalPath(),
                    oldSelection:s,
                    newSelection:c
                });
            }
        }, i.prototype._onInsertBefore = function(e, t, n) {
            var o = this.editor.getDomSelection(), r = new i(this.editor, {
                field:void 0 != e ? e :"",
                value:void 0 != t ? t :"",
                type:n
            });
            r.expand(!0);
            var s = this.getInternalPath();
            this.parent.insertBefore(r, this), this.editor.highlighter.unhighlight(), r.focus("field");
            var a = this.editor.getDomSelection();
            this.editor._onAction("insertBeforeNodes", {
                nodes:[ r ],
                paths:[ r.getInternalPath() ],
                beforePath:s,
                parentPath:this.parent.getInternalPath(),
                oldSelection:o,
                newSelection:a
            });
        }, i.prototype._onInsertAfter = function(e, t, n) {
            var o = this.editor.getDomSelection(), r = new i(this.editor, {
                field:void 0 != e ? e :"",
                value:void 0 != t ? t :"",
                type:n
            });
            r.expand(!0), this.parent.insertAfter(r, this), this.editor.highlighter.unhighlight(),
                r.focus("field");
            var s = this.editor.getDomSelection();
            this.editor._onAction("insertAfterNodes", {
                nodes:[ r ],
                paths:[ r.getInternalPath() ],
                afterPath:this.getInternalPath(),
                parentPath:this.parent.getInternalPath(),
                oldSelection:o,
                newSelection:s
            });
        }, i.prototype._onAppend = function(e, t, n) {
            var o = this.editor.getDomSelection(), r = new i(this.editor, {
                field:void 0 != e ? e :"",
                value:void 0 != t ? t :"",
                type:n
            });
            r.expand(!0), this.parent.appendChild(r), this.editor.highlighter.unhighlight(),
                r.focus("field");
            var s = this.editor.getDomSelection();
            this.editor._onAction("appendNodes", {
                nodes:[ r ],
                paths:[ r.getInternalPath() ],
                parentPath:this.parent.getInternalPath(),
                oldSelection:o,
                newSelection:s
            });
        }, i.prototype._onChangeType = function(e) {
            var t = this.type;
            if (e != t) {
                var n = this.editor.getDomSelection();
                this.changeType(e);
                var i = this.editor.getDomSelection();
                this.editor._onAction("changeType", {
                    path:this.getInternalPath(),
                    oldType:t,
                    newType:e,
                    oldSelection:n,
                    newSelection:i
                });
            }
        }, i.prototype.sort = function(e, t) {
            if (this._hasChilds()) {
                this.hideChilds();
                var n = this.childs;
                this.childs = this.childs.concat();
                var i = "desc" === t ? -1 :1;
                "object" === this.type ? this.childs.sort(function(e, t) {
                    return i * a(e.field, t.field);
                }) :this.childs.sort(function(t, n) {
                    var o = t.getNestedChild(e), r = n.getNestedChild(e);
                    if (!o) return i;
                    if (!r) return -i;
                    var s = o.value, l = r.value;
                    return "string" != typeof s && "string" != typeof l ? s > l ? i :s < l ? -i :0 :i * a(s, l);
                }), this._updateDomIndexes(), this.editor._onAction("sort", {
                    path:this.getInternalPath(),
                    oldChilds:n,
                    newChilds:this.childs
                }), this.showChilds();
            }
        }, i.prototype.update = function(e) {
            var t = this.getInternalValue();
            this.setValue(e), this.editor._onAction("transform", {
                path:this.getInternalPath(),
                oldValue:t,
                newValue:this.getInternalValue()
            });
        }, i.prototype._detachFromDom = function() {
            var e, t = this.dom.tr ? this.dom.tr.parentNode :void 0;
            e = this.expanded ? this.getAppendDom() :this.getDom();
            var n = e && e.parentNode ? e.nextSibling :void 0;
            return this.hide({
                resetVisibleChilds:!1
            }), {
                table:t,
                nextTr:n
            };
        }, i.prototype._attachToDom = function(e) {
            e.table && (e.nextTr ? e.table.insertBefore(this.getDom(), e.nextTr) :e.table.appendChild(this.getDom())),
            this.expanded && this.showChilds();
        }, i.prototype.transform = function(e) {
            if (this._hasChilds()) {
                this.hideChilds();
                try {
                    var t = this.getInternalValue(), n = s.search(t, e);
                    this.setValue(n), this.editor._onAction("transform", {
                        path:this.getInternalPath(),
                        oldValue:t,
                        newValue:this.getInternalValue()
                    }), this.showChilds();
                } catch (e) {
                    this.showChilds(), this.editor._onError(e);
                }
            }
        }, i.prototype.getNestedChild = function(e) {
            for (var t = 0, n = this; n && t < e.length; ) n = n.findChildByProperty(e[t]),
                t++;
            return n;
        }, i.prototype.findChildByProperty = function(e) {
            if ("object" === this.type) return this.childs.find(function(t) {
                return t.field === e;
            });
        }, i.prototype.getChildPaths = function(e) {
            var t = {};
            return this._getChildPaths(t, "", e), "array" === this.type && this.childs.forEach(function(n) {
                n._getChildPaths(t, "", e);
            }), Object.keys(t).sort();
        }, i.prototype._getChildPaths = function(e, t, n) {
            ("auto" === this.type || "string" === this.type || n) && (e[t || "."] = !0), "object" === this.type && this.childs.forEach(function(i) {
                i._getChildPaths(e, t + "." + i.field, n);
            });
        }, i.prototype.getAppendDom = function() {
            return this.append || (this.append = new g(this.editor), this.append.setParent(this)),
                this.append.getDom();
        }, i.prototype.getShowMoreDom = function() {
            return this.showMore || (this.showMore = new v(this.editor, this)), this.showMore.getDom();
        }, i.getNodeFromTarget = function(e) {
            for (;e; ) {
                if (e.node) return e.node;
                e = e.parentNode;
            }
        }, i.blurNodes = function(e) {
            if (!Array.isArray(e)) return void i.blurNodes([ e ]);
            var t = e[0], n = t.parent, o = t.getIndex();
            n.childs[o + e.length] ? n.childs[o + e.length].focus() :n.childs[o - 1] ? n.childs[o - 1].focus() :n.focus();
        }, i.prototype.nextSibling = function() {
            var e = this.parent.childs.indexOf(this);
            return this.parent.childs[e + 1] || this.parent.append;
        }, i.prototype._previousNode = function() {
            var e = null, t = this.getDom();
            if (t && t.parentNode) {
                var n = t;
                do {
                    n = n.previousSibling, e = i.getNodeFromTarget(n);
                } while (n && e && e instanceof g && !e.isVisible());
            }
            return e;
        }, i.prototype._nextNode = function() {
            var e = null, t = this.getDom();
            if (t && t.parentNode) {
                var n = t;
                do {
                    n = n.nextSibling, e = i.getNodeFromTarget(n);
                } while (n && e && e instanceof g && !e.isVisible());
            }
            return e;
        }, i.prototype._firstNode = function() {
            var e = null, t = this.getDom();
            if (t && t.parentNode) {
                var n = t.parentNode.firstChild;
                e = i.getNodeFromTarget(n);
            }
            return e;
        }, i.prototype._lastNode = function() {
            var e = null, t = this.getDom();
            if (t && t.parentNode) {
                var n = t.parentNode.lastChild;
                for (e = i.getNodeFromTarget(n); n && e && !e.isVisible(); ) n = n.previousSibling,
                    e = i.getNodeFromTarget(n);
            }
            return e;
        }, i.prototype._previousElement = function(e) {
            var t = this.dom;
            switch (e) {
                case t.value:
                    if (this.fieldEditable) return t.field;

                case t.field:
                    if (this._hasChilds()) return t.expand;

                case t.expand:
                    return t.menu;

                case t.menu:
                    if (t.drag) return t.drag;

                default:
                    return null;
            }
        }, i.prototype._nextElement = function(e) {
            var t = this.dom;
            switch (e) {
                case t.drag:
                    return t.menu;

                case t.menu:
                    if (this._hasChilds()) return t.expand;

                case t.expand:
                    if (this.fieldEditable) return t.field;

                case t.field:
                    if (!this._hasChilds()) return t.value;

                default:
                    return null;
            }
        }, i.prototype._getElementName = function(e) {
            var t = this.dom;
            for (var n in t) if (t.hasOwnProperty(n) && t[n] == e) return n;
            return null;
        }, i.prototype._hasChilds = function() {
            return "array" == this.type || "object" == this.type;
        }, i.TYPE_TITLES = {
            auto:f("autoType"),
            object:f("objectType"),
            array:f("arrayType"),
            string:f("stringType")
        }, i.prototype.addTemplates = function(e, t) {
            var n = this, i = n.editor.options.templates;
            if (null != i) {
                i.length && e.push({
                    type:"separator"
                });
                var o = function(e, t) {
                    n._onAppend(e, t);
                }, r = function(e, t) {
                    n._onInsertBefore(e, t);
                };
                i.forEach(function(n) {
                    e.push({
                        text:n.text,
                        className:n.className || "jsoneditor-type-object",
                        title:n.title,
                        click:t ? o.bind(this, n.field, n.value) :r.bind(this, n.field, n.value)
                    });
                });
            }
        }, i.prototype.showContextMenu = function(e, t) {
            var n = this, o = i.TYPE_TITLES, r = [];
            if (this.editable.value && r.push({
                    text:f("type"),
                    title:f("typeTitle"),
                    className:"jsoneditor-type-" + this.type,
                    submenu:[ {
                        text:f("auto"),
                        className:"jsoneditor-type-auto" + ("auto" == this.type ? " jsoneditor-selected" :""),
                        title:o.auto,
                        click:function() {
                            n._onChangeType("auto");
                        }
                    }, {
                        text:f("array"),
                        className:"jsoneditor-type-array" + ("array" == this.type ? " jsoneditor-selected" :""),
                        title:o.array,
                        click:function() {
                            n._onChangeType("array");
                        }
                    }, {
                        text:f("object"),
                        className:"jsoneditor-type-object" + ("object" == this.type ? " jsoneditor-selected" :""),
                        title:o.object,
                        click:function() {
                            n._onChangeType("object");
                        }
                    }, {
                        text:f("string"),
                        className:"jsoneditor-type-string" + ("string" == this.type ? " jsoneditor-selected" :""),
                        title:o.string,
                        click:function() {
                            n._onChangeType("string");
                        }
                    } ]
                }), this._hasChilds() && (r.push({
                    text:f("sort"),
                    title:f("sortTitle", {
                        type:this.type
                    }),
                    className:"jsoneditor-sort-asc",
                    click:function() {
                        var e = n.editor.options.modalAnchor || m;
                        d(n, e);
                    }
                }), r.push({
                    text:f("transform"),
                    title:f("transformTitle", {
                        type:this.type
                    }),
                    className:"jsoneditor-transform",
                    click:function() {
                        var e = n.editor.options.modalAnchor || m;
                        u(n, e);
                    }
                })), this.parent && this.parent._hasChilds()) {
                r.length && r.push({
                    type:"separator"
                });
                var s = n.parent.childs;
                if (n == s[s.length - 1]) {
                    var a = [ {
                        text:f("auto"),
                        className:"jsoneditor-type-auto",
                        title:o.auto,
                        click:function() {
                            n._onAppend("", "", "auto");
                        }
                    }, {
                        text:f("array"),
                        className:"jsoneditor-type-array",
                        title:o.array,
                        click:function() {
                            n._onAppend("", []);
                        }
                    }, {
                        text:f("object"),
                        className:"jsoneditor-type-object",
                        title:o.object,
                        click:function() {
                            n._onAppend("", {});
                        }
                    }, {
                        text:f("string"),
                        className:"jsoneditor-type-string",
                        title:o.string,
                        click:function() {
                            n._onAppend("", "", "string");
                        }
                    } ];
                    n.addTemplates(a, !0), r.push({
                        text:f("appendText"),
                        title:f("appendTitle"),
                        submenuTitle:f("appendSubmenuTitle"),
                        className:"jsoneditor-append",
                        click:function() {
                            n._onAppend("", "", "auto");
                        },
                        submenu:a
                    });
                }
                var c = [ {
                    text:f("auto"),
                    className:"jsoneditor-type-auto",
                    title:o.auto,
                    click:function() {
                        n._onInsertBefore("", "", "auto");
                    }
                }, {
                    text:f("array"),
                    className:"jsoneditor-type-array",
                    title:o.array,
                    click:function() {
                        n._onInsertBefore("", []);
                    }
                }, {
                    text:f("object"),
                    className:"jsoneditor-type-object",
                    title:o.object,
                    click:function() {
                        n._onInsertBefore("", {});
                    }
                }, {
                    text:f("string"),
                    className:"jsoneditor-type-string",
                    title:o.string,
                    click:function() {
                        n._onInsertBefore("", "", "string");
                    }
                } ];
                n.addTemplates(c, !1), r.push({
                    text:f("insert"),
                    title:f("insertTitle"),
                    submenuTitle:f("insertSub"),
                    className:"jsoneditor-insert",
                    click:function() {
                        n._onInsertBefore("", "", "auto");
                    },
                    submenu:c
                }), this.editable.field && (r.push({
                    text:f("duplicateText"),
                    title:f("duplicateField"),
                    className:"jsoneditor-duplicate",
                    click:function() {
                        i.onDuplicate(n);
                    }
                }), r.push({
                    text:f("removeText"),
                    title:f("removeField"),
                    className:"jsoneditor-remove",
                    click:function() {
                        i.onRemove(n);
                    }
                }));
            }
            new l(r, {
                close:t
            }).show(e, this.editor.content);
        }, i.prototype._getType = function(e) {
            return e instanceof Array ? "array" :e instanceof Object ? "object" :"string" == typeof e && "string" != typeof this._stringCast(e) ? "string" :"auto";
        }, i.prototype._stringCast = function(e) {
            var t = e.toLowerCase(), n = Number(e), i = parseFloat(e);
            return "" == e ? "" :"null" == t ? null :"true" == t || "false" != t && (isNaN(n) || isNaN(i) ? e :n);
        }, i.prototype._escapeHTML = function(e) {
            if ("string" != typeof e) return String(e);
            var t = String(e).replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/  /g, " &nbsp;").replace(/^ /, "&nbsp;").replace(/ $/, "&nbsp;"), n = JSON.stringify(t), i = n.substring(1, n.length - 1);
            return !0 === this.editor.options.escapeUnicode && (i = p.escapeUnicodeChars(i)),
                i;
        }, i.prototype._unescapeHTML = function(e) {
            var t = '"' + this._escapeJSON(e) + '"';
            return p.parse(t).replace(/&lt;/g, "<").replace(/&gt;/g, ">").replace(/&nbsp;|\u00A0/g, " ").replace(/&amp;/g, "&");
        }, i.prototype._escapeJSON = function(e) {
            for (var t = "", n = 0; n < e.length; ) {
                var i = e.charAt(n);
                "\n" == i ? t += "\\n" :"\\" == i ? (t += i, n++, i = e.charAt(n), "" !== i && -1 != '"\\/bfnrtu'.indexOf(i) || (t += "\\"),
                    t += i) :t += '"' == i ? '\\"' :i, n++;
            }
            return t;
        };
        var g = c(i), v = h(i);
        e.exports = i;
    }, function(e, t, n) {
        !function(e) {
            "use strict";
            function t(e) {
                return null !== e && "[object Array]" === Object.prototype.toString.call(e);
            }
            function n(e) {
                return null !== e && "[object Object]" === Object.prototype.toString.call(e);
            }
            function i(e, o) {
                if (e === o) return !0;
                if (Object.prototype.toString.call(e) !== Object.prototype.toString.call(o)) return !1;
                if (!0 === t(e)) {
                    if (e.length !== o.length) return !1;
                    for (var r = 0; r < e.length; r++) if (!1 === i(e[r], o[r])) return !1;
                    return !0;
                }
                if (!0 === n(e)) {
                    var s = {};
                    for (var a in e) if (hasOwnProperty.call(e, a)) {
                        if (!1 === i(e[a], o[a])) return !1;
                        s[a] = !0;
                    }
                    for (var l in o) if (hasOwnProperty.call(o, l) && !0 !== s[l]) return !1;
                    return !0;
                }
                return !1;
            }
            function o(e) {
                if ("" === e || !1 === e || null === e) return !0;
                if (t(e) && 0 === e.length) return !0;
                if (n(e)) {
                    for (var i in e) if (e.hasOwnProperty(i)) return !1;
                    return !0;
                }
                return !1;
            }
            function r(e) {
                for (var t = Object.keys(e), n = [], i = 0; i < t.length; i++) n.push(e[t[i]]);
                return n;
            }
            function s(e) {
                return e >= "a" && e <= "z" || e >= "A" && e <= "Z" || "_" === e;
            }
            function a(e) {
                return e >= "0" && e <= "9" || "-" === e;
            }
            function l(e) {
                return e >= "a" && e <= "z" || e >= "A" && e <= "Z" || e >= "0" && e <= "9" || "_" === e;
            }
            function c() {}
            function h() {}
            function d(e) {
                this.runtime = e;
            }
            function u(e) {
                this._interpreter = e, this.functionTable = {
                    abs:{
                        _func:this._functionAbs,
                        _signature:[ {
                            types:[ v ]
                        } ]
                    },
                    avg:{
                        _func:this._functionAvg,
                        _signature:[ {
                            types:[ C ]
                        } ]
                    },
                    ceil:{
                        _func:this._functionCeil,
                        _signature:[ {
                            types:[ v ]
                        } ]
                    },
                    contains:{
                        _func:this._functionContains,
                        _signature:[ {
                            types:[ b, x ]
                        }, {
                            types:[ y ]
                        } ]
                    },
                    ends_with:{
                        _func:this._functionEndsWith,
                        _signature:[ {
                            types:[ b ]
                        }, {
                            types:[ b ]
                        } ]
                    },
                    floor:{
                        _func:this._functionFloor,
                        _signature:[ {
                            types:[ v ]
                        } ]
                    },
                    length:{
                        _func:this._functionLength,
                        _signature:[ {
                            types:[ b, x, w ]
                        } ]
                    },
                    map:{
                        _func:this._functionMap,
                        _signature:[ {
                            types:[ _ ]
                        }, {
                            types:[ x ]
                        } ]
                    },
                    max:{
                        _func:this._functionMax,
                        _signature:[ {
                            types:[ C, E ]
                        } ]
                    },
                    merge:{
                        _func:this._functionMerge,
                        _signature:[ {
                            types:[ w ],
                            variadic:!0
                        } ]
                    },
                    max_by:{
                        _func:this._functionMaxBy,
                        _signature:[ {
                            types:[ x ]
                        }, {
                            types:[ _ ]
                        } ]
                    },
                    sum:{
                        _func:this._functionSum,
                        _signature:[ {
                            types:[ C ]
                        } ]
                    },
                    starts_with:{
                        _func:this._functionStartsWith,
                        _signature:[ {
                            types:[ b ]
                        }, {
                            types:[ b ]
                        } ]
                    },
                    min:{
                        _func:this._functionMin,
                        _signature:[ {
                            types:[ C, E ]
                        } ]
                    },
                    min_by:{
                        _func:this._functionMinBy,
                        _signature:[ {
                            types:[ x ]
                        }, {
                            types:[ _ ]
                        } ]
                    },
                    type:{
                        _func:this._functionType,
                        _signature:[ {
                            types:[ y ]
                        } ]
                    },
                    keys:{
                        _func:this._functionKeys,
                        _signature:[ {
                            types:[ w ]
                        } ]
                    },
                    values:{
                        _func:this._functionValues,
                        _signature:[ {
                            types:[ w ]
                        } ]
                    },
                    sort:{
                        _func:this._functionSort,
                        _signature:[ {
                            types:[ E, C ]
                        } ]
                    },
                    sort_by:{
                        _func:this._functionSortBy,
                        _signature:[ {
                            types:[ x ]
                        }, {
                            types:[ _ ]
                        } ]
                    },
                    join:{
                        _func:this._functionJoin,
                        _signature:[ {
                            types:[ b ]
                        }, {
                            types:[ E ]
                        } ]
                    },
                    reverse:{
                        _func:this._functionReverse,
                        _signature:[ {
                            types:[ b, x ]
                        } ]
                    },
                    to_array:{
                        _func:this._functionToArray,
                        _signature:[ {
                            types:[ y ]
                        } ]
                    },
                    to_string:{
                        _func:this._functionToString,
                        _signature:[ {
                            types:[ y ]
                        } ]
                    },
                    to_number:{
                        _func:this._functionToNumber,
                        _signature:[ {
                            types:[ y ]
                        } ]
                    },
                    not_null:{
                        _func:this._functionNotNull,
                        _signature:[ {
                            types:[ y ],
                            variadic:!0
                        } ]
                    }
                };
            }
            function p(e) {
                return new h().parse(e);
            }
            function f(e) {
                return new c().tokenize(e);
            }
            function m(e, t) {
                var n = new h(), i = new u(), o = new d(i);
                i._interpreter = o;
                var r = n.parse(t);
                return o.search(r, e);
            }
            var g;
            g = "function" == typeof String.prototype.trimLeft ? function(e) {
                return e.trimLeft();
            } :function(e) {
                return e.match(/^\s*(.*)/)[1];
            };
            var v = 0, y = 1, b = 2, x = 3, w = 4, _ = 6, C = 8, E = 9, S = {
                ".":"Dot",
                "*":"Star",
                ",":"Comma",
                ":":"Colon",
                "{":"Lbrace",
                "}":"Rbrace",
                "]":"Rbracket",
                "(":"Lparen",
                ")":"Rparen",
                "@":"Current"
            }, j = {
                "<":!0,
                ">":!0,
                "=":!0,
                "!":!0
            }, N = {
                " ":!0,
                "	":!0,
                "\n":!0
            };
            c.prototype = {
                tokenize:function(e) {
                    var t = [];
                    this._current = 0;
                    for (var n, i, o; this._current < e.length; ) if (s(e[this._current])) n = this._current,
                        i = this._consumeUnquotedIdentifier(e), t.push({
                        type:"UnquotedIdentifier",
                        value:i,
                        start:n
                    }); else if (void 0 !== S[e[this._current]]) t.push({
                        type:S[e[this._current]],
                        value:e[this._current],
                        start:this._current
                    }), this._current++; else if (a(e[this._current])) o = this._consumeNumber(e), t.push(o); else if ("[" === e[this._current]) o = this._consumeLBracket(e),
                        t.push(o); else if ('"' === e[this._current]) n = this._current, i = this._consumeQuotedIdentifier(e),
                        t.push({
                            type:"QuotedIdentifier",
                            value:i,
                            start:n
                        }); else if ("'" === e[this._current]) n = this._current, i = this._consumeRawStringLiteral(e),
                        t.push({
                            type:"Literal",
                            value:i,
                            start:n
                        }); else if ("`" === e[this._current]) {
                        n = this._current;
                        var r = this._consumeLiteral(e);
                        t.push({
                            type:"Literal",
                            value:r,
                            start:n
                        });
                    } else if (void 0 !== j[e[this._current]]) t.push(this._consumeOperator(e)); else if (void 0 !== N[e[this._current]]) this._current++; else if ("&" === e[this._current]) n = this._current,
                        this._current++, "&" === e[this._current] ? (this._current++, t.push({
                        type:"And",
                        value:"&&",
                        start:n
                    })) :t.push({
                        type:"Expref",
                        value:"&",
                        start:n
                    }); else {
                        if ("|" !== e[this._current]) {
                            var l = new Error("Unknown character:" + e[this._current]);
                            throw l.name = "LexerError", l;
                        }
                        n = this._current, this._current++, "|" === e[this._current] ? (this._current++,
                            t.push({
                                type:"Or",
                                value:"||",
                                start:n
                            })) :t.push({
                            type:"Pipe",
                            value:"|",
                            start:n
                        });
                    }
                    return t;
                },
                _consumeUnquotedIdentifier:function(e) {
                    var t = this._current;
                    for (this._current++; this._current < e.length && l(e[this._current]); ) this._current++;
                    return e.slice(t, this._current);
                },
                _consumeQuotedIdentifier:function(e) {
                    var t = this._current;
                    this._current++;
                    for (var n = e.length; '"' !== e[this._current] && this._current < n; ) {
                        var i = this._current;
                        "\\" !== e[i] || "\\" !== e[i + 1] && '"' !== e[i + 1] ? i++ :i += 2, this._current = i;
                    }
                    return this._current++, JSON.parse(e.slice(t, this._current));
                },
                _consumeRawStringLiteral:function(e) {
                    var t = this._current;
                    this._current++;
                    for (var n = e.length; "'" !== e[this._current] && this._current < n; ) {
                        var i = this._current;
                        "\\" !== e[i] || "\\" !== e[i + 1] && "'" !== e[i + 1] ? i++ :i += 2, this._current = i;
                    }
                    return this._current++, e.slice(t + 1, this._current - 1).replace("\\'", "'");
                },
                _consumeNumber:function(e) {
                    var t = this._current;
                    this._current++;
                    for (var n = e.length; a(e[this._current]) && this._current < n; ) this._current++;
                    return {
                        type:"Number",
                        value:parseInt(e.slice(t, this._current)),
                        start:t
                    };
                },
                _consumeLBracket:function(e) {
                    var t = this._current;
                    return this._current++, "?" === e[this._current] ? (this._current++, {
                        type:"Filter",
                        value:"[?",
                        start:t
                    }) :"]" === e[this._current] ? (this._current++, {
                        type:"Flatten",
                        value:"[]",
                        start:t
                    }) :{
                        type:"Lbracket",
                        value:"[",
                        start:t
                    };
                },
                _consumeOperator:function(e) {
                    var t = this._current, n = e[t];
                    return this._current++, "!" === n ? "=" === e[this._current] ? (this._current++,
                        {
                            type:"NE",
                            value:"!=",
                            start:t
                        }) :{
                        type:"Not",
                        value:"!",
                        start:t
                    } :"<" === n ? "=" === e[this._current] ? (this._current++, {
                        type:"LTE",
                        value:"<=",
                        start:t
                    }) :{
                        type:"LT",
                        value:"<",
                        start:t
                    } :">" === n ? "=" === e[this._current] ? (this._current++, {
                        type:"GTE",
                        value:">=",
                        start:t
                    }) :{
                        type:"GT",
                        value:">",
                        start:t
                    } :"=" === n && "=" === e[this._current] ? (this._current++, {
                        type:"EQ",
                        value:"==",
                        start:t
                    }) :void 0;
                },
                _consumeLiteral:function(e) {
                    this._current++;
                    for (var t, n = this._current, i = e.length; "`" !== e[this._current] && this._current < i; ) {
                        var o = this._current;
                        "\\" !== e[o] || "\\" !== e[o + 1] && "`" !== e[o + 1] ? o++ :o += 2, this._current = o;
                    }
                    var r = g(e.slice(n, this._current));
                    return r = r.replace("\\`", "`"), t = this._looksLikeJSON(r) ? JSON.parse(r) :JSON.parse('"' + r + '"'),
                        this._current++, t;
                },
                _looksLikeJSON:function(e) {
                    var t = '[{"', n = [ "true", "false", "null" ], i = "-0123456789";
                    if ("" === e) return !1;
                    if (t.indexOf(e[0]) >= 0) return !0;
                    if (n.indexOf(e) >= 0) return !0;
                    if (!(i.indexOf(e[0]) >= 0)) return !1;
                    try {
                        return JSON.parse(e), !0;
                    } catch (e) {
                        return !1;
                    }
                }
            };
            var k = {};
            k.EOF = 0, k.UnquotedIdentifier = 0, k.QuotedIdentifier = 0, k.Rbracket = 0, k.Rparen = 0,
                k.Comma = 0, k.Rbrace = 0, k.Number = 0, k.Current = 0, k.Expref = 0, k.Pipe = 1,
                k.Or = 2, k.And = 3, k.EQ = 5, k.GT = 5, k.LT = 5, k.GTE = 5, k.LTE = 5, k.NE = 5,
                k.Flatten = 9, k.Star = 20, k.Filter = 21, k.Dot = 40, k.Not = 45, k.Lbrace = 50,
                k.Lbracket = 55, k.Lparen = 60, h.prototype = {
                parse:function(e) {
                    this._loadTokens(e), this.index = 0;
                    var t = this.expression(0);
                    if ("EOF" !== this._lookahead(0)) {
                        var n = this._lookaheadToken(0), i = new Error("Unexpected token type: " + n.type + ", value: " + n.value);
                        throw i.name = "ParserError", i;
                    }
                    return t;
                },
                _loadTokens:function(e) {
                    var t = new c(), n = t.tokenize(e);
                    n.push({
                        type:"EOF",
                        value:"",
                        start:e.length
                    }), this.tokens = n;
                },
                expression:function(e) {
                    var t = this._lookaheadToken(0);
                    this._advance();
                    for (var n = this.nud(t), i = this._lookahead(0); e < k[i]; ) this._advance(), n = this.led(i, n),
                        i = this._lookahead(0);
                    return n;
                },
                _lookahead:function(e) {
                    return this.tokens[this.index + e].type;
                },
                _lookaheadToken:function(e) {
                    return this.tokens[this.index + e];
                },
                _advance:function() {
                    this.index++;
                },
                nud:function(e) {
                    var t, n, i;
                    switch (e.type) {
                        case "Literal":
                            return {
                                type:"Literal",
                                value:e.value
                            };

                        case "UnquotedIdentifier":
                            return {
                                type:"Field",
                                name:e.value
                            };

                        case "QuotedIdentifier":
                            var o = {
                                type:"Field",
                                name:e.value
                            };
                            if ("Lparen" === this._lookahead(0)) throw new Error("Quoted identifier not allowed for function names.");
                            return o;

                        case "Not":
                            return n = this.expression(k.Not), {
                                type:"NotExpression",
                                children:[ n ]
                            };

                        case "Star":
                            return t = {
                                type:"Identity"
                            }, n = null, n = "Rbracket" === this._lookahead(0) ? {
                                type:"Identity"
                            } :this._parseProjectionRHS(k.Star), {
                                type:"ValueProjection",
                                children:[ t, n ]
                            };

                        case "Filter":
                            return this.led(e.type, {
                                type:"Identity"
                            });

                        case "Lbrace":
                            return this._parseMultiselectHash();

                        case "Flatten":
                            return t = {
                                type:"Flatten",
                                children:[ {
                                    type:"Identity"
                                } ]
                            }, n = this._parseProjectionRHS(k.Flatten), {
                                type:"Projection",
                                children:[ t, n ]
                            };

                        case "Lbracket":
                            return "Number" === this._lookahead(0) || "Colon" === this._lookahead(0) ? (n = this._parseIndexExpression(),
                                this._projectIfSlice({
                                    type:"Identity"
                                }, n)) :"Star" === this._lookahead(0) && "Rbracket" === this._lookahead(1) ? (this._advance(),
                                this._advance(), n = this._parseProjectionRHS(k.Star), {
                                type:"Projection",
                                children:[ {
                                    type:"Identity"
                                }, n ]
                            }) :this._parseMultiselectList();

                        case "Current":
                            return {
                                type:"Current"
                            };

                        case "Expref":
                            return i = this.expression(k.Expref), {
                                type:"ExpressionReference",
                                children:[ i ]
                            };

                        case "Lparen":
                            for (var r = []; "Rparen" !== this._lookahead(0); ) "Current" === this._lookahead(0) ? (i = {
                                type:"Current"
                            }, this._advance()) :i = this.expression(0), r.push(i);
                            return this._match("Rparen"), r[0];

                        default:
                            this._errorToken(e);
                    }
                },
                led:function(e, t) {
                    var n;
                    switch (e) {
                        case "Dot":
                            var i = k.Dot;
                            return "Star" !== this._lookahead(0) ? (n = this._parseDotRHS(i), {
                                type:"Subexpression",
                                children:[ t, n ]
                            }) :(this._advance(), n = this._parseProjectionRHS(i), {
                                type:"ValueProjection",
                                children:[ t, n ]
                            });

                        case "Pipe":
                            return n = this.expression(k.Pipe), {
                                type:"Pipe",
                                children:[ t, n ]
                            };

                        case "Or":
                            return n = this.expression(k.Or), {
                                type:"OrExpression",
                                children:[ t, n ]
                            };

                        case "And":
                            return n = this.expression(k.And), {
                                type:"AndExpression",
                                children:[ t, n ]
                            };

                        case "Lparen":
                            for (var o, r = t.name, s = []; "Rparen" !== this._lookahead(0); ) "Current" === this._lookahead(0) ? (o = {
                                type:"Current"
                            }, this._advance()) :o = this.expression(0), "Comma" === this._lookahead(0) && this._match("Comma"),
                                s.push(o);
                            return this._match("Rparen"), {
                                type:"Function",
                                name:r,
                                children:s
                            };

                        case "Filter":
                            var a = this.expression(0);
                            return this._match("Rbracket"), n = "Flatten" === this._lookahead(0) ? {
                                type:"Identity"
                            } :this._parseProjectionRHS(k.Filter), {
                                type:"FilterProjection",
                                children:[ t, n, a ]
                            };

                        case "Flatten":
                            return {
                                type:"Projection",
                                children:[ {
                                    type:"Flatten",
                                    children:[ t ]
                                }, this._parseProjectionRHS(k.Flatten) ]
                            };

                        case "EQ":
                        case "NE":
                        case "GT":
                        case "GTE":
                        case "LT":
                        case "LTE":
                            return this._parseComparator(t, e);

                        case "Lbracket":
                            var l = this._lookaheadToken(0);
                            return "Number" === l.type || "Colon" === l.type ? (n = this._parseIndexExpression(),
                                this._projectIfSlice(t, n)) :(this._match("Star"), this._match("Rbracket"), n = this._parseProjectionRHS(k.Star),
                                {
                                    type:"Projection",
                                    children:[ t, n ]
                                });

                        default:
                            this._errorToken(this._lookaheadToken(0));
                    }
                },
                _match:function(e) {
                    if (this._lookahead(0) !== e) {
                        var t = this._lookaheadToken(0), n = new Error("Expected " + e + ", got: " + t.type);
                        throw n.name = "ParserError", n;
                    }
                    this._advance();
                },
                _errorToken:function(e) {
                    var t = new Error("Invalid token (" + e.type + '): "' + e.value + '"');
                    throw t.name = "ParserError", t;
                },
                _parseIndexExpression:function() {
                    if ("Colon" === this._lookahead(0) || "Colon" === this._lookahead(1)) return this._parseSliceExpression();
                    var e = {
                        type:"Index",
                        value:this._lookaheadToken(0).value
                    };
                    return this._advance(), this._match("Rbracket"), e;
                },
                _projectIfSlice:function(e, t) {
                    var n = {
                        type:"IndexExpression",
                        children:[ e, t ]
                    };
                    return "Slice" === t.type ? {
                        type:"Projection",
                        children:[ n, this._parseProjectionRHS(k.Star) ]
                    } :n;
                },
                _parseSliceExpression:function() {
                    for (var e = [ null, null, null ], t = 0, n = this._lookahead(0); "Rbracket" !== n && t < 3; ) {
                        if ("Colon" === n) t++, this._advance(); else {
                            if ("Number" !== n) {
                                var i = this._lookahead(0), o = new Error("Syntax error, unexpected token: " + i.value + "(" + i.type + ")");
                                throw o.name = "Parsererror", o;
                            }
                            e[t] = this._lookaheadToken(0).value, this._advance();
                        }
                        n = this._lookahead(0);
                    }
                    return this._match("Rbracket"), {
                        type:"Slice",
                        children:e
                    };
                },
                _parseComparator:function(e, t) {
                    return {
                        type:"Comparator",
                        name:t,
                        children:[ e, this.expression(k[t]) ]
                    };
                },
                _parseDotRHS:function(e) {
                    var t = this._lookahead(0);
                    return [ "UnquotedIdentifier", "QuotedIdentifier", "Star" ].indexOf(t) >= 0 ? this.expression(e) :"Lbracket" === t ? (this._match("Lbracket"),
                        this._parseMultiselectList()) :"Lbrace" === t ? (this._match("Lbrace"), this._parseMultiselectHash()) :void 0;
                },
                _parseProjectionRHS:function(e) {
                    var t;
                    if (k[this._lookahead(0)] < 10) t = {
                        type:"Identity"
                    }; else if ("Lbracket" === this._lookahead(0)) t = this.expression(e); else if ("Filter" === this._lookahead(0)) t = this.expression(e); else {
                        if ("Dot" !== this._lookahead(0)) {
                            var n = this._lookaheadToken(0), i = new Error("Sytanx error, unexpected token: " + n.value + "(" + n.type + ")");
                            throw i.name = "ParserError", i;
                        }
                        this._match("Dot"), t = this._parseDotRHS(e);
                    }
                    return t;
                },
                _parseMultiselectList:function() {
                    for (var e = []; "Rbracket" !== this._lookahead(0); ) {
                        var t = this.expression(0);
                        if (e.push(t), "Comma" === this._lookahead(0) && (this._match("Comma"), "Rbracket" === this._lookahead(0))) throw new Error("Unexpected token Rbracket");
                    }
                    return this._match("Rbracket"), {
                        type:"MultiSelectList",
                        children:e
                    };
                },
                _parseMultiselectHash:function() {
                    for (var e, t, n, i, o = [], r = [ "UnquotedIdentifier", "QuotedIdentifier" ]; ;) {
                        if (e = this._lookaheadToken(0), r.indexOf(e.type) < 0) throw new Error("Expecting an identifier token, got: " + e.type);
                        if (t = e.value, this._advance(), this._match("Colon"), n = this.expression(0),
                                i = {
                                    type:"KeyValuePair",
                                    name:t,
                                    value:n
                                }, o.push(i), "Comma" === this._lookahead(0)) this._match("Comma"); else if ("Rbrace" === this._lookahead(0)) {
                            this._match("Rbrace");
                            break;
                        }
                    }
                    return {
                        type:"MultiSelectHash",
                        children:o
                    };
                }
            }, d.prototype = {
                search:function(e, t) {
                    return this.visit(e, t);
                },
                visit:function(e, s) {
                    var a, l, c, h, d, u, p, f, m;
                    switch (e.type) {
                        case "Field":
                            return null === s ? null :n(s) ? (u = s[e.name], void 0 === u ? null :u) :null;

                        case "Subexpression":
                            for (c = this.visit(e.children[0], s), m = 1; m < e.children.length; m++) if (null === (c = this.visit(e.children[1], c))) return null;
                            return c;

                        case "IndexExpression":
                            return p = this.visit(e.children[0], s), this.visit(e.children[1], p);

                        case "Index":
                            if (!t(s)) return null;
                            var g = e.value;
                            return g < 0 && (g = s.length + g), c = s[g], void 0 === c && (c = null), c;

                        case "Slice":
                            if (!t(s)) return null;
                            var v = e.children.slice(0), y = this.computeSliceParams(s.length, v), b = y[0], x = y[1], w = y[2];
                            if (c = [], w > 0) for (m = b; m < x; m += w) c.push(s[m]); else for (m = b; m > x; m += w) c.push(s[m]);
                            return c;

                        case "Projection":
                            var _ = this.visit(e.children[0], s);
                            if (!t(_)) return null;
                            for (f = [], m = 0; m < _.length; m++) null !== (l = this.visit(e.children[1], _[m])) && f.push(l);
                            return f;

                        case "ValueProjection":
                            if (_ = this.visit(e.children[0], s), !n(_)) return null;
                            f = [];
                            var C = r(_);
                            for (m = 0; m < C.length; m++) null !== (l = this.visit(e.children[1], C[m])) && f.push(l);
                            return f;

                        case "FilterProjection":
                            if (_ = this.visit(e.children[0], s), !t(_)) return null;
                            var E = [], S = [];
                            for (m = 0; m < _.length; m++) a = this.visit(e.children[2], _[m]), o(a) || E.push(_[m]);
                            for (var j = 0; j < E.length; j++) null !== (l = this.visit(e.children[1], E[j])) && S.push(l);
                            return S;

                        case "Comparator":
                            switch (h = this.visit(e.children[0], s), d = this.visit(e.children[1], s), e.name) {
                                case "EQ":
                                    c = i(h, d);
                                    break;

                                case "NE":
                                    c = !i(h, d);
                                    break;

                                case "GT":
                                    c = h > d;
                                    break;

                                case "GTE":
                                    c = h >= d;
                                    break;

                                case "LT":
                                    c = h < d;
                                    break;

                                case "LTE":
                                    c = h <= d;
                                    break;

                                default:
                                    throw new Error("Unknown comparator: " + e.name);
                            }
                            return c;

                        case "Flatten":
                            var N = this.visit(e.children[0], s);
                            if (!t(N)) return null;
                            var k = [];
                            for (m = 0; m < N.length; m++) l = N[m], t(l) ? k.push.apply(k, l) :k.push(l);
                            return k;

                        case "Identity":
                            return s;

                        case "MultiSelectList":
                            if (null === s) return null;
                            for (f = [], m = 0; m < e.children.length; m++) f.push(this.visit(e.children[m], s));
                            return f;

                        case "MultiSelectHash":
                            if (null === s) return null;
                            f = {};
                            var T;
                            for (m = 0; m < e.children.length; m++) T = e.children[m], f[T.name] = this.visit(T.value, s);
                            return f;

                        case "OrExpression":
                            return a = this.visit(e.children[0], s), o(a) && (a = this.visit(e.children[1], s)),
                                a;

                        case "AndExpression":
                            return h = this.visit(e.children[0], s), !0 === o(h) ? h :this.visit(e.children[1], s);

                        case "NotExpression":
                            return h = this.visit(e.children[0], s), o(h);

                        case "Literal":
                            return e.value;

                        case "Pipe":
                            return p = this.visit(e.children[0], s), this.visit(e.children[1], p);

                        case "Current":
                            return s;

                        case "Function":
                            var I = [];
                            for (m = 0; m < e.children.length; m++) I.push(this.visit(e.children[m], s));
                            return this.runtime.callFunction(e.name, I);

                        case "ExpressionReference":
                            var O = e.children[0];
                            return O.jmespathType = "Expref", O;

                        default:
                            throw new Error("Unknown node type: " + e.type);
                    }
                },
                computeSliceParams:function(e, t) {
                    var n = t[0], i = t[1], o = t[2], r = [ null, null, null ];
                    if (null === o) o = 1; else if (0 === o) {
                        var s = new Error("Invalid slice, step cannot be 0");
                        throw s.name = "RuntimeError", s;
                    }
                    var a = o < 0;
                    return n = null === n ? a ? e - 1 :0 :this.capSliceRange(e, n, o), i = null === i ? a ? -1 :e :this.capSliceRange(e, i, o),
                        r[0] = n, r[1] = i, r[2] = o, r;
                },
                capSliceRange:function(e, t, n) {
                    return t < 0 ? (t += e) < 0 && (t = n < 0 ? -1 :0) :t >= e && (t = n < 0 ? e - 1 :e),
                        t;
                }
            }, u.prototype = {
                callFunction:function(e, t) {
                    var n = this.functionTable[e];
                    if (void 0 === n) throw new Error("Unknown function: " + e + "()");
                    return this._validateArgs(e, t, n._signature), n._func.call(this, t);
                },
                _validateArgs:function(e, t, n) {
                    var i;
                    if (n[n.length - 1].variadic) {
                        if (t.length < n.length) throw i = 1 === n.length ? " argument" :" arguments", new Error("ArgumentError: " + e + "() takes at least" + n.length + i + " but received " + t.length);
                    } else if (t.length !== n.length) throw i = 1 === n.length ? " argument" :" arguments",
                        new Error("ArgumentError: " + e + "() takes " + n.length + i + " but received " + t.length);
                    for (var o, r, s, a = 0; a < n.length; a++) {
                        s = !1, o = n[a].types, r = this._getTypeName(t[a]);
                        for (var l = 0; l < o.length; l++) if (this._typeMatches(r, o[l], t[a])) {
                            s = !0;
                            break;
                        }
                        if (!s) throw new Error("TypeError: " + e + "() expected argument " + (a + 1) + " to be type " + o + " but received type " + r + " instead.");
                    }
                },
                _typeMatches:function(e, t, n) {
                    if (t === y) return !0;
                    if (t !== E && t !== C && t !== x) return e === t;
                    if (t === x) return e === x;
                    if (e === x) {
                        var i;
                        t === C ? i = v :t === E && (i = b);
                        for (var o = 0; o < n.length; o++) if (!this._typeMatches(this._getTypeName(n[o]), i, n[o])) return !1;
                        return !0;
                    }
                },
                _getTypeName:function(e) {
                    switch (Object.prototype.toString.call(e)) {
                        case "[object String]":
                            return b;

                        case "[object Number]":
                            return v;

                        case "[object Array]":
                            return x;

                        case "[object Boolean]":
                            return 5;

                        case "[object Null]":
                            return 7;

                        case "[object Object]":
                            return "Expref" === e.jmespathType ? _ :w;
                    }
                },
                _functionStartsWith:function(e) {
                    return 0 === e[0].lastIndexOf(e[1]);
                },
                _functionEndsWith:function(e) {
                    var t = e[0], n = e[1];
                    return -1 !== t.indexOf(n, t.length - n.length);
                },
                _functionReverse:function(e) {
                    if (this._getTypeName(e[0]) === b) {
                        for (var t = e[0], n = "", i = t.length - 1; i >= 0; i--) n += t[i];
                        return n;
                    }
                    var o = e[0].slice(0);
                    return o.reverse(), o;
                },
                _functionAbs:function(e) {
                    return Math.abs(e[0]);
                },
                _functionCeil:function(e) {
                    return Math.ceil(e[0]);
                },
                _functionAvg:function(e) {
                    for (var t = 0, n = e[0], i = 0; i < n.length; i++) t += n[i];
                    return t / n.length;
                },
                _functionContains:function(e) {
                    return e[0].indexOf(e[1]) >= 0;
                },
                _functionFloor:function(e) {
                    return Math.floor(e[0]);
                },
                _functionLength:function(e) {
                    return n(e[0]) ? Object.keys(e[0]).length :e[0].length;
                },
                _functionMap:function(e) {
                    for (var t = [], n = this._interpreter, i = e[0], o = e[1], r = 0; r < o.length; r++) t.push(n.visit(i, o[r]));
                    return t;
                },
                _functionMerge:function(e) {
                    for (var t = {}, n = 0; n < e.length; n++) {
                        var i = e[n];
                        for (var o in i) t[o] = i[o];
                    }
                    return t;
                },
                _functionMax:function(e) {
                    if (e[0].length > 0) {
                        if (this._getTypeName(e[0][0]) === v) return Math.max.apply(Math, e[0]);
                        for (var t = e[0], n = t[0], i = 1; i < t.length; i++) n.localeCompare(t[i]) < 0 && (n = t[i]);
                        return n;
                    }
                    return null;
                },
                _functionMin:function(e) {
                    if (e[0].length > 0) {
                        if (this._getTypeName(e[0][0]) === v) return Math.min.apply(Math, e[0]);
                        for (var t = e[0], n = t[0], i = 1; i < t.length; i++) t[i].localeCompare(n) < 0 && (n = t[i]);
                        return n;
                    }
                    return null;
                },
                _functionSum:function(e) {
                    for (var t = 0, n = e[0], i = 0; i < n.length; i++) t += n[i];
                    return t;
                },
                _functionType:function(e) {
                    switch (this._getTypeName(e[0])) {
                        case v:
                            return "number";

                        case b:
                            return "string";

                        case x:
                            return "array";

                        case w:
                            return "object";

                        case 5:
                            return "boolean";

                        case _:
                            return "expref";

                        case 7:
                            return "null";
                    }
                },
                _functionKeys:function(e) {
                    return Object.keys(e[0]);
                },
                _functionValues:function(e) {
                    for (var t = e[0], n = Object.keys(t), i = [], o = 0; o < n.length; o++) i.push(t[n[o]]);
                    return i;
                },
                _functionJoin:function(e) {
                    var t = e[0];
                    return e[1].join(t);
                },
                _functionToArray:function(e) {
                    return this._getTypeName(e[0]) === x ? e[0] :[ e[0] ];
                },
                _functionToString:function(e) {
                    return this._getTypeName(e[0]) === b ? e[0] :JSON.stringify(e[0]);
                },
                _functionToNumber:function(e) {
                    var t, n = this._getTypeName(e[0]);
                    return n === v ? e[0] :n !== b || (t = +e[0], isNaN(t)) ? null :t;
                },
                _functionNotNull:function(e) {
                    for (var t = 0; t < e.length; t++) if (7 !== this._getTypeName(e[t])) return e[t];
                    return null;
                },
                _functionSort:function(e) {
                    var t = e[0].slice(0);
                    return t.sort(), t;
                },
                _functionSortBy:function(e) {
                    var t = e[0].slice(0);
                    if (0 === t.length) return t;
                    var n = this._interpreter, i = e[1], o = this._getTypeName(n.visit(i, t[0]));
                    if ([ v, b ].indexOf(o) < 0) throw new Error("TypeError");
                    for (var r = this, s = [], a = 0; a < t.length; a++) s.push([ a, t[a] ]);
                    s.sort(function(e, t) {
                        var s = n.visit(i, e[1]), a = n.visit(i, t[1]);
                        if (r._getTypeName(s) !== o) throw new Error("TypeError: expected " + o + ", received " + r._getTypeName(s));
                        if (r._getTypeName(a) !== o) throw new Error("TypeError: expected " + o + ", received " + r._getTypeName(a));
                        return s > a ? 1 :s < a ? -1 :e[0] - t[0];
                    });
                    for (var l = 0; l < s.length; l++) t[l] = s[l][1];
                    return t;
                },
                _functionMaxBy:function(e) {
                    for (var t, n, i = e[1], o = e[0], r = this.createKeyFunction(i, [ v, b ]), s = -1 / 0, a = 0; a < o.length; a++) (n = r(o[a])) > s && (s = n,
                        t = o[a]);
                    return t;
                },
                _functionMinBy:function(e) {
                    for (var t, n, i = e[1], o = e[0], r = this.createKeyFunction(i, [ v, b ]), s = 1 / 0, a = 0; a < o.length; a++) (n = r(o[a])) < s && (s = n,
                        t = o[a]);
                    return t;
                },
                createKeyFunction:function(e, t) {
                    var n = this, i = this._interpreter;
                    return function(o) {
                        var r = i.visit(e, o);
                        if (t.indexOf(n._getTypeName(r)) < 0) {
                            var s = "TypeError: expected one of " + t + ", received " + n._getTypeName(r);
                            throw new Error(s);
                        }
                        return r;
                    };
                }
            }, e.tokenize = f, e.compile = p, e.search = m, e.strictDeepEqual = i;
        }(t);
    }, function(e, t) {
        e.exports = function e(t, n) {
            "use strict";
            var i, o, r = /(^([+\-]?(?:0|[1-9]\d*)(?:\.\d*)?(?:[eE][+\-]?\d+)?)?$|^0x[0-9a-f]+$|\d+)/gi, s = /(^[ ]*|[ ]*$)/g, a = /(^([\w ]+,?[\w ]+)?[\w ]+,?[\w ]+\d+:\d+(:\d+)?[\w ]?|^\d{1,4}[\/\-]\d{1,4}[\/\-]\d{1,4}|^\w+, \w+ \d+, \d{4})/, l = /^0x[0-9a-f]+$/i, c = function(t) {
                return e.insensitive && ("" + t).toLowerCase() || "" + t;
            }, h = c(t).replace(s, "") || "", d = c(n).replace(s, "") || "", u = h.replace(r, "\0$1\0").replace(/\0$/, "").replace(/^\0/, "").split("\0"), p = d.replace(r, "\0$1\0").replace(/\0$/, "").replace(/^\0/, "").split("\0"), f = parseInt(h.match(l), 16) || 1 !== u.length && h.match(a) && Date.parse(h), m = parseInt(d.match(l), 16) || f && d.match(a) && Date.parse(d) || null;
            if (m) {
                if (f < m) return -1;
                if (f > m) return 1;
            }
            for (var g = 0, v = Math.max(u.length, p.length); g < v; g++) {
                if (i = !(u[g] || "").match(/^0/) && parseFloat(u[g]) || u[g] || 0, o = !(p[g] || "").match(/^0/) && parseFloat(p[g]) || p[g] || 0,
                    isNaN(i) !== isNaN(o)) return isNaN(i) ? 1 :-1;
                if (typeof i != typeof o && (i += "", o += ""), i < o) return -1;
                if (i > o) return 1;
            }
            return 0;
        };
    }, function(e, t, n) {
        "use strict";
        function i(e) {
            function t(e) {
                this.editor = e, this.dom = {};
            }
            return t.prototype = new e(), t.prototype.getDom = function() {
                var e = this.dom;
                if (e.tr) return e.tr;
                this._updateEditability();
                var t = document.createElement("tr");
                if (t.className = "jsoneditor-append", t.node = this, e.tr = t, "tree" === this.editor.options.mode) {
                    e.tdDrag = document.createElement("td");
                    var n = document.createElement("td");
                    e.tdMenu = n;
                    var i = document.createElement("button");
                    i.type = "button", i.className = "jsoneditor-contextmenu", i.title = "Click to open the actions menu (Ctrl+M)",
                        e.menu = i, n.appendChild(e.menu);
                }
                var o = document.createElement("td"), r = document.createElement("div");
                return r.innerHTML = "(" + s("empty") + ")", r.className = "jsoneditor-readonly",
                    o.appendChild(r), e.td = o, e.text = r, this.updateDom(), t;
            }, t.prototype.getPath = function() {
                return null;
            }, t.prototype.getIndex = function() {
                return null;
            }, t.prototype.updateDom = function(e) {
                var t = this.dom, n = t.td;
                n && (n.style.paddingLeft = 24 * this.getLevel() + 26 + "px");
                var i = t.text;
                i && (i.innerHTML = "(" + s("empty") + " " + this.parent.type + ")");
                var o = t.tr;
                this.isVisible() ? t.tr.firstChild || (t.tdDrag && o.appendChild(t.tdDrag), t.tdMenu && o.appendChild(t.tdMenu),
                    o.appendChild(n)) :t.tr.firstChild && (t.tdDrag && o.removeChild(t.tdDrag), t.tdMenu && o.removeChild(t.tdMenu),
                    o.removeChild(n));
            }, t.prototype.isVisible = function() {
                return 0 == this.parent.childs.length;
            }, t.prototype.showContextMenu = function(t, n) {
                var i = this, o = e.TYPE_TITLES, a = [ {
                    text:s("auto"),
                    className:"jsoneditor-type-auto",
                    title:o.auto,
                    click:function() {
                        i._onAppend("", "", "auto");
                    }
                }, {
                    text:s("array"),
                    className:"jsoneditor-type-array",
                    title:o.array,
                    click:function() {
                        i._onAppend("", []);
                    }
                }, {
                    text:s("object"),
                    className:"jsoneditor-type-object",
                    title:o.object,
                    click:function() {
                        i._onAppend("", {});
                    }
                }, {
                    text:s("string"),
                    className:"jsoneditor-type-string",
                    title:o.string,
                    click:function() {
                        i._onAppend("", "", "string");
                    }
                } ];
                i.addTemplates(a, !0);
                var l = [ {
                    text:s("appendText"),
                    title:s("appendTitleAuto"),
                    submenuTitle:s("appendSubmenuTitle"),
                    className:"jsoneditor-insert",
                    click:function() {
                        i._onAppend("", "", "auto");
                    },
                    submenu:a
                } ];
                new r(l, {
                    close:n
                }).show(t, this.editor.content);
            }, t.prototype.onEvent = function(e) {
                var t = e.type, n = e.target || e.srcElement, i = this.dom;
                if (n == i.menu && ("mouseover" == t ? this.editor.highlighter.highlight(this.parent) :"mouseout" == t && this.editor.highlighter.unhighlight()),
                    "click" == t && n == i.menu) {
                    var r = this.editor.highlighter;
                    r.highlight(this.parent), r.lock(), o.addClassName(i.menu, "jsoneditor-selected"),
                        this.showContextMenu(i.menu, function() {
                            o.removeClassName(i.menu, "jsoneditor-selected"), r.unlock(), r.unhighlight();
                        });
                }
                "keydown" == t && this.onKeyDown(e);
            }, t;
        }
        var o = n(6), r = n(5), s = n(8).translate;
        e.exports = i;
    }, function(e, t, n) {
        "use strict";
        function i(e) {
            function t(e, t) {
                this.editor = e, this.parent = t, this.dom = {};
            }
            return t.prototype = new e(), t.prototype.getDom = function() {
                if (this.dom.tr) return this.dom.tr;
                if (this._updateEditability(), !this.dom.tr) {
                    var e = this, t = this.parent, n = document.createElement("a");
                    n.appendChild(document.createTextNode(o("showMore"))), n.href = "#", n.onclick = function(n) {
                        return t.visibleChilds = Math.floor(t.visibleChilds / t.MAX_VISIBLE_CHILDS + 1) * t.MAX_VISIBLE_CHILDS,
                            e.updateDom(), t.showChilds(), n.preventDefault(), !1;
                    };
                    var i = document.createElement("a");
                    i.appendChild(document.createTextNode(o("showAll"))), i.href = "#", i.onclick = function(n) {
                        return t.visibleChilds = 1 / 0, e.updateDom(), t.showChilds(), n.preventDefault(),
                            !1;
                    };
                    var r = document.createElement("div"), s = document.createTextNode(this._getShowMoreText());
                    r.className = "jsoneditor-show-more", r.appendChild(s), r.appendChild(n), r.appendChild(document.createTextNode(". ")),
                        r.appendChild(i), r.appendChild(document.createTextNode(". "));
                    var a = document.createElement("td");
                    a.appendChild(r);
                    var l = document.createElement("tr");
                    l.appendChild(document.createElement("td")), l.appendChild(document.createElement("td")),
                        l.appendChild(a), l.className = "jsoneditor-show-more", this.dom.tr = l, this.dom.moreContents = r,
                        this.dom.moreText = s;
                }
                return this.updateDom(), this.dom.tr;
            }, t.prototype.updateDom = function(e) {
                if (this.isVisible()) {
                    if (this.dom.tr.node = this.parent.childs[this.parent.visibleChilds], !this.dom.tr.parentNode) {
                        var t = this.parent._getNextTr();
                        t && t.parentNode.insertBefore(this.dom.tr, t);
                    }
                    this.dom.moreText.nodeValue = this._getShowMoreText(), this.dom.moreContents.style.marginLeft = 24 * (this.getLevel() + 1) + "px";
                } else this.dom.tr && this.dom.tr.parentNode && this.dom.tr.parentNode.removeChild(this.dom.tr);
            }, t.prototype._getShowMoreText = function() {
                return o("showMoreStatus", {
                    visibleChilds:this.parent.visibleChilds,
                    totalChilds:this.parent.childs.length
                }) + " ";
            }, t.prototype.isVisible = function() {
                return this.parent.expanded && this.parent.childs.length > this.parent.visibleChilds;
            }, t.prototype.onEvent = function(e) {
                "keydown" === e.type && this.onKeyDown(e);
            }, t;
        }
        var o = n(8).translate;
        e.exports = i;
    }, function(e, t, n) {
        function i(e, t) {
            var n = '<div class="pico-modal-contents"><div class="pico-modal-header">' + r("sort") + "</div><form><table><tbody><tr>  <td>" + r("sortFieldLabel") + ' </td>  <td class="jsoneditor-modal-input">  <div class="jsoneditor-select-wrapper">    <select id="field" title="' + r("sortFieldTitle") + '">    </select>  </div>  </td></tr><tr>  <td>' + r("sortDirectionLabel") + ' </td>  <td class="jsoneditor-modal-input">  <div id="direction" class="jsoneditor-button-group"><input type="button" value="' + r("sortAscending") + '" title="' + r("sortAscendingTitle") + '" data-value="asc" class="jsoneditor-button-first jsoneditor-button-asc"/><input type="button" value="' + r("sortDescending") + '" title="' + r("sortDescendingTitle") + '" data-value="desc" class="jsoneditor-button-last jsoneditor-button-desc"/>  </div>  </td></tr><tr><td colspan="2" class="jsoneditor-modal-input jsoneditor-modal-actions">  <input type="submit" id="ok" value="' + r("ok") + '" /></td></tr></tbody></table></form></div>';
            o({
                parent:t,
                content:n,
                overlayClass:"jsoneditor-modal-overlay",
                modalClass:"jsoneditor-modal jsoneditor-modal-sort"
            }).afterCreate(function(t) {
                function n(e) {
                    s.value = e, s.className = "jsoneditor-button-group jsoneditor-button-group-value-" + s.value;
                }
                var i = t.modalElem().querySelector("form"), o = t.modalElem().querySelector("#ok"), r = t.modalElem().querySelector("#field"), s = t.modalElem().querySelector("#direction"), a = "array" === e.type ? e.getChildPaths() :[ "." ];
                a.forEach(function(e) {
                    var t = document.createElement("option");
                    t.text = e, t.value = e, r.appendChild(t);
                }), r.value = e.sortedBy ? e.sortedBy.path :a[0], n(e.sortedBy ? e.sortedBy.direction :"asc"),
                    s.onclick = function(e) {
                        n(e.target.getAttribute("data-value"));
                    }, o.onclick = function(n) {
                    n.preventDefault(), n.stopPropagation(), t.close();
                    var i = r.value, o = "." === i ? [] :i.split(".").slice(1);
                    e.sortedBy = {
                        path:i,
                        direction:s.value
                    }, e.sort(o, s.value);
                }, i && (i.onsubmit = o.onclick);
            }).afterClose(function(e) {
                e.destroy();
            }).show();
        }
        var o = n(16), r = n(8).translate;
        e.exports = i;
    }, function(e, t, n) {
        var i, o, r;
        !function(n, s) {
            "use strict";
            o = [], i = s, void 0 !== (r = "function" == typeof i ? i.apply(t, o) :i) && (e.exports = r);
        }(0, function() {
            "use strict";
            function e(e) {
                return "object" == typeof Node ? e instanceof Node :e && "object" == typeof e && "number" == typeof e.nodeType;
            }
            function t(e) {
                return "string" == typeof e;
            }
            function n() {
                var e = [];
                return {
                    watch:e.push.bind(e),
                    trigger:function(t, n) {
                        for (var i = !0, o = {
                            detail:n,
                            preventDefault:function() {
                                i = !1;
                            }
                        }, r = 0; r < e.length; r++) e[r](t, o);
                        return i;
                    }
                };
            }
            function i(e) {
                return "none" === window.getComputedStyle(e).display;
            }
            function o(e) {
                this.elem = e;
            }
            function r(e, t) {
                return o.make(e("parent")).clazz("pico-overlay").clazz(e("overlayClass", "")).stylize({
                    display:"none",
                    position:"fixed",
                    top:"0px",
                    left:"0px",
                    height:"100%",
                    width:"100%",
                    zIndex:1e4
                }).stylize(e("overlayStyles", {
                    opacity:.5,
                    background:"#000"
                })).onClick(function() {
                    e("overlayClose", !0) && t();
                });
            }
            function s(e, t) {
                var n = e("width", "auto");
                "number" == typeof n && (n += "px");
                var i = e("modalId", "pico-" + d++);
                return o.make(e("parent")).clazz("pico-content").clazz(e("modalClass", "")).stylize({
                    display:"none",
                    position:"fixed",
                    zIndex:10001,
                    left:"50%",
                    top:"38.1966%",
                    maxHeight:"90%",
                    boxSizing:"border-box",
                    width:n,
                    "-ms-transform":"translate(-50%,-38.1966%)",
                    "-moz-transform":"translate(-50%,-38.1966%)",
                    "-webkit-transform":"translate(-50%,-38.1966%)",
                    "-o-transform":"translate(-50%,-38.1966%)",
                    transform:"translate(-50%,-38.1966%)"
                }).stylize(e("modalStyles", {
                    overflow:"auto",
                    backgroundColor:"white",
                    padding:"20px",
                    borderRadius:"5px"
                })).html(e("content")).attr("id", i).attr("role", "dialog").attr("aria-labelledby", e("ariaLabelledBy")).attr("aria-describedby", e("ariaDescribedBy", i)).onClick(function(e) {
                    new o(e.target).anyAncestor(function(e) {
                        return /\bpico-close\b/.test(e.elem.className);
                    }) && t();
                });
            }
            function a(e, t) {
                if (t("closeButton", !0)) return e.child("button").html(t("closeHtml", "&#xD7;")).clazz("pico-close").clazz(t("closeClass", "")).stylize(t("closeStyles", {
                    borderRadius:"2px",
                    border:0,
                    padding:0,
                    cursor:"pointer",
                    height:"15px",
                    width:"15px",
                    position:"absolute",
                    top:"5px",
                    right:"5px",
                    fontSize:"16px",
                    textAlign:"center",
                    lineHeight:"15px",
                    background:"#CCC"
                })).attr("aria-label", t("close-label", "Close"));
            }
            function l(e) {
                return function() {
                    return e().elem;
                };
            }
            function c(e, t) {
                function n(e, t) {
                    return (e.msMatchesSelector || e.webkitMatchesSelector || e.matches).call(e, t);
                }
                function o(e) {
                    return !(i(e) || n(e, ":disabled") || e.hasAttribute("contenteditable")) && (e.hasAttribute("tabindex") || n(e, "input,select,textarea,button,a[href],area[href],iframe"));
                }
                function r(e) {
                    for (var t = e.getElementsByTagName("*"), n = 0; n < t.length; n++) if (o(t[n])) return t[n];
                }
                function s(e) {
                    for (var t = e.getElementsByTagName("*"), n = t.length; n--; ) if (o(t[n])) return t[n];
                }
                var a;
                e.beforeShow(function() {
                    a = document.activeElement;
                }), e.afterShow(function() {
                    if (t()) {
                        var n = r(e.modalElem());
                        n && n.focus();
                    }
                }), e.afterClose(function() {
                    t() && a && a.focus(), a = null;
                }), p.watch(function(n) {
                    if (t() && e.isVisible()) {
                        var i = r(e.modalElem()), o = s(e.modalElem());
                        (n.shiftKey ? i :o) === document.activeElement && ((n.shiftKey ? o :i).focus(),
                            n.preventDefault());
                    }
                });
            }
            function h(e, t) {
                var n, i = new o(document.body);
                e.beforeShow(function() {
                    n = i.elem.style.overflow, t() && i.stylize({
                        overflow:"hidden"
                    });
                }), e.afterClose(function() {
                    i.stylize({
                        overflow:n
                    });
                });
            }
            o.make = function(e, t) {
                "string" == typeof e && (e = document.querySelector(e));
                var n = document.createElement(t || "div");
                return (e || document.body).appendChild(n), new o(n);
            }, o.prototype = {
                child:function(e) {
                    return o.make(this.elem, e);
                },
                stylize:function(e) {
                    e = e || {}, void 0 !== e.opacity && (e.filter = "alpha(opacity=" + 100 * e.opacity + ")");
                    for (var t in e) e.hasOwnProperty(t) && (this.elem.style[t] = e[t]);
                    return this;
                },
                clazz:function(e) {
                    return this.elem.className += " " + e, this;
                },
                html:function(t) {
                    return e(t) ? this.elem.appendChild(t) :this.elem.innerHTML = t, this;
                },
                onClick:function(e) {
                    return this.elem.addEventListener("click", e), this;
                },
                destroy:function() {
                    this.elem.parentNode.removeChild(this.elem);
                },
                hide:function() {
                    this.elem.style.display = "none";
                },
                show:function() {
                    this.elem.style.display = "block";
                },
                attr:function(e, t) {
                    return void 0 !== t && this.elem.setAttribute(e, t), this;
                },
                anyAncestor:function(e) {
                    for (var t = this.elem; t; ) {
                        if (e(new o(t))) return !0;
                        t = t.parentNode;
                    }
                    return !1;
                },
                isVisible:function() {
                    return !i(this.elem);
                }
            };
            var d = 1, u = n(), p = n();
            return document.documentElement.addEventListener("keydown", function(e) {
                var t = e.which || e.keyCode;
                27 === t ? u.trigger() :9 === t && p.trigger(e);
            }), function(i) {
                function o(e, t) {
                    var n = i[e];
                    return "function" == typeof n && (n = n(t)), void 0 === n ? t :n;
                }
                function d(e) {
                    E().hide(), C().hide(), _.trigger(g, e);
                }
                function p(e) {
                    w.trigger(g, e) && d(e);
                }
                function f(e) {
                    return function() {
                        return e.apply(this, arguments), g;
                    };
                }
                function m(e, t) {
                    if (!v) {
                        var n = s(o, p);
                        v = {
                            modal:n,
                            overlay:r(o, p),
                            close:a(n, o)
                        }, y.trigger(g, t);
                    }
                    return v[e];
                }
                (t(i) || e(i)) && (i = {
                    content:i
                });
                var g, v, y = n(), b = n(), x = n(), w = n(), _ = n(), C = m.bind(window, "modal"), E = m.bind(window, "overlay"), S = m.bind(window, "close");
                return g = {
                    modalElem:l(C),
                    closeElem:l(S),
                    overlayElem:l(E),
                    buildDom:f(m.bind(null, null)),
                    isVisible:function() {
                        return !!(v && C && C().isVisible());
                    },
                    show:function(e) {
                        return b.trigger(g, e) && (E().show(), S(), C().show(), x.trigger(g, e)), this;
                    },
                    close:f(p),
                    forceClose:f(d),
                    destroy:function() {
                        C().destroy(), E().destroy(), E = C = S = void 0;
                    },
                    options:function(e) {
                        Object.keys(e).map(function(t) {
                            i[t] = e[t];
                        });
                    },
                    afterCreate:f(y.watch),
                    beforeShow:f(b.watch),
                    afterShow:f(x.watch),
                    beforeClose:f(w.watch),
                    afterClose:f(_.watch)
                }, c(g, o.bind(null, "focus", !0)), h(g, o.bind(null, "bodyOverflow", !0)), u.watch(function() {
                    o("escCloses", !0) && g.isVisible() && g.close();
                }), g;
            };
        });
    }, function(e, t, n) {
        function i(e, t) {
            var n = e.getValue(), i = '<label class="pico-modal-contents"><div class="pico-modal-header">' + a("transform") + '</div><p>Enter a <a href="http://jmespath.org" target="_blank">JMESPath</a> query to filter, sort, or transform the JSON data.<br/>To learn JMESPath, go to <a href="http://jmespath.org/tutorial.html" target="_blank">the interactive tutorial</a>.</p><table><tbody><tr>  <th>' + a("transformWizardLabel") + ' </th>  <td>  <div id="wizard" class="jsoneditor-jmespath-wizard">  <div>    <div class="jsoneditor-jmespath-wizard-label">' + a("transformWizardFilter") + '</div>    <div class="jsoneditor-jmespath-filter">      <div class="jsoneditor-inline jsoneditor-jmespath-filter-field" >        <select id="filterField">        </select>      </div>      <div class="jsoneditor-inline jsoneditor-jmespath-filter-relation" >        <select id="filterRelation">          <option value="==">==</option>          <option value="!=">!=</option>          <option value="<">&lt;</option>          <option value="<=">&lt;=</option>          <option value=">">&gt;</option>          <option value=">=">&gt;=</option>        </select>      </div>      <div class="jsoneditor-inline jsoneditor-jmespath-filter-value" >        <input placeholder="value..." id="filterValue" />      </div>    </div>  </div>  <div>    <div class="jsoneditor-jmespath-wizard-label">' + a("transformWizardSortBy") + '</div>    <div class="jsoneditor-jmespath-filter">      <div class="jsoneditor-inline jsoneditor-jmespath-sort-field">        <select id="sortField">        </select>      </div>      <div class="jsoneditor-inline jsoneditor-jmespath-sort-order" >        <select id="sortOrder">          <option value="asc">Ascending</option>          <option value="desc">Descending</option>        </select>      </div>    </div>  </div>  <div id="selectFieldsPart">    <div class="jsoneditor-jmespath-wizard-label">' + a("transformWizardSelectFields") + '</div>    <select class="jsoneditor-jmespath-select-fields" id="selectFields" multiple>    </select>  </div>  </div>  </td></tr><tr>  <th>' + a("transformQueryLabel") + ' </th>  <td class="jsoneditor-modal-input">    <textarea id="query"               rows="4"               autocomplete="off"               autocorrect="off"               autocapitalize="off"               spellcheck="false"              title="' + a("transformQueryTitle") + '">[*]</textarea>  </td></tr><tr>  <th>' + a("transformPreviewLabel") + ' </th>  <td class="jsoneditor-modal-input">    <textarea id="preview"         class="jsoneditor-transform-preview"        readonly> </textarea>  </td></tr><tr><td colspan="2" class="jsoneditor-modal-input jsoneditor-modal-actions">  <input type="submit" id="ok" value="' + a("ok") + '" autofocus /></td></tr></tbody></table></div>';
            r({
                parent:t,
                content:i,
                overlayClass:"jsoneditor-modal-overlay",
                modalClass:"jsoneditor-modal jsoneditor-modal-transform",
                focus:!1
            }).afterCreate(function(t) {
                function i(e) {
                    return "." === e[0] ? "." === e ? "@" :e.slice(1) :e;
                }
                function r() {
                    if (p.value && f.value && m.value) {
                        var t = p.value, n = JSON.stringify(e._stringCast(m.value));
                        b.value = "[? " + t + " " + f.value + " `" + n + "`]";
                    } else b.value = "[*]";
                    if (g.value && v.value) {
                        var i = g.value;
                        "desc" === v.value ? b.value += " | reverse(sort_by(@, &" + i + "))" :b.value += " | sort_by(@, &" + i + ")";
                    }
                    if (y.value) {
                        for (var o = [], r = 0; r < y.options.length; r++) if (y.options[r].selected) {
                            var s = y.options[r].value;
                            o.push(s);
                        }
                        "]" !== b.value[b.value.length - 1] && (b.value += " | [*]"), 1 === o.length ? b.value += "." + s :o.length > 1 && (b.value += ".{" + o.map(function(e) {
                            var t = e.split(".");
                            return t[t.length - 1] + ": " + e;
                        }).join(", ") + "}");
                    }
                    N();
                }
                function a() {
                    try {
                        var e = o.search(n, b.value), t = JSON.stringify(e, null, 2).split("\n");
                        t.length > c && (t = t.slice(0, c).concat([ "..." ])), x.className = "jsoneditor-transform-preview",
                            x.value = t.join("\n"), u.disabled = !1;
                    } catch (e) {
                        x.className = "jsoneditor-transform-preview jsoneditor-error", x.value = e.toString(),
                            u.disabled = !0;
                    }
                }
                var h = t.modalElem(), d = h.querySelector("#wizard"), u = h.querySelector("#ok"), p = h.querySelector("#filterField"), f = h.querySelector("#filterRelation"), m = h.querySelector("#filterValue"), g = h.querySelector("#sortField"), v = h.querySelector("#sortOrder"), y = h.querySelector("#selectFields"), b = h.querySelector("#query"), x = h.querySelector("#preview");
                Array.isArray(n) || (d.style.display = "none", d.parentNode.style.fontStyle = "italic",
                    d.parentNode.appendChild(document.createTextNode("(wizard not available for objects, only for arrays)"))),
                    e.getChildPaths().forEach(function(e) {
                        var t = i(e), n = document.createElement("option");
                        n.text = t, n.value = t, p.appendChild(n);
                        var o = document.createElement("option");
                        o.text = t, o.value = t, g.appendChild(o);
                    });
                var w = e.getChildPaths(!0).filter(function(e) {
                    return "." !== e;
                });
                w.length > 0 ? w.forEach(function(e) {
                    var t = i(e), n = document.createElement("option");
                    n.text = t, n.value = t, y.appendChild(n);
                }) :h.querySelector("#selectFieldsPart").style.display = "none";
                var _ = new s(p, {
                    defaultSelected:!1,
                    clearable:!0,
                    allowDeselect:!0,
                    placeholder:"field..."
                }), C = new s(f, {
                    defaultSelected:!1,
                    clearable:!0,
                    allowDeselect:!0,
                    placeholder:"compare..."
                }), E = new s(g, {
                    defaultSelected:!1,
                    clearable:!0,
                    allowDeselect:!0,
                    placeholder:"field..."
                }), S = new s(v, {
                    defaultSelected:!1,
                    clearable:!0,
                    allowDeselect:!0,
                    placeholder:"order..."
                }), j = new s(y, {
                    multiple:!0,
                    clearable:!0,
                    defaultSelected:!1
                });
                _.on("selectr.change", r), C.on("selectr.change", r), m.oninput = r, E.on("selectr.change", r),
                    S.on("selectr.change", r), j.on("selectr.change", r), h.querySelector(".pico-modal-contents").onclick = function(e) {
                    e.preventDefault();
                }, b.value = Array.isArray(n) ? "[*]" :"@";
                var N = l(a, 300);
                b.oninput = N, N(), u.onclick = function(n) {
                    n.preventDefault(), n.stopPropagation(), t.close(), e.transform(b.value);
                }, setTimeout(function() {
                    b.select(), b.focus(), b.selectionStart = 3, b.selectionEnd = 3;
                });
            }).afterClose(function(e) {
                e.destroy();
            }).show();
        }
        var o = n(11), r = n(16), s = n(18), a = n(8).translate, l = n(6).debounce, c = 100;
        e.exports = i;
    }, function(e, t) {
        "use strict";
        function n(e, t) {
            return e.hasOwnProperty(t) && (!0 === e[t] || e[t].length);
        }
        function i(e, t, n) {
            e.parentNode ? e.parentNode.parentNode || t.appendChild(e.parentNode) :t.appendChild(e),
                s.removeClass(e, "excluded"), n || (e.innerHTML = e.textContent);
        }
        var o = {
            defaultSelected:!0,
            width:"auto",
            disabled:!1,
            searchable:!0,
            clearable:!1,
            sortSelected:!1,
            allowDeselect:!1,
            closeOnScroll:!1,
            nativeDropdown:!1,
            placeholder:"Select an option...",
            taggable:!1,
            tagPlaceholder:"Enter a tag..."
        }, r = function() {};
        r.prototype = {
            on:function(e, t) {
                this._events = this._events || {}, this._events[e] = this._events[e] || [], this._events[e].push(t);
            },
            off:function(e, t) {
                this._events = this._events || {}, e in this._events != !1 && this._events[e].splice(this._events[e].indexOf(t), 1);
            },
            emit:function(e) {
                if (this._events = this._events || {}, e in this._events != !1) for (var t = 0; t < this._events[e].length; t++) this._events[e][t].apply(this, Array.prototype.slice.call(arguments, 1));
            }
        }, r.mixin = function(e) {
            for (var t = [ "on", "off", "emit" ], n = 0; n < t.length; n++) "function" == typeof e ? e.prototype[t[n]] = r.prototype[t[n]] :e[t[n]] = r.prototype[t[n]];
            return e;
        };
        var s = {
            extend:function(e, t) {
                t = t || {};
                var n;
                for (n in e) e.hasOwnProperty(n) && (t.hasOwnProperty(n) || (t[n] = e[n]));
                return t;
            },
            each:function(e, t, n) {
                if ("[object Object]" === Object.prototype.toString.call(e)) for (var i in e) Object.prototype.hasOwnProperty.call(e, i) && t.call(n, i, e[i], e); else for (var o = 0, r = e.length; o < r; o++) t.call(n, o, e[o], e);
            },
            createElement:function(e, t) {
                var n = document, i = n.createElement(e);
                if (t && "[object Object]" === Object.prototype.toString.call(t)) {
                    var o;
                    for (o in t) if (o in i) i[o] = t[o]; else if ("html" === o) i.innerHTML = t[o]; else if ("text" === o) {
                        var r = n.createTextNode(t[o]);
                        i.appendChild(r);
                    } else i.setAttribute(o, t[o]);
                }
                return i;
            },
            hasClass:function(e, t) {
                if (e) return e.classList ? e.classList.contains(t) :!!e.className && !!e.className.match(new RegExp("(\\s|^)" + t + "(\\s|$)"));
            },
            addClass:function(e, t) {
                s.hasClass(e, t) || (e.classList ? e.classList.add(t) :e.className = e.className.trim() + " " + t);
            },
            removeClass:function(e, t) {
                s.hasClass(e, t) && (e.classList ? e.classList.remove(t) :e.className = e.className.replace(new RegExp("(^|\\s)" + t.split(" ").join("|") + "(\\s|$)", "gi"), " "));
            },
            closest:function(e, t) {
                return e && e !== document.body && (t(e) ? e :s.closest(e.parentNode, t));
            },
            isInt:function(e) {
                return "number" == typeof e && isFinite(e) && Math.floor(e) === e;
            },
            debounce:function(e, t, n) {
                var i;
                return function() {
                    var o = this, r = arguments, s = function() {
                        i = null, n || e.apply(o, r);
                    }, a = n && !i;
                    clearTimeout(i), i = setTimeout(s, t), a && e.apply(o, r);
                };
            },
            rect:function(e, t) {
                var n = window, i = e.getBoundingClientRect(), o = t ? n.pageXOffset :0, r = t ? n.pageYOffset :0;
                return {
                    bottom:i.bottom + r,
                    height:i.height,
                    left:i.left + o,
                    right:i.right + o,
                    top:i.top + r,
                    width:i.width
                };
            },
            includes:function(e, t) {
                return e.indexOf(t) > -1;
            },
            truncate:function(e) {
                for (;e.firstChild; ) e.removeChild(e.firstChild);
            }
        }, a = function() {
            if (this.items.length) {
                var e = document.createDocumentFragment();
                if (this.config.pagination) {
                    var t = this.pages.slice(0, this.pageIndex);
                    s.each(t, function(t, n) {
                        s.each(n, function(t, n) {
                            i(n, e, this.customOption);
                        }, this);
                    }, this);
                } else s.each(this.items, function(t, n) {
                    i(n, e, this.customOption);
                }, this);
                e.childElementCount && (s.removeClass(this.items[this.navIndex], "active"), this.navIndex = e.querySelector(".selectr-option").idx,
                    s.addClass(this.items[this.navIndex], "active")), this.tree.appendChild(e);
            }
        }, l = function(e) {
            var t = e.target;
            this.container.contains(t) || !this.opened && !s.hasClass(this.container, "notice") || this.close();
        }, c = function(e, t) {
            t = t || e;
            var n = this.customOption ? this.config.renderOption(t) :e.textContent, i = s.createElement("li", {
                "class":"selectr-option",
                html:n,
                role:"treeitem",
                "aria-selected":!1
            });
            return i.idx = e.idx, this.items.push(i), e.defaultSelected && this.defaultSelected.push(e.idx),
            e.disabled && (i.disabled = !0, s.addClass(i, "disabled")), i;
        }, h = function() {
            this.requiresPagination = this.config.pagination && this.config.pagination > 0,
            n(this.config, "width") && (s.isInt(this.config.width) ? this.width = this.config.width + "px" :"auto" === this.config.width ? this.width = "100%" :s.includes(this.config.width, "%") && (this.width = this.config.width)),
                this.container = s.createElement("div", {
                    "class":"selectr-container"
                }), this.config.customClass && s.addClass(this.container, this.config.customClass),
                this.mobileDevice ? s.addClass(this.container, "selectr-mobile") :s.addClass(this.container, "selectr-desktop"),
                this.el.tabIndex = -1, this.config.nativeDropdown || this.mobileDevice ? s.addClass(this.el, "selectr-visible") :s.addClass(this.el, "selectr-hidden"),
                this.selected = s.createElement("div", {
                    "class":"selectr-selected",
                    disabled:this.disabled,
                    tabIndex:1,
                    "aria-expanded":!1
                }), this.label = s.createElement(this.el.multiple ? "ul" :"span", {
                "class":"selectr-label"
            });
            var e = s.createElement("div", {
                "class":"selectr-options-container"
            });
            if (this.tree = s.createElement("ul", {
                    "class":"selectr-options",
                    role:"tree",
                    "aria-hidden":!0,
                    "aria-expanded":!1
                }), this.notice = s.createElement("div", {
                    "class":"selectr-notice"
                }), this.el.setAttribute("aria-hidden", !0), this.disabled && (this.el.disabled = !0),
                this.el.multiple && (s.addClass(this.label, "selectr-tags"), s.addClass(this.container, "multiple"),
                    this.tags = [], this.selectedValues = this.getSelectedProperties("value"), this.selectedIndexes = this.getSelectedProperties("idx")),
                    this.selected.appendChild(this.label), this.config.clearable && (this.selectClear = s.createElement("button", {
                    "class":"selectr-clear",
                    type:"button"
                }), this.container.appendChild(this.selectClear), s.addClass(this.container, "clearable")),
                    this.config.taggable) {
                var t = s.createElement("li", {
                    "class":"input-tag"
                });
                this.input = s.createElement("input", {
                    "class":"selectr-tag-input",
                    placeholder:this.config.tagPlaceholder,
                    tagIndex:0,
                    autocomplete:"off",
                    autocorrect:"off",
                    autocapitalize:"off",
                    spellcheck:"false",
                    role:"textbox",
                    type:"search"
                }), t.appendChild(this.input), this.label.appendChild(t), s.addClass(this.container, "taggable"),
                    this.tagSeperators = [ "," ], this.config.tagSeperators && (this.tagSeperators = this.tagSeperators.concat(this.config.tagSeperators));
            }
            this.config.searchable && (this.input = s.createElement("input", {
                "class":"selectr-input",
                tagIndex:-1,
                autocomplete:"off",
                autocorrect:"off",
                autocapitalize:"off",
                spellcheck:"false",
                role:"textbox",
                type:"search"
            }), this.inputClear = s.createElement("button", {
                "class":"selectr-input-clear",
                type:"button"
            }), this.inputContainer = s.createElement("div", {
                "class":"selectr-input-container"
            }), this.inputContainer.appendChild(this.input), this.inputContainer.appendChild(this.inputClear),
                e.appendChild(this.inputContainer)), e.appendChild(this.notice), e.appendChild(this.tree),
                this.items = [], this.options = [], this.el.options.length && (this.options = [].slice.call(this.el.options));
            var i = !1, o = 0;
            if (this.el.children.length && s.each(this.el.children, function(e, t) {
                    "OPTGROUP" === t.nodeName ? (i = s.createElement("ul", {
                        "class":"selectr-optgroup",
                        role:"group",
                        html:"<li class='selectr-optgroup--label'>" + t.label + "</li>"
                    }), s.each(t.children, function(e, t) {
                        t.idx = o, i.appendChild(c.call(this, t, i)), o++;
                    }, this)) :(t.idx = o, c.call(this, t), o++);
                }, this), this.config.data && Array.isArray(this.config.data)) {
                this.data = [];
                var r, a = !1;
                i = !1, o = 0, s.each(this.config.data, function(e, t) {
                    n(t, "children") ? (a = s.createElement("optgroup", {
                        label:t.text
                    }), i = s.createElement("ul", {
                        "class":"selectr-optgroup",
                        role:"group",
                        html:"<li class='selectr-optgroup--label'>" + t.text + "</li>"
                    }), s.each(t.children, function(e, t) {
                        r = new Option(t.text, t.value, !1, t.hasOwnProperty("selected") && !0 === t.selected),
                            r.disabled = n(t, "disabled"), this.options.push(r), a.appendChild(r), r.idx = o,
                            i.appendChild(c.call(this, r, t)), this.data[o] = t, o++;
                    }, this)) :(r = new Option(t.text, t.value, !1, t.hasOwnProperty("selected") && !0 === t.selected),
                        r.disabled = n(t, "disabled"), this.options.push(r), r.idx = o, c.call(this, r, t),
                        this.data[o] = t, o++);
                }, this);
            }
            this.setSelected(!0);
            var l;
            this.navIndex = 0;
            for (var h = 0; h < this.items.length; h++) if (l = this.items[h], !s.hasClass(l, "disabled")) {
                s.addClass(l, "active"), this.navIndex = h;
                break;
            }
            this.requiresPagination && (this.pageIndex = 1, this.paginate()), this.container.appendChild(this.selected),
                this.container.appendChild(e), this.placeEl = s.createElement("div", {
                "class":"selectr-placeholder"
            }), this.setPlaceholder(), this.selected.appendChild(this.placeEl), this.disabled && this.disable(),
                this.el.parentNode.insertBefore(this.container, this.el), this.container.appendChild(this.el);
        }, d = function(e) {
            if (e = e || window.event, !this.items.length || !this.opened || !s.includes([ 13, 38, 40 ], e.which)) return void (this.navigating = !1);
            if (e.preventDefault(), 13 === e.which) return !(this.config.taggable && this.input.value.length > 0) && this.change(this.navIndex);
            var t, n = this.items[this.navIndex];
            switch (e.which) {
                case 38:
                    t = 0, this.navIndex > 0 && this.navIndex--;
                    break;

                case 40:
                    t = 1, this.navIndex < this.items.length - 1 && this.navIndex++;
            }
            for (this.navigating = !0; s.hasClass(this.items[this.navIndex], "disabled") || s.hasClass(this.items[this.navIndex], "excluded"); ) if (t ? this.navIndex++ :this.navIndex--,
                    this.searching) {
                if (this.navIndex > this.tree.lastElementChild.idx) {
                    this.navIndex = this.tree.lastElementChild.idx;
                    break;
                }
                if (this.navIndex < this.tree.firstElementChild.idx) {
                    this.navIndex = this.tree.firstElementChild.idx;
                    break;
                }
            }
            var i = s.rect(this.items[this.navIndex]);
            t ? (0 === this.navIndex ? this.tree.scrollTop = 0 :i.top + i.height > this.optsRect.top + this.optsRect.height && (this.tree.scrollTop = this.tree.scrollTop + (i.top + i.height - (this.optsRect.top + this.optsRect.height))),
            this.navIndex === this.tree.childElementCount - 1 && this.requiresPagination && f.call(this)) :0 === this.navIndex ? this.tree.scrollTop = 0 :i.top - this.optsRect.top < 0 && (this.tree.scrollTop = this.tree.scrollTop + (i.top - this.optsRect.top)),
            n && s.removeClass(n, "active"), s.addClass(this.items[this.navIndex], "active");
        }, u = function(e) {
            var t, n = this, i = document.createDocumentFragment(), o = this.options[e.idx], r = this.data ? this.data[e.idx] :o, a = this.customSelected ? this.config.renderSelection(r) :o.textContent, l = s.createElement("li", {
                "class":"selectr-tag",
                html:a
            }), c = s.createElement("button", {
                "class":"selectr-tag-remove",
                type:"button"
            });
            if (l.appendChild(c), l.idx = e.idx, l.tag = o.value, this.tags.push(l), this.config.sortSelected) {
                var h = this.tags.slice();
                t = function(e, t) {
                    e.replace(/(\d+)|(\D+)/g, function(e, n, i) {
                        t.push([ n || 1 / 0, i || "" ]);
                    });
                }, h.sort(function(e, i) {
                    var o, r, s = [], a = [];
                    for (!0 === n.config.sortSelected ? (o = e.tag, r = i.tag) :"text" === n.config.sortSelected && (o = e.textContent,
                        r = i.textContent), t(o, s), t(r, a); s.length && a.length; ) {
                        var l = s.shift(), c = a.shift(), h = l[0] - c[0] || l[1].localeCompare(c[1]);
                        if (h) return h;
                    }
                    return s.length - a.length;
                }), s.each(h, function(e, t) {
                    i.appendChild(t);
                }), this.label.innerHTML = "";
            } else i.appendChild(l);
            this.config.taggable ? this.label.insertBefore(i, this.input.parentNode) :this.label.appendChild(i);
        }, p = function(e) {
            var t = !1;
            s.each(this.tags, function(n, i) {
                i.idx === e.idx && (t = i);
            }, this), t && (this.label.removeChild(t), this.tags.splice(this.tags.indexOf(t), 1));
        }, f = function() {
            var e = this.tree;
            if (e.scrollTop >= e.scrollHeight - e.offsetHeight && this.pageIndex < this.pages.length) {
                var t = document.createDocumentFragment();
                s.each(this.pages[this.pageIndex], function(e, n) {
                    i(n, t, this.customOption);
                }, this), e.appendChild(t), this.pageIndex++, this.emit("selectr.paginate", {
                    items:this.items.length,
                    total:this.data.length,
                    page:this.pageIndex,
                    pages:this.pages.length
                });
            }
        }, m = function() {
            (this.config.searchable || this.config.taggable) && (this.input.value = null, this.searching = !1,
            this.config.searchable && s.removeClass(this.inputContainer, "active"), s.hasClass(this.container, "notice") && (s.removeClass(this.container, "notice"),
                s.addClass(this.container, "open"), this.input.focus()), s.each(this.items, function(e, t) {
                s.removeClass(t, "excluded"), this.customOption || (t.innerHTML = t.textContent);
            }, this));
        }, g = function(e, t) {
            var n = new RegExp(e, "i").exec(t.textContent);
            return !!n && t.textContent.replace(n[0], "<span class='selectr-match'>" + n[0] + "</span>");
        }, v = function(e, t) {
            if (t = t || {}, !e) throw new Error("You must supply either a HTMLSelectElement or a CSS3 selector string.");
            if (this.el = e, "string" == typeof e && (this.el = document.querySelector(e)),
                null === this.el) throw new Error("The element you passed to Selectr can not be found.");
            if ("select" !== this.el.nodeName.toLowerCase()) throw new Error("The element you passed to Selectr is not a HTMLSelectElement.");
            this.render(t);
        };
        v.prototype.render = function(e) {
            if (!this.rendered) {
                this.config = s.extend(o, e), this.originalType = this.el.type, this.originalIndex = this.el.tabIndex,
                    this.defaultSelected = [], this.originalOptionCount = this.el.options.length, (this.config.multiple || this.config.taggable) && (this.el.multiple = !0),
                    this.disabled = n(this.config, "disabled"), this.opened = !1, this.config.taggable && (this.config.searchable = !1),
                    this.navigating = !1, this.mobileDevice = !1, /Android|webOS|iPhone|iPad|BlackBerry|Windows Phone|Opera Mini|IEMobile|Mobile/i.test(navigator.userAgent) && (this.mobileDevice = !0),
                    this.customOption = this.config.hasOwnProperty("renderOption") && "function" == typeof this.config.renderOption,
                    this.customSelected = this.config.hasOwnProperty("renderSelection") && "function" == typeof this.config.renderSelection,
                    r.mixin(this), h.call(this), this.bindEvents(), this.update(), this.optsRect = s.rect(this.tree),
                    this.rendered = !0, this.el.multiple || (this.el.selectedIndex = this.selectedIndex);
                var t = this;
                setTimeout(function() {
                    t.emit("selectr.init");
                }, 20);
            }
        }, v.prototype.getSelected = function() {
            return this.el.querySelectorAll("option:checked");
        }, v.prototype.getSelectedProperties = function(e) {
            var t = this.getSelected();
            return [].slice.call(t).map(function(t) {
                return t[e];
            }).filter(function(e) {
                return null !== e && void 0 !== e;
            });
        }, v.prototype.bindEvents = function() {
            var e = this;
            if (this.events = {}, this.events.dismiss = l.bind(this), this.events.navigate = d.bind(this),
                    this.events.reset = this.reset.bind(this), this.config.nativeDropdown || this.mobileDevice) {
                this.container.addEventListener("touchstart", function(t) {
                    t.changedTouches[0].target === e.el && e.toggle();
                }), (this.config.nativeDropdown || this.mobileDevice) && this.container.addEventListener("click", function(t) {
                    t.preventDefault(), t.stopPropagation(), t.target === e.el && e.toggle();
                });
                var t = function(e, t) {
                    for (var n, i = [], o = e.slice(0), r = 0; r < t.length; r++) n = o.indexOf(t[r]),
                        n > -1 ? o.splice(n, 1) :i.push(t[r]);
                    return [ i, o ];
                };
                this.el.addEventListener("change", function(n) {
                    if (e.el.multiple) {
                        var i = e.getSelectedProperties("idx"), o = t(e.selectedIndexes, i);
                        s.each(o[0], function(t, n) {
                            e.select(n);
                        }, e), s.each(o[1], function(t, n) {
                            e.deselect(n);
                        }, e);
                    } else e.el.selectedIndex > -1 && e.select(e.el.selectedIndex);
                });
            }
            this.config.nativeDropdown && this.container.addEventListener("keydown", function(t) {
                "Enter" === t.key && e.selected === document.activeElement && (e.toggle(), setTimeout(function() {
                    e.el.focus();
                }, 200));
            }), this.selected.addEventListener("click", function(t) {
                e.disabled || e.toggle(), t.preventDefault(), t.stopPropagation();
            }), this.label.addEventListener("click", function(t) {
                s.hasClass(t.target, "selectr-tag-remove") && e.deselect(t.target.parentNode.idx);
            }), this.selectClear && this.selectClear.addEventListener("click", this.clear.bind(this)),
                this.tree.addEventListener("mousedown", function(e) {
                    e.preventDefault();
                }), this.tree.addEventListener("click", function(t) {
                t.preventDefault(), t.stopPropagation();
                var n = s.closest(t.target, function(e) {
                    return e && s.hasClass(e, "selectr-option");
                });
                n && (s.hasClass(n, "disabled") || (s.hasClass(n, "selected") ? (e.el.multiple || !e.el.multiple && e.config.allowDeselect) && e.deselect(n.idx) :e.select(n.idx),
                e.opened && !e.el.multiple && e.close()));
            }), this.tree.addEventListener("mouseover", function(t) {
                s.hasClass(t.target, "selectr-option") && (s.hasClass(t.target, "disabled") || (s.removeClass(e.items[e.navIndex], "active"),
                    s.addClass(t.target, "active"), e.navIndex = [].slice.call(e.items).indexOf(t.target)));
            }), this.config.searchable && (this.input.addEventListener("focus", function(t) {
                e.searching = !0;
            }), this.input.addEventListener("blur", function(t) {
                e.searching = !1;
            }), this.input.addEventListener("keyup", function(t) {
                e.search(), e.config.taggable || (this.value.length ? s.addClass(this.parentNode, "active") :s.removeClass(this.parentNode, "active"));
            }), this.inputClear.addEventListener("click", function(t) {
                e.input.value = null, m.call(e), e.tree.childElementCount || a.call(e);
            })), this.config.taggable && this.input.addEventListener("keyup", function(t) {
                if (e.search(), e.config.taggable && this.value.length) {
                    var n = this.value.trim();
                    if (13 === t.which || s.includes(e.tagSeperators, t.key)) {
                        s.each(e.tagSeperators, function(e, t) {
                            n = n.replace(t, "");
                        });
                        e.add({
                            value:n,
                            text:n,
                            selected:!0
                        }, !0) ? (e.close(), m.call(e)) :(this.value = "", e.setMessage("That tag is already in use."));
                    }
                }
            }), this.update = s.debounce(function() {
                e.opened && e.config.closeOnScroll && e.close(), e.width && (e.container.style.width = e.width),
                    e.invert();
            }, 50), this.requiresPagination && (this.paginateItems = s.debounce(function() {
                f.call(this);
            }, 50), this.tree.addEventListener("scroll", this.paginateItems.bind(this))), document.addEventListener("click", this.events.dismiss),
                window.addEventListener("keydown", this.events.navigate), window.addEventListener("resize", this.update),
                window.addEventListener("scroll", this.update), this.el.form && this.el.form.addEventListener("reset", this.events.reset);
        }, v.prototype.setSelected = function(e) {
            if (this.config.data || this.el.multiple || !this.el.options.length || (0 === this.el.selectedIndex && (this.el.options[0].defaultSelected || this.config.defaultSelected || (this.el.selectedIndex = -1)),
                    this.selectedIndex = this.el.selectedIndex, this.selectedIndex > -1 && this.select(this.selectedIndex)),
                this.config.multiple && "select-one" === this.originalType && !this.config.data && this.el.options[0].selected && !this.el.options[0].defaultSelected && (this.el.options[0].selected = !1),
                    s.each(this.options, function(e, t) {
                        t.selected && t.defaultSelected && this.select(t.idx);
                    }, this), this.config.selectedValue && this.setValue(this.config.selectedValue),
                    this.config.data) {
                !this.el.multiple && this.config.defaultSelected && this.el.selectedIndex < 0 && this.select(0);
                var t = 0;
                s.each(this.config.data, function(e, i) {
                    n(i, "children") ? s.each(i.children, function(e, n) {
                        n.hasOwnProperty("selected") && !0 === n.selected && this.select(t), t++;
                    }, this) :(i.hasOwnProperty("selected") && !0 === i.selected && this.select(t),
                        t++);
                }, this);
            }
        }, v.prototype.destroy = function() {
            this.rendered && (this.emit("selectr.destroy"), "select-one" === this.originalType && (this.el.multiple = !1),
            this.config.data && (this.el.innerHTML = ""), s.removeClass(this.el, "selectr-hidden"),
            this.el.form && s.off(this.el.form, "reset", this.events.reset), s.off(document, "click", this.events.dismiss),
                s.off(document, "keydown", this.events.navigate), s.off(window, "resize", this.update),
                s.off(window, "scroll", this.update), this.container.parentNode.replaceChild(this.el, this.container),
                this.rendered = !1);
        }, v.prototype.change = function(e) {
            var t = this.items[e], n = this.options[e];
            n.disabled || (n.selected && s.hasClass(t, "selected") ? this.deselect(e) :this.select(e),
            this.opened && !this.el.multiple && this.close());
        }, v.prototype.select = function(e) {
            var t = this.items[e], n = [].slice.call(this.el.options), i = this.options[e];
            if (this.el.multiple) {
                if (s.includes(this.selectedIndexes, e)) return !1;
                if (this.config.maxSelections && this.tags.length === this.config.maxSelections) return this.setMessage("A maximum of " + this.config.maxSelections + " items can be selected.", !0),
                    !1;
                this.selectedValues.push(i.value), this.selectedIndexes.push(e), u.call(this, t);
            } else {
                var o = this.data ? this.data[e] :i;
                this.label.innerHTML = this.customSelected ? this.config.renderSelection(o) :i.textContent,
                    this.selectedValue = i.value, this.selectedIndex = e, s.each(this.options, function(t, n) {
                    var i = this.items[t];
                    t !== e && (i && s.removeClass(i, "selected"), n.selected = !1, n.removeAttribute("selected"));
                }, this);
            }
            s.includes(n, i) || this.el.add(i), t.setAttribute("aria-selected", !0), s.addClass(t, "selected"),
                s.addClass(this.container, "has-selected"), i.selected = !0, i.setAttribute("selected", ""),
                this.emit("selectr.change", i), this.emit("selectr.select", i);
        }, v.prototype.deselect = function(e, t) {
            var n = this.items[e], i = this.options[e];
            if (this.el.multiple) {
                var o = this.selectedIndexes.indexOf(e);
                this.selectedIndexes.splice(o, 1);
                var r = this.selectedValues.indexOf(i.value);
                this.selectedValues.splice(r, 1), p.call(this, n), this.tags.length || s.removeClass(this.container, "has-selected");
            } else {
                if (!t && !this.config.clearable && !this.config.allowDeselect) return !1;
                this.label.innerHTML = "", this.selectedValue = null, this.el.selectedIndex = this.selectedIndex = -1,
                    s.removeClass(this.container, "has-selected");
            }
            this.items[e].setAttribute("aria-selected", !1), s.removeClass(this.items[e], "selected"),
                i.selected = !1, i.removeAttribute("selected"), this.emit("selectr.change", null),
                this.emit("selectr.deselect", i);
        }, v.prototype.setValue = function(e) {
            var t = Array.isArray(e);
            if (t || (e = e.toString().trim()), !this.el.multiple && t) return !1;
            s.each(this.options, function(n, i) {
                (t && s.includes(e.toString(), i.value) || i.value === e) && this.change(i.idx);
            }, this);
        }, v.prototype.getValue = function(e, t) {
            var n;
            if (this.el.multiple) e ? this.selectedIndexes.length && (n = {}, n.values = [],
                s.each(this.selectedIndexes, function(e, t) {
                    var i = this.options[t];
                    n.values[e] = {
                        value:i.value,
                        text:i.textContent
                    };
                }, this)) :n = this.selectedValues.slice(); else if (e) {
                var i = this.options[this.selectedIndex];
                n = {
                    value:i.value,
                    text:i.textContent
                };
            } else n = this.selectedValue;
            return e && t && (n = JSON.stringify(n)), n;
        }, v.prototype.add = function(e, t) {
            if (e) {
                if (this.data = this.data || [], this.items = this.items || [], this.options = this.options || [],
                        Array.isArray(e)) s.each(e, function(e, n) {
                    this.add(n, t);
                }, this); else if ("[object Object]" === Object.prototype.toString.call(e)) {
                    if (t) {
                        var n = !1;
                        if (s.each(this.options, function(t, i) {
                                i.value.toLowerCase() === e.value.toLowerCase() && (n = !0);
                            }), n) return !1;
                    }
                    var i = s.createElement("option", e);
                    return this.data.push(e), this.options.push(i), i.idx = this.options.length > 0 ? this.options.length - 1 :0,
                        c.call(this, i), e.selected && this.select(i.idx), i;
                }
                return this.setPlaceholder(), this.config.pagination && this.paginate(), !0;
            }
        }, v.prototype.remove = function(e) {
            var t = [];
            if (Array.isArray(e) ? s.each(e, function(n, i) {
                    s.isInt(i) ? t.push(this.getOptionByIndex(i)) :"string" == typeof e && t.push(this.getOptionByValue(i));
                }, this) :s.isInt(e) ? t.push(this.getOptionByIndex(e)) :"string" == typeof e && t.push(this.getOptionByValue(e)),
                    t.length) {
                var n;
                s.each(t, function(e, t) {
                    n = t.idx, this.el.remove(t), this.options.splice(n, 1);
                    var i = this.items[n].parentNode;
                    i && i.removeChild(this.items[n]), this.items.splice(n, 1), s.each(this.options, function(e, t) {
                        t.idx = e, this.items[e].idx = e;
                    }, this);
                }, this), this.setPlaceholder(), this.config.pagination && this.paginate();
            }
        }, v.prototype.removeAll = function() {
            this.clear(!0), s.each(this.el.options, function(e, t) {
                this.el.remove(t);
            }, this), s.truncate(this.tree), this.items = [], this.options = [], this.data = [],
                this.navIndex = 0, this.requiresPagination && (this.requiresPagination = !1, this.pageIndex = 1,
                this.pages = []), this.setPlaceholder();
        }, v.prototype.search = function(e) {
            if (!this.navigating) {
                e = e || this.input.value;
                var t = document.createDocumentFragment();
                if (this.removeMessage(), s.truncate(this.tree), e.length > 1) if (s.each(this.options, function(n, o) {
                        var r = this.items[o.idx];
                        s.includes(o.textContent.toLowerCase(), e.toLowerCase()) && !o.disabled ? (i(r, t, this.customOption),
                            s.removeClass(r, "excluded"), this.customOption || (r.innerHTML = g(e, o))) :s.addClass(r, "excluded");
                    }, this), t.childElementCount) {
                    var n = this.items[this.navIndex], o = t.firstElementChild;
                    s.removeClass(n, "active"), this.navIndex = o.idx, s.addClass(o, "active");
                } else this.config.taggable || this.setMessage("no results."); else a.call(this);
                this.tree.appendChild(t);
            }
        }, v.prototype.toggle = function() {
            this.disabled || (this.opened ? this.close() :this.open());
        }, v.prototype.open = function() {
            var e = this;
            return !!this.options.length && (this.opened || this.emit("selectr.open"), this.opened = !0,
                this.mobileDevice || this.config.nativeDropdown ? (s.addClass(this.container, "native-open"),
                    void (this.config.data && s.each(this.options, function(e, t) {
                        this.el.add(t);
                    }, this))) :(s.addClass(this.container, "open"), a.call(this), this.invert(), this.tree.scrollTop = 0,
                    s.removeClass(this.container, "notice"), this.selected.setAttribute("aria-expanded", !0),
                    this.tree.setAttribute("aria-hidden", !1), this.tree.setAttribute("aria-expanded", !0),
                    void (this.config.searchable && !this.config.taggable && setTimeout(function() {
                        e.input.focus(), e.input.tabIndex = 0;
                    }, 10))));
        }, v.prototype.close = function() {
            if (this.opened && this.emit("selectr.close"), this.opened = !1, this.mobileDevice || this.config.nativeDropdown) return void s.removeClass(this.container, "native-open");
            var e = s.hasClass(this.container, "notice");
            this.config.searchable && !e && (this.input.blur(), this.input.tabIndex = -1, this.searching = !1),
            e && (s.removeClass(this.container, "notice"), this.notice.textContent = ""), s.removeClass(this.container, "open"),
                s.removeClass(this.container, "native-open"), this.selected.setAttribute("aria-expanded", !1),
                this.tree.setAttribute("aria-hidden", !0), this.tree.setAttribute("aria-expanded", !1),
                s.truncate(this.tree), m.call(this);
        }, v.prototype.enable = function() {
            this.disabled = !1, this.el.disabled = !1, this.selected.tabIndex = this.originalIndex,
            this.el.multiple && s.each(this.tags, function(e, t) {
                t.lastElementChild.tabIndex = 0;
            }), s.removeClass(this.container, "selectr-disabled");
        }, v.prototype.disable = function(e) {
            e || (this.el.disabled = !0), this.selected.tabIndex = -1, this.el.multiple && s.each(this.tags, function(e, t) {
                t.lastElementChild.tabIndex = -1;
            }), this.disabled = !0, s.addClass(this.container, "selectr-disabled");
        }, v.prototype.reset = function() {
            this.disabled || (this.clear(), this.setSelected(!0), s.each(this.defaultSelected, function(e, t) {
                this.select(t);
            }, this), this.emit("selectr.reset"));
        }, v.prototype.clear = function(e) {
            if (this.el.multiple) {
                if (this.selectedIndexes.length) {
                    var t = this.selectedIndexes.slice();
                    s.each(t, function(e, t) {
                        this.deselect(t);
                    }, this);
                }
            } else this.selectedIndex > -1 && this.deselect(this.selectedIndex, e);
            this.emit("selectr.clear");
        }, v.prototype.serialise = function(e) {
            var t = [];
            return s.each(this.options, function(e, n) {
                var i = {
                    value:n.value,
                    text:n.textContent
                };
                n.selected && (i.selected = !0), n.disabled && (i.disabled = !0), t[e] = i;
            }), e ? JSON.stringify(t) :t;
        }, v.prototype.serialize = function(e) {
            return this.serialise(e);
        }, v.prototype.setPlaceholder = function(e) {
            e = e || this.config.placeholder || this.el.getAttribute("placeholder"), this.options.length || (e = "No options available"),
                this.placeEl.innerHTML = e;
        }, v.prototype.paginate = function() {
            if (this.items.length) {
                var e = this;
                return this.pages = this.items.map(function(t, n) {
                    return n % e.config.pagination == 0 ? e.items.slice(n, n + e.config.pagination) :null;
                }).filter(function(e) {
                    return e;
                }), this.pages;
            }
        }, v.prototype.setMessage = function(e, t) {
            t && this.close(), s.addClass(this.container, "notice"), this.notice.textContent = e;
        }, v.prototype.removeMessage = function() {
            s.removeClass(this.container, "notice"), this.notice.innerHTML = "";
        }, v.prototype.invert = function() {
            var e = s.rect(this.selected), t = this.tree.parentNode.offsetHeight, n = window.innerHeight;
            e.top + e.height + t > n ? (s.addClass(this.container, "inverted"), this.isInverted = !0) :(s.removeClass(this.container, "inverted"),
                this.isInverted = !1), this.optsRect = s.rect(this.tree);
        }, v.prototype.getOptionByIndex = function(e) {
            return this.options[e];
        }, v.prototype.getOptionByValue = function(e) {
            for (var t = !1, n = 0, i = this.options.length; n < i; n++) if (this.options[n].value.trim() === e.toString().trim()) {
                t = this.options[n];
                break;
            }
            return t;
        }, e.exports = v;
    }, function(e, t, n) {
        "use strict";
        function i(e, t, n, i) {
            for (var r = {
                code:{
                    text:"Code",
                    title:"Switch to code highlighter",
                    click:function() {
                        i("code");
                    }
                },
                form:{
                    text:"Form",
                    title:"Switch to form editor",
                    click:function() {
                        i("form");
                    }
                },
                text:{
                    text:"Text",
                    title:"Switch to plain text editor",
                    click:function() {
                        i("text");
                    }
                },
                tree:{
                    text:"Tree",
                    title:"Switch to tree editor",
                    click:function() {
                        i("tree");
                    }
                },
                view:{
                    text:"View",
                    title:"Switch to tree view",
                    click:function() {
                        i("view");
                    }
                }
            }, s = [], a = 0; a < t.length; a++) {
                var l = t[a], c = r[l];
                if (!c) throw new Error('Unknown mode "' + l + '"');
                c.className = "jsoneditor-type-modes" + (n == l ? " jsoneditor-selected" :""), s.push(c);
            }
            var h = r[n];
            if (!h) throw new Error('Unknown mode "' + n + '"');
            var d = h.text, u = document.createElement("button");
            u.type = "button", u.className = "jsoneditor-modes jsoneditor-separator", u.innerHTML = d + " &#x25BE;",
                u.title = "Switch editor mode", u.onclick = function() {
                new o(s).show(u);
            };
            var p = document.createElement("div");
            p.className = "jsoneditor-modes", p.style.position = "relative", p.appendChild(u),
                e.appendChild(p), this.dom = {
                container:e,
                box:u,
                frame:p
            };
        }
        var o = n(5);
        i.prototype.focus = function() {
            this.dom.box.focus();
        }, i.prototype.destroy = function() {
            this.dom && this.dom.frame && this.dom.frame.parentNode && this.dom.frame.parentNode.removeChild(this.dom.frame),
                this.dom = null;
        }, e.exports = i;
    }, function(e, t) {
        "use strict";
        function n(e) {
            function t(e) {
                var t, n;
                document.createRange ? (t = document.createRange(), t.selectNodeContents(e), t.collapse(!1),
                    n = window.getSelection(), n.removeAllRanges(), n.addRange(t)) :document.selection && (t = document.body.createTextRange(),
                    t.moveToElementText(e), t.collapse(!1), t.select());
            }
            function n(e) {
                return void 0 === a && (a = document.createElement("span"), a.style.visibility = "hidden",
                    a.style.position = "fixed", a.style.outline = "0", a.style.margin = "0", a.style.padding = "0",
                    a.style.border = "0", a.style.left = "0", a.style.whiteSpace = "pre", a.style.fontSize = i,
                    a.style.fontFamily = o, a.style.fontWeight = "normal", document.body.appendChild(a)),
                    a.innerHTML = String(e).replace(/&/g, "&amp;").replace(/"/g, "&quot;").replace(/'/g, "&#39;").replace(/</g, "&lt;").replace(/>/g, "&gt;"),
                    a.getBoundingClientRect().right;
            }
            e = e || {}, e.confirmKeys = e.confirmKeys || [ 39, 35, 9 ], e.caseSensitive = e.caseSensitive || !1;
            var i = "", o = "", r = document.createElement("div");
            r.style.position = "relative", r.style.outline = "0", r.style.border = "0", r.style.margin = "0",
                r.style.padding = "0";
            var s = document.createElement("div");
            s.className = "autocomplete dropdown", s.style.position = "absolute", s.style.visibility = "hidden";
            var a, l, c = {
                onArrowDown:function() {},
                onArrowUp:function() {},
                onEnter:function() {},
                onTab:function() {},
                startFrom:0,
                options:[],
                element:null,
                elementHint:null,
                elementStyle:null,
                wrapper:r,
                show:function(e, t, n) {
                    this.startFrom = t, this.wrapper.remove(), this.elementHint && (this.elementHint.remove(),
                        this.elementHint = null), "" == i && (i = window.getComputedStyle(e).getPropertyValue("font-size")),
                    "" == o && (o = window.getComputedStyle(e).getPropertyValue("font-family"));
                    e.getBoundingClientRect().right, e.getBoundingClientRect().left;
                    s.style.marginLeft = "0", s.style.marginTop = e.getBoundingClientRect().height + "px",
                        this.options = n, this.element != e && (this.element = e, this.elementStyle = {
                        zIndex:this.element.style.zIndex,
                        position:this.element.style.position,
                        backgroundColor:this.element.style.backgroundColor,
                        borderColor:this.element.style.borderColor
                    }), this.element.style.zIndex = 3, this.element.style.position = "relative", this.element.style.backgroundColor = "transparent",
                        this.element.style.borderColor = "transparent", this.elementHint = e.cloneNode(),
                        this.elementHint.className = "autocomplete hint", this.elementHint.style.zIndex = 2,
                        this.elementHint.style.position = "absolute", this.elementHint.onfocus = function() {
                        this.element.focus();
                    }.bind(this), this.element.addEventListener && (this.element.removeEventListener("keydown", d),
                        this.element.addEventListener("keydown", d, !1), this.element.removeEventListener("blur", u),
                        this.element.addEventListener("blur", u, !1)), r.appendChild(this.elementHint),
                        r.appendChild(s), e.parentElement.appendChild(r), this.repaint(e);
                },
                setText:function(e) {
                    this.element.innerText = e;
                },
                getText:function() {
                    return this.element.innerText;
                },
                hideDropDown:function() {
                    this.wrapper.remove(), this.elementHint && (this.elementHint.remove(), this.elementHint = null,
                        h.hide(), this.element.style.zIndex = this.elementStyle.zIndex, this.element.style.position = this.elementStyle.position,
                        this.element.style.backgroundColor = this.elementStyle.backgroundColor, this.element.style.borderColor = this.elementStyle.borderColor);
                },
                repaint:function(t) {
                    var i = t.innerText;
                    i = i.replace("\n", "");
                    var o = (this.startFrom, this.options, this.options.length), r = i.substring(this.startFrom);
                    l = i.substring(0, this.startFrom);
                    for (var a = 0; a < o; a++) {
                        var c = this.options[a];
                        if (!e.caseSensitive && 0 === c.toLowerCase().indexOf(r.toLowerCase()) || e.caseSensitive && 0 === c.indexOf(r)) {
                            this.elementHint.innerText = l + r + c.substring(r.length), this.elementHint.realInnerText = l + c;
                            break;
                        }
                    }
                    s.style.left = n(l) + "px", h.refresh(r, this.options), this.elementHint.style.width = n(this.elementHint.innerText) + 10 + "px",
                    "hidden" == s.style.visibility || (this.elementHint.style.width = n(this.elementHint.innerText) + s.clientWidth + "px");
                }
            }, h = function(t, n) {
                var i = [], o = 0, r = -1, s = function() {
                    this.style.outline = "1px solid #ddd";
                }, a = function() {
                    this.style.outline = "0";
                }, l = function() {
                    c.hide(), c.onmouseselection(this.__hint, c.rs);
                }, c = {
                    rs:n,
                    hide:function() {
                        t.style.visibility = "hidden";
                    },
                    refresh:function(n, r) {
                        t.style.visibility = "hidden", o = 0, t.innerHTML = "";
                        var h = window.innerHeight || document.documentElement.clientHeight, d = t.parentNode.getBoundingClientRect(), u = d.top - 6, p = h - d.bottom - 6;
                        i = [];
                        for (var f = 0; f < r.length; f++) if (!(e.caseSensitive && 0 !== r[f].indexOf(n) || !e.caseSensitive && 0 !== r[f].toLowerCase().indexOf(n.toLowerCase()))) {
                            var m = document.createElement("div");
                            m.className = "item", m.onmouseover = s, m.onmouseout = a, m.onmousedown = l, m.__hint = r[f],
                                m.innerHTML = r[f].substring(0, n.length) + "<b>" + r[f].substring(n.length) + "</b>",
                                i.push(m), t.appendChild(m);
                        }
                        0 !== i.length && (1 === i.length && (n.toLowerCase() === i[0].__hint.toLowerCase() && !e.caseSensitive || n === i[0].__hint && e.caseSensitive) || i.length < 2 || (c.highlight(0),
                            u > 3 * p ? (t.style.maxHeight = u + "px", t.style.top = "", t.style.bottom = "100%") :(t.style.top = "100%",
                                t.style.bottom = "", t.style.maxHeight = p + "px"), t.style.visibility = "visible"));
                    },
                    highlight:function(e) {
                        -1 != r && i[r] && (i[r].className = "item"), i[e].className = "item hover", r = e;
                    },
                    move:function(e) {
                        return "hidden" === t.style.visibility ? "" :o + e === -1 || o + e === i.length ? i[o].__hint :(o += e,
                            c.highlight(o), i[o].__hint);
                    },
                    onmouseselection:function() {}
                };
                return c;
            }(s, c), d = function(n) {
                n = n || window.event;
                var i = n.keyCode;
                if (null != this.elementHint && 33 != i && 34 != i) {
                    if (27 == i) return c.hideDropDown(), c.element.focus(), n.preventDefault(), void n.stopPropagation();
                    var o = this.element.innerText;
                    o = o.replace("\n", "");
                    this.startFrom;
                    if (e.confirmKeys.indexOf(i) >= 0) return 9 == i && 0 == this.elementHint.innerText.length && c.onTab(),
                        void (this.elementHint.innerText.length > 0 && this.element.innerText != this.elementHint.realInnerText && (this.element.innerText = this.elementHint.realInnerText,
                            c.hideDropDown(), t(this.element), 9 == i && (c.element.focus(), n.preventDefault(),
                            n.stopPropagation())));
                    if (13 != i) {
                        if (40 == i) {
                            var r = o.substring(this.startFrom), a = h.move(1);
                            return "" == a && c.onArrowDown(), this.elementHint.innerText = l + r + a.substring(r.length),
                                this.elementHint.realInnerText = l + a, n.preventDefault(), void n.stopPropagation();
                        }
                        if (38 == i) {
                            var r = o.substring(this.startFrom), a = h.move(-1);
                            return "" == a && c.onArrowUp(), this.elementHint.innerText = l + r + a.substring(r.length),
                                this.elementHint.realInnerText = l + a, n.preventDefault(), void n.stopPropagation();
                        }
                    } else if (0 == this.elementHint.innerText.length) c.onEnter(); else {
                        var d = "hidden" == s.style.visibility;
                        if (h.hide(), d) return c.hideDropDown(), c.element.focus(), void c.onEnter();
                        this.element.innerText = this.elementHint.realInnerText, c.hideDropDown(), t(this.element),
                            n.preventDefault(), n.stopPropagation();
                    }
                }
            }.bind(c), u = function(e) {
                c.hideDropDown();
            }.bind(c);
            return h.onmouseselection = function(e, n) {
                n.element.innerText = n.elementHint.innerText = l + e, n.hideDropDown(), window.setTimeout(function() {
                    n.element.focus(), t(n.element);
                }, 1);
            }, c;
        }
        e.exports = n;
    }, function(e, t, n) {
        "use strict";
        function i() {
            try {
                this.format();
            } catch (e) {}
        }
        var o = n(22), r = n(19), s = n(6), a = {};
        a.create = function(e, t) {
            t = t || {}, void 0 === t.statusBar && (t.statusBar = !0), this.options = t, t.indentation ? this.indentation = Number(t.indentation) :this.indentation = 2;
            var i = t.ace ? t.ace :o;
            if (this.mode = "code" == t.mode ? "code" :"text", "code" == this.mode && void 0 === i && (this.mode = "text",
                    console.warn("Failed to load Ace editor, falling back to plain text mode. Please use a JSONEditor bundle including Ace, or pass Ace as via the configuration option `ace`.")),
                    this.theme = t.theme || "ace/theme/jsoneditor", "ace/theme/jsoneditor" === this.theme && i) try {
                n(26);
            } catch (e) {
                console.error(e);
            }
            t.onTextSelectionChange && this.onTextSelectionChange(t.onTextSelectionChange);
            var a = this;
            this.container = e, this.dom = {}, this.aceEditor = void 0, this.textarea = void 0,
                this.validateSchema = null, this._debouncedValidate = s.debounce(this.validate.bind(this), this.DEBOUNCE_INTERVAL),
                this.width = e.clientWidth, this.height = e.clientHeight, this.frame = document.createElement("div"),
                this.frame.className = "jsoneditor jsoneditor-mode-" + this.options.mode, this.frame.onclick = function(e) {
                e.preventDefault();
            }, this.frame.onkeydown = function(e) {
                a._onKeyDown(e);
            }, this.menu = document.createElement("div"), this.menu.className = "jsoneditor-menu",
                this.frame.appendChild(this.menu);
            var l = document.createElement("button");
            l.type = "button", l.className = "jsoneditor-format", l.title = "Format JSON data, with proper indentation and line feeds (Ctrl+\\)",
                this.menu.appendChild(l), l.onclick = function() {
                try {
                    a.format(), a._onChange();
                } catch (e) {
                    a._onError(e);
                }
            };
            var c = document.createElement("button");
            c.type = "button", c.className = "jsoneditor-compact", c.title = "Compact JSON data, remove all whitespaces (Ctrl+Shift+\\)",
                this.menu.appendChild(c), c.onclick = function() {
                try {
                    a.compact(), a._onChange();
                } catch (e) {
                    a._onError(e);
                }
            };
            var h = document.createElement("button");
            h.type = "button", h.className = "jsoneditor-repair", h.title = "Repair JSON: fix quotes and escape characters, remove comments and JSONP notation, turn JavaScript objects into JSON.",
                this.menu.appendChild(h), h.onclick = function() {
                try {
                    a.repair(), a._onChange();
                } catch (e) {
                    a._onError(e);
                }
            }, this.options && this.options.modes && this.options.modes.length && (this.modeSwitcher = new r(this.menu, this.options.modes, this.options.mode, function(e) {
                a.setMode(e), a.modeSwitcher.focus();
            }));
            var d = {}, u = this.options.onEditable && typeof ("function" === this.options.onEditable) && !this.options.onEditable(d);
            if (this.content = document.createElement("div"), this.content.className = "jsoneditor-outer",
                    this.frame.appendChild(this.content), this.container.appendChild(this.frame), "code" == this.mode) {
                this.editorDom = document.createElement("div"), this.editorDom.style.height = "100%",
                    this.editorDom.style.width = "100%", this.content.appendChild(this.editorDom);
                var p = i.edit(this.editorDom);
                p.$blockScrolling = 1 / 0, p.setTheme(this.theme), p.setOptions({
                    readOnly:u
                }), p.setShowPrintMargin(!1), p.setFontSize(13), p.getSession().setMode("ace/mode/json"),
                    p.getSession().setTabSize(this.indentation), p.getSession().setUseSoftTabs(!0),
                    p.getSession().setUseWrapMode(!0), p.commands.bindKey("Ctrl-L", null), p.commands.bindKey("Command-L", null),
                    this.aceEditor = p, this.hasOwnProperty("editor") || Object.defineProperty(this, "editor", {
                    get:function() {
                        return console.warn('Property "editor" has been renamed to "aceEditor".'), a.aceEditor;
                    },
                    set:function(e) {
                        console.warn('Property "editor" has been renamed to "aceEditor".'), a.aceEditor = e;
                    }
                });
                var f = document.createElement("a");
                f.appendChild(document.createTextNode("powered by ace")), f.href = "http://ace.ajax.org",
                    f.target = "_blank", f.className = "jsoneditor-poweredBy", f.onclick = function() {
                    window.open(f.href, f.target);
                }, this.menu.appendChild(f), p.on("change", this._onChange.bind(this)), p.on("changeSelection", this._onSelect.bind(this));
            } else {
                var m = document.createElement("textarea");
                m.className = "jsoneditor-text", m.spellcheck = !1, this.content.appendChild(m),
                    this.textarea = m, this.textarea.readOnly = u, null === this.textarea.oninput ? this.textarea.oninput = this._onChange.bind(this) :this.textarea.onchange = this._onChange.bind(this),
                    m.onselect = this._onSelect.bind(this), m.onmousedown = this._onMouseDown.bind(this),
                    m.onblur = this._onBlur.bind(this);
            }
            var g = document.createElement("div");
            if (g.className = "validation-errors-container", this.dom.validationErrorsContainer = g,
                    this.frame.appendChild(g), t.statusBar) {
                s.addClassName(this.content, "has-status-bar"), this.curserInfoElements = {};
                var v = document.createElement("div");
                this.dom.statusBar = v, v.className = "jsoneditor-statusbar", this.frame.appendChild(v);
                var y = document.createElement("span");
                y.className = "jsoneditor-curserinfo-label", y.innerText = "Ln:";
                var b = document.createElement("span");
                b.className = "jsoneditor-curserinfo-val", b.innerText = "1", v.appendChild(y),
                    v.appendChild(b);
                var x = document.createElement("span");
                x.className = "jsoneditor-curserinfo-label", x.innerText = "Col:";
                var w = document.createElement("span");
                w.className = "jsoneditor-curserinfo-val", w.innerText = "1", v.appendChild(x),
                    v.appendChild(w), this.curserInfoElements.colVal = w, this.curserInfoElements.lnVal = b;
                var _ = document.createElement("span");
                _.className = "jsoneditor-curserinfo-label", _.innerText = "characters selected",
                    _.style.display = "none";
                var C = document.createElement("span");
                C.className = "jsoneditor-curserinfo-count", C.innerText = "0", C.style.display = "none",
                    this.curserInfoElements.countLabel = _, this.curserInfoElements.countVal = C, v.appendChild(C),
                    v.appendChild(_);
            }
            this.setSchema(this.options.schema, this.options.schemaRefs);
        }, a._onChange = function() {
            if (!this.onChangeDisabled) {
                if (this._debouncedValidate(), this.options.onChange) try {
                    this.options.onChange();
                } catch (e) {
                    console.error("Error in onChange callback: ", e);
                }
                if (this.options.onChangeText) try {
                    this.options.onChangeText(this.getText());
                } catch (e) {
                    console.error("Error in onChangeText callback: ", e);
                }
            }
        }, a._onSelect = function() {
            this._updateCursorInfo(), this._emitSelectionChange();
        }, a._onKeyDown = function(e) {
            var t = e.which || e.keyCode, n = !1;
            220 == t && e.ctrlKey && (e.shiftKey ? (this.compact(), this._onChange()) :(this.format(),
                this._onChange()), n = !0), n && (e.preventDefault(), e.stopPropagation()), this._updateCursorInfo(),
                this._emitSelectionChange();
        }, a._onMouseDown = function(e) {
            this._updateCursorInfo(), this._emitSelectionChange();
        }, a._onBlur = function(e) {
            this._updateCursorInfo(), this._emitSelectionChange();
        }, a._updateCursorInfo = function() {
            function e() {
                o.curserInfoElements.countVal.innerText !== i && (o.curserInfoElements.countVal.innerText = i,
                    o.curserInfoElements.countVal.style.display = i ? "inline" :"none", o.curserInfoElements.countLabel.style.display = i ? "inline" :"none"),
                    o.curserInfoElements.lnVal.innerText = t, o.curserInfoElements.colVal.innerText = n;
            }
            var t, n, i, o = this;
            if (this.textarea) setTimeout(function() {
                var r = s.getInputSelection(o.textarea);
                r.startIndex !== r.endIndex && (i = r.endIndex - r.startIndex), i && o.cursorInfo && o.cursorInfo.line === r.end.row && o.cursorInfo.column === r.end.column ? (t = r.start.row,
                    n = r.start.column) :(t = r.end.row, n = r.end.column), o.cursorInfo = {
                    line:t,
                    column:n,
                    count:i
                }, o.options.statusBar && e();
            }, 0); else if (this.aceEditor && this.curserInfoElements) {
                var r = this.aceEditor.getCursorPosition(), a = this.aceEditor.getSelectedText();
                t = r.row + 1, n = r.column + 1, i = a.length, o.cursorInfo = {
                    line:t,
                    column:n,
                    count:i
                }, this.options.statusBar && e();
            }
        }, a._emitSelectionChange = function() {
            if (this._selectionChangedHandler) {
                var e = this.getTextSelection();
                this._selectionChangedHandler(e.start, e.end, e.text);
            }
        }, a.destroy = function() {
            this.aceEditor && (this.aceEditor.destroy(), this.aceEditor = null), this.frame && this.container && this.frame.parentNode == this.container && this.container.removeChild(this.frame),
            this.modeSwitcher && (this.modeSwitcher.destroy(), this.modeSwitcher = null), this.textarea = null,
                this._debouncedValidate = null;
        }, a.compact = function() {
            var e = this.get(), t = JSON.stringify(e);
            this.setText(t);
        }, a.format = function() {
            var e = this.get(), t = JSON.stringify(e, null, this.indentation);
            this.setText(t);
        }, a.repair = function() {
            var e = this.getText(), t = s.sanitize(e);
            this.setText(t);
        }, a.focus = function() {
            this.textarea && this.textarea.focus(), this.aceEditor && this.aceEditor.focus();
        }, a.resize = function() {
            if (this.aceEditor) {
                this.aceEditor.resize(!1);
            }
        }, a.set = function(e) {
            this.setText(JSON.stringify(e, null, this.indentation));
        }, a.update = function(e) {
            this.updateText(JSON.stringify(e, null, this.indentation));
        }, a.get = function() {
            var e, t = this.getText();
            try {
                e = s.parse(t);
            } catch (n) {
                t = s.sanitize(t), e = s.parse(t);
            }
            return e;
        }, a.getText = function() {
            return this.textarea ? this.textarea.value :this.aceEditor ? this.aceEditor.getValue() :"";
        }, a.setText = function(e) {
            var t;
            t = !0 === this.options.escapeUnicode ? s.escapeUnicodeChars(e) :e, this.textarea && (this.textarea.value = t),
            this.aceEditor && (this.onChangeDisabled = !0, this.aceEditor.setValue(t, -1), this.onChangeDisabled = !1),
                this.validate();
        }, a.updateText = function(e) {
            this.getText() !== e && (this.onChangeDisabled = !0, this.setText(e), this.onChangeDisabled = !1);
        }, a.validate = function() {
            this.dom.validationErrors && (this.dom.validationErrors.parentNode.removeChild(this.dom.validationErrors),
                this.dom.validationErrors = null, this.content.style.marginBottom = "", this.content.style.paddingBottom = "");
            var e, t = !1, n = [];
            try {
                e = this.get(), t = !0;
            } catch (e) {}
            if (t && this.validateSchema) {
                this.validateSchema(e) || (n = this.validateSchema.errors.map(function(e) {
                    return s.improveSchemaError(e);
                }));
            }
            if (n.length > 0) {
                if (n.length > 3) {
                    n = n.slice(0, 3);
                    var i = this.validateSchema.errors.length - 3;
                    n.push("(" + i + " more errors...)");
                }
                var o = document.createElement("div");
                o.innerHTML = '<table class="jsoneditor-text-errors"><tbody>' + n.map(function(e) {
                    return '<tr><td><button class="jsoneditor-schema-error"></button></td>' + ("string" == typeof e ? '<td colspan="2"><pre>' + e + "</pre></td>" :"<td>" + e.dataPath + "</td><td>" + e.message + "</td>") + "</tr>";
                }).join("") + "</tbody></table>", this.dom.validationErrors = o, this.dom.validationErrorsContainer.appendChild(o);
                var r = o.clientHeight + (this.dom.statusBar ? this.dom.statusBar.clientHeight :0);
                this.content.style.marginBottom = -r + "px", this.content.style.paddingBottom = r + "px";
            }
            if (this.aceEditor) {
                this.aceEditor.resize(!1);
            }
        }, a.getTextSelection = function() {
            var e = {};
            if (this.textarea) {
                var t = s.getInputSelection(this.textarea);
                return this.cursorInfo && this.cursorInfo.line === t.end.row && this.cursorInfo.column === t.end.column ? (e.start = t.end,
                    e.end = t.start) :e = t, {
                    start:e.start,
                    end:e.end,
                    text:this.textarea.value.substring(t.startIndex, t.endIndex)
                };
            }
            if (this.aceEditor) {
                var n = this.aceEditor.getSelection(), i = this.aceEditor.getSelectedText(), o = n.getRange(), r = n.getSelectionLead();
                return r.row === o.end.row && r.column === o.end.column ? e = o :(e.start = o.end,
                    e.end = o.start), {
                    start:{
                        row:e.start.row + 1,
                        column:e.start.column + 1
                    },
                    end:{
                        row:e.end.row + 1,
                        column:e.end.column + 1
                    },
                    text:i
                };
            }
        }, a.onTextSelectionChange = function(e) {
            "function" == typeof e && (this._selectionChangedHandler = s.debounce(e, this.DEBOUNCE_INTERVAL));
        }, a.setTextSelection = function(e, t) {
            if (e && t) if (this.textarea) {
                var n = s.getIndexForPosition(this.textarea, e.row, e.column), i = s.getIndexForPosition(this.textarea, t.row, t.column);
                if (n > -1 && i > -1) if (this.textarea.setSelectionRange) this.textarea.focus(),
                    this.textarea.setSelectionRange(n, i); else if (this.textarea.createTextRange) {
                    var o = this.textarea.createTextRange();
                    o.collapse(!0), o.moveEnd("character", i), o.moveStart("character", n), o.select();
                }
            } else if (this.aceEditor) {
                var o = {
                    start:{
                        row:e.row - 1,
                        column:e.column - 1
                    },
                    end:{
                        row:t.row - 1,
                        column:t.column - 1
                    }
                };
                this.aceEditor.selection.setRange(o);
            }
        }, e.exports = [ {
            mode:"text",
            mixin:a,
            data:"text",
            load:i
        }, {
            mode:"code",
            mixin:a,
            data:"text",
            load:i
        } ];
    }, function(e, t, n) {
        var i;
        if (window.ace) i = window.ace; else try {
            i = n(!function() {
                var e = new Error('Cannot find module "brace"');
                throw e.code = "MODULE_NOT_FOUND", e;
            }()), n(23), n(25);
        } catch (e) {}
        e.exports = i;
    }, function(e, t, n) {
        ace.define("ace/mode/json_highlight_rules", [ "require", "exports", "module", "ace/lib/oop", "ace/mode/text_highlight_rules" ], function(e, t, n) {
            "use strict";
            var i = e("../lib/oop"), o = e("./text_highlight_rules").TextHighlightRules, r = function() {
                this.$rules = {
                    start:[ {
                        token:"variable",
                        regex:'["](?:(?:\\\\.)|(?:[^"\\\\]))*?["]\\s*(?=:)'
                    }, {
                        token:"string",
                        regex:'"',
                        next:"string"
                    }, {
                        token:"constant.numeric",
                        regex:"0[xX][0-9a-fA-F]+\\b"
                    }, {
                        token:"constant.numeric",
                        regex:"[+-]?\\d+(?:(?:\\.\\d*)?(?:[eE][+-]?\\d+)?)?\\b"
                    }, {
                        token:"constant.language.boolean",
                        regex:"(?:true|false)\\b"
                    }, {
                        token:"text",
                        regex:"['](?:(?:\\\\.)|(?:[^'\\\\]))*?[']"
                    }, {
                        token:"comment",
                        regex:"\\/\\/.*$"
                    }, {
                        token:"comment.start",
                        regex:"\\/\\*",
                        next:"comment"
                    }, {
                        token:"paren.lparen",
                        regex:"[[({]"
                    }, {
                        token:"paren.rparen",
                        regex:"[\\])}]"
                    }, {
                        token:"text",
                        regex:"\\s+"
                    } ],
                    string:[ {
                        token:"constant.language.escape",
                        regex:/\\(?:x[0-9a-fA-F]{2}|u[0-9a-fA-F]{4}|["\\\/bfnrt])/
                    }, {
                        token:"string",
                        regex:'"|$',
                        next:"start"
                    }, {
                        defaultToken:"string"
                    } ],
                    comment:[ {
                        token:"comment.end",
                        regex:"\\*\\/",
                        next:"start"
                    }, {
                        defaultToken:"comment"
                    } ]
                };
            };
            i.inherits(r, o), t.JsonHighlightRules = r;
        }), ace.define("ace/mode/matching_brace_outdent", [ "require", "exports", "module", "ace/range" ], function(e, t, n) {
            "use strict";
            var i = e("../range").Range, o = function() {};
            (function() {
                this.checkOutdent = function(e, t) {
                    return !!/^\s+$/.test(e) && /^\s*\}/.test(t);
                }, this.autoOutdent = function(e, t) {
                    var n = e.getLine(t), o = n.match(/^(\s*\})/);
                    if (!o) return 0;
                    var r = o[1].length, s = e.findMatchingBracket({
                        row:t,
                        column:r
                    });
                    if (!s || s.row == t) return 0;
                    var a = this.$getIndent(e.getLine(s.row));
                    e.replace(new i(t, 0, t, r - 1), a);
                }, this.$getIndent = function(e) {
                    return e.match(/^\s*/)[0];
                };
            }).call(o.prototype), t.MatchingBraceOutdent = o;
        }), ace.define("ace/mode/folding/cstyle", [ "require", "exports", "module", "ace/lib/oop", "ace/range", "ace/mode/folding/fold_mode" ], function(e, t, n) {
            "use strict";
            var i = e("../../lib/oop"), o = e("../../range").Range, r = e("./fold_mode").FoldMode, s = t.FoldMode = function(e) {
                e && (this.foldingStartMarker = new RegExp(this.foldingStartMarker.source.replace(/\|[^|]*?$/, "|" + e.start)),
                    this.foldingStopMarker = new RegExp(this.foldingStopMarker.source.replace(/\|[^|]*?$/, "|" + e.end)));
            };
            i.inherits(s, r), function() {
                this.foldingStartMarker = /([\{\[\(])[^\}\]\)]*$|^\s*(\/\*)/, this.foldingStopMarker = /^[^\[\{\(]*([\}\]\)])|^[\s\*]*(\*\/)/,
                    this.singleLineBlockCommentRe = /^\s*(\/\*).*\*\/\s*$/, this.tripleStarBlockCommentRe = /^\s*(\/\*\*\*).*\*\/\s*$/,
                    this.startRegionRe = /^\s*(\/\*|\/\/)#?region\b/, this._getFoldWidgetBase = this.getFoldWidget,
                    this.getFoldWidget = function(e, t, n) {
                        var i = e.getLine(n);
                        if (this.singleLineBlockCommentRe.test(i) && !this.startRegionRe.test(i) && !this.tripleStarBlockCommentRe.test(i)) return "";
                        var o = this._getFoldWidgetBase(e, t, n);
                        return !o && this.startRegionRe.test(i) ? "start" :o;
                    }, this.getFoldWidgetRange = function(e, t, n, i) {
                    var o = e.getLine(n);
                    if (this.startRegionRe.test(o)) return this.getCommentRegionBlock(e, o, n);
                    var r = o.match(this.foldingStartMarker);
                    if (r) {
                        var s = r.index;
                        if (r[1]) return this.openingBracketBlock(e, r[1], n, s);
                        var a = e.getCommentFoldRange(n, s + r[0].length, 1);
                        return a && !a.isMultiLine() && (i ? a = this.getSectionRange(e, n) :"all" != t && (a = null)),
                            a;
                    }
                    if ("markbegin" !== t) {
                        var r = o.match(this.foldingStopMarker);
                        if (r) {
                            var s = r.index + r[0].length;
                            return r[1] ? this.closingBracketBlock(e, r[1], n, s) :e.getCommentFoldRange(n, s, -1);
                        }
                    }
                }, this.getSectionRange = function(e, t) {
                    var n = e.getLine(t), i = n.search(/\S/), r = t, s = n.length;
                    t += 1;
                    for (var a = t, l = e.getLength(); ++t < l; ) {
                        n = e.getLine(t);
                        var c = n.search(/\S/);
                        if (-1 !== c) {
                            if (i > c) break;
                            var h = this.getFoldWidgetRange(e, "all", t);
                            if (h) {
                                if (h.start.row <= r) break;
                                if (h.isMultiLine()) t = h.end.row; else if (i == c) break;
                            }
                            a = t;
                        }
                    }
                    return new o(r, s, a, e.getLine(a).length);
                }, this.getCommentRegionBlock = function(e, t, n) {
                    for (var i = t.search(/\s*$/), r = e.getLength(), s = n, a = /^\s*(?:\/\*|\/\/|--)#?(end)?region\b/, l = 1; ++n < r; ) {
                        t = e.getLine(n);
                        var c = a.exec(t);
                        if (c && (c[1] ? l-- :l++, !l)) break;
                    }
                    var h = n;
                    if (h > s) return new o(s, i, h, t.length);
                };
            }.call(s.prototype);
        }), ace.define("ace/mode/json", [ "require", "exports", "module", "ace/lib/oop", "ace/mode/text", "ace/mode/json_highlight_rules", "ace/mode/matching_brace_outdent", "ace/mode/behaviour/cstyle", "ace/mode/folding/cstyle", "ace/worker/worker_client" ], function(e, t, i) {
            "use strict";
            var o = e("../lib/oop"), r = e("./text").Mode, s = e("./json_highlight_rules").JsonHighlightRules, a = e("./matching_brace_outdent").MatchingBraceOutdent, l = e("./behaviour/cstyle").CstyleBehaviour, c = e("./folding/cstyle").FoldMode, h = e("../worker/worker_client").WorkerClient, d = function() {
                this.HighlightRules = s, this.$outdent = new a(), this.$behaviour = new l(), this.foldingRules = new c();
            };
            o.inherits(d, r), function() {
                this.getNextLineIndent = function(e, t, n) {
                    var i = this.$getIndent(t);
                    if ("start" == e) {
                        t.match(/^.*[\{\(\[]\s*$/) && (i += n);
                    }
                    return i;
                }, this.checkOutdent = function(e, t, n) {
                    return this.$outdent.checkOutdent(t, n);
                }, this.autoOutdent = function(e, t, n) {
                    this.$outdent.autoOutdent(t, n);
                }, this.createWorker = function(e) {
                    var t = new h([ "ace" ], n(24), "JsonWorker");
                    return t.attachToDocument(e.getDocument()), t.on("annotate", function(t) {
                        e.setAnnotations(t.data);
                    }), t.on("terminate", function() {
                        e.clearAnnotations();
                    }), t;
                }, this.$id = "ace/mode/json";
            }.call(d.prototype), t.Mode = d;
        });
    }, function(e, t) {
        e.exports.id = "ace/mode/json_worker", e.exports.src = '"no use strict";!function(window){function resolveModuleId(id,paths){for(var testPath=id,tail="";testPath;){var alias=paths[testPath];if("string"==typeof alias)return alias+tail;if(alias)return alias.location.replace(/\\/*$/,"/")+(tail||alias.main||alias.name);if(alias===!1)return"";var i=testPath.lastIndexOf("/");if(-1===i)break;tail=testPath.substr(i)+tail,testPath=testPath.slice(0,i)}return id}if(!(void 0!==window.window&&window.document||window.acequire&&window.define)){window.console||(window.console=function(){var msgs=Array.prototype.slice.call(arguments,0);postMessage({type:"log",data:msgs})},window.console.error=window.console.warn=window.console.log=window.console.trace=window.console),window.window=window,window.ace=window,window.onerror=function(message,file,line,col,err){postMessage({type:"error",data:{message:message,data:err.data,file:file,line:line,col:col,stack:err.stack}})},window.normalizeModule=function(parentId,moduleName){if(-1!==moduleName.indexOf("!")){var chunks=moduleName.split("!");return window.normalizeModule(parentId,chunks[0])+"!"+window.normalizeModule(parentId,chunks[1])}if("."==moduleName.charAt(0)){var base=parentId.split("/").slice(0,-1).join("/");for(moduleName=(base?base+"/":"")+moduleName;-1!==moduleName.indexOf(".")&&previous!=moduleName;){var previous=moduleName;moduleName=moduleName.replace(/^\\.\\//,"").replace(/\\/\\.\\//,"/").replace(/[^\\/]+\\/\\.\\.\\//,"")}}return moduleName},window.acequire=function acequire(parentId,id){if(id||(id=parentId,parentId=null),!id.charAt)throw Error("worker.js acequire() accepts only (parentId, id) as arguments");id=window.normalizeModule(parentId,id);var module=window.acequire.modules[id];if(module)return module.initialized||(module.initialized=!0,module.exports=module.factory().exports),module.exports;if(!window.acequire.tlns)return console.log("unable to load "+id);var path=resolveModuleId(id,window.acequire.tlns);return".js"!=path.slice(-3)&&(path+=".js"),window.acequire.id=id,window.acequire.modules[id]={},importScripts(path),window.acequire(parentId,id)},window.acequire.modules={},window.acequire.tlns={},window.define=function(id,deps,factory){if(2==arguments.length?(factory=deps,"string"!=typeof id&&(deps=id,id=window.acequire.id)):1==arguments.length&&(factory=id,deps=[],id=window.acequire.id),"function"!=typeof factory)return window.acequire.modules[id]={exports:factory,initialized:!0},void 0;deps.length||(deps=["require","exports","module"]);var req=function(childId){return window.acequire(id,childId)};window.acequire.modules[id]={exports:{},factory:function(){var module=this,returnExports=factory.apply(this,deps.map(function(dep){switch(dep){case"require":return req;case"exports":return module.exports;case"module":return module;default:return req(dep)}}));return returnExports&&(module.exports=returnExports),module}}},window.define.amd={},acequire.tlns={},window.initBaseUrls=function(topLevelNamespaces){for(var i in topLevelNamespaces)acequire.tlns[i]=topLevelNamespaces[i]},window.initSender=function(){var EventEmitter=window.acequire("ace/lib/event_emitter").EventEmitter,oop=window.acequire("ace/lib/oop"),Sender=function(){};return function(){oop.implement(this,EventEmitter),this.callback=function(data,callbackId){postMessage({type:"call",id:callbackId,data:data})},this.emit=function(name,data){postMessage({type:"event",name:name,data:data})}}.call(Sender.prototype),new Sender};var main=window.main=null,sender=window.sender=null;window.onmessage=function(e){var msg=e.data;if(msg.event&&sender)sender._signal(msg.event,msg.data);else if(msg.command)if(main[msg.command])main[msg.command].apply(main,msg.args);else{if(!window[msg.command])throw Error("Unknown command:"+msg.command);window[msg.command].apply(window,msg.args)}else if(msg.init){window.initBaseUrls(msg.tlns),acequire("ace/lib/es5-shim"),sender=window.sender=window.initSender();var clazz=acequire(msg.module)[msg.classname];main=window.main=new clazz(sender)}}}}(this),ace.define("ace/lib/oop",["require","exports","module"],function(acequire,exports){"use strict";exports.inherits=function(ctor,superCtor){ctor.super_=superCtor,ctor.prototype=Object.create(superCtor.prototype,{constructor:{value:ctor,enumerable:!1,writable:!0,configurable:!0}})},exports.mixin=function(obj,mixin){for(var key in mixin)obj[key]=mixin[key];return obj},exports.implement=function(proto,mixin){exports.mixin(proto,mixin)}}),ace.define("ace/range",["require","exports","module"],function(acequire,exports){"use strict";var comparePoints=function(p1,p2){return p1.row-p2.row||p1.column-p2.column},Range=function(startRow,startColumn,endRow,endColumn){this.start={row:startRow,column:startColumn},this.end={row:endRow,column:endColumn}};(function(){this.isEqual=function(range){return this.start.row===range.start.row&&this.end.row===range.end.row&&this.start.column===range.start.column&&this.end.column===range.end.column},this.toString=function(){return"Range: ["+this.start.row+"/"+this.start.column+"] -> ["+this.end.row+"/"+this.end.column+"]"},this.contains=function(row,column){return 0==this.compare(row,column)},this.compareRange=function(range){var cmp,end=range.end,start=range.start;return cmp=this.compare(end.row,end.column),1==cmp?(cmp=this.compare(start.row,start.column),1==cmp?2:0==cmp?1:0):-1==cmp?-2:(cmp=this.compare(start.row,start.column),-1==cmp?-1:1==cmp?42:0)},this.comparePoint=function(p){return this.compare(p.row,p.column)},this.containsRange=function(range){return 0==this.comparePoint(range.start)&&0==this.comparePoint(range.end)},this.intersects=function(range){var cmp=this.compareRange(range);return-1==cmp||0==cmp||1==cmp},this.isEnd=function(row,column){return this.end.row==row&&this.end.column==column},this.isStart=function(row,column){return this.start.row==row&&this.start.column==column},this.setStart=function(row,column){"object"==typeof row?(this.start.column=row.column,this.start.row=row.row):(this.start.row=row,this.start.column=column)},this.setEnd=function(row,column){"object"==typeof row?(this.end.column=row.column,this.end.row=row.row):(this.end.row=row,this.end.column=column)},this.inside=function(row,column){return 0==this.compare(row,column)?this.isEnd(row,column)||this.isStart(row,column)?!1:!0:!1},this.insideStart=function(row,column){return 0==this.compare(row,column)?this.isEnd(row,column)?!1:!0:!1},this.insideEnd=function(row,column){return 0==this.compare(row,column)?this.isStart(row,column)?!1:!0:!1},this.compare=function(row,column){return this.isMultiLine()||row!==this.start.row?this.start.row>row?-1:row>this.end.row?1:this.start.row===row?column>=this.start.column?0:-1:this.end.row===row?this.end.column>=column?0:1:0:this.start.column>column?-1:column>this.end.column?1:0},this.compareStart=function(row,column){return this.start.row==row&&this.start.column==column?-1:this.compare(row,column)},this.compareEnd=function(row,column){return this.end.row==row&&this.end.column==column?1:this.compare(row,column)},this.compareInside=function(row,column){return this.end.row==row&&this.end.column==column?1:this.start.row==row&&this.start.column==column?-1:this.compare(row,column)},this.clipRows=function(firstRow,lastRow){if(this.end.row>lastRow)var end={row:lastRow+1,column:0};else if(firstRow>this.end.row)var end={row:firstRow,column:0};if(this.start.row>lastRow)var start={row:lastRow+1,column:0};else if(firstRow>this.start.row)var start={row:firstRow,column:0};return Range.fromPoints(start||this.start,end||this.end)},this.extend=function(row,column){var cmp=this.compare(row,column);if(0==cmp)return this;if(-1==cmp)var start={row:row,column:column};else var end={row:row,column:column};return Range.fromPoints(start||this.start,end||this.end)},this.isEmpty=function(){return this.start.row===this.end.row&&this.start.column===this.end.column},this.isMultiLine=function(){return this.start.row!==this.end.row},this.clone=function(){return Range.fromPoints(this.start,this.end)},this.collapseRows=function(){return 0==this.end.column?new Range(this.start.row,0,Math.max(this.start.row,this.end.row-1),0):new Range(this.start.row,0,this.end.row,0)},this.toScreenRange=function(session){var screenPosStart=session.documentToScreenPosition(this.start),screenPosEnd=session.documentToScreenPosition(this.end);return new Range(screenPosStart.row,screenPosStart.column,screenPosEnd.row,screenPosEnd.column)},this.moveBy=function(row,column){this.start.row+=row,this.start.column+=column,this.end.row+=row,this.end.column+=column}}).call(Range.prototype),Range.fromPoints=function(start,end){return new Range(start.row,start.column,end.row,end.column)},Range.comparePoints=comparePoints,Range.comparePoints=function(p1,p2){return p1.row-p2.row||p1.column-p2.column},exports.Range=Range}),ace.define("ace/apply_delta",["require","exports","module"],function(acequire,exports){"use strict";exports.applyDelta=function(docLines,delta){var row=delta.start.row,startColumn=delta.start.column,line=docLines[row]||"";switch(delta.action){case"insert":var lines=delta.lines;if(1===lines.length)docLines[row]=line.substring(0,startColumn)+delta.lines[0]+line.substring(startColumn);else{var args=[row,1].concat(delta.lines);docLines.splice.apply(docLines,args),docLines[row]=line.substring(0,startColumn)+docLines[row],docLines[row+delta.lines.length-1]+=line.substring(startColumn)}break;case"remove":var endColumn=delta.end.column,endRow=delta.end.row;row===endRow?docLines[row]=line.substring(0,startColumn)+line.substring(endColumn):docLines.splice(row,endRow-row+1,line.substring(0,startColumn)+docLines[endRow].substring(endColumn))}}}),ace.define("ace/lib/event_emitter",["require","exports","module"],function(acequire,exports){"use strict";var EventEmitter={},stopPropagation=function(){this.propagationStopped=!0},preventDefault=function(){this.defaultPrevented=!0};EventEmitter._emit=EventEmitter._dispatchEvent=function(eventName,e){this._eventRegistry||(this._eventRegistry={}),this._defaultHandlers||(this._defaultHandlers={});var listeners=this._eventRegistry[eventName]||[],defaultHandler=this._defaultHandlers[eventName];if(listeners.length||defaultHandler){"object"==typeof e&&e||(e={}),e.type||(e.type=eventName),e.stopPropagation||(e.stopPropagation=stopPropagation),e.preventDefault||(e.preventDefault=preventDefault),listeners=listeners.slice();for(var i=0;listeners.length>i&&(listeners[i](e,this),!e.propagationStopped);i++);return defaultHandler&&!e.defaultPrevented?defaultHandler(e,this):void 0}},EventEmitter._signal=function(eventName,e){var listeners=(this._eventRegistry||{})[eventName];if(listeners){listeners=listeners.slice();for(var i=0;listeners.length>i;i++)listeners[i](e,this)}},EventEmitter.once=function(eventName,callback){var _self=this;callback&&this.addEventListener(eventName,function newCallback(){_self.removeEventListener(eventName,newCallback),callback.apply(null,arguments)})},EventEmitter.setDefaultHandler=function(eventName,callback){var handlers=this._defaultHandlers;if(handlers||(handlers=this._defaultHandlers={_disabled_:{}}),handlers[eventName]){var old=handlers[eventName],disabled=handlers._disabled_[eventName];disabled||(handlers._disabled_[eventName]=disabled=[]),disabled.push(old);var i=disabled.indexOf(callback);-1!=i&&disabled.splice(i,1)}handlers[eventName]=callback},EventEmitter.removeDefaultHandler=function(eventName,callback){var handlers=this._defaultHandlers;if(handlers){var disabled=handlers._disabled_[eventName];if(handlers[eventName]==callback)handlers[eventName],disabled&&this.setDefaultHandler(eventName,disabled.pop());else if(disabled){var i=disabled.indexOf(callback);-1!=i&&disabled.splice(i,1)}}},EventEmitter.on=EventEmitter.addEventListener=function(eventName,callback,capturing){this._eventRegistry=this._eventRegistry||{};var listeners=this._eventRegistry[eventName];return listeners||(listeners=this._eventRegistry[eventName]=[]),-1==listeners.indexOf(callback)&&listeners[capturing?"unshift":"push"](callback),callback},EventEmitter.off=EventEmitter.removeListener=EventEmitter.removeEventListener=function(eventName,callback){this._eventRegistry=this._eventRegistry||{};var listeners=this._eventRegistry[eventName];if(listeners){var index=listeners.indexOf(callback);-1!==index&&listeners.splice(index,1)}},EventEmitter.removeAllListeners=function(eventName){this._eventRegistry&&(this._eventRegistry[eventName]=[])},exports.EventEmitter=EventEmitter}),ace.define("ace/anchor",["require","exports","module","ace/lib/oop","ace/lib/event_emitter"],function(acequire,exports){"use strict";var oop=acequire("./lib/oop"),EventEmitter=acequire("./lib/event_emitter").EventEmitter,Anchor=exports.Anchor=function(doc,row,column){this.$onChange=this.onChange.bind(this),this.attach(doc),column===void 0?this.setPosition(row.row,row.column):this.setPosition(row,column)};(function(){function $pointsInOrder(point1,point2,equalPointsInOrder){var bColIsAfter=equalPointsInOrder?point1.column<=point2.column:point1.column<point2.column;return point1.row<point2.row||point1.row==point2.row&&bColIsAfter}function $getTransformedPoint(delta,point,moveIfEqual){var deltaIsInsert="insert"==delta.action,deltaRowShift=(deltaIsInsert?1:-1)*(delta.end.row-delta.start.row),deltaColShift=(deltaIsInsert?1:-1)*(delta.end.column-delta.start.column),deltaStart=delta.start,deltaEnd=deltaIsInsert?deltaStart:delta.end;return $pointsInOrder(point,deltaStart,moveIfEqual)?{row:point.row,column:point.column}:$pointsInOrder(deltaEnd,point,!moveIfEqual)?{row:point.row+deltaRowShift,column:point.column+(point.row==deltaEnd.row?deltaColShift:0)}:{row:deltaStart.row,column:deltaStart.column}}oop.implement(this,EventEmitter),this.getPosition=function(){return this.$clipPositionToDocument(this.row,this.column)},this.getDocument=function(){return this.document},this.$insertRight=!1,this.onChange=function(delta){if(!(delta.start.row==delta.end.row&&delta.start.row!=this.row||delta.start.row>this.row)){var point=$getTransformedPoint(delta,{row:this.row,column:this.column},this.$insertRight);this.setPosition(point.row,point.column,!0)}},this.setPosition=function(row,column,noClip){var pos;if(pos=noClip?{row:row,column:column}:this.$clipPositionToDocument(row,column),this.row!=pos.row||this.column!=pos.column){var old={row:this.row,column:this.column};this.row=pos.row,this.column=pos.column,this._signal("change",{old:old,value:pos})}},this.detach=function(){this.document.removeEventListener("change",this.$onChange)},this.attach=function(doc){this.document=doc||this.document,this.document.on("change",this.$onChange)},this.$clipPositionToDocument=function(row,column){var pos={};return row>=this.document.getLength()?(pos.row=Math.max(0,this.document.getLength()-1),pos.column=this.document.getLine(pos.row).length):0>row?(pos.row=0,pos.column=0):(pos.row=row,pos.column=Math.min(this.document.getLine(pos.row).length,Math.max(0,column))),0>column&&(pos.column=0),pos}}).call(Anchor.prototype)}),ace.define("ace/document",["require","exports","module","ace/lib/oop","ace/apply_delta","ace/lib/event_emitter","ace/range","ace/anchor"],function(acequire,exports){"use strict";var oop=acequire("./lib/oop"),applyDelta=acequire("./apply_delta").applyDelta,EventEmitter=acequire("./lib/event_emitter").EventEmitter,Range=acequire("./range").Range,Anchor=acequire("./anchor").Anchor,Document=function(textOrLines){this.$lines=[""],0===textOrLines.length?this.$lines=[""]:Array.isArray(textOrLines)?this.insertMergedLines({row:0,column:0},textOrLines):this.insert({row:0,column:0},textOrLines)};(function(){oop.implement(this,EventEmitter),this.setValue=function(text){var len=this.getLength()-1;this.remove(new Range(0,0,len,this.getLine(len).length)),this.insert({row:0,column:0},text)},this.getValue=function(){return this.getAllLines().join(this.getNewLineCharacter())},this.createAnchor=function(row,column){return new Anchor(this,row,column)},this.$split=0==="aaa".split(/a/).length?function(text){return text.replace(/\\r\\n|\\r/g,"\\n").split("\\n")}:function(text){return text.split(/\\r\\n|\\r|\\n/)},this.$detectNewLine=function(text){var match=text.match(/^.*?(\\r\\n|\\r|\\n)/m);this.$autoNewLine=match?match[1]:"\\n",this._signal("changeNewLineMode")},this.getNewLineCharacter=function(){switch(this.$newLineMode){case"windows":return"\\r\\n";case"unix":return"\\n";default:return this.$autoNewLine||"\\n"}},this.$autoNewLine="",this.$newLineMode="auto",this.setNewLineMode=function(newLineMode){this.$newLineMode!==newLineMode&&(this.$newLineMode=newLineMode,this._signal("changeNewLineMode"))},this.getNewLineMode=function(){return this.$newLineMode},this.isNewLine=function(text){return"\\r\\n"==text||"\\r"==text||"\\n"==text},this.getLine=function(row){return this.$lines[row]||""},this.getLines=function(firstRow,lastRow){return this.$lines.slice(firstRow,lastRow+1)},this.getAllLines=function(){return this.getLines(0,this.getLength())},this.getLength=function(){return this.$lines.length},this.getTextRange=function(range){return this.getLinesForRange(range).join(this.getNewLineCharacter())},this.getLinesForRange=function(range){var lines;if(range.start.row===range.end.row)lines=[this.getLine(range.start.row).substring(range.start.column,range.end.column)];else{lines=this.getLines(range.start.row,range.end.row),lines[0]=(lines[0]||"").substring(range.start.column);var l=lines.length-1;range.end.row-range.start.row==l&&(lines[l]=lines[l].substring(0,range.end.column))}return lines},this.insertLines=function(row,lines){return console.warn("Use of document.insertLines is deprecated. Use the insertFullLines method instead."),this.insertFullLines(row,lines)},this.removeLines=function(firstRow,lastRow){return console.warn("Use of document.removeLines is deprecated. Use the removeFullLines method instead."),this.removeFullLines(firstRow,lastRow)},this.insertNewLine=function(position){return console.warn("Use of document.insertNewLine is deprecated. Use insertMergedLines(position, [\'\', \'\']) instead."),this.insertMergedLines(position,["",""])},this.insert=function(position,text){return 1>=this.getLength()&&this.$detectNewLine(text),this.insertMergedLines(position,this.$split(text))},this.insertInLine=function(position,text){var start=this.clippedPos(position.row,position.column),end=this.pos(position.row,position.column+text.length);return this.applyDelta({start:start,end:end,action:"insert",lines:[text]},!0),this.clonePos(end)},this.clippedPos=function(row,column){var length=this.getLength();void 0===row?row=length:0>row?row=0:row>=length&&(row=length-1,column=void 0);var line=this.getLine(row);return void 0==column&&(column=line.length),column=Math.min(Math.max(column,0),line.length),{row:row,column:column}},this.clonePos=function(pos){return{row:pos.row,column:pos.column}},this.pos=function(row,column){return{row:row,column:column}},this.$clipPosition=function(position){var length=this.getLength();return position.row>=length?(position.row=Math.max(0,length-1),position.column=this.getLine(length-1).length):(position.row=Math.max(0,position.row),position.column=Math.min(Math.max(position.column,0),this.getLine(position.row).length)),position},this.insertFullLines=function(row,lines){row=Math.min(Math.max(row,0),this.getLength());var column=0;this.getLength()>row?(lines=lines.concat([""]),column=0):(lines=[""].concat(lines),row--,column=this.$lines[row].length),this.insertMergedLines({row:row,column:column},lines)},this.insertMergedLines=function(position,lines){var start=this.clippedPos(position.row,position.column),end={row:start.row+lines.length-1,column:(1==lines.length?start.column:0)+lines[lines.length-1].length};return this.applyDelta({start:start,end:end,action:"insert",lines:lines}),this.clonePos(end)},this.remove=function(range){var start=this.clippedPos(range.start.row,range.start.column),end=this.clippedPos(range.end.row,range.end.column);return this.applyDelta({start:start,end:end,action:"remove",lines:this.getLinesForRange({start:start,end:end})}),this.clonePos(start)},this.removeInLine=function(row,startColumn,endColumn){var start=this.clippedPos(row,startColumn),end=this.clippedPos(row,endColumn);return this.applyDelta({start:start,end:end,action:"remove",lines:this.getLinesForRange({start:start,end:end})},!0),this.clonePos(start)},this.removeFullLines=function(firstRow,lastRow){firstRow=Math.min(Math.max(0,firstRow),this.getLength()-1),lastRow=Math.min(Math.max(0,lastRow),this.getLength()-1);var deleteFirstNewLine=lastRow==this.getLength()-1&&firstRow>0,deleteLastNewLine=this.getLength()-1>lastRow,startRow=deleteFirstNewLine?firstRow-1:firstRow,startCol=deleteFirstNewLine?this.getLine(startRow).length:0,endRow=deleteLastNewLine?lastRow+1:lastRow,endCol=deleteLastNewLine?0:this.getLine(endRow).length,range=new Range(startRow,startCol,endRow,endCol),deletedLines=this.$lines.slice(firstRow,lastRow+1);return this.applyDelta({start:range.start,end:range.end,action:"remove",lines:this.getLinesForRange(range)}),deletedLines},this.removeNewLine=function(row){this.getLength()-1>row&&row>=0&&this.applyDelta({start:this.pos(row,this.getLine(row).length),end:this.pos(row+1,0),action:"remove",lines:["",""]})},this.replace=function(range,text){if(range instanceof Range||(range=Range.fromPoints(range.start,range.end)),0===text.length&&range.isEmpty())return range.start;if(text==this.getTextRange(range))return range.end;this.remove(range);var end;return end=text?this.insert(range.start,text):range.start},this.applyDeltas=function(deltas){for(var i=0;deltas.length>i;i++)this.applyDelta(deltas[i])},this.revertDeltas=function(deltas){for(var i=deltas.length-1;i>=0;i--)this.revertDelta(deltas[i])},this.applyDelta=function(delta,doNotValidate){var isInsert="insert"==delta.action;(isInsert?1>=delta.lines.length&&!delta.lines[0]:!Range.comparePoints(delta.start,delta.end))||(isInsert&&delta.lines.length>2e4&&this.$splitAndapplyLargeDelta(delta,2e4),applyDelta(this.$lines,delta,doNotValidate),this._signal("change",delta))},this.$splitAndapplyLargeDelta=function(delta,MAX){for(var lines=delta.lines,l=lines.length,row=delta.start.row,column=delta.start.column,from=0,to=0;;){from=to,to+=MAX-1;var chunk=lines.slice(from,to);if(to>l){delta.lines=chunk,delta.start.row=row+from,delta.start.column=column;break}chunk.push(""),this.applyDelta({start:this.pos(row+from,column),end:this.pos(row+to,column=0),action:delta.action,lines:chunk},!0)}},this.revertDelta=function(delta){this.applyDelta({start:this.clonePos(delta.start),end:this.clonePos(delta.end),action:"insert"==delta.action?"remove":"insert",lines:delta.lines.slice()})},this.indexToPosition=function(index,startRow){for(var lines=this.$lines||this.getAllLines(),newlineLength=this.getNewLineCharacter().length,i=startRow||0,l=lines.length;l>i;i++)if(index-=lines[i].length+newlineLength,0>index)return{row:i,column:index+lines[i].length+newlineLength};return{row:l-1,column:lines[l-1].length}},this.positionToIndex=function(pos,startRow){for(var lines=this.$lines||this.getAllLines(),newlineLength=this.getNewLineCharacter().length,index=0,row=Math.min(pos.row,lines.length),i=startRow||0;row>i;++i)index+=lines[i].length+newlineLength;return index+pos.column}}).call(Document.prototype),exports.Document=Document}),ace.define("ace/lib/lang",["require","exports","module"],function(acequire,exports){"use strict";exports.last=function(a){return a[a.length-1]},exports.stringReverse=function(string){return string.split("").reverse().join("")},exports.stringRepeat=function(string,count){for(var result="";count>0;)1&count&&(result+=string),(count>>=1)&&(string+=string);return result};var trimBeginRegexp=/^\\s\\s*/,trimEndRegexp=/\\s\\s*$/;exports.stringTrimLeft=function(string){return string.replace(trimBeginRegexp,"")},exports.stringTrimRight=function(string){return string.replace(trimEndRegexp,"")},exports.copyObject=function(obj){var copy={};for(var key in obj)copy[key]=obj[key];return copy},exports.copyArray=function(array){for(var copy=[],i=0,l=array.length;l>i;i++)copy[i]=array[i]&&"object"==typeof array[i]?this.copyObject(array[i]):array[i];return copy},exports.deepCopy=function deepCopy(obj){if("object"!=typeof obj||!obj)return obj;var copy;if(Array.isArray(obj)){copy=[];for(var key=0;obj.length>key;key++)copy[key]=deepCopy(obj[key]);return copy}if("[object Object]"!==Object.prototype.toString.call(obj))return obj;copy={};for(var key in obj)copy[key]=deepCopy(obj[key]);return copy},exports.arrayToMap=function(arr){for(var map={},i=0;arr.length>i;i++)map[arr[i]]=1;return map},exports.createMap=function(props){var map=Object.create(null);for(var i in props)map[i]=props[i];return map},exports.arrayRemove=function(array,value){for(var i=0;array.length>=i;i++)value===array[i]&&array.splice(i,1)},exports.escapeRegExp=function(str){return str.replace(/([.*+?^${}()|[\\]\\/\\\\])/g,"\\\\$1")},exports.escapeHTML=function(str){return str.replace(/&/g,"&#38;").replace(/"/g,"&#34;").replace(/\'/g,"&#39;").replace(/</g,"&#60;")},exports.getMatchOffsets=function(string,regExp){var matches=[];return string.replace(regExp,function(str){matches.push({offset:arguments[arguments.length-2],length:str.length})}),matches},exports.deferredCall=function(fcn){var timer=null,callback=function(){timer=null,fcn()},deferred=function(timeout){return deferred.cancel(),timer=setTimeout(callback,timeout||0),deferred};return deferred.schedule=deferred,deferred.call=function(){return this.cancel(),fcn(),deferred},deferred.cancel=function(){return clearTimeout(timer),timer=null,deferred},deferred.isPending=function(){return timer},deferred},exports.delayedCall=function(fcn,defaultTimeout){var timer=null,callback=function(){timer=null,fcn()},_self=function(timeout){null==timer&&(timer=setTimeout(callback,timeout||defaultTimeout))};return _self.delay=function(timeout){timer&&clearTimeout(timer),timer=setTimeout(callback,timeout||defaultTimeout)},_self.schedule=_self,_self.call=function(){this.cancel(),fcn()},_self.cancel=function(){timer&&clearTimeout(timer),timer=null},_self.isPending=function(){return timer},_self}}),ace.define("ace/worker/mirror",["require","exports","module","ace/range","ace/document","ace/lib/lang"],function(acequire,exports){"use strict";acequire("../range").Range;var Document=acequire("../document").Document,lang=acequire("../lib/lang"),Mirror=exports.Mirror=function(sender){this.sender=sender;var doc=this.doc=new Document(""),deferredUpdate=this.deferredUpdate=lang.delayedCall(this.onUpdate.bind(this)),_self=this;sender.on("change",function(e){var data=e.data;if(data[0].start)doc.applyDeltas(data);else for(var i=0;data.length>i;i+=2){if(Array.isArray(data[i+1]))var d={action:"insert",start:data[i],lines:data[i+1]};else var d={action:"remove",start:data[i],end:data[i+1]};doc.applyDelta(d,!0)}return _self.$timeout?deferredUpdate.schedule(_self.$timeout):(_self.onUpdate(),void 0)})};(function(){this.$timeout=500,this.setTimeout=function(timeout){this.$timeout=timeout},this.setValue=function(value){this.doc.setValue(value),this.deferredUpdate.schedule(this.$timeout)},this.getValue=function(callbackId){this.sender.callback(this.doc.getValue(),callbackId)},this.onUpdate=function(){},this.isPending=function(){return this.deferredUpdate.isPending()}}).call(Mirror.prototype)}),ace.define("ace/mode/json/json_parse",["require","exports","module"],function(){"use strict";var at,ch,text,value,escapee={\'"\':\'"\',"\\\\":"\\\\","/":"/",b:"\\b",f:"\\f",n:"\\n",r:"\\r",t:"	"},error=function(m){throw{name:"SyntaxError",message:m,at:at,text:text}},next=function(c){return c&&c!==ch&&error("Expected \'"+c+"\' instead of \'"+ch+"\'"),ch=text.charAt(at),at+=1,ch},number=function(){var number,string="";for("-"===ch&&(string="-",next("-"));ch>="0"&&"9">=ch;)string+=ch,next();if("."===ch)for(string+=".";next()&&ch>="0"&&"9">=ch;)string+=ch;if("e"===ch||"E"===ch)for(string+=ch,next(),("-"===ch||"+"===ch)&&(string+=ch,next());ch>="0"&&"9">=ch;)string+=ch,next();return number=+string,isNaN(number)?(error("Bad number"),void 0):number},string=function(){var hex,i,uffff,string="";if(\'"\'===ch)for(;next();){if(\'"\'===ch)return next(),string;if("\\\\"===ch)if(next(),"u"===ch){for(uffff=0,i=0;4>i&&(hex=parseInt(next(),16),isFinite(hex));i+=1)uffff=16*uffff+hex;string+=String.fromCharCode(uffff)}else{if("string"!=typeof escapee[ch])break;string+=escapee[ch]}else string+=ch}error("Bad string")},white=function(){for(;ch&&" ">=ch;)next()},word=function(){switch(ch){case"t":return next("t"),next("r"),next("u"),next("e"),!0;case"f":return next("f"),next("a"),next("l"),next("s"),next("e"),!1;case"n":return next("n"),next("u"),next("l"),next("l"),null}error("Unexpected \'"+ch+"\'")},array=function(){var array=[];if("["===ch){if(next("["),white(),"]"===ch)return next("]"),array;for(;ch;){if(array.push(value()),white(),"]"===ch)return next("]"),array;next(","),white()}}error("Bad array")},object=function(){var key,object={};if("{"===ch){if(next("{"),white(),"}"===ch)return next("}"),object;for(;ch;){if(key=string(),white(),next(":"),Object.hasOwnProperty.call(object,key)&&error(\'Duplicate key "\'+key+\'"\'),object[key]=value(),white(),"}"===ch)return next("}"),object;next(","),white()}}error("Bad object")};return value=function(){switch(white(),ch){case"{":return object();case"[":return array();case\'"\':return string();case"-":return number();default:return ch>="0"&&"9">=ch?number():word()}},function(source,reviver){var result;return text=source,at=0,ch=" ",result=value(),white(),ch&&error("Syntax error"),"function"==typeof reviver?function walk(holder,key){var k,v,value=holder[key];if(value&&"object"==typeof value)for(k in value)Object.hasOwnProperty.call(value,k)&&(v=walk(value,k),void 0!==v?value[k]=v:delete value[k]);return reviver.call(holder,key,value)}({"":result},""):result}}),ace.define("ace/mode/json_worker",["require","exports","module","ace/lib/oop","ace/worker/mirror","ace/mode/json/json_parse"],function(acequire,exports){"use strict";var oop=acequire("../lib/oop"),Mirror=acequire("../worker/mirror").Mirror,parse=acequire("./json/json_parse"),JsonWorker=exports.JsonWorker=function(sender){Mirror.call(this,sender),this.setTimeout(200)};oop.inherits(JsonWorker,Mirror),function(){this.onUpdate=function(){var value=this.doc.getValue(),errors=[];try{value&&parse(value)}catch(e){var pos=this.doc.indexToPosition(e.at-1);errors.push({row:pos.row,column:pos.column,text:e.message,type:"error"})}this.sender.emit("annotate",errors)}}.call(JsonWorker.prototype)}),ace.define("ace/lib/es5-shim",["require","exports","module"],function(){function Empty(){}function doesDefinePropertyWork(object){try{return Object.defineProperty(object,"sentinel",{}),"sentinel"in object}catch(exception){}}function toInteger(n){return n=+n,n!==n?n=0:0!==n&&n!==1/0&&n!==-(1/0)&&(n=(n>0||-1)*Math.floor(Math.abs(n))),n}Function.prototype.bind||(Function.prototype.bind=function(that){var target=this;if("function"!=typeof target)throw new TypeError("Function.prototype.bind called on incompatible "+target);var args=slice.call(arguments,1),bound=function(){if(this instanceof bound){var result=target.apply(this,args.concat(slice.call(arguments)));return Object(result)===result?result:this}return target.apply(that,args.concat(slice.call(arguments)))};return target.prototype&&(Empty.prototype=target.prototype,bound.prototype=new Empty,Empty.prototype=null),bound});var defineGetter,defineSetter,lookupGetter,lookupSetter,supportsAccessors,call=Function.prototype.call,prototypeOfArray=Array.prototype,prototypeOfObject=Object.prototype,slice=prototypeOfArray.slice,_toString=call.bind(prototypeOfObject.toString),owns=call.bind(prototypeOfObject.hasOwnProperty);if((supportsAccessors=owns(prototypeOfObject,"__defineGetter__"))&&(defineGetter=call.bind(prototypeOfObject.__defineGetter__),defineSetter=call.bind(prototypeOfObject.__defineSetter__),lookupGetter=call.bind(prototypeOfObject.__lookupGetter__),lookupSetter=call.bind(prototypeOfObject.__lookupSetter__)),2!=[1,2].splice(0).length)if(function(){function makeArray(l){var a=Array(l+2);return a[0]=a[1]=0,a}var lengthBefore,array=[];return array.splice.apply(array,makeArray(20)),array.splice.apply(array,makeArray(26)),lengthBefore=array.length,array.splice(5,0,"XXX"),lengthBefore+1==array.length,lengthBefore+1==array.length?!0:void 0\n}()){var array_splice=Array.prototype.splice;Array.prototype.splice=function(start,deleteCount){return arguments.length?array_splice.apply(this,[void 0===start?0:start,void 0===deleteCount?this.length-start:deleteCount].concat(slice.call(arguments,2))):[]}}else Array.prototype.splice=function(pos,removeCount){var length=this.length;pos>0?pos>length&&(pos=length):void 0==pos?pos=0:0>pos&&(pos=Math.max(length+pos,0)),length>pos+removeCount||(removeCount=length-pos);var removed=this.slice(pos,pos+removeCount),insert=slice.call(arguments,2),add=insert.length;if(pos===length)add&&this.push.apply(this,insert);else{var remove=Math.min(removeCount,length-pos),tailOldPos=pos+remove,tailNewPos=tailOldPos+add-remove,tailCount=length-tailOldPos,lengthAfterRemove=length-remove;if(tailOldPos>tailNewPos)for(var i=0;tailCount>i;++i)this[tailNewPos+i]=this[tailOldPos+i];else if(tailNewPos>tailOldPos)for(i=tailCount;i--;)this[tailNewPos+i]=this[tailOldPos+i];if(add&&pos===lengthAfterRemove)this.length=lengthAfterRemove,this.push.apply(this,insert);else for(this.length=lengthAfterRemove+add,i=0;add>i;++i)this[pos+i]=insert[i]}return removed};Array.isArray||(Array.isArray=function(obj){return"[object Array]"==_toString(obj)});var boxedString=Object("a"),splitString="a"!=boxedString[0]||!(0 in boxedString);if(Array.prototype.forEach||(Array.prototype.forEach=function(fun){var object=toObject(this),self=splitString&&"[object String]"==_toString(this)?this.split(""):object,thisp=arguments[1],i=-1,length=self.length>>>0;if("[object Function]"!=_toString(fun))throw new TypeError;for(;length>++i;)i in self&&fun.call(thisp,self[i],i,object)}),Array.prototype.map||(Array.prototype.map=function(fun){var object=toObject(this),self=splitString&&"[object String]"==_toString(this)?this.split(""):object,length=self.length>>>0,result=Array(length),thisp=arguments[1];if("[object Function]"!=_toString(fun))throw new TypeError(fun+" is not a function");for(var i=0;length>i;i++)i in self&&(result[i]=fun.call(thisp,self[i],i,object));return result}),Array.prototype.filter||(Array.prototype.filter=function(fun){var value,object=toObject(this),self=splitString&&"[object String]"==_toString(this)?this.split(""):object,length=self.length>>>0,result=[],thisp=arguments[1];if("[object Function]"!=_toString(fun))throw new TypeError(fun+" is not a function");for(var i=0;length>i;i++)i in self&&(value=self[i],fun.call(thisp,value,i,object)&&result.push(value));return result}),Array.prototype.every||(Array.prototype.every=function(fun){var object=toObject(this),self=splitString&&"[object String]"==_toString(this)?this.split(""):object,length=self.length>>>0,thisp=arguments[1];if("[object Function]"!=_toString(fun))throw new TypeError(fun+" is not a function");for(var i=0;length>i;i++)if(i in self&&!fun.call(thisp,self[i],i,object))return!1;return!0}),Array.prototype.some||(Array.prototype.some=function(fun){var object=toObject(this),self=splitString&&"[object String]"==_toString(this)?this.split(""):object,length=self.length>>>0,thisp=arguments[1];if("[object Function]"!=_toString(fun))throw new TypeError(fun+" is not a function");for(var i=0;length>i;i++)if(i in self&&fun.call(thisp,self[i],i,object))return!0;return!1}),Array.prototype.reduce||(Array.prototype.reduce=function(fun){var object=toObject(this),self=splitString&&"[object String]"==_toString(this)?this.split(""):object,length=self.length>>>0;if("[object Function]"!=_toString(fun))throw new TypeError(fun+" is not a function");if(!length&&1==arguments.length)throw new TypeError("reduce of empty array with no initial value");var result,i=0;if(arguments.length>=2)result=arguments[1];else for(;;){if(i in self){result=self[i++];break}if(++i>=length)throw new TypeError("reduce of empty array with no initial value")}for(;length>i;i++)i in self&&(result=fun.call(void 0,result,self[i],i,object));return result}),Array.prototype.reduceRight||(Array.prototype.reduceRight=function(fun){var object=toObject(this),self=splitString&&"[object String]"==_toString(this)?this.split(""):object,length=self.length>>>0;if("[object Function]"!=_toString(fun))throw new TypeError(fun+" is not a function");if(!length&&1==arguments.length)throw new TypeError("reduceRight of empty array with no initial value");var result,i=length-1;if(arguments.length>=2)result=arguments[1];else for(;;){if(i in self){result=self[i--];break}if(0>--i)throw new TypeError("reduceRight of empty array with no initial value")}do i in this&&(result=fun.call(void 0,result,self[i],i,object));while(i--);return result}),Array.prototype.indexOf&&-1==[0,1].indexOf(1,2)||(Array.prototype.indexOf=function(sought){var self=splitString&&"[object String]"==_toString(this)?this.split(""):toObject(this),length=self.length>>>0;if(!length)return-1;var i=0;for(arguments.length>1&&(i=toInteger(arguments[1])),i=i>=0?i:Math.max(0,length+i);length>i;i++)if(i in self&&self[i]===sought)return i;return-1}),Array.prototype.lastIndexOf&&-1==[0,1].lastIndexOf(0,-3)||(Array.prototype.lastIndexOf=function(sought){var self=splitString&&"[object String]"==_toString(this)?this.split(""):toObject(this),length=self.length>>>0;if(!length)return-1;var i=length-1;for(arguments.length>1&&(i=Math.min(i,toInteger(arguments[1]))),i=i>=0?i:length-Math.abs(i);i>=0;i--)if(i in self&&sought===self[i])return i;return-1}),Object.getPrototypeOf||(Object.getPrototypeOf=function(object){return object.__proto__||(object.constructor?object.constructor.prototype:prototypeOfObject)}),!Object.getOwnPropertyDescriptor){var ERR_NON_OBJECT="Object.getOwnPropertyDescriptor called on a non-object: ";Object.getOwnPropertyDescriptor=function(object,property){if("object"!=typeof object&&"function"!=typeof object||null===object)throw new TypeError(ERR_NON_OBJECT+object);if(owns(object,property)){var descriptor,getter,setter;if(descriptor={enumerable:!0,configurable:!0},supportsAccessors){var prototype=object.__proto__;object.__proto__=prototypeOfObject;var getter=lookupGetter(object,property),setter=lookupSetter(object,property);if(object.__proto__=prototype,getter||setter)return getter&&(descriptor.get=getter),setter&&(descriptor.set=setter),descriptor}return descriptor.value=object[property],descriptor}}}if(Object.getOwnPropertyNames||(Object.getOwnPropertyNames=function(object){return Object.keys(object)}),!Object.create){var createEmpty;createEmpty=null===Object.prototype.__proto__?function(){return{__proto__:null}}:function(){var empty={};for(var i in empty)empty[i]=null;return empty.constructor=empty.hasOwnProperty=empty.propertyIsEnumerable=empty.isPrototypeOf=empty.toLocaleString=empty.toString=empty.valueOf=empty.__proto__=null,empty},Object.create=function(prototype,properties){var object;if(null===prototype)object=createEmpty();else{if("object"!=typeof prototype)throw new TypeError("typeof prototype["+typeof prototype+"] != \'object\'");var Type=function(){};Type.prototype=prototype,object=new Type,object.__proto__=prototype}return void 0!==properties&&Object.defineProperties(object,properties),object}}if(Object.defineProperty){var definePropertyWorksOnObject=doesDefinePropertyWork({}),definePropertyWorksOnDom="undefined"==typeof document||doesDefinePropertyWork(document.createElement("div"));if(!definePropertyWorksOnObject||!definePropertyWorksOnDom)var definePropertyFallback=Object.defineProperty}if(!Object.defineProperty||definePropertyFallback){var ERR_NON_OBJECT_DESCRIPTOR="Property description must be an object: ",ERR_NON_OBJECT_TARGET="Object.defineProperty called on non-object: ",ERR_ACCESSORS_NOT_SUPPORTED="getters & setters can not be defined on this javascript engine";Object.defineProperty=function(object,property,descriptor){if("object"!=typeof object&&"function"!=typeof object||null===object)throw new TypeError(ERR_NON_OBJECT_TARGET+object);if("object"!=typeof descriptor&&"function"!=typeof descriptor||null===descriptor)throw new TypeError(ERR_NON_OBJECT_DESCRIPTOR+descriptor);if(definePropertyFallback)try{return definePropertyFallback.call(Object,object,property,descriptor)}catch(exception){}if(owns(descriptor,"value"))if(supportsAccessors&&(lookupGetter(object,property)||lookupSetter(object,property))){var prototype=object.__proto__;object.__proto__=prototypeOfObject,delete object[property],object[property]=descriptor.value,object.__proto__=prototype}else object[property]=descriptor.value;else{if(!supportsAccessors)throw new TypeError(ERR_ACCESSORS_NOT_SUPPORTED);owns(descriptor,"get")&&defineGetter(object,property,descriptor.get),owns(descriptor,"set")&&defineSetter(object,property,descriptor.set)}return object}}Object.defineProperties||(Object.defineProperties=function(object,properties){for(var property in properties)owns(properties,property)&&Object.defineProperty(object,property,properties[property]);return object}),Object.seal||(Object.seal=function(object){return object}),Object.freeze||(Object.freeze=function(object){return object});try{Object.freeze(function(){})}catch(exception){Object.freeze=function(freezeObject){return function(object){return"function"==typeof object?object:freezeObject(object)}}(Object.freeze)}if(Object.preventExtensions||(Object.preventExtensions=function(object){return object}),Object.isSealed||(Object.isSealed=function(){return!1}),Object.isFrozen||(Object.isFrozen=function(){return!1}),Object.isExtensible||(Object.isExtensible=function(object){if(Object(object)===object)throw new TypeError;for(var name="";owns(object,name);)name+="?";object[name]=!0;var returnValue=owns(object,name);return delete object[name],returnValue}),!Object.keys){var hasDontEnumBug=!0,dontEnums=["toString","toLocaleString","valueOf","hasOwnProperty","isPrototypeOf","propertyIsEnumerable","constructor"],dontEnumsLength=dontEnums.length;for(var key in{toString:null})hasDontEnumBug=!1;Object.keys=function(object){if("object"!=typeof object&&"function"!=typeof object||null===object)throw new TypeError("Object.keys called on a non-object");var keys=[];for(var name in object)owns(object,name)&&keys.push(name);if(hasDontEnumBug)for(var i=0,ii=dontEnumsLength;ii>i;i++){var dontEnum=dontEnums[i];owns(object,dontEnum)&&keys.push(dontEnum)}return keys}}Date.now||(Date.now=function(){return(new Date).getTime()});var ws="	\\n\\f\\r   ᠎             　\\u2028\\u2029﻿";if(!String.prototype.trim||ws.trim()){ws="["+ws+"]";var trimBeginRegexp=RegExp("^"+ws+ws+"*"),trimEndRegexp=RegExp(ws+ws+"*$");String.prototype.trim=function(){return(this+"").replace(trimBeginRegexp,"").replace(trimEndRegexp,"")}}var toObject=function(o){if(null==o)throw new TypeError("can\'t convert "+o+" to object");return Object(o)}});';
    }, function(e, t) {
        ace.define("ace/ext/searchbox", [ "require", "exports", "module", "ace/lib/dom", "ace/lib/lang", "ace/lib/event", "ace/keyboard/hash_handler", "ace/lib/keys" ], function(e, t, n) {
            "use strict";
            var i = e("../lib/dom"), o = e("../lib/lang"), r = e("../lib/event"), s = e("../keyboard/hash_handler").HashHandler, a = e("../lib/keys");
            i.importCssString('	.ace_search {	background-color: #ddd;	color: #666;	border: 1px solid #cbcbcb;	border-top: 0 none;	overflow: hidden;	margin: 0;	padding: 4px 6px 0 4px;	position: absolute;	top: 0;	z-index: 99;	white-space: normal;	}	.ace_search.left {	border-left: 0 none;	border-radius: 0px 0px 5px 0px;	left: 0;	}	.ace_search.right {	border-radius: 0px 0px 0px 5px;	border-right: 0 none;	right: 0;	}	.ace_search_form, .ace_replace_form {	margin: 0 20px 4px 0;	overflow: hidden;	line-height: 1.9;	}	.ace_replace_form {	margin-right: 0;	}	.ace_search_form.ace_nomatch {	outline: 1px solid red;	}	.ace_search_field {	border-radius: 3px 0 0 3px;	background-color: white;	color: black;	border: 1px solid #cbcbcb;	border-right: 0 none;	box-sizing: border-box!important;	outline: 0;	padding: 0;	font-size: inherit;	margin: 0;	line-height: inherit;	padding: 0 6px;	min-width: 17em;	vertical-align: top;	}	.ace_searchbtn {	border: 1px solid #cbcbcb;	line-height: inherit;	display: inline-block;	padding: 0 6px;	background: #fff;	border-right: 0 none;	border-left: 1px solid #dcdcdc;	cursor: pointer;	margin: 0;	position: relative;	box-sizing: content-box!important;	color: #666;	}	.ace_searchbtn:last-child {	border-radius: 0 3px 3px 0;	border-right: 1px solid #cbcbcb;	}	.ace_searchbtn:disabled {	background: none;	cursor: default;	}	.ace_searchbtn:hover {	background-color: #eef1f6;	}	.ace_searchbtn.prev, .ace_searchbtn.next {	padding: 0px 0.7em	}	.ace_searchbtn.prev:after, .ace_searchbtn.next:after {	content: "";	border: solid 2px #888;	width: 0.5em;	height: 0.5em;	border-width:  2px 0 0 2px;	display:inline-block;	transform: rotate(-45deg);	}	.ace_searchbtn.next:after {	border-width: 0 2px 2px 0 ;	}	.ace_searchbtn_close {	background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA4AAAAcCAYAAABRVo5BAAAAZ0lEQVR42u2SUQrAMAhDvazn8OjZBilCkYVVxiis8H4CT0VrAJb4WHT3C5xU2a2IQZXJjiQIRMdkEoJ5Q2yMqpfDIo+XY4k6h+YXOyKqTIj5REaxloNAd0xiKmAtsTHqW8sR2W5f7gCu5nWFUpVjZwAAAABJRU5ErkJggg==) no-repeat 50% 0;	border-radius: 50%;	border: 0 none;	color: #656565;	cursor: pointer;	font: 16px/16px Arial;	padding: 0;	height: 14px;	width: 14px;	top: 9px;	right: 7px;	position: absolute;	}	.ace_searchbtn_close:hover {	background-color: #656565;	background-position: 50% 100%;	color: white;	}	.ace_button {	margin-left: 2px;	cursor: pointer;	-webkit-user-select: none;	-moz-user-select: none;	-o-user-select: none;	-ms-user-select: none;	user-select: none;	overflow: hidden;	opacity: 0.7;	border: 1px solid rgba(100,100,100,0.23);	padding: 1px;	box-sizing:    border-box!important;	color: black;	}	.ace_button:hover {	background-color: #eee;	opacity:1;	}	.ace_button:active {	background-color: #ddd;	}	.ace_button.checked {	border-color: #3399ff;	opacity:1;	}	.ace_search_options{	margin-bottom: 3px;	text-align: right;	-webkit-user-select: none;	-moz-user-select: none;	-o-user-select: none;	-ms-user-select: none;	user-select: none;	clear: both;	}	.ace_search_counter {	float: left;	font-family: arial;	padding: 0 8px;	}', "ace_searchbox");
            var l = '<div class="ace_search right">	    <span action="hide" class="ace_searchbtn_close"></span>	    <div class="ace_search_form">	        <input class="ace_search_field" placeholder="Search for" spellcheck="false"></input>	        <span action="findPrev" class="ace_searchbtn prev"></span>	        <span action="findNext" class="ace_searchbtn next"></span>	        <span action="findAll" class="ace_searchbtn" title="Alt-Enter">All</span>	    </div>	    <div class="ace_replace_form">	        <input class="ace_search_field" placeholder="Replace with" spellcheck="false"></input>	        <span action="replaceAndFindNext" class="ace_searchbtn">Replace</span>	        <span action="replaceAll" class="ace_searchbtn">All</span>	    </div>	    <div class="ace_search_options">	        <span action="toggleReplace" class="ace_button" title="Toggel Replace mode"	            style="float:left;margin-top:-2px;padding:0 5px;">+</span>	        <span class="ace_search_counter"></span>	        <span action="toggleRegexpMode" class="ace_button" title="RegExp Search">.*</span>	        <span action="toggleCaseSensitive" class="ace_button" title="CaseSensitive Search">Aa</span>	        <span action="toggleWholeWords" class="ace_button" title="Whole Word Search">\\b</span>	        <span action="searchInSelection" class="ace_button" title="Search In Selection">S</span>	    </div>	</div>'.replace(/> +/g, ">"), c = function(e, t, n) {
                var o = i.createElement("div");
                o.innerHTML = l, this.element = o.firstChild, this.setSession = this.setSession.bind(this),
                    this.$init(), this.setEditor(e);
            };
            (function() {
                this.setEditor = function(e) {
                    e.searchBox = this, e.renderer.scroller.appendChild(this.element), this.editor = e;
                }, this.setSession = function(e) {
                    this.searchRange = null, this.$syncOptions(!0);
                }, this.$initElements = function(e) {
                    this.searchBox = e.querySelector(".ace_search_form"), this.replaceBox = e.querySelector(".ace_replace_form"),
                        this.searchOption = e.querySelector("[action=searchInSelection]"), this.replaceOption = e.querySelector("[action=toggleReplace]"),
                        this.regExpOption = e.querySelector("[action=toggleRegexpMode]"), this.caseSensitiveOption = e.querySelector("[action=toggleCaseSensitive]"),
                        this.wholeWordOption = e.querySelector("[action=toggleWholeWords]"), this.searchInput = this.searchBox.querySelector(".ace_search_field"),
                        this.replaceInput = this.replaceBox.querySelector(".ace_search_field"), this.searchCounter = e.querySelector(".ace_search_counter");
                }, this.$init = function() {
                    var e = this.element;
                    this.$initElements(e);
                    var t = this;
                    r.addListener(e, "mousedown", function(e) {
                        setTimeout(function() {
                            t.activeInput.focus();
                        }, 0), r.stopPropagation(e);
                    }), r.addListener(e, "click", function(e) {
                        var n = e.target || e.srcElement, i = n.getAttribute("action");
                        i && t[i] ? t[i]() :t.$searchBarKb.commands[i] && t.$searchBarKb.commands[i].exec(t),
                            r.stopPropagation(e);
                    }), r.addCommandKeyListener(e, function(e, n, i) {
                        var o = a.keyCodeToString(i), s = t.$searchBarKb.findKeyCommand(n, o);
                        s && s.exec && (s.exec(t), r.stopEvent(e));
                    }), this.$onChange = o.delayedCall(function() {
                        t.find(!1, !1);
                    }), r.addListener(this.searchInput, "input", function() {
                        t.$onChange.schedule(20);
                    }), r.addListener(this.searchInput, "focus", function() {
                        t.activeInput = t.searchInput, t.searchInput.value && t.highlight();
                    }), r.addListener(this.replaceInput, "focus", function() {
                        t.activeInput = t.replaceInput, t.searchInput.value && t.highlight();
                    });
                }, this.$closeSearchBarKb = new s([ {
                    bindKey:"Esc",
                    name:"closeSearchBar",
                    exec:function(e) {
                        e.searchBox.hide();
                    }
                } ]), this.$searchBarKb = new s(), this.$searchBarKb.bindKeys({
                    "Ctrl-f|Command-f":function(e) {
                        var t = e.isReplace = !e.isReplace;
                        e.replaceBox.style.display = t ? "" :"none", e.replaceOption.checked = !1, e.$syncOptions(),
                            e.searchInput.focus();
                    },
                    "Ctrl-H|Command-Option-F":function(e) {
                        e.replaceOption.checked = !0, e.$syncOptions(), e.replaceInput.focus();
                    },
                    "Ctrl-G|Command-G":function(e) {
                        e.findNext();
                    },
                    "Ctrl-Shift-G|Command-Shift-G":function(e) {
                        e.findPrev();
                    },
                    esc:function(e) {
                        setTimeout(function() {
                            e.hide();
                        });
                    },
                    Return:function(e) {
                        e.activeInput == e.replaceInput && e.replace(), e.findNext();
                    },
                    "Shift-Return":function(e) {
                        e.activeInput == e.replaceInput && e.replace(), e.findPrev();
                    },
                    "Alt-Return":function(e) {
                        e.activeInput == e.replaceInput && e.replaceAll(), e.findAll();
                    },
                    Tab:function(e) {
                        (e.activeInput == e.replaceInput ? e.searchInput :e.replaceInput).focus();
                    }
                }), this.$searchBarKb.addCommands([ {
                    name:"toggleRegexpMode",
                    bindKey:{
                        win:"Alt-R|Alt-/",
                        mac:"Ctrl-Alt-R|Ctrl-Alt-/"
                    },
                    exec:function(e) {
                        e.regExpOption.checked = !e.regExpOption.checked, e.$syncOptions();
                    }
                }, {
                    name:"toggleCaseSensitive",
                    bindKey:{
                        win:"Alt-C|Alt-I",
                        mac:"Ctrl-Alt-R|Ctrl-Alt-I"
                    },
                    exec:function(e) {
                        e.caseSensitiveOption.checked = !e.caseSensitiveOption.checked, e.$syncOptions();
                    }
                }, {
                    name:"toggleWholeWords",
                    bindKey:{
                        win:"Alt-B|Alt-W",
                        mac:"Ctrl-Alt-B|Ctrl-Alt-W"
                    },
                    exec:function(e) {
                        e.wholeWordOption.checked = !e.wholeWordOption.checked, e.$syncOptions();
                    }
                }, {
                    name:"toggleReplace",
                    exec:function(e) {
                        e.replaceOption.checked = !e.replaceOption.checked, e.$syncOptions();
                    }
                }, {
                    name:"searchInSelection",
                    exec:function(e) {
                        e.searchOption.checked = !e.searchRange, e.setSearchRange(e.searchOption.checked && e.editor.getSelectionRange()),
                            e.$syncOptions();
                    }
                } ]), this.setSearchRange = function(e) {
                    this.searchRange = e, e ? this.searchRangeMarker = this.editor.session.addMarker(e, "ace_active-line") :this.searchRangeMarker && (this.editor.session.removeMarker(this.searchRangeMarker),
                        this.searchRangeMarker = null);
                }, this.$syncOptions = function(e) {
                    i.setCssClass(this.replaceOption, "checked", this.searchRange), i.setCssClass(this.searchOption, "checked", this.searchOption.checked),
                        this.replaceOption.textContent = this.replaceOption.checked ? "-" :"+", i.setCssClass(this.regExpOption, "checked", this.regExpOption.checked),
                        i.setCssClass(this.wholeWordOption, "checked", this.wholeWordOption.checked), i.setCssClass(this.caseSensitiveOption, "checked", this.caseSensitiveOption.checked),
                        this.replaceBox.style.display = this.replaceOption.checked ? "" :"none", this.find(!1, !1, e);
                }, this.highlight = function(e) {
                    this.editor.session.highlight(e || this.editor.$search.$options.re), this.editor.renderer.updateBackMarkers();
                }, this.find = function(e, t, n) {
                    var o = this.editor.find(this.searchInput.value, {
                        skipCurrent:e,
                        backwards:t,
                        wrap:!0,
                        regExp:this.regExpOption.checked,
                        caseSensitive:this.caseSensitiveOption.checked,
                        wholeWord:this.wholeWordOption.checked,
                        preventScroll:n,
                        range:this.searchRange
                    }), r = !o && this.searchInput.value;
                    i.setCssClass(this.searchBox, "ace_nomatch", r), this.editor._emit("findSearchBox", {
                        match:!r
                    }), this.highlight(), this.updateCounter();
                }, this.updateCounter = function() {
                    var e = this.editor, t = e.$search.$options.re, n = 0, i = 0;
                    if (t) {
                        var o = this.searchRange ? e.session.getTextRange(this.searchRange) :e.getValue(), r = e.session.doc.positionToIndex(e.selection.anchor);
                        this.searchRange && (r -= e.session.doc.positionToIndex(this.searchRange.start));
                        for (var s, a = t.lastIndex = 0; (s = t.exec(o)) && (n++, a = s.index, a <= r && i++,
                            !(n > 999)) && (s[0] || (t.lastIndex = a += 1, !(a >= o.length))); ) ;
                    }
                    this.searchCounter.textContent = i + " of " + (n > 999 ? "999+" :n);
                }, this.findNext = function() {
                    this.find(!0, !1);
                }, this.findPrev = function() {
                    this.find(!0, !0);
                }, this.findAll = function() {
                    var e = this.editor.findAll(this.searchInput.value, {
                        regExp:this.regExpOption.checked,
                        caseSensitive:this.caseSensitiveOption.checked,
                        wholeWord:this.wholeWordOption.checked
                    }), t = !e && this.searchInput.value;
                    i.setCssClass(this.searchBox, "ace_nomatch", t), this.editor._emit("findSearchBox", {
                        match:!t
                    }), this.highlight(), this.hide();
                }, this.replace = function() {
                    this.editor.getReadOnly() || this.editor.replace(this.replaceInput.value);
                }, this.replaceAndFindNext = function() {
                    this.editor.getReadOnly() || (this.editor.replace(this.replaceInput.value), this.findNext());
                }, this.replaceAll = function() {
                    this.editor.getReadOnly() || this.editor.replaceAll(this.replaceInput.value);
                }, this.hide = function() {
                    this.active = !1, this.setSearchRange(null), this.editor.off("changeSession", this.setSession),
                        this.element.style.display = "none", this.editor.keyBinding.removeKeyboardHandler(this.$closeSearchBarKb),
                        this.editor.focus();
                }, this.show = function(e, t) {
                    this.active = !0, this.editor.on("changeSession", this.setSession), this.element.style.display = "",
                        this.replaceOption.checked = t, e && (this.searchInput.value = e), this.searchInput.focus(),
                        this.searchInput.select(), this.editor.keyBinding.addKeyboardHandler(this.$closeSearchBarKb),
                        this.$syncOptions(!0);
                }, this.isFocused = function() {
                    var e = document.activeElement;
                    return e == this.searchInput || e == this.replaceInput;
                };
            }).call(c.prototype), t.SearchBox = c, t.Search = function(e, t) {
                (e.searchBox || new c(e)).show(e.session.getTextRange(), t);
            };
        }), function() {
            ace.acequire([ "ace/ext/searchbox" ], function() {});
        }();
    }, function(e, t) {
        ace.define("ace/theme/jsoneditor", [ "require", "exports", "module", "ace/lib/dom" ], function(e, t, n) {
            t.isDark = !1, t.cssClass = "ace-jsoneditor", t.cssText = '.ace-jsoneditor .ace_gutter {	background: #ebebeb;	color: #333	}		.ace-jsoneditor.ace_editor {	font-family: "dejavu sans mono", "droid sans mono", consolas, monaco, "lucida console", "courier new", courier, monospace, sans-serif;	line-height: 1.3;	background-color: #fff;	}	.ace-jsoneditor .ace_print-margin {	width: 1px;	background: #e8e8e8	}	.ace-jsoneditor .ace_scroller {	background-color: #FFFFFF	}	.ace-jsoneditor .ace_text-layer {	color: gray	}	.ace-jsoneditor .ace_variable {	color: #1a1a1a	}	.ace-jsoneditor .ace_cursor {	border-left: 2px solid #000000	}	.ace-jsoneditor .ace_overwrite-cursors .ace_cursor {	border-left: 0px;	border-bottom: 1px solid #000000	}	.ace-jsoneditor .ace_marker-layer .ace_selection {	background: lightgray	}	.ace-jsoneditor.ace_multiselect .ace_selection.ace_start {	box-shadow: 0 0 3px 0px #FFFFFF;	border-radius: 2px	}	.ace-jsoneditor .ace_marker-layer .ace_step {	background: rgb(255, 255, 0)	}	.ace-jsoneditor .ace_marker-layer .ace_bracket {	margin: -1px 0 0 -1px;	border: 1px solid #BFBFBF	}	.ace-jsoneditor .ace_marker-layer .ace_active-line {	background: #FFFBD1	}	.ace-jsoneditor .ace_gutter-active-line {	background-color : #dcdcdc	}	.ace-jsoneditor .ace_marker-layer .ace_selected-word {	border: 1px solid lightgray	}	.ace-jsoneditor .ace_invisible {	color: #BFBFBF	}	.ace-jsoneditor .ace_keyword,	.ace-jsoneditor .ace_meta,	.ace-jsoneditor .ace_support.ace_constant.ace_property-value {	color: #AF956F	}	.ace-jsoneditor .ace_keyword.ace_operator {	color: #484848	}	.ace-jsoneditor .ace_keyword.ace_other.ace_unit {	color: #96DC5F	}	.ace-jsoneditor .ace_constant.ace_language {	color: darkorange	}	.ace-jsoneditor .ace_constant.ace_numeric {	color: red	}	.ace-jsoneditor .ace_constant.ace_character.ace_entity {	color: #BF78CC	}	.ace-jsoneditor .ace_invalid {	color: #FFFFFF;	background-color: #FF002A;	}	.ace-jsoneditor .ace_fold {	background-color: #AF956F;	border-color: #000000	}	.ace-jsoneditor .ace_storage,	.ace-jsoneditor .ace_support.ace_class,	.ace-jsoneditor .ace_support.ace_function,	.ace-jsoneditor .ace_support.ace_other,	.ace-jsoneditor .ace_support.ace_type {	color: #C52727	}	.ace-jsoneditor .ace_string {	color: green	}	.ace-jsoneditor .ace_comment {	color: #BCC8BA	}	.ace-jsoneditor .ace_entity.ace_name.ace_tag,	.ace-jsoneditor .ace_entity.ace_other.ace_attribute-name {	color: #606060	}	.ace-jsoneditor .ace_markup.ace_underline {	text-decoration: underline	}	.ace-jsoneditor .ace_indent-guide {	background: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACCAYAAACZgbYnAAAAE0lEQVQImWP4////f4bLly//BwAmVgd1/w11/gAAAABJRU5ErkJggg==") right repeat-y	}',
                e("../lib/dom").importCssString(t.cssText, t.cssClass);
        });
    } ]);
});
/**!
 * Sortable
 * @author	RubaXa   <trash@rubaxa.org>
 * @license MIT
 */

(function sortableModule(factory) {
    "use strict";

    if (typeof define === "function" && define.amd) {
        define(factory);
    }
    else if (typeof module != "undefined" && typeof module.exports != "undefined") {
        module.exports = factory();
    }
    else {
        /* jshint sub:true */
        window["Sortable"] = factory();
    }
})(function sortableFactory() {
    "use strict";

    if (typeof window == "undefined" || !window.document) {
        return function sortableError() {
            throw new Error("Sortable.js requires a window with a document");
        };
    }

    var dragEl,
        parentEl,
        ghostEl,
        cloneEl,
        rootEl,
        nextEl,
        lastDownEl,

        scrollEl,
        scrollParentEl,
        scrollCustomFn,

        lastEl,
        lastCSS,
        lastParentCSS,

        oldIndex,
        newIndex,

        activeGroup,
        putSortable,

        autoScroll = {},

        tapEvt,
        touchEvt,

        moved,

        /** @const */
        R_SPACE = /\s+/g,
        R_FLOAT = /left|right|inline/,

        expando = 'Sortable' + (new Date).getTime(),

        win = window,
        document = win.document,
        parseInt = win.parseInt,

        $ = win.jQuery || win.Zepto,
        Polymer = win.Polymer,

        captureMode = false,

        supportDraggable = !!('draggable' in document.createElement('div')),
        supportCssPointerEvents = (function (el) {
            // false when IE11
            if (!!navigator.userAgent.match(/Trident.*rv[ :]?11\./)) {
                return false;
            }
            el = document.createElement('x');
            el.style.cssText = 'pointer-events:auto';
            return el.style.pointerEvents === 'auto';
        })(),

        _silent = false,

        abs = Math.abs,
        min = Math.min,

        savedInputChecked = [],
        touchDragOverListeners = [],

        _autoScroll = _throttle(function (/**Event*/evt, /**Object*/options, /**HTMLElement*/rootEl) {
            // Bug: https://bugzilla.mozilla.org/show_bug.cgi?id=505521
            if (rootEl && options.scroll) {
                var _this = rootEl[expando],
                    el,
                    rect,
                    sens = options.scrollSensitivity,
                    speed = options.scrollSpeed,

                    x = evt.clientX,
                    y = evt.clientY,

                    winWidth = window.innerWidth,
                    winHeight = window.innerHeight,

                    vx,
                    vy,

                    scrollOffsetX,
                    scrollOffsetY
                ;

                // Delect scrollEl
                if (scrollParentEl !== rootEl) {
                    scrollEl = options.scroll;
                    scrollParentEl = rootEl;
                    scrollCustomFn = options.scrollFn;

                    if (scrollEl === true) {
                        scrollEl = rootEl;

                        do {
                            if ((scrollEl.offsetWidth < scrollEl.scrollWidth) ||
                                (scrollEl.offsetHeight < scrollEl.scrollHeight)
                            ) {
                                break;
                            }
                            /* jshint boss:true */
                        } while (scrollEl = scrollEl.parentNode);
                    }
                }

                if (scrollEl) {
                    el = scrollEl;
                    rect = scrollEl.getBoundingClientRect();
                    vx = (abs(rect.right - x) <= sens) - (abs(rect.left - x) <= sens);
                    vy = (abs(rect.bottom - y) <= sens) - (abs(rect.top - y) <= sens);
                }


                if (!(vx || vy)) {
                    vx = (winWidth - x <= sens) - (x <= sens);
                    vy = (winHeight - y <= sens) - (y <= sens);

                    /* jshint expr:true */
                    (vx || vy) && (el = win);
                }


                if (autoScroll.vx !== vx || autoScroll.vy !== vy || autoScroll.el !== el) {
                    autoScroll.el = el;
                    autoScroll.vx = vx;
                    autoScroll.vy = vy;

                    clearInterval(autoScroll.pid);

                    if (el) {
                        autoScroll.pid = setInterval(function () {
                            scrollOffsetY = vy ? vy * speed : 0;
                            scrollOffsetX = vx ? vx * speed : 0;

                            if ('function' === typeof(scrollCustomFn)) {
                                return scrollCustomFn.call(_this, scrollOffsetX, scrollOffsetY, evt);
                            }

                            if (el === win) {
                                win.scrollTo(win.pageXOffset + scrollOffsetX, win.pageYOffset + scrollOffsetY);
                            } else {
                                el.scrollTop += scrollOffsetY;
                                el.scrollLeft += scrollOffsetX;
                            }
                        }, 24);
                    }
                }
            }
        }, 30),

        _prepareGroup = function (options) {
            function toFn(value, pull) {
                if (value === void 0 || value === true) {
                    value = group.name;
                }

                if (typeof value === 'function') {
                    return value;
                } else {
                    return function (to, from) {
                        var fromGroup = from.options.group.name;

                        return pull
                            ? value
                            : value && (value.join
                                ? value.indexOf(fromGroup) > -1
                                : (fromGroup == value)
                        );
                    };
                }
            }

            var group = {};
            var originalGroup = options.group;

            if (!originalGroup || typeof originalGroup != 'object') {
                originalGroup = {name: originalGroup};
            }

            group.name = originalGroup.name;
            group.checkPull = toFn(originalGroup.pull, true);
            group.checkPut = toFn(originalGroup.put);
            group.revertClone = originalGroup.revertClone;

            options.group = group;
        }
    ;


    /**
     * @class  Sortable
     * @param  {HTMLElement}  el
     * @param  {Object}       [options]
     */
    function Sortable(el, options) {
        if (!(el && el.nodeType && el.nodeType === 1)) {
            throw 'Sortable: `el` must be HTMLElement, and not ' + {}.toString.call(el);
        }

        this.el = el; // root element
        this.options = options = _extend({}, options);


        // Export instance
        el[expando] = this;

        // Default options
        var defaults = {
            group: Math.random(),
            sort: true,
            disabled: false,
            store: null,
            handle: null,
            scroll: true,
            scrollSensitivity: 30,
            scrollSpeed: 10,
            draggable: /[uo]l/i.test(el.nodeName) ? 'li' : '>*',
            ghostClass: 'sortable-ghost',
            chosenClass: 'sortable-chosen',
            dragClass: 'sortable-drag',
            ignore: 'a, img',
            filter: null,
            preventOnFilter: true,
            animation: 0,
            setData: function (dataTransfer, dragEl) {
                dataTransfer.setData('Text', dragEl.textContent);
            },
            dropBubble: false,
            dragoverBubble: false,
            dataIdAttr: 'data-id',
            delay: 0,
            forceFallback: false,
            fallbackClass: 'sortable-fallback',
            fallbackOnBody: false,
            fallbackTolerance: 0,
            fallbackOffset: {x: 0, y: 0}
        };


        // Set default options
        for (var name in defaults) {
            !(name in options) && (options[name] = defaults[name]);
        }

        _prepareGroup(options);

        // Bind all private methods
        for (var fn in this) {
            if (fn.charAt(0) === '_' && typeof this[fn] === 'function') {
                this[fn] = this[fn].bind(this);
            }
        }

        // Setup drag mode
        this.nativeDraggable = options.forceFallback ? false : supportDraggable;

        // Bind events
        _on(el, 'mousedown', this._onTapStart);
        _on(el, 'touchstart', this._onTapStart);
        _on(el, 'pointerdown', this._onTapStart);

        if (this.nativeDraggable) {
            _on(el, 'dragover', this);
            _on(el, 'dragenter', this);
        }

        touchDragOverListeners.push(this._onDragOver);

        // Restore sorting
        options.store && this.sort(options.store.get(this));
    }


    Sortable.prototype = /** @lends Sortable.prototype */ {
        constructor: Sortable,

        _onTapStart: function (/** Event|TouchEvent */evt) {
            var _this = this,
                el = this.el,
                options = this.options,
                preventOnFilter = options.preventOnFilter,
                type = evt.type,
                touch = evt.touches && evt.touches[0],
                target = (touch || evt).target,
                originalTarget = evt.target.shadowRoot && evt.path[0] || target,
                filter = options.filter,
                startIndex;

            _saveInputCheckedState(el);


            // Don't trigger start event when an element is been dragged, otherwise the evt.oldindex always wrong when set option.group.
            if (dragEl) {
                return;
            }

            if (type === 'mousedown' && evt.button !== 0 || options.disabled) {
                return; // only left button or enabled
            }


            target = _closest(target, options.draggable, el);

            if (!target) {
                return;
            }

            if (lastDownEl === target) {
                // Ignoring duplicate `down`
                return;
            }

            // Get the index of the dragged element within its parent
            startIndex = _index(target, options.draggable);

            // Check filter
            if (typeof filter === 'function') {
                if (filter.call(this, evt, target, this)) {
                    _dispatchEvent(_this, originalTarget, 'filter', target, el, startIndex);
                    preventOnFilter && evt.preventDefault();
                    return; // cancel dnd
                }
            }
            else if (filter) {
                filter = filter.split(',').some(function (criteria) {
                    criteria = _closest(originalTarget, criteria.trim(), el);

                    if (criteria) {
                        _dispatchEvent(_this, criteria, 'filter', target, el, startIndex);
                        return true;
                    }
                });

                if (filter) {
                    preventOnFilter && evt.preventDefault();
                    return; // cancel dnd
                }
            }

            if (options.handle && !_closest(originalTarget, options.handle, el)) {
                return;
            }

            // Prepare `dragstart`
            this._prepareDragStart(evt, touch, target, startIndex);
        },

        _prepareDragStart: function (/** Event */evt, /** Touch */touch, /** HTMLElement */target, /** Number */startIndex) {
            var _this = this,
                el = _this.el,
                options = _this.options,
                ownerDocument = el.ownerDocument,
                dragStartFn;

            if (target && !dragEl && (target.parentNode === el)) {
                tapEvt = evt;

                rootEl = el;
                dragEl = target;
                parentEl = dragEl.parentNode;
                nextEl = dragEl.nextSibling;
                lastDownEl = target;
                activeGroup = options.group;
                oldIndex = startIndex;

                this._lastX = (touch || evt).clientX;
                this._lastY = (touch || evt).clientY;

                dragEl.style['will-change'] = 'transform';

                dragStartFn = function () {
                    // Delayed drag has been triggered
                    // we can re-enable the events: touchmove/mousemove
                    _this._disableDelayedDrag();

                    // Make the element draggable
                    dragEl.draggable = _this.nativeDraggable;

                    // Chosen item
                    _toggleClass(dragEl, options.chosenClass, true);

                    // Bind the events: dragstart/dragend
                    _this._triggerDragStart(evt, touch);

                    // Drag start event
                    _dispatchEvent(_this, rootEl, 'choose', dragEl, rootEl, oldIndex);
                };

                // Disable "draggable"
                options.ignore.split(',').forEach(function (criteria) {
                    _find(dragEl, criteria.trim(), _disableDraggable);
                });

                _on(ownerDocument, 'mouseup', _this._onDrop);
                _on(ownerDocument, 'touchend', _this._onDrop);
                _on(ownerDocument, 'touchcancel', _this._onDrop);
                _on(ownerDocument, 'pointercancel', _this._onDrop);
                _on(ownerDocument, 'selectstart', _this);

                if (options.delay) {
                    // If the user moves the pointer or let go the click or touch
                    // before the delay has been reached:
                    // disable the delayed drag
                    _on(ownerDocument, 'mouseup', _this._disableDelayedDrag);
                    _on(ownerDocument, 'touchend', _this._disableDelayedDrag);
                    _on(ownerDocument, 'touchcancel', _this._disableDelayedDrag);
                    _on(ownerDocument, 'mousemove', _this._disableDelayedDrag);
                    _on(ownerDocument, 'touchmove', _this._disableDelayedDrag);
                    _on(ownerDocument, 'pointermove', _this._disableDelayedDrag);

                    _this._dragStartTimer = setTimeout(dragStartFn, options.delay);
                } else {
                    dragStartFn();
                }


            }
        },

        _disableDelayedDrag: function () {
            var ownerDocument = this.el.ownerDocument;

            clearTimeout(this._dragStartTimer);
            _off(ownerDocument, 'mouseup', this._disableDelayedDrag);
            _off(ownerDocument, 'touchend', this._disableDelayedDrag);
            _off(ownerDocument, 'touchcancel', this._disableDelayedDrag);
            _off(ownerDocument, 'mousemove', this._disableDelayedDrag);
            _off(ownerDocument, 'touchmove', this._disableDelayedDrag);
            _off(ownerDocument, 'pointermove', this._disableDelayedDrag);
        },

        _triggerDragStart: function (/** Event */evt, /** Touch */touch) {
            touch = touch || (evt.pointerType == 'touch' ? evt : null);

            if (touch) {
                // Touch device support
                tapEvt = {
                    target: dragEl,
                    clientX: touch.clientX,
                    clientY: touch.clientY
                };

                this._onDragStart(tapEvt, 'touch');
            }
            else if (!this.nativeDraggable) {
                this._onDragStart(tapEvt, true);
            }
            else {
                _on(dragEl, 'dragend', this);
                _on(rootEl, 'dragstart', this._onDragStart);
            }

            try {
                if (document.selection) {
                    // Timeout neccessary for IE9
                    setTimeout(function () {
                        document.selection.empty();
                    });
                } else {
                    window.getSelection().removeAllRanges();
                }
            } catch (err) {
            }
        },

        _dragStarted: function () {
            if (rootEl && dragEl) {
                var options = this.options;

                // Apply effect
                _toggleClass(dragEl, options.ghostClass, true);
                _toggleClass(dragEl, options.dragClass, false);

                Sortable.active = this;

                // Drag start event
                _dispatchEvent(this, rootEl, 'start', dragEl, rootEl, oldIndex);
            } else {
                this._nulling();
            }
        },

        _emulateDragOver: function () {
            if (touchEvt) {
                if (this._lastX === touchEvt.clientX && this._lastY === touchEvt.clientY) {
                    return;
                }

                this._lastX = touchEvt.clientX;
                this._lastY = touchEvt.clientY;

                if (!supportCssPointerEvents) {
                    _css(ghostEl, 'display', 'none');
                }

                var target = document.elementFromPoint(touchEvt.clientX, touchEvt.clientY),
                    parent = target,
                    i = touchDragOverListeners.length;

                if (parent) {
                    do {
                        if (parent[expando]) {
                            while (i--) {
                                touchDragOverListeners[i]({
                                    clientX: touchEvt.clientX,
                                    clientY: touchEvt.clientY,
                                    target: target,
                                    rootEl: parent
                                });
                            }

                            break;
                        }

                        target = parent; // store last element
                    }
                        /* jshint boss:true */
                    while (parent = parent.parentNode);
                }

                if (!supportCssPointerEvents) {
                    _css(ghostEl, 'display', '');
                }
            }
        },


        _onTouchMove: function (/**TouchEvent*/evt) {
            if (tapEvt) {
                var	options = this.options,
                    fallbackTolerance = options.fallbackTolerance,
                    fallbackOffset = options.fallbackOffset,
                    touch = evt.touches ? evt.touches[0] : evt,
                    dx = (touch.clientX - tapEvt.clientX) + fallbackOffset.x,
                    dy = (touch.clientY - tapEvt.clientY) + fallbackOffset.y,
                    translate3d = evt.touches ? 'translate3d(' + dx + 'px,' + dy + 'px,0)' : 'translate(' + dx + 'px,' + dy + 'px)';

                // only set the status to dragging, when we are actually dragging
                if (!Sortable.active) {
                    if (fallbackTolerance &&
                        min(abs(touch.clientX - this._lastX), abs(touch.clientY - this._lastY)) < fallbackTolerance
                    ) {
                        return;
                    }

                    this._dragStarted();
                }

                // as well as creating the ghost element on the document body
                this._appendGhost();

                moved = true;
                touchEvt = touch;

                _css(ghostEl, 'webkitTransform', translate3d);
                _css(ghostEl, 'mozTransform', translate3d);
                _css(ghostEl, 'msTransform', translate3d);
                _css(ghostEl, 'transform', translate3d);

                evt.preventDefault();
            }
        },

        _appendGhost: function () {
            if (!ghostEl) {
                var rect = dragEl.getBoundingClientRect(),
                    css = _css(dragEl),
                    options = this.options,
                    ghostRect;

                ghostEl = dragEl.cloneNode(true);

                _toggleClass(ghostEl, options.ghostClass, false);
                _toggleClass(ghostEl, options.fallbackClass, true);
                _toggleClass(ghostEl, options.dragClass, true);

                _css(ghostEl, 'top', rect.top - parseInt(css.marginTop, 10));
                _css(ghostEl, 'left', rect.left - parseInt(css.marginLeft, 10));
                _css(ghostEl, 'width', rect.width);
                _css(ghostEl, 'height', rect.height);
                _css(ghostEl, 'opacity', '0.8');
                _css(ghostEl, 'position', 'fixed');
                _css(ghostEl, 'zIndex', '100000');
                _css(ghostEl, 'pointerEvents', 'none');

                options.fallbackOnBody && document.body.appendChild(ghostEl) || rootEl.appendChild(ghostEl);

                // Fixing dimensions.
                ghostRect = ghostEl.getBoundingClientRect();
                _css(ghostEl, 'width', rect.width * 2 - ghostRect.width);
                _css(ghostEl, 'height', rect.height * 2 - ghostRect.height);
            }
        },

        _onDragStart: function (/**Event*/evt, /**boolean*/useFallback) {
            var dataTransfer = evt.dataTransfer,
                options = this.options;

            this._offUpEvents();

            if (activeGroup.checkPull(this, this, dragEl, evt)) {
                cloneEl = _clone(dragEl);

                cloneEl.draggable = false;
                cloneEl.style['will-change'] = '';

                _css(cloneEl, 'display', 'none');
                _toggleClass(cloneEl, this.options.chosenClass, false);

                rootEl.insertBefore(cloneEl, dragEl);
                _dispatchEvent(this, rootEl, 'clone', dragEl);
            }

            _toggleClass(dragEl, options.dragClass, true);

            if (useFallback) {
                if (useFallback === 'touch') {
                    // Bind touch events
                    _on(document, 'touchmove', this._onTouchMove);
                    _on(document, 'touchend', this._onDrop);
                    _on(document, 'touchcancel', this._onDrop);
                    _on(document, 'pointermove', this._onTouchMove);
                    _on(document, 'pointerup', this._onDrop);
                } else {
                    // Old brwoser
                    _on(document, 'mousemove', this._onTouchMove);
                    _on(document, 'mouseup', this._onDrop);
                }

                this._loopId = setInterval(this._emulateDragOver, 50);
            }
            else {
                if (dataTransfer) {
                    dataTransfer.effectAllowed = 'move';
                    options.setData && options.setData.call(this, dataTransfer, dragEl);
                }

                _on(document, 'drop', this);
                setTimeout(this._dragStarted, 0);
            }
        },

        _onDragOver: function (/**Event*/evt) {
            var el = this.el,
                target,
                dragRect,
                targetRect,
                revert,
                options = this.options,
                group = options.group,
                activeSortable = Sortable.active,
                isOwner = (activeGroup === group),
                isMovingBetweenSortable = false,
                canSort = options.sort;

            if (evt.preventDefault !== void 0) {
                evt.preventDefault();
                !options.dragoverBubble && evt.stopPropagation();
            }

            if (dragEl.animated) {
                return;
            }

            moved = true;

            if (activeSortable && !options.disabled &&
                (isOwner
                        ? canSort || (revert = !rootEl.contains(dragEl)) // Reverting item into the original list
                        : (
                            putSortable === this ||
                            (
                                (activeSortable.lastPullMode = activeGroup.checkPull(this, activeSortable, dragEl, evt)) &&
                                group.checkPut(this, activeSortable, dragEl, evt)
                            )
                        )
                ) &&
                (evt.rootEl === void 0 || evt.rootEl === this.el) // touch fallback
            ) {
                // Smart auto-scrolling
                _autoScroll(evt, options, this.el);

                if (_silent) {
                    return;
                }

                target = _closest(evt.target, options.draggable, el);
                dragRect = dragEl.getBoundingClientRect();

                if (putSortable !== this) {
                    putSortable = this;
                    isMovingBetweenSortable = true;
                }

                if (revert) {
                    _cloneHide(activeSortable, true);
                    parentEl = rootEl; // actualization

                    if (cloneEl || nextEl) {
                        rootEl.insertBefore(dragEl, cloneEl || nextEl);
                    }
                    else if (!canSort) {
                        rootEl.appendChild(dragEl);
                    }

                    return;
                }


                if ((el.children.length === 0) || (el.children[0] === ghostEl) ||
                    (el === evt.target) && (_ghostIsLast(el, evt))
                ) {
                    //assign target only if condition is true
                    if (el.children.length !== 0 && el.children[0] !== ghostEl && el === evt.target) {
                        target = el.lastElementChild;
                    }

                    if (target) {
                        if (target.animated) {
                            return;
                        }

                        targetRect = target.getBoundingClientRect();
                    }

                    _cloneHide(activeSortable, isOwner);

                    if (_onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt) !== false) {
                        if (!dragEl.contains(el)) {
                            el.appendChild(dragEl);
                            parentEl = el; // actualization
                        }

                        this._animate(dragRect, dragEl);
                        target && this._animate(targetRect, target);
                    }
                }
                else if (target && !target.animated && target !== dragEl && (target.parentNode[expando] !== void 0)) {
                    if (lastEl !== target) {
                        lastEl = target;
                        lastCSS = _css(target);
                        lastParentCSS = _css(target.parentNode);
                    }

                    targetRect = target.getBoundingClientRect();

                    var width = targetRect.right - targetRect.left,
                        height = targetRect.bottom - targetRect.top,
                        floating = R_FLOAT.test(lastCSS.cssFloat + lastCSS.display)
                            || (lastParentCSS.display == 'flex' && lastParentCSS['flex-direction'].indexOf('row') === 0),
                        isWide = (target.offsetWidth > dragEl.offsetWidth),
                        isLong = (target.offsetHeight > dragEl.offsetHeight),
                        halfway = (floating ? (evt.clientX - targetRect.left) / width : (evt.clientY - targetRect.top) / height) > 0.5,
                        nextSibling = target.nextElementSibling,
                        after = false
                    ;

                    if (floating) {
                        var elTop = dragEl.offsetTop,
                            tgTop = target.offsetTop;

                        if (elTop === tgTop) {
                            after = (target.previousElementSibling === dragEl) && !isWide || halfway && isWide;
                        }
                        else if (target.previousElementSibling === dragEl || dragEl.previousElementSibling === target) {
                            after = (evt.clientY - targetRect.top) / height > 0.5;
                        } else {
                            after = tgTop > elTop;
                        }
                    } else if (!isMovingBetweenSortable) {
                        after = (nextSibling !== dragEl) && !isLong || halfway && isLong;
                    }

                    var moveVector = _onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, after);

                    if (moveVector !== false) {
                        if (moveVector === 1 || moveVector === -1) {
                            after = (moveVector === 1);
                        }

                        _silent = true;
                        setTimeout(_unsilent, 30);

                        _cloneHide(activeSortable, isOwner);

                        if (!dragEl.contains(el)) {
                            if (after && !nextSibling) {
                                el.appendChild(dragEl);
                            } else {
                                target.parentNode.insertBefore(dragEl, after ? nextSibling : target);
                            }
                        }

                        parentEl = dragEl.parentNode; // actualization

                        this._animate(dragRect, dragEl);
                        this._animate(targetRect, target);
                    }
                }
            }
        },

        _animate: function (prevRect, target) {
            var ms = this.options.animation;

            if (ms) {
                var currentRect = target.getBoundingClientRect();

                if (prevRect.nodeType === 1) {
                    prevRect = prevRect.getBoundingClientRect();
                }

                _css(target, 'transition', 'none');
                _css(target, 'transform', 'translate3d('
                    + (prevRect.left - currentRect.left) + 'px,'
                    + (prevRect.top - currentRect.top) + 'px,0)'
                );

                target.offsetWidth; // repaint

                _css(target, 'transition', 'all ' + ms + 'ms');
                _css(target, 'transform', 'translate3d(0,0,0)');

                clearTimeout(target.animated);
                target.animated = setTimeout(function () {
                    _css(target, 'transition', '');
                    _css(target, 'transform', '');
                    target.animated = false;
                }, ms);
            }
        },

        _offUpEvents: function () {
            var ownerDocument = this.el.ownerDocument;

            _off(document, 'touchmove', this._onTouchMove);
            _off(document, 'pointermove', this._onTouchMove);
            _off(ownerDocument, 'mouseup', this._onDrop);
            _off(ownerDocument, 'touchend', this._onDrop);
            _off(ownerDocument, 'pointerup', this._onDrop);
            _off(ownerDocument, 'touchcancel', this._onDrop);
            _off(ownerDocument, 'pointercancel', this._onDrop);
            _off(ownerDocument, 'selectstart', this);
        },

        _onDrop: function (/**Event*/evt) {
            var el = this.el,
                options = this.options;

            clearInterval(this._loopId);
            clearInterval(autoScroll.pid);
            clearTimeout(this._dragStartTimer);

            // Unbind events
            _off(document, 'mousemove', this._onTouchMove);

            if (this.nativeDraggable) {
                _off(document, 'drop', this);
                _off(el, 'dragstart', this._onDragStart);
            }

            this._offUpEvents();

            if (evt) {
                if (moved) {
                    evt.preventDefault();
                    !options.dropBubble && evt.stopPropagation();
                }

                ghostEl && ghostEl.parentNode && ghostEl.parentNode.removeChild(ghostEl);

                if (rootEl === parentEl || Sortable.active.lastPullMode !== 'clone') {
                    // Remove clone
                    cloneEl && cloneEl.parentNode && cloneEl.parentNode.removeChild(cloneEl);
                }

                if (dragEl) {
                    if (this.nativeDraggable) {
                        _off(dragEl, 'dragend', this);
                    }

                    _disableDraggable(dragEl);
                    dragEl.style['will-change'] = '';

                    // Remove class's
                    _toggleClass(dragEl, this.options.ghostClass, false);
                    _toggleClass(dragEl, this.options.chosenClass, false);

                    // Drag stop event
                    _dispatchEvent(this, rootEl, 'unchoose', dragEl, rootEl, oldIndex);

                    if (rootEl !== parentEl) {
                        newIndex = _index(dragEl, options.draggable);

                        if (newIndex >= 0) {
                            // Add event
                            _dispatchEvent(null, parentEl, 'add', dragEl, rootEl, oldIndex, newIndex);

                            // Remove event
                            _dispatchEvent(this, rootEl, 'remove', dragEl, rootEl, oldIndex, newIndex);

                            // drag from one list and drop into another
                            _dispatchEvent(null, parentEl, 'sort', dragEl, rootEl, oldIndex, newIndex);
                            _dispatchEvent(this, rootEl, 'sort', dragEl, rootEl, oldIndex, newIndex);
                        }
                    }
                    else {
                        if (dragEl.nextSibling !== nextEl) {
                            // Get the index of the dragged element within its parent
                            newIndex = _index(dragEl, options.draggable);

                            if (newIndex >= 0) {
                                // drag & drop within the same list
                                _dispatchEvent(this, rootEl, 'update', dragEl, rootEl, oldIndex, newIndex);
                                _dispatchEvent(this, rootEl, 'sort', dragEl, rootEl, oldIndex, newIndex);
                            }
                        }
                    }

                    if (Sortable.active) {
                        /* jshint eqnull:true */
                        if (newIndex == null || newIndex === -1) {
                            newIndex = oldIndex;
                        }

                        _dispatchEvent(this, rootEl, 'end', dragEl, rootEl, oldIndex, newIndex);

                        // Save sorting
                        this.save();
                    }
                }

            }

            this._nulling();
        },

        _nulling: function() {
            rootEl =
                dragEl =
                    parentEl =
                        ghostEl =
                            nextEl =
                                cloneEl =
                                    lastDownEl =

                                        scrollEl =
                                            scrollParentEl =

                                                tapEvt =
                                                    touchEvt =

                                                        moved =
                                                            newIndex =

                                                                lastEl =
                                                                    lastCSS =

                                                                        putSortable =
                                                                            activeGroup =
                                                                                Sortable.active = null;

            savedInputChecked.forEach(function (el) {
                el.checked = true;
            });
            savedInputChecked.length = 0;
        },

        handleEvent: function (/**Event*/evt) {
            switch (evt.type) {
                case 'drop':
                case 'dragend':
                    this._onDrop(evt);
                    break;

                case 'dragover':
                case 'dragenter':
                    if (dragEl) {
                        this._onDragOver(evt);
                        _globalDragOver(evt);
                    }
                    break;

                case 'selectstart':
                    evt.preventDefault();
                    break;
            }
        },


        /**
         * Serializes the item into an array of string.
         * @returns {String[]}
         */
        toArray: function () {
            var order = [],
                el,
                children = this.el.children,
                i = 0,
                n = children.length,
                options = this.options;

            for (; i < n; i++) {
                el = children[i];
                if (_closest(el, options.draggable, this.el)) {
                    order.push(el.getAttribute(options.dataIdAttr) || _generateId(el));
                }
            }

            return order;
        },


        /**
         * Sorts the elements according to the array.
         * @param  {String[]}  order  order of the items
         */
        sort: function (order) {
            var items = {}, rootEl = this.el;

            this.toArray().forEach(function (id, i) {
                var el = rootEl.children[i];

                if (_closest(el, this.options.draggable, rootEl)) {
                    items[id] = el;
                }
            }, this);

            order.forEach(function (id) {
                if (items[id]) {
                    rootEl.removeChild(items[id]);
                    rootEl.appendChild(items[id]);
                }
            });
        },


        /**
         * Save the current sorting
         */
        save: function () {
            var store = this.options.store;
            store && store.set(this);
        },


        /**
         * For each element in the set, get the first element that matches the selector by testing the element itself and traversing up through its ancestors in the DOM tree.
         * @param   {HTMLElement}  el
         * @param   {String}       [selector]  default: `options.draggable`
         * @returns {HTMLElement|null}
         */
        closest: function (el, selector) {
            return _closest(el, selector || this.options.draggable, this.el);
        },


        /**
         * Set/get option
         * @param   {string} name
         * @param   {*}      [value]
         * @returns {*}
         */
        option: function (name, value) {
            var options = this.options;

            if (value === void 0) {
                return options[name];
            } else {
                options[name] = value;

                if (name === 'group') {
                    _prepareGroup(options);
                }
            }
        },


        /**
         * Destroy
         */
        destroy: function () {
            var el = this.el;

            el[expando] = null;

            _off(el, 'mousedown', this._onTapStart);
            _off(el, 'touchstart', this._onTapStart);
            _off(el, 'pointerdown', this._onTapStart);

            if (this.nativeDraggable) {
                _off(el, 'dragover', this);
                _off(el, 'dragenter', this);
            }

            // Remove draggable attributes
            Array.prototype.forEach.call(el.querySelectorAll('[draggable]'), function (el) {
                el.removeAttribute('draggable');
            });

            touchDragOverListeners.splice(touchDragOverListeners.indexOf(this._onDragOver), 1);

            this._onDrop();

            this.el = el = null;
        }
    };


    function _cloneHide(sortable, state) {
        if (sortable.lastPullMode !== 'clone') {
            state = true;
        }

        if (cloneEl && (cloneEl.state !== state)) {
            _css(cloneEl, 'display', state ? 'none' : '');

            if (!state) {
                if (cloneEl.state) {
                    if (sortable.options.group.revertClone) {
                        rootEl.insertBefore(cloneEl, nextEl);
                        sortable._animate(dragEl, cloneEl);
                    } else {
                        rootEl.insertBefore(cloneEl, dragEl);
                    }
                }
            }

            cloneEl.state = state;
        }
    }


    function _closest(/**HTMLElement*/el, /**String*/selector, /**HTMLElement*/ctx) {
        if (el) {
            ctx = ctx || document;

            do {
                if ((selector === '>*' && el.parentNode === ctx) || _matches(el, selector)) {
                    return el;
                }
                /* jshint boss:true */
            } while (el = _getParentOrHost(el));
        }

        return null;
    }


    function _getParentOrHost(el) {
        var parent = el.host;

        return (parent && parent.nodeType) ? parent : el.parentNode;
    }


    function _globalDragOver(/**Event*/evt) {
        if (evt.dataTransfer) {
            evt.dataTransfer.dropEffect = 'move';
        }
        evt.preventDefault();
    }


    function _on(el, event, fn) {
        el.addEventListener(event, fn, captureMode);
    }


    function _off(el, event, fn) {
        el.removeEventListener(event, fn, captureMode);
    }


    function _toggleClass(el, name, state) {
        if (el) {
            if (el.classList) {
                el.classList[state ? 'add' : 'remove'](name);
            }
            else {
                var className = (' ' + el.className + ' ').replace(R_SPACE, ' ').replace(' ' + name + ' ', ' ');
                el.className = (className + (state ? ' ' + name : '')).replace(R_SPACE, ' ');
            }
        }
    }


    function _css(el, prop, val) {
        var style = el && el.style;

        if (style) {
            if (val === void 0) {
                if (document.defaultView && document.defaultView.getComputedStyle) {
                    val = document.defaultView.getComputedStyle(el, '');
                }
                else if (el.currentStyle) {
                    val = el.currentStyle;
                }

                return prop === void 0 ? val : val[prop];
            }
            else {
                if (!(prop in style)) {
                    prop = '-webkit-' + prop;
                }

                style[prop] = val + (typeof val === 'string' ? '' : 'px');
            }
        }
    }


    function _find(ctx, tagName, iterator) {
        if (ctx) {
            var list = ctx.getElementsByTagName(tagName), i = 0, n = list.length;

            if (iterator) {
                for (; i < n; i++) {
                    iterator(list[i], i);
                }
            }

            return list;
        }

        return [];
    }



    function _dispatchEvent(sortable, rootEl, name, targetEl, fromEl, startIndex, newIndex) {
        sortable = (sortable || rootEl[expando]);

        var evt = document.createEvent('Event'),
            options = sortable.options,
            onName = 'on' + name.charAt(0).toUpperCase() + name.substr(1);

        evt.initEvent(name, true, true);

        evt.to = rootEl;
        evt.from = fromEl || rootEl;
        evt.item = targetEl || rootEl;
        evt.clone = cloneEl;

        evt.oldIndex = startIndex;
        evt.newIndex = newIndex;

        rootEl.dispatchEvent(evt);

        if (options[onName]) {
            options[onName].call(sortable, evt);
        }
    }


    function _onMove(fromEl, toEl, dragEl, dragRect, targetEl, targetRect, originalEvt, willInsertAfter) {
        var evt,
            sortable = fromEl[expando],
            onMoveFn = sortable.options.onMove,
            retVal;

        evt = document.createEvent('Event');
        evt.initEvent('move', true, true);

        evt.to = toEl;
        evt.from = fromEl;
        evt.dragged = dragEl;
        evt.draggedRect = dragRect;
        evt.related = targetEl || toEl;
        evt.relatedRect = targetRect || toEl.getBoundingClientRect();
        evt.willInsertAfter = willInsertAfter;

        fromEl.dispatchEvent(evt);

        if (onMoveFn) {
            retVal = onMoveFn.call(sortable, evt, originalEvt);
        }

        return retVal;
    }


    function _disableDraggable(el) {
        el.draggable = false;
    }


    function _unsilent() {
        _silent = false;
    }


    /** @returns {HTMLElement|false} */
    function _ghostIsLast(el, evt) {
        var lastEl = el.lastElementChild,
            rect = lastEl.getBoundingClientRect();

        // 5 — min delta
        // abs — нельзя добавлять, а то глюки при наведении сверху
        return (evt.clientY - (rect.top + rect.height) > 5) ||
            (evt.clientX - (rect.left + rect.width) > 5);
    }


    /**
     * Generate id
     * @param   {HTMLElement} el
     * @returns {String}
     * @private
     */
    function _generateId(el) {
        var str = el.tagName + el.className + el.src + el.href + el.textContent,
            i = str.length,
            sum = 0;

        while (i--) {
            sum += str.charCodeAt(i);
        }

        return sum.toString(36);
    }

    /**
     * Returns the index of an element within its parent for a selected set of
     * elements
     * @param  {HTMLElement} el
     * @param  {selector} selector
     * @return {number}
     */
    function _index(el, selector) {
        var index = 0;

        if (!el || !el.parentNode) {
            return -1;
        }

        while (el && (el = el.previousElementSibling)) {
            if ((el.nodeName.toUpperCase() !== 'TEMPLATE') && (selector === '>*' || _matches(el, selector))) {
                index++;
            }
        }

        return index;
    }

    function _matches(/**HTMLElement*/el, /**String*/selector) {
        if (el) {
            selector = selector.split('.');

            var tag = selector.shift().toUpperCase(),
                re = new RegExp('\\s(' + selector.join('|') + ')(?=\\s)', 'g');

            return (
                (tag === '' || el.nodeName.toUpperCase() == tag) &&
                (!selector.length || ((' ' + el.className + ' ').match(re) || []).length == selector.length)
            );
        }

        return false;
    }

    function _throttle(callback, ms) {
        var args, _this;

        return function () {
            if (args === void 0) {
                args = arguments;
                _this = this;

                setTimeout(function () {
                    if (args.length === 1) {
                        callback.call(_this, args[0]);
                    } else {
                        callback.apply(_this, args);
                    }

                    args = void 0;
                }, ms);
            }
        };
    }

    function _extend(dst, src) {
        if (dst && src) {
            for (var key in src) {
                if (src.hasOwnProperty(key)) {
                    dst[key] = src[key];
                }
            }
        }

        return dst;
    }

    function _clone(el) {
        return $
            ? $(el).clone(true)[0]
            : (Polymer && Polymer.dom
                    ? Polymer.dom(el).cloneNode(true)
                    : el.cloneNode(true)
            );
    }

    function _saveInputCheckedState(root) {
        var inputs = root.getElementsByTagName('input');
        var idx = inputs.length;

        while (idx--) {
            var el = inputs[idx];
            el.checked && savedInputChecked.push(el);
        }
    }

    // Fixed #973:
    _on(document, 'touchmove', function (evt) {
        if (Sortable.active) {
            evt.preventDefault();
        }
    });

    try {
        window.addEventListener('test', null, Object.defineProperty({}, 'passive', {
            get: function () {
                captureMode = {
                    capture: false,
                    passive: false
                };
            }
        }));
    } catch (err) {}

    // Export utils
    Sortable.utils = {
        on: _on,
        off: _off,
        css: _css,
        find: _find,
        is: function (el, selector) {
            return !!_closest(el, selector, el);
        },
        extend: _extend,
        throttle: _throttle,
        closest: _closest,
        toggleClass: _toggleClass,
        clone: _clone,
        index: _index
    };


    /**
     * Create sortable instance
     * @param {HTMLElement}  el
     * @param {Object}      [options]
     */
    Sortable.create = function (el, options) {
        return new Sortable(el, options);
    };


    // Export
    Sortable.version = '1.6.0';
    return Sortable;
});
/*! https://github.com/mhulse/jquery-pollster */

;(function($, window) {

    'use strict';

    // Plugin namespace:
    var NS = 'pollster';

    // Initialization public defaults:
    var $defaults = {
        ajax: {},         // Options for `jQuery.ajax()` (http://api.jquery.com/jquery.ajax/).
        callback: $.noop, // Method to call upon JSONP success.
        count: 1,         // Loop counter.
        first: true,      // Will be `false` after first run.
        seconds: 10,      // Refresh time in seconds (defaults to 10).
        url: ''           // Override `jQuery.ajax()` url option (useful if `url` is a function).
    };

    var console = (window.console || { log : $.noop, warn : $.noop });

    var methods = {

        init: function($options) {

            var $settings = $.extend(true, {}, $defaults, $[NS].defaults, $options);
            var $timeout;

            // Check required params:
            if ($settings.url || $settings.ajax.url) {

                // Pause the timeout?
                if ($settings.pause) {

                    window.clearInterval($timeout);

                    $timeout = 0;

                } else {

                    // Allow for url to be a function:
                    $settings.ajax.url = ((typeof $settings.url == 'function') ? $settings.url() : $settings.ajax.url);

                    if ($.inArray($settings.count, $settings.skip) !== -1) {

                        $settings.skipped = true;

                        $timeout = methods.restart($settings);

                    } else {

                        $settings.skipped = false;

                        $.ajax($settings.ajax)
                            .always(function($data) {

                                $timeout = methods.restart($settings, $data);

                            });

                    }

                }

            } else {

                console.warn('jQuery.%s: No URL endpoint specified.', NS);

            }

        },

        restart: function($settings, $data) {

            $data = ($data || {});

            // Success, call user's code:
            $settings.callback.call(
                ($settings.ajax.context || null), // Give optional context to all ajax-related callbacks.
                $settings,
                $data
            );

            // Helpers:
            $settings.first = false;
            $settings.count++;

            return setTimeout(function() {

                // Wash, rinse and repeat:
                $[NS].call(this, $settings);

            }, ($settings.seconds * 1000)); // Converts seconds to milliseconds.

        }

    };

    // Boilerplate method calling logic:
    $[NS] = function(method) {

        if (methods[method]) {

            return methods[method].apply(this, Array.prototype.slice.call(arguments, 1));

        } else if ((typeof method === 'object') || ( ! method)) {

            return methods.init.apply(this, arguments);

        } else {

            $.error('Error using jQuery.%s "%s"!', NS, method);

        }

    };

    // Pre-initialization public defaults.
    $[NS].defaults = $defaults;

}(jQuery, window));
/*!
 * @wcjiang/notify v2.0.10
 * JS achieve the browser title flashing , scrolling, voice prompts , chrome notice.
 *
 * Copyright (c) 2018 kenny wang
 * http://jaywcjlove.github.io/iNotify
 *
 * Licensed under the MIT license.
 */

(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
        typeof define === 'function' && define.amd ? define(factory) :
            (global.Notify = factory());
}(this, (function () { 'use strict';

    // 提醒是否添加chrome通知
    if (window.Notification && window.Notification.permission !== 'granted') {
        window.Notification.requestPermission();
    }
    var iconURL = '';
    var repeatableEffects = ['flash', 'scroll'];

    var defaultNotification = {
        title: 'iNotify !',
        body: 'You have a new message.',
        openurl: ''
    };

    function jsonArguments(news, olds) {
        for (var a in olds) {
            if (news[a]) {
                olds[a] = news[a];
            }
        }
        return olds;
    }
    function isArray(value) {
        return Object.prototype.toString.call(value) === '[object Array]';
    }

    function createAudio(url) {
        var audioElm = document.createElement('audio');
        var source = void 0;
        if (isArray(url) && url.length > 0) {
            for (var i = 0; i < url.length; i++) {
                source = document.createElement('source');
                source.src = url[i];
                source.type = 'audio/' + getExtension(url[i]);
                audioElm.appendChild(source);
            }
        } else {
            audioElm.src = url;
        }
        return audioElm;
    }

    function getFavicon(setting) {
        var ic = document.querySelectorAll('link[rel~=shortcut]')[0];
        if (!ic) {
            ic = changeFavicon('O', setting);
        }
        return ic;
    }

    function getExtension(fileName) {
        return fileName.match(/\.([^\\.]+)$/)[1];
    }

    function changeFavicon(num, settings) {
        var canvas = document.createElement('canvas');
        var head = document.getElementsByTagName('head')[0];
        var linkTag = document.createElement('link');
        var ctx = null;

        canvas.height = 32;
        canvas.width = 32;
        ctx = canvas.getContext('2d');
        ctx.fillStyle = settings.backgroundColor;
        ctx.fillRect(0, 0, 32, 32);

        ctx.textAlign = 'center';
        ctx.font = '22px "helvetica", sans-serif';
        ctx.fillStyle = settings.textColor;
        num && ctx.fillText(num, 16, 24);

        // 生成到
        linkTag.setAttribute('rel', 'shortcut icon');
        linkTag.setAttribute('type', 'image/x-icon');
        linkTag.setAttribute('id', 'new' + settings.id);
        linkTag.setAttribute('href', canvas.toDataURL('image/png'));
        iconURL = canvas.toDataURL('image/png');
        return head.appendChild(linkTag);
    }

    function Notify(config) {
        if (config) {
            this.init(config);
        }
    }

    Notify.prototype = {
        init: function init(config) {
            if (!config) {
                config = {};
            }
            this.interval = config.interval || 100; // 响应时长
            this.effect = config.effect || 'flash'; // 效果
            this.title = config.title || document.title; // 标题
            this.message = config.message || this.title; // 原来的标题
            this.onclick = config.onclick || this.onclick; // 点击事件
            this.openurl = config.openurl || this.openurl; // 点击事件
            this.updateFavicon = config.updateFavicon || {
                id: 'favicon',
                textColor: '#fff',
                backgroundColor: '#2F9A00'
            };
            this.audio = config.audio || '';
            this.favicon = getFavicon(this.updateFavicon);
            this.cloneFavicon = this.favicon.cloneNode(true);
            iconURL = config.notification && config.notification.icon ? config.notification.icon : config.icon ? config.icon : this.favicon.href;
            defaultNotification.icon = iconURL;
            this.notification = config.notification || defaultNotification;
            // 初始化生成声音文件节点
            if (this.audio && this.audio.file) {
                this.setURL(this.audio.file);
            }
            return this;
        },
        render: function render() {
            if (this.effect === 'flash') {
                document.title = this.title === document.title ? this.message : this.title;
            } else if (this.effect === 'scroll') {
                var title = this.message || document.title;
                if (!this.scrollTitle || !this.scrollTitle.slice(1)) {
                    document.title = title;
                    this.scrollTitle = title;
                } else {
                    this.scrollTitle = this.scrollTitle.slice(1);
                    document.title = this.scrollTitle;
                }
            }
            return this;
        },

        // 设置标题
        setTitle: function setTitle(str) {
            if (str === true) {
                if (repeatableEffects.indexOf(this.effect) >= 0) {
                    return this.addTimer();
                }
            } else if (str) {
                this.message = str;
                this.scrollTitle = '';
                this.addTimer();
            } else {
                this.clearTimer();
            }
            return this;
        },
        setURL: function setURL(url) {
            if (url) {
                if (this.audioElm) {
                    this.audioElm.remove();
                }
                this.audioElm = createAudio(url);
                document.body.appendChild(this.audioElm);
            }
            return this;
        },
        loopPlay: function loopPlay() {
            this.setURL();
            this.audioElm.loop = true;
            this.player();
            return this;
        },
        stopPlay: function stopPlay() {
            this.audioElm && (this.audioElm.loop = false, this.audioElm.pause());
            return this;
        },

        // 播放声音
        player: function player() {
            if (!this.audio || !this.audio.file) {
                return;
            }
            if (!this.audioElm) {
                this.audioElm = createAudio(this.audio.file);
                document.body.appendChild(this.audioElm);
            }
            this.audioElm.play();
            return this;
        },
        notify: function notify(json) {
            var nt = this.notification;
            var url = json.openurl ? json.openurl : this.openurl;
            var onclick = json.onclick ? json.onclick : this.onclick;
            if (window.Notification) {
                if (json) {
                    nt = jsonArguments(json, nt);
                } else {
                    nt = defaultNotification;
                }
                var option = {};
                option.icon = json.icon ? json.icon : iconURL;
                option.body = nt.body;
                if (json.dir) option.dir = json.dir;
                var n = new Notification(nt.title, option);
                n.onclick = function () {
                    onclick && typeof onclick === 'function' && onclick(n);
                    url && window.open(url);
                };
                n.onshow = function () {
                    json.onshow && typeof json.onshow === 'function' && json.onshow(n);
                };
                n.onclose = function () {
                    json.onclose && typeof json.onclose === 'function' && json.onclose(n);
                };
                n.onerror = function () {
                    json.onerror && typeof json.onerror === 'function' && json.onerror(n);
                };
                this.Notifiy = n;
            }
            return this;
        },

        // 是否许可弹框通知
        isPermission: function isPermission() {
            return window.Notification && Notification.permission === 'granted';
        },

        // 设置时间间隔
        setInterval: function setInterval(num) {
            if (num) {
                this.interval = num;
                this.addTimer();
            }
            return this;
        },

        // 设置网页Icon
        setFavicon: function setFavicon(num) {
            if (!num && num !== 0) {
                return this.faviconClear();
            }
            var oldicon = document.getElementById('new' + this.updateFavicon.id);
            if (this.favicon) {
                this.favicon.remove();
            }
            if (oldicon) {
                oldicon.remove();
            }
            this.updateFavicon.num = num;
            changeFavicon(num, this.updateFavicon);
            return this;
        },

        // 设置 Favicon 文字颜色
        setFaviconColor: function setFaviconColor(color) {
            if (color) {
                this.faviconRemove();
                this.updateFavicon.textColor = color;
                changeFavicon(this.updateFavicon.num, this.updateFavicon);
            }
            return this;
        },

        // 设置 Favicon 背景颜色
        setFaviconBackgroundColor: function setFaviconBackgroundColor(color) {
            if (color) {
                this.faviconRemove();
                this.updateFavicon.backgroundColor = color;
                changeFavicon(this.updateFavicon.num, this.updateFavicon);
            }
            return this;
        },
        faviconRemove: function faviconRemove() {
            this.faviconClear();
            var oldicon = document.getElementById('new' + this.updateFavicon.id);
            if (this.favicon) {
                this.favicon.remove();
            }
            if (oldicon) {
                oldicon.remove();
            }
        },

        // 添加计数器
        addTimer: function addTimer() {
            this.clearTimer();
            if (repeatableEffects.indexOf(this.effect) >= 0) {
                this.timer = setInterval(this.render.bind(this), this.interval);
            }
            return this;
        },
        close: function close() {
            if (this.Notifiy) this.Notifiy.close();
        },

        // 清除Icon
        faviconClear: function faviconClear() {
            var newicon = document.getElementById('new' + this.updateFavicon.id);
            var head = document.getElementsByTagName('head')[0];
            var ficon = document.querySelectorAll('link[rel~=shortcut]');
            newicon && newicon.remove();
            if (ficon.length > 0) {
                for (var i = 0; i < ficon.length; i++) {
                    ficon[i].remove();
                }
            }
            head.appendChild(this.cloneFavicon);
            iconURL = this.cloneFavicon.href;
            this.favicon = this.cloneFavicon;
            return this;
        },

        // 清除计数器
        clearTimer: function clearTimer() {
            this.timer && clearInterval(this.timer);
            document.title = this.title;
            return this;
        }
    };

    return Notify;

})));

